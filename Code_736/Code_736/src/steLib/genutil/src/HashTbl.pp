


/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */


/*****************************************************************************/
/* stdarg.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/



   typedef char *va_list;


/*****************************************************************************/
/* VA_END - Reclaim resources used by varargs handling.                      */
/*                                                                           */
/* No action needed                                                          */
/*****************************************************************************/


/*****************************************************************************/
/* VA_START - Set up the va_list pointer.				     */
/*****************************************************************************/



/*---------------------------------------------------------------------------*/
/* ELF ABI convention:							     */
/* - va_list pointer points one byte beyond the last argument.		     */
/*---------------------------------------------------------------------------*/



/*****************************************************************************/
/* VA_ARG - Return the next argument, adjust va_list pointer		     */
/*                                                                           */
/* Some arguments passed by value are turned into pass-by-reference by	     */
/* making a temporary object and passing a pointer to this temporary.  For   */
/* such an argument (indicated by __va_argref(_type)) the actual argument    */
/* passed is a pointer, so it must be dealt with specially.		     */
/*                                                                           */
/* When an argument is larger than the maximum alignment (8 bytes for double */
/* or long long), we only align to 8 bytes.				     */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* What happens on every va_arg(_ap, _type) call is:			     */
/* 1) Align the value of _ap (the va_list pointer) appropriately for _type   */
/*    (the requested type).						     */
/* 2) Increment _ap appropriately for _type.				     */
/* 3) Return the value desired by dereferencing _ap.			     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* 1) Align _ap to satisfy alignment of _type.				     */
/* 2) Increment _ap by sizeof(_type)                                         */
/* 3) return *(ap-sizeof(_type))                                             */
/*---------------------------------------------------------------------------*/







/*---------------------------------------------------------------------------*/
/* The big- and little-endian variants are different only because we are     */
/* trying to support the case of the user asking for "char" or "short",	     */
/* which is actually undefined behavior (See ISO/IEC 9899:1999 7.15.1.1),    */
/* but we are trying to be friendly.					     */
/*---------------------------------------------------------------------------*/







/*****************************************************************************/
/* stddef.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/




typedef int ptrdiff_t;

typedef unsigned size_t;


typedef unsigned short wchar_t;






/*-----------------------------------------------------------------------*/
/* Define _win_t, for compiling GCC libraries with the TI compiler.      */
/* GCC's library (newlib) expects wint_t to be defined here, in stddef.h,*/
/* which is arguably incorrect, but we go along for compatibility.       */
/* This is outside the _STDDEF guard in case this file has already       */
/* been included without __need_wint_t.                                  */
/*-----------------------------------------------------------------------*/

/* macros to simplify "stringification" and computed includes */

/* TitleCase standard types */


typedef char            xdc_Char;
typedef unsigned char   xdc_UChar;
typedef short           xdc_Short;
typedef unsigned short  xdc_UShort;
typedef int             xdc_Int;
typedef unsigned int    xdc_UInt;
typedef long            xdc_Long;
typedef unsigned long   xdc_ULong;
typedef float           xdc_Float;
typedef double          xdc_Double;
typedef long double     xdc_LDouble;
typedef size_t          xdc_SizeT;
typedef va_list         xdc_VaList;

/* Generic Extended Types */

typedef unsigned short  xdc_Bool;       /* boolean flag */
typedef void            *xdc_Ptr;       /* data pointer */
typedef char            *xdc_String;    /* null terminated string */

/* we intentionally omit arguments from Fxn to indicate that it can have
 * any (or none).  Unfortunately this causes gcc to emit warnings when
 * -Wstrict-prototypes is used.  Newer gcc's (4.6 or later) support a pragma
 * that works around this:
 *
 *    #pragma GCC diagnostic ignored "-Wstrict-prototypes"
 */
    typedef int             (*xdc_Fxn)();   /* function pointer */

/*
 * Import the target-specific std.h
 */
/* if the user did not supply the required xdc_target* definitions, ask well
 * known compiler tool chains to select based on their pre-defined macros
 */
/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  ======== select.h ========
 *  This header selects an appropriate target name based on TI compiler
 *  predefined macros and includes the appropriate target-specific std.h.
 *
 *  This header is entirely optional: the user can directly select any
 *  existing target by adding definition of the following two symbols to
 *  the compile line:
 *    xdc_target_name__     the short name of the target; e.g., C64P
 *    xdc_target_types__    a package path relative path to the types header
 *                          for the target; e.g., ti/targets/std.h
 *
 *  For more information about these symbols see:
 *  http://rtsc.eclipse.org/docs-tip/Integrating_RTSC_Modules
 */

/*
 *  ======== MSP430 ========
 */
     /* set to 1 if compiling for EABI (ELF) and is set to 0 otherwise. */

/*
 *  ======== ARP32 ========
 *  ARP32 (EVE) devices
 */

/*
 *  ======== include the selected type header ========
 */
/* 
 *  Copyright (c) 2008 Texas Instruments and others.
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 * 
 *  Contributors:
 *      Texas Instruments - initial implementation
 * 
 * */
/*
 *  ======== ti/targets/elf/std.h ========
 *  Standard types for supported TI compilers for ELF
 */


/*  Define target-specific "portable" macros
 *
 *  The build command-line define xdc_target_name__ to be the value
 *  of the target's name config parameter.  We use this to include the
 *  target-specific definitions for the required target-independent
 *  xdc_target* macros.
 */
/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  ======== C66.h ========
 *  DO NOT MODIFY: This header is generated from stddef.xdt
 *
 *  This header contains target-specific definitions of target-independent
 *  macros required by the ITarget interface.  These definitions allow C/C++
 *  sources to portably compile for multiple targets (using #ifdef ...).
 */

/*
 *  ======== ti_targets_elf_C66 ========
 *  This macro identifies the specific target being used.  This macro should
 *  probably be avoided in portable sources.
 */

/*
 *  ======== xdc_target__isaCompatible_* macros ========
 *  The following definitions enable clients to conditionally compile for any
 *  compatible subset of the actual target ISA.
 */

/*
 *  ======== xdc_target__isa_66 ========
 *  This macro identifies the specific target ISA for which we are being
 *  compiled.
 */

/*
 *  ======== xdc_target__{big|little}Endian ========
 *  The following macro enables clients to portably compile for big or little
 *  endian targets.
 */

/*
 *  ======== xdc_target__os_undefined ========
 *  The following macro enables clients to portably compile for target specific
 *  OS; e.g., Linux, Solaris, Windows, undefined.
 */

/*
 *  ======== xdc_target__sizeof_ ========
 *  The following macros enable clients to portably determine type sizes
 *  within #ifdef blocks; sizeof() can't be used and the definitions in
 *  stdint.h are not available to C++ clients (unless the special macro
 *  __STDC_LIMIT_MACROS is defined).
 */

/*
 *  ======== xdc_target__alignof_ ========
 *  The following macros enable clients to portably determine type alignment
 *  within #ifdef blocks; even if provided by the compiler, alignof() can't
 *  be used in pre-processor statements.
 */

/*
 *  ======== xdc_target__bitsPerChar ========
 *  The number of bits in a char.  This macro allow one to determine the
 *  precise number of bits in any of the standard types (whose sizes are
 *  expressed as a number of chars).
 */

/*
 *  @(#) ti.targets.elf; 1, 0, 0,298; 4-27-2012 17:07:43; /db/ztree/library/trees/xdctargets/xdctargets-f21x/src/ xlibrary

 */


/* "inherit" (i.e., include) all ti.targets standard types */
/* 
 *  Copyright (c) 2008 Texas Instruments and others.
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 * 
 *  Contributors:
 *      Texas Instruments - initial implementation
 * 
 * */
/*
 *  ======== ti/targets/std.h ========
 *  Standard types for supported TI compilers
 *
 */


/* include target-specific "portable" macros */

/*****************************************************************************/
/* STDINT.H v7.3.4                                                           */
/*                                                                           */
/* Copyright (c) 2002-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/

/* 7.18.1.1 Exact-width integer types */

    typedef   signed char   int8_t;
    typedef unsigned char  uint8_t;
    typedef          short  int16_t;
    typedef unsigned short uint16_t;
    typedef          int    int32_t;
    typedef unsigned int   uint32_t;

    typedef          __int40_t  int40_t;
    typedef unsigned __int40_t uint40_t;

    typedef          long long  int64_t;
    typedef unsigned long long uint64_t;

/* 7.18.1.2 Minimum-width integer types */

    typedef  int8_t   int_least8_t;
    typedef uint8_t  uint_least8_t;

    typedef  int16_t  int_least16_t;
    typedef uint16_t uint_least16_t;
    typedef  int32_t  int_least32_t;
    typedef uint32_t uint_least32_t;

    typedef  int40_t  int_least40_t;
    typedef uint40_t uint_least40_t;

    typedef  int64_t  int_least64_t;
    typedef uint64_t uint_least64_t;

/* 7.18.1.3 Fastest minimum-width integer types */

    typedef  int32_t  int_fast8_t;
    typedef uint32_t uint_fast8_t;
    typedef  int32_t  int_fast16_t;
    typedef uint32_t uint_fast16_t;

    typedef  int32_t  int_fast32_t;
    typedef uint32_t uint_fast32_t;

    typedef  int40_t  int_fast40_t;
    typedef uint40_t uint_fast40_t;

    typedef  int64_t  int_fast64_t;
    typedef uint64_t uint_fast64_t;

/* 7.18.1.4 Integer types capable of holding object pointers */
    typedef          int intptr_t;
    typedef unsigned int uintptr_t;

/* 7.18.1.5 Greatest-width integer types */
    typedef          long long intmax_t;
    typedef unsigned long long uintmax_t;

/* 
   According to footnotes in the 1999 C standard, "C++ implementations
   should define these macros only when __STDC_LIMIT_MACROS is defined
   before <stdint.h> is included." 
*/

/* 7.18.2 Limits of specified width integer types */
















/* 7.18.3 Limits of other integer types */







/* 7.18.4.1 Macros for minimum-width integer constants */

/*
   There is a defect report filed against the C99 standard concerning how 
   the (U)INTN_C macros should be implemented.  Please refer to --
   http://wwwold.dkuug.dk/JTC1/SC22/WG14/www/docs/dr_209.htm 
   for more information.  These macros are implemented according to the
   suggestion given at this web site.
*/




/* 7.18.4.2 Macros for greatest-width integer constants */




        typedef int xdc_Arg;    /* deprecated, but compatible with BIOS 5.x */

/*
 * xdc__LONGLONG__ indicates if compiler supports 'long long' type
 * xdc__BITS<n> __ indicates if compiler supports 'uint<n>_t' type
 */



/*
 *  ======== [U]Int<n> ========
 */
typedef int_least8_t    xdc_Int8;
typedef uint_least8_t   xdc_UInt8;
typedef int_least16_t   xdc_Int16;
typedef uint_least16_t  xdc_UInt16;
typedef int_least32_t   xdc_Int32;
typedef uint_least32_t  xdc_UInt32;

    typedef int_least64_t   xdc_Int64;
    typedef uint_least64_t   xdc_UInt64;

    typedef int_least40_t   xdc_Int40;
    typedef uint_least40_t  xdc_UInt40;

  /*  the following unqualified names are here because 40-bit types are not
   *  supported by xdc/std.h
   */
    typedef xdc_Int40       Int40;
    typedef xdc_UInt40      UInt40;

/*
 *  ======== Bits<n> ========
 */
    typedef uint8_t     xdc_Bits8;
    typedef uint16_t    xdc_Bits16;
    typedef uint32_t    xdc_Bits32;
    typedef uint64_t    xdc_Bits64;

/*
 *  ======== [UI]Arg ========
 */
typedef intptr_t        xdc_IArg;
typedef uintptr_t       xdc_UArg;

/*
 *  ======== restrict ========
 */


/*
 *  ======== ti_targets_mkPragma ========
 */

/*
 *  ======== xdc__META ========
 */

/*
 *  ======== __ti__ ========
 *  These symbols are used by RTSC tools to indicate presence/absence of
 *  assorted #pragma options in TI compiler.
 */


/*
 *  @(#) ti.targets; 1, 0, 3,531; 4-27-2012 17:07:38; /db/ztree/library/trees/xdctargets/xdctargets-f21x/src/ xlibrary

 */


/*
 *  @(#) ti.targets.elf; 1, 0, 0,298; 4-27-2012 17:07:43; /db/ztree/library/trees/xdctargets/xdctargets-f21x/src/ xlibrary

 */


/*
 *  @(#) ti.targets; 1, 0, 3,531; 4-27-2012 17:07:38; /db/ztree/library/trees/xdctargets/xdctargets-f21x/src/ xlibrary

 */


/* Each modules' internal header file defines 'module' as 
 * xdc__MODOBJADDR__(Module__state__V), where Module__state__V is the actual
 * object where the module state is kept. For most targets, the default macro
 * given here results in the construct '(&Module__state__V)->field', when the
 * expression 'module->field' is used. Compilers then generate the code that
 * doesn't dereference a pointer, but puts the address of the field in the
 * code.
 * The targets that need to do something different can define
 * xdc__MODOBJADDR__ in std.h for their target package.
 */

/* Long Long Types */

typedef long long               xdc_LLong;
typedef unsigned long long      xdc_ULLong;


/* Arg to Ptr and Fxn conversion operators
 *
 * Individual targets may override these definitions in the event
 * that compilers issue warnings about shortening of an Arg to a pointer,
 * for example.
 */
static inline xdc_Ptr xdc_iargToPtr(xdc_IArg a) { return ((xdc_Ptr)a); }
static inline xdc_Ptr xdc_uargToPtr(xdc_UArg a) { return ((xdc_Ptr)a); }

static inline xdc_Fxn xdc_iargToFxn(xdc_IArg a) { return ((xdc_Fxn)a); }
static inline xdc_Fxn xdc_uargToFxn(xdc_UArg a) { return ((xdc_Fxn)a); }

/*
 * functions to convert a single precision float to an arg
 * Here assumption is that sizeof(Float) <= sizeof(IArg);
 */
typedef union xdc_FloatData {
    xdc_Float f;
    xdc_IArg  a;
} xdc_FloatData;

static inline xdc_IArg xdc_floatToArg(xdc_Float f)
{
     xdc_FloatData u;
     u.f = f;

     return (u.a);
}

static inline xdc_Float xdc_argToFloat(xdc_IArg a)
{
     xdc_FloatData u;
     u.a = a;

     return (u.f);
}

/* restrict keyword */

/* Unprefixed Aliases */




typedef xdc_Char        Char;
typedef xdc_UChar       UChar;
typedef xdc_Short       Short;
typedef xdc_UShort      UShort;
typedef xdc_Int         Int;
typedef xdc_UInt        UInt;
typedef xdc_Long        Long;
typedef xdc_ULong       ULong;
typedef xdc_LLong       LLong;
typedef xdc_ULLong      ULLong;
typedef xdc_Float       Float;
typedef xdc_Double      Double;
typedef xdc_LDouble     LDouble;
typedef xdc_SizeT       SizeT;
typedef xdc_VaList      VaList;

typedef xdc_IArg        IArg;
typedef xdc_UArg        UArg;
typedef xdc_Bool        Bool;
typedef xdc_Int8        Int8;
typedef xdc_Int16       Int16;
typedef xdc_Int32       Int32;
typedef xdc_Fxn         Fxn;
typedef xdc_Ptr         Ptr;
typedef xdc_String      String;

typedef xdc_UInt8       UInt8;
typedef xdc_UInt16      UInt16;
typedef xdc_UInt32      UInt32;

/* DEPRECATED Aliases */

/* xdc_Arg is defined only in ti/targets/std.h; use IArg and UArg instead */
typedef xdc_Arg         Arg;

typedef xdc_UInt8       Uint8;
typedef xdc_UInt16      Uint16;
typedef xdc_UInt32      Uint32;
typedef xdc_UInt        Uns;

/*
 *  ======== optional types ========
 *  The following types are not always defined for all targets
 */
typedef xdc_Int64       Int64;
typedef xdc_UInt64      UInt64;

/* The following exact size types are not required by C99 and may not be
 * supported by some compiler/processor environments.  For greater
 * portability, use the IntN or UIntN types above.
 */
typedef xdc_Bits8       Bits8;

typedef xdc_Bits16      Bits16;

typedef xdc_Bits32      Bits32;

typedef xdc_Bits64      Bits64;


/* Standard Constants */

/* NULL must be 0 for C++ and is set to 0 in C to allow legacy code to
 * compile without warnings.
 *
 * If xdc_strict is defined, NULL is defined to be a pointer to allow
 * maximal type checking in "modern" C sources
 */



/* Declaration Qualifiers */


/*
 *  ======== xdc__CODESECT ========
 *  Code-Section Directive
 *
 *  Targets can optionally #define xdc__CODESECT in their specific
 *  std.h files.  This directive is placed in front of all
 *  "extern" function declarations, and specifies a section-name in
 *  which to place this function.  This approach
 *  provides more control on combining/organizing groups of
 *  related functions into a single named sub-section (e.g.,
 *  "init-code")  If this macro is not defined by the target, an
 *  empty definition is used instead.
 */ 

/*
 *  ======== xdc__META ========
 *  Embed unreferenced string in the current file
 *
 *  Strings emebdded via xdc__META can be placed in a section that is
 *  _not_ loaded on the target but are, nevertheless, part of the
 *  executable and available to loaders.
 *
 *  Different targets may define this macro in a way that places these
 *  strings in an output section that is not loaded (and therefore does
 *  not takeup space on the target).  Unless the target provides a
 *  definition of xdc__META, the definition below simply defines
 *  as string constant in the current file.
 */

/*
 *  @(#) xdc; 1, 1, 1,380; 4-27-2012 14:30:08; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*****************************************************************************/
/* STDIO.H v7.3.4                                                            */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/

/*****************************************************************************/
/* linkage.h   v7.3.4                                                        */
/*                                                                           */
/* Copyright (c) 1998-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/


/*--------------------------------------------------------------------------*/
/* Define _CODE_ACCESS ==> how to call RTS functions                        */
/*--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/
/* Define _DATA_ACCESS ==> how to access RTS global or static data          */
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/* Define _DATA_ACCESS_NEAR ==> some C6000 RTS data must always be near     */
/*--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/
/* Define _IDECL ==> how inline functions are declared                      */
/*--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/
/* If compiling with non-TI compiler (e.g. GCC), nullify any TI-specific    */
/* language extensions.                                                     */
/*--------------------------------------------------------------------------*/

/*****************************************************************************/
/* stdarg.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/




/*---------------------------------------------------------------------------*/
/* Attributes are only available in relaxed ANSI mode.                       */
/*---------------------------------------------------------------------------*/



/****************************************************************************/
/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
/****************************************************************************/

typedef struct {
      int fd;                    /* File descriptor */
      unsigned char* buf;        /* Pointer to start of buffer */
      unsigned char* pos;        /* Position in buffer */
      unsigned char* bufend;     /* Pointer to end of buffer */
      unsigned char* buff_stop;  /* Pointer to last read char in buffer */
      unsigned int   flags;      /* File status flags (see below) */
} FILE;

typedef int fpos_t; 

/****************************************************************************/
/* DEVICE AND STREAM RELATED MACROS                                         */
/****************************************************************************/
/****************************************************************************/
/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
/****************************************************************************/



/****************************************************************************/
/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
/****************************************************************************/









/******** END OF ANSI MACROS ************************************************/


/****************************************************************************/
/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
/****************************************************************************/

extern far FILE _ftable[20];
extern far char _tmpnams[20][16];

/****************************************************************************/
/*   FUNCTION DEFINITIONS  - ANSI                                           */
/****************************************************************************/
/****************************************************************************/
/* OPERATIONS ON FILES                                                      */
/****************************************************************************/
extern  int     remove(const char *_file);
extern  int     rename(const char *_old, const char *_new);
extern  FILE   *tmpfile(void);
extern  char   *tmpnam(char *_s);

/****************************************************************************/
/* FILE ACCESS FUNCTIONS                                                    */
/****************************************************************************/
extern  int     fclose(FILE *_fp); 
extern  FILE   *fopen(const char *_fname, const char *_mode);
extern  FILE   *freopen(const char *_fname, const char *_mode,
			            register FILE *_fp);
extern  void    setbuf(register FILE *_fp, char *_buf);
extern  int     setvbuf(register FILE *_fp, register char *_buf, 
			            register int _type, register size_t _size);
extern  int     fflush(register FILE *_fp); 

/****************************************************************************/
/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern  int fprintf(FILE *_fp, const char *_format, ...)
               __attribute__((__format__ (__printf__, 2, 3)));
extern  int fscanf(FILE *_fp, const char *_fmt, ...)
               __attribute__((__format__ (__scanf__, 2, 3)));
extern  int printf(const char *_format, ...)
               __attribute__((__format__ (__printf__, 1, 2)));
extern  int scanf(const char *_fmt, ...)
               __attribute__((__format__ (__scanf__, 1, 2)));
extern  int sprintf(char *_string, const char *_format, ...)
               __attribute__((__format__ (__printf__, 2, 3)));
extern  int snprintf(char *_string, size_t _n, 
				 const char *_format, ...)
               __attribute__((__format__ (__printf__, 3, 4)));
extern  int sscanf(const char *_str, const char *_fmt, ...)
               __attribute__((__format__ (__scanf__, 2, 3)));
extern  int vfprintf(FILE *_fp, const char *_format, va_list _ap)
               __attribute__((__format__ (__printf__, 2, 0)));
extern  int vprintf(const char *_format, va_list _ap)
               __attribute__((__format__ (__printf__, 1, 0)));
extern  int vsprintf(char *_string, const char *_format,
				 va_list _ap)
               __attribute__((__format__ (__printf__, 2, 0)));
extern  int vsnprintf(char *_string, size_t _n, 
				  const char *_format, va_list _ap)
               __attribute__((__format__ (__printf__, 3, 0)));

/****************************************************************************/
/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern  int     fgetc(register FILE *_fp);
extern  char   *fgets(char *_ptr, register int _size,
				  register FILE *_fp);
extern  int     fputc(int _c, register FILE *_fp);
extern  int     fputs(const char *_ptr, register FILE *_fp);
extern  int     getc(FILE *_p);
extern  int     getchar(void);
extern  char   *gets(char *_ptr); 
extern  int     putc(int _x, FILE *_fp);
extern  int     putchar(int _x);
extern  int     puts(const char *_ptr); 
extern  int     ungetc(int _c, register FILE *_fp);

/****************************************************************************/
/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
/****************************************************************************/
extern  size_t  fread(void *_ptr, size_t _size, size_t _count,
				  FILE *_fp);
extern  size_t  fwrite(const void *_ptr, size_t _size,
				   size_t _count, register FILE *_fp); 

/****************************************************************************/
/* FILE POSITIONING FUNCTIONS                                               */
/****************************************************************************/
extern  int     fgetpos(FILE *_fp, fpos_t *_pos);
extern  int     fseek(register FILE *_fp, long _offset,
				  int _ptrname);
extern  int     fsetpos(FILE *_fp, const fpos_t *_pos);
extern  long    ftell(FILE *_fp);
extern  void    rewind(register FILE *_fp); 

/****************************************************************************/
/* ERROR-HANDLING FUNCTIONS                                                 */
/****************************************************************************/
extern  void    clearerr(FILE *_fp);
extern  int     feof(FILE *_fp);
extern  int     ferror(FILE *_fp);
extern  void    perror(const char *_s);








/************************************************************************
 * File:
 *      $RCSfile: dcs_types.h,v $
 *      $Revision: 1.5 $
 *      $Date: 2010/04/04 02:35:35 $
 *
 *      (c) 2006 DelCom Systems, Inc.
 *      The Source Code contained herein is DelCom
 *      Systems, Inc. Confidential material and subject to Non-Disclosure.
 *
 *      The Source Code is and shall remain owned by DelCom
 *      Systems, Inc. and/or its suppliers and is protected by United
 *      States copyright laws and international treaty provisions.  As an
 *      express condition of the executed Source License Agreement, title
 *      to, ownership of, and all rights in patents, copyrights, trade
 *      secrets and any other intellectual property rights in this Source
 *      Code and/or any copy or part thereof is and shall remain in DelCom
 *      Systems, Inc. and/or its suppliers.  It is understood
 *      by the user of the Source Code that valuable, confidential
 *      information and trade secrets are contained within and that
 *      unauthorized use and/or copying shall be harmful to DelCom
 *      Systems, Inc.
 *
 *      THE SOURCE CODE MAY NOT BE MODIFIED, ADAPTED, TRANSLATED, RENTED,
 *      LEASED, LOANED, RESOLD FOR PROFIT, DISTRIBUTED OR OTHERWISE ASSIGNED
 *      OR TRANSFERRED NOR MAY DERIVITATIVE WORKS BASED UPON THIS SOFTWARE
 *      OR ANY PART THEREOF BE DEVELOPED WITHOUT WRITTEN AGREEMENT BY DELCOM
 *      SYSTEMS, INC. 
 *
 *
 *
 ************************************************************************/
/************************************************************************
 * File:
 *      $RCSfile: dcs_types.h,v $
 *      $Revision: 1.5 $
 *      $Date: 2010/04/04 02:35:35 $
 *
 * Purpose:
 *      This file contains the type definitions for the global types
 *      used to specify types that require certain bit widths, such
 *      as INT16, UINT16, etc...
 *
 * Operation:
 *      
 * Notes/Issues:
 *      hye: add types used for receiver performance simulation
 *       
 ************************************************************************/

typedef unsigned short UINT16;
typedef unsigned int   UINT32;
typedef short INT16;
typedef short Flag;
typedef short FLAG;
typedef int INT32;
typedef long long INT64;
typedef unsigned long long UINT64;
typedef long INT40;
typedef unsigned long UINT40;
typedef          char  INT8;    /* 8 bit wide signed quantities */ 
typedef unsigned char  UINT8;   /* 8 bit wide unsigned quantities */
typedef unsigned char  BIT_TYPE;/* 1 bit per element 0 or 1 only */
typedef unsigned char  OCTET;   /* 8 bits per element */
typedef unsigned char  SCRATCH; /* Scratch buffer pointer type */






typedef struct complex16 {      /* 16 bit precision complex quantities */
  INT16 r; 
  INT16 i;
} COMPLEX16;


#pragma STRUCT_ALIGN (complex16, 4);

typedef struct complex32 {      /* 32 bit precision complex quantities */
  INT32 r;
  INT32 i;
} COMPLEX32;
#pragma STRUCT_ALIGN (complex32, 8);

/* Define complex floating point data structure */
typedef struct 
{
  float re;
  float im;
} complex_flt;

/*  Define complex double precision floating point data structure */
typedef struct
{
  double re;
  double im;
} complex_double;








//typedef	signed char		INT8;
//typedef	signed short	INT16;
//typedef signed int		INT32;
//typedef signed long long int	INT64;

//typedef	unsigned char	UINT8;
//typedef	unsigned short	UINT16;
//typedef unsigned int	UINT32;
//typedef unsigned long long int	UINT64;
//### typedef modification for 6678(previously these defined in dcs_types.h, now we are excluding that file)
//typedef Int16 INT16;
//typedef Int8 INT8;
//typedef UInt16 UINT16;
//typedef UInt8 UINT8;

//#########################
typedef INT8	BOOL;
//typedef Int8	BOOL;  // remesh

typedef signed char CHAR;
//typedef Char CHAR;

typedef enum DSP_CORE
{
	CORE_0 = 0,
	CORE_1,
	CORE_2,
	CORE_3,
	CORE_4,
	CORE_5,
	CORE_6,
	CORE_7,
	MAX_CORE,
	INVALID_CORE = 0xFF

}DSP_CORE;




//#define	TRUE	(BOOL)1
//#define FALSE	(BOOL)0




/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */
/*
 * ======== xdc.h ========
 *  All generated public module headers include this file
 */


/*
 *  ======== __CONC__ ========
 *  Concatenate the specified tokens to create a new single token
 */

/*
 *  ======== __STR__ ========
 *  Stringify the specified arguement
 */

/*
 *  ======== xdc_FILE__ ========
 *  Alternative to __FILE__ which defaults to NULL
 *
 *  We define our own symbol in lieu of the standard __FILE__
 *  so we can avoid embedding lots of static strings in applications
 *  that use Error and Assert.
 *
 *  Both Error and Assert use xdc_FILE__ and ALL module internal headers
 *  redefine xdc_FILE__ to be NULL, unless xdc_FILE is defined.  If xdc_FILE
 *  is defined, xdc-FILE__ has the same value assigned to xdc_FILE.  So, by
 *  default, Error and Asserts in modules do *not* provide a file name.
 *
 *  Since this header in included in all module public headers, "non-module"
 *  clients of Error and Assert *will*, by default, provide a file name
 *  string.  To eliminate these embedded strings, add the following line
 *  before all module headers:
 *      #define xdc_FILE    NULL
 *
 *  Module creators may opt to define xdc_FILE as the string to use in
 *  Error and Assert messages.  For example, adding the following line
 *  to a module's implementation (before the inclusion of the module's
 *  internal header) will cause the standard __FILE__ to be
 *  used in lieu of NULL in Error and Assert calls:
 *      #define xdc_FILE    __FILE__
 *
 */

/*
 *  ======== xdc_LINE ========
 *  Standard file-line-number string for identifying a call site
 */







/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */
/*
 *  ======== Types__prologue.h ========
 *  Hand crafted definitions for Types.xdc
 */
/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */



/*
 * ======== interface xdc.runtime.IModule ========
 */

typedef struct xdc_runtime_IModule_Fxns__ xdc_runtime_IModule_Fxns__;
typedef const xdc_runtime_IModule_Fxns__* xdc_runtime_IModule_Module;

/*
 * ======== module xdc.runtime.Assert ========
 */


/*
 * ======== module xdc.runtime.Core ========
 */

typedef struct xdc_runtime_Core_ObjDesc xdc_runtime_Core_ObjDesc;

/*
 * ======== module xdc.runtime.Defaults ========
 */


/*
 * ======== module xdc.runtime.Diags ========
 */

typedef struct xdc_runtime_Diags_DictElem xdc_runtime_Diags_DictElem;

/*
 * ======== module xdc.runtime.Error ========
 */

typedef struct xdc_runtime_Error_Data xdc_runtime_Error_Data;
typedef struct xdc_runtime_Error_Block xdc_runtime_Error_Block;
typedef struct xdc_runtime_Error_Module_State xdc_runtime_Error_Module_State;

/*
 * ======== module xdc.runtime.Gate ========
 */


/*
 * ======== interface xdc.runtime.IGateProvider ========
 */

typedef struct xdc_runtime_IGateProvider_Fxns__ xdc_runtime_IGateProvider_Fxns__;
typedef const xdc_runtime_IGateProvider_Fxns__* xdc_runtime_IGateProvider_Module;
typedef struct xdc_runtime_IGateProvider_Params xdc_runtime_IGateProvider_Params;
typedef struct xdc_runtime_IGateProvider___Object { xdc_runtime_IGateProvider_Fxns__* __fxns; xdc_Bits32 __label; } *xdc_runtime_IGateProvider_Handle;

/*
 * ======== module xdc.runtime.GateNull ========
 */

typedef struct xdc_runtime_GateNull_Fxns__ xdc_runtime_GateNull_Fxns__;
typedef const xdc_runtime_GateNull_Fxns__* xdc_runtime_GateNull_Module;
typedef struct xdc_runtime_GateNull_Params xdc_runtime_GateNull_Params;
typedef struct xdc_runtime_GateNull_Object xdc_runtime_GateNull_Object;
typedef struct xdc_runtime_GateNull_Struct xdc_runtime_GateNull_Struct;
typedef xdc_runtime_GateNull_Object* xdc_runtime_GateNull_Handle;
typedef struct xdc_runtime_GateNull_Object__ xdc_runtime_GateNull_Instance_State;
typedef xdc_runtime_GateNull_Object* xdc_runtime_GateNull_Instance;

/*
 * ======== module xdc.runtime.Log ========
 */

typedef struct xdc_runtime_Log_EventRec xdc_runtime_Log_EventRec;

/*
 * ======== interface xdc.runtime.ILogger ========
 */

typedef struct xdc_runtime_ILogger_Fxns__ xdc_runtime_ILogger_Fxns__;
typedef const xdc_runtime_ILogger_Fxns__* xdc_runtime_ILogger_Module;
typedef struct xdc_runtime_ILogger_Params xdc_runtime_ILogger_Params;
typedef struct xdc_runtime_ILogger___Object { xdc_runtime_ILogger_Fxns__* __fxns; xdc_Bits32 __label; } *xdc_runtime_ILogger_Handle;

/*
 * ======== interface xdc.runtime.IFilterLogger ========
 */

typedef struct xdc_runtime_IFilterLogger_Fxns__ xdc_runtime_IFilterLogger_Fxns__;
typedef const xdc_runtime_IFilterLogger_Fxns__* xdc_runtime_IFilterLogger_Module;
typedef struct xdc_runtime_IFilterLogger_Params xdc_runtime_IFilterLogger_Params;
typedef struct xdc_runtime_IFilterLogger___Object { xdc_runtime_IFilterLogger_Fxns__* __fxns; xdc_Bits32 __label; } *xdc_runtime_IFilterLogger_Handle;

/*
 * ======== module xdc.runtime.LoggerBuf ========
 */

typedef struct xdc_runtime_LoggerBuf_Entry xdc_runtime_LoggerBuf_Entry;
typedef struct xdc_runtime_LoggerBuf_Module_State xdc_runtime_LoggerBuf_Module_State;
typedef struct xdc_runtime_LoggerBuf_Fxns__ xdc_runtime_LoggerBuf_Fxns__;
typedef const xdc_runtime_LoggerBuf_Fxns__* xdc_runtime_LoggerBuf_Module;
typedef struct xdc_runtime_LoggerBuf_Params xdc_runtime_LoggerBuf_Params;
typedef struct xdc_runtime_LoggerBuf_Object xdc_runtime_LoggerBuf_Object;
typedef struct xdc_runtime_LoggerBuf_Struct xdc_runtime_LoggerBuf_Struct;
typedef xdc_runtime_LoggerBuf_Object* xdc_runtime_LoggerBuf_Handle;
typedef struct xdc_runtime_LoggerBuf_Object__ xdc_runtime_LoggerBuf_Instance_State;
typedef xdc_runtime_LoggerBuf_Object* xdc_runtime_LoggerBuf_Instance;

/*
 * ======== module xdc.runtime.LoggerSys ========
 */

typedef struct xdc_runtime_LoggerSys_Fxns__ xdc_runtime_LoggerSys_Fxns__;
typedef const xdc_runtime_LoggerSys_Fxns__* xdc_runtime_LoggerSys_Module;
typedef struct xdc_runtime_LoggerSys_Params xdc_runtime_LoggerSys_Params;
typedef struct xdc_runtime_LoggerSys_Object xdc_runtime_LoggerSys_Object;
typedef struct xdc_runtime_LoggerSys_Struct xdc_runtime_LoggerSys_Struct;
typedef xdc_runtime_LoggerSys_Object* xdc_runtime_LoggerSys_Handle;
typedef struct xdc_runtime_LoggerSys_Object__ xdc_runtime_LoggerSys_Instance_State;
typedef xdc_runtime_LoggerSys_Object* xdc_runtime_LoggerSys_Instance;

/*
 * ======== module xdc.runtime.Main ========
 */


/*
 * ======== module xdc.runtime.Memory ========
 */

typedef struct xdc_runtime_Memory_Stats xdc_runtime_Memory_Stats;
typedef struct xdc_runtime_Memory_Module_State xdc_runtime_Memory_Module_State;

/*
 * ======== interface xdc.runtime.IHeap ========
 */

typedef struct xdc_runtime_IHeap_Fxns__ xdc_runtime_IHeap_Fxns__;
typedef const xdc_runtime_IHeap_Fxns__* xdc_runtime_IHeap_Module;
typedef struct xdc_runtime_IHeap_Params xdc_runtime_IHeap_Params;
typedef struct xdc_runtime_IHeap___Object { xdc_runtime_IHeap_Fxns__* __fxns; xdc_Bits32 __label; } *xdc_runtime_IHeap_Handle;

/*
 * ======== module xdc.runtime.HeapMin ========
 */

typedef struct xdc_runtime_HeapMin_Fxns__ xdc_runtime_HeapMin_Fxns__;
typedef const xdc_runtime_HeapMin_Fxns__* xdc_runtime_HeapMin_Module;
typedef struct xdc_runtime_HeapMin_Params xdc_runtime_HeapMin_Params;
typedef struct xdc_runtime_HeapMin_Object xdc_runtime_HeapMin_Object;
typedef struct xdc_runtime_HeapMin_Struct xdc_runtime_HeapMin_Struct;
typedef xdc_runtime_HeapMin_Object* xdc_runtime_HeapMin_Handle;
typedef struct xdc_runtime_HeapMin_Object__ xdc_runtime_HeapMin_Instance_State;
typedef xdc_runtime_HeapMin_Object* xdc_runtime_HeapMin_Instance;

/*
 * ======== module xdc.runtime.HeapStd ========
 */

typedef struct xdc_runtime_HeapStd_Module_State xdc_runtime_HeapStd_Module_State;
typedef struct xdc_runtime_HeapStd_Fxns__ xdc_runtime_HeapStd_Fxns__;
typedef const xdc_runtime_HeapStd_Fxns__* xdc_runtime_HeapStd_Module;
typedef struct xdc_runtime_HeapStd_Params xdc_runtime_HeapStd_Params;
typedef struct xdc_runtime_HeapStd_Object xdc_runtime_HeapStd_Object;
typedef struct xdc_runtime_HeapStd_Struct xdc_runtime_HeapStd_Struct;
typedef xdc_runtime_HeapStd_Object* xdc_runtime_HeapStd_Handle;
typedef struct xdc_runtime_HeapStd_Object__ xdc_runtime_HeapStd_Instance_State;
typedef xdc_runtime_HeapStd_Object* xdc_runtime_HeapStd_Instance;

/*
 * ======== module xdc.runtime.Registry ========
 */

typedef struct xdc_runtime_Registry_Module_State xdc_runtime_Registry_Module_State;

/*
 * ======== module xdc.runtime.Rta ========
 */

typedef struct xdc_runtime_Rta_CommandPacket xdc_runtime_Rta_CommandPacket;
typedef struct xdc_runtime_Rta_ResponsePacket xdc_runtime_Rta_ResponsePacket;

/*
 * ======== module xdc.runtime.Startup ========
 */

typedef struct xdc_runtime_Startup_Module_State xdc_runtime_Startup_Module_State;

/*
 * ======== module xdc.runtime.System ========
 */

typedef struct xdc_runtime_System_ParseData xdc_runtime_System_ParseData;
typedef struct xdc_runtime_System_Module_State xdc_runtime_System_Module_State;

/*
 * ======== interface xdc.runtime.ISystemSupport ========
 */

typedef struct xdc_runtime_ISystemSupport_Fxns__ xdc_runtime_ISystemSupport_Fxns__;
typedef const xdc_runtime_ISystemSupport_Fxns__* xdc_runtime_ISystemSupport_Module;

/*
 * ======== module xdc.runtime.SysStd ========
 */

typedef struct xdc_runtime_SysStd_Fxns__ xdc_runtime_SysStd_Fxns__;
typedef const xdc_runtime_SysStd_Fxns__* xdc_runtime_SysStd_Module;

/*
 * ======== module xdc.runtime.SysMin ========
 */

typedef struct xdc_runtime_SysMin_Module_State xdc_runtime_SysMin_Module_State;
typedef struct xdc_runtime_SysMin_Fxns__ xdc_runtime_SysMin_Fxns__;
typedef const xdc_runtime_SysMin_Fxns__* xdc_runtime_SysMin_Module;

/*
 * ======== module xdc.runtime.Text ========
 */

typedef struct xdc_runtime_Text_Node xdc_runtime_Text_Node;
typedef struct xdc_runtime_Text_MatchVisState xdc_runtime_Text_MatchVisState;
typedef struct xdc_runtime_Text_PrintVisState xdc_runtime_Text_PrintVisState;
typedef struct xdc_runtime_Text_Module_State xdc_runtime_Text_Module_State;

/*
 * ======== interface xdc.runtime.ITimestampClient ========
 */

typedef struct xdc_runtime_ITimestampClient_Fxns__ xdc_runtime_ITimestampClient_Fxns__;
typedef const xdc_runtime_ITimestampClient_Fxns__* xdc_runtime_ITimestampClient_Module;

/*
 * ======== module xdc.runtime.Timestamp ========
 */

typedef struct xdc_runtime_Timestamp_Fxns__ xdc_runtime_Timestamp_Fxns__;
typedef const xdc_runtime_Timestamp_Fxns__* xdc_runtime_Timestamp_Module;

/*
 * ======== interface xdc.runtime.ITimestampProvider ========
 */

typedef struct xdc_runtime_ITimestampProvider_Fxns__ xdc_runtime_ITimestampProvider_Fxns__;
typedef const xdc_runtime_ITimestampProvider_Fxns__* xdc_runtime_ITimestampProvider_Module;

/*
 * ======== module xdc.runtime.TimestampNull ========
 */

typedef struct xdc_runtime_TimestampNull_Fxns__ xdc_runtime_TimestampNull_Fxns__;
typedef const xdc_runtime_TimestampNull_Fxns__* xdc_runtime_TimestampNull_Module;

/*
 * ======== module xdc.runtime.TimestampStd ========
 */

typedef struct xdc_runtime_TimestampStd_Fxns__ xdc_runtime_TimestampStd_Fxns__;
typedef const xdc_runtime_TimestampStd_Fxns__* xdc_runtime_TimestampStd_Module;

/*
 * ======== module xdc.runtime.Types ========
 */

typedef struct xdc_runtime_Types_CordAddr__ xdc_runtime_Types_CordAddr__;
typedef struct xdc_runtime_Types_GateRef__ xdc_runtime_Types_GateRef__;
typedef struct xdc_runtime_Types_Label xdc_runtime_Types_Label;
typedef struct xdc_runtime_Types_Site xdc_runtime_Types_Site;
typedef struct xdc_runtime_Types_Timestamp64 xdc_runtime_Types_Timestamp64;
typedef struct xdc_runtime_Types_FreqHz xdc_runtime_Types_FreqHz;
typedef struct xdc_runtime_Types_RegDesc xdc_runtime_Types_RegDesc;
typedef struct xdc_runtime_Types_Vec xdc_runtime_Types_Vec;
typedef struct xdc_runtime_Types_Link xdc_runtime_Types_Link;
typedef struct xdc_runtime_Types_InstHdr xdc_runtime_Types_InstHdr;
typedef struct xdc_runtime_Types_PrmsHdr xdc_runtime_Types_PrmsHdr;
typedef struct xdc_runtime_Types_Base xdc_runtime_Types_Base;
typedef struct xdc_runtime_Types_SysFxns xdc_runtime_Types_SysFxns;
typedef struct xdc_runtime_Types_SysFxns2 xdc_runtime_Types_SysFxns2;

/*
 * ======== interface xdc.runtime.IInstance ========
 */

typedef struct xdc_runtime_IInstance_Fxns__ xdc_runtime_IInstance_Fxns__;
typedef const xdc_runtime_IInstance_Fxns__* xdc_runtime_IInstance_Module;
typedef struct xdc_runtime_IInstance_Params xdc_runtime_IInstance_Params;
typedef struct xdc_runtime_IInstance___Object { xdc_runtime_IInstance_Fxns__* __fxns; xdc_Bits32 __label; } *xdc_runtime_IInstance_Handle;

/*
 * ======== module xdc.runtime.LoggerBuf_TimestampProxy ========
 */

typedef struct xdc_runtime_LoggerBuf_TimestampProxy_Fxns__ xdc_runtime_LoggerBuf_TimestampProxy_Fxns__;
typedef const xdc_runtime_LoggerBuf_TimestampProxy_Fxns__* xdc_runtime_LoggerBuf_TimestampProxy_Module;

/*
 * ======== module xdc.runtime.LoggerBuf_Module_GateProxy ========
 */

typedef struct xdc_runtime_LoggerBuf_Module_GateProxy_Fxns__ xdc_runtime_LoggerBuf_Module_GateProxy_Fxns__;
typedef const xdc_runtime_LoggerBuf_Module_GateProxy_Fxns__* xdc_runtime_LoggerBuf_Module_GateProxy_Module;
typedef struct xdc_runtime_LoggerBuf_Module_GateProxy_Params xdc_runtime_LoggerBuf_Module_GateProxy_Params;
typedef struct xdc_runtime_IGateProvider___Object *xdc_runtime_LoggerBuf_Module_GateProxy_Handle;

/*
 * ======== module xdc.runtime.LoggerSys_TimestampProxy ========
 */

typedef struct xdc_runtime_LoggerSys_TimestampProxy_Fxns__ xdc_runtime_LoggerSys_TimestampProxy_Fxns__;
typedef const xdc_runtime_LoggerSys_TimestampProxy_Fxns__* xdc_runtime_LoggerSys_TimestampProxy_Module;

/*
 * ======== module xdc.runtime.Main_Module_GateProxy ========
 */

typedef struct xdc_runtime_Main_Module_GateProxy_Fxns__ xdc_runtime_Main_Module_GateProxy_Fxns__;
typedef const xdc_runtime_Main_Module_GateProxy_Fxns__* xdc_runtime_Main_Module_GateProxy_Module;
typedef struct xdc_runtime_Main_Module_GateProxy_Params xdc_runtime_Main_Module_GateProxy_Params;
typedef struct xdc_runtime_IGateProvider___Object *xdc_runtime_Main_Module_GateProxy_Handle;

/*
 * ======== module xdc.runtime.Memory_HeapProxy ========
 */

typedef struct xdc_runtime_Memory_HeapProxy_Fxns__ xdc_runtime_Memory_HeapProxy_Fxns__;
typedef const xdc_runtime_Memory_HeapProxy_Fxns__* xdc_runtime_Memory_HeapProxy_Module;
typedef struct xdc_runtime_Memory_HeapProxy_Params xdc_runtime_Memory_HeapProxy_Params;
typedef struct xdc_runtime_IHeap___Object *xdc_runtime_Memory_HeapProxy_Handle;

/*
 * ======== module xdc.runtime.System_SupportProxy ========
 */

typedef struct xdc_runtime_System_SupportProxy_Fxns__ xdc_runtime_System_SupportProxy_Fxns__;
typedef const xdc_runtime_System_SupportProxy_Fxns__* xdc_runtime_System_SupportProxy_Module;

/*
 * ======== module xdc.runtime.System_Module_GateProxy ========
 */

typedef struct xdc_runtime_System_Module_GateProxy_Fxns__ xdc_runtime_System_Module_GateProxy_Fxns__;
typedef const xdc_runtime_System_Module_GateProxy_Fxns__* xdc_runtime_System_Module_GateProxy_Module;
typedef struct xdc_runtime_System_Module_GateProxy_Params xdc_runtime_System_Module_GateProxy_Params;
typedef struct xdc_runtime_IGateProvider___Object *xdc_runtime_System_Module_GateProxy_Handle;

/*
 * ======== module xdc.runtime.Timestamp_SupportProxy ========
 */

typedef struct xdc_runtime_Timestamp_SupportProxy_Fxns__ xdc_runtime_Timestamp_SupportProxy_Fxns__;
typedef const xdc_runtime_Timestamp_SupportProxy_Fxns__* xdc_runtime_Timestamp_SupportProxy_Module;




/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* ModuleId */
typedef xdc_Bits16 xdc_runtime_Types_ModuleId;

/* DiagsMask */
typedef xdc_Bits16 xdc_runtime_Types_DiagsMask;

/* Event */
typedef xdc_Bits32 xdc_runtime_Types_Event;

/* EventId */
typedef xdc_runtime_Types_Event xdc_runtime_Types_EventId;

/* CordAddr__ */
struct xdc_runtime_Types_CordAddr__;

/* CordAddr */
typedef xdc_runtime_Types_CordAddr__* xdc_runtime_Types_CordAddr;

/* GateRef__ */
struct xdc_runtime_Types_GateRef__;

/* GateRef */
typedef xdc_runtime_Types_GateRef__* xdc_runtime_Types_GateRef;

/* RopeId */
typedef xdc_Bits16 xdc_runtime_Types_RopeId;

/* CreatePolicy */
enum xdc_runtime_Types_CreatePolicy {
    xdc_runtime_Types_STATIC_POLICY,
    xdc_runtime_Types_CREATE_POLICY,
    xdc_runtime_Types_DELETE_POLICY
};
typedef enum xdc_runtime_Types_CreatePolicy xdc_runtime_Types_CreatePolicy;

/* Label */
struct xdc_runtime_Types_Label {
    xdc_Ptr handle;
    xdc_runtime_Types_ModuleId modId;
    xdc_String iname;
    xdc_Bool named;
};

/* Site */
struct xdc_runtime_Types_Site {
    xdc_runtime_Types_ModuleId mod;
    xdc_String file;
    xdc_Int line;
};

/* Timestamp64 */
struct xdc_runtime_Types_Timestamp64 {
    xdc_Bits32 hi;
    xdc_Bits32 lo;
};

/* FreqHz */
struct xdc_runtime_Types_FreqHz {
    xdc_Bits32 hi;
    xdc_Bits32 lo;
};

/* RegDesc */
struct xdc_runtime_Types_RegDesc {
    xdc_runtime_Types_RegDesc* next;
    xdc_String modName;
    xdc_runtime_Types_ModuleId id;
    xdc_runtime_Types_DiagsMask mask;
};


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* LogEvent */
typedef xdc_Bits32 xdc_runtime_Types_LogEvent;

/* LoggerFxn0 */
typedef void (*xdc_runtime_Types_LoggerFxn0)(xdc_Ptr, xdc_runtime_Types_LogEvent, xdc_runtime_Types_ModuleId);

/* LoggerFxn1 */
typedef void (*xdc_runtime_Types_LoggerFxn1)(xdc_Ptr, xdc_runtime_Types_LogEvent, xdc_runtime_Types_ModuleId, xdc_IArg);

/* LoggerFxn2 */
typedef void (*xdc_runtime_Types_LoggerFxn2)(xdc_Ptr, xdc_runtime_Types_LogEvent, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg);

/* LoggerFxn4 */
typedef void (*xdc_runtime_Types_LoggerFxn4)(xdc_Ptr, xdc_runtime_Types_LogEvent, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);

/* LoggerFxn8 */
typedef void (*xdc_runtime_Types_LoggerFxn8)(xdc_Ptr, xdc_runtime_Types_LogEvent, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);

/* Vec */
struct xdc_runtime_Types_Vec {
    xdc_Int len;
    xdc_Ptr arr;
};

/* Link */
struct xdc_runtime_Types_Link {
    xdc_runtime_Types_Link* next;
    xdc_runtime_Types_Link* prev;
};

/* InstHdr */
struct xdc_runtime_Types_InstHdr {
    xdc_runtime_Types_Link link;
};

/* PrmsHdr */
struct xdc_runtime_Types_PrmsHdr {
    xdc_SizeT size;
    xdc_Ptr self;
    xdc_Ptr modFxns;
    xdc_Ptr instPrms;
};

/* Base */
struct xdc_runtime_Types_Base {
    xdc_runtime_Types_Base* base;
};

/* SysFxns */
struct xdc_runtime_Types_SysFxns {
    xdc_Ptr (*__create)(xdc_Ptr, xdc_SizeT, const xdc_Ptr, const xdc_Ptr, xdc_SizeT, xdc_runtime_Error_Block*);
    void (*__delete)(xdc_Ptr);
    xdc_runtime_Types_Label* (*__label)(xdc_Ptr, xdc_runtime_Types_Label*);
    xdc_runtime_Types_ModuleId __mid;
};

/* SysFxns2 */
struct xdc_runtime_Types_SysFxns2 {
    xdc_Ptr (*__create)(xdc_Ptr, xdc_SizeT, const xdc_Ptr, const xdc_UChar*, xdc_SizeT, xdc_runtime_Error_Block*);
    void (*__delete)(xdc_Ptr);
    xdc_runtime_Types_Label* (*__label)(xdc_Ptr, xdc_runtime_Types_Label*);
    xdc_runtime_Types_ModuleId __mid;
};


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Types_Module__diagsEnabled;
extern far const CT__xdc_runtime_Types_Module__diagsEnabled xdc_runtime_Types_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Types_Module__diagsIncluded;
extern far const CT__xdc_runtime_Types_Module__diagsIncluded xdc_runtime_Types_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Types_Module__diagsMask;
extern far const CT__xdc_runtime_Types_Module__diagsMask xdc_runtime_Types_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Types_Module__gateObj;
extern far const CT__xdc_runtime_Types_Module__gateObj xdc_runtime_Types_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Types_Module__gatePrms;
extern far const CT__xdc_runtime_Types_Module__gatePrms xdc_runtime_Types_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Types_Module__id;
extern far const CT__xdc_runtime_Types_Module__id xdc_runtime_Types_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Types_Module__loggerDefined;
extern far const CT__xdc_runtime_Types_Module__loggerDefined xdc_runtime_Types_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Types_Module__loggerObj;
extern far const CT__xdc_runtime_Types_Module__loggerObj xdc_runtime_Types_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Types_Module__loggerFxn0;
extern far const CT__xdc_runtime_Types_Module__loggerFxn0 xdc_runtime_Types_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Types_Module__loggerFxn1;
extern far const CT__xdc_runtime_Types_Module__loggerFxn1 xdc_runtime_Types_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Types_Module__loggerFxn2;
extern far const CT__xdc_runtime_Types_Module__loggerFxn2 xdc_runtime_Types_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Types_Module__loggerFxn4;
extern far const CT__xdc_runtime_Types_Module__loggerFxn4 xdc_runtime_Types_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Types_Module__loggerFxn8;
extern far const CT__xdc_runtime_Types_Module__loggerFxn8 xdc_runtime_Types_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Types_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Types_Module__startupDoneFxn xdc_runtime_Types_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Types_Object__count;
extern far const CT__xdc_runtime_Types_Object__count xdc_runtime_Types_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Types_Object__heap;
extern far const CT__xdc_runtime_Types_Object__heap xdc_runtime_Types_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Types_Object__sizeof;
extern far const CT__xdc_runtime_Types_Object__sizeof xdc_runtime_Types_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Types_Object__table;
extern far const CT__xdc_runtime_Types_Object__table xdc_runtime_Types_Object__table__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Types_Module__startupDone__S( void );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Types_Module__id xdc_runtime_Types_Module_id( void ) 
{
    return xdc_runtime_Types_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_Types_Module_hasMask( void ) 
{
    return xdc_runtime_Types_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_Types_Module_getMask( void ) 
{
    return xdc_runtime_Types_Module__diagsMask__C != 0 ? *xdc_runtime_Types_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_Types_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_Types_Module__diagsMask__C != 0) *xdc_runtime_Types_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */
/*
 *  ======== Types__epilogue.h ========
 *  Hand crafted macros for Types.xdc
 */

/*
 *  ======== xdc_runtime_Types_getEventId ========
 */

/*
 *  ======== xdc_runtime_Types_makeEvent ========
 */

/*
 *  ======== xdc_runtime_Types_getModuleId ========
 */
/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */





/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_IInstance_Params {
    size_t __size;
    xdc_String name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_IInstance_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base xdc_runtime_IInstance_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* delete */
static inline void xdc_runtime_IInstance_delete( xdc_runtime_IInstance_Handle* instp )
{
    (*instp)->__fxns->__sysp->__delete(instp);
}

/* Handle_to_Module */
static inline xdc_runtime_IInstance_Module xdc_runtime_IInstance_Handle_to_Module( xdc_runtime_IInstance_Handle inst )
{
    return inst->__fxns;
}

/* Handle_label */
static inline xdc_runtime_Types_Label* xdc_runtime_IInstance_Handle_label( xdc_runtime_IInstance_Handle inst, xdc_runtime_Types_Label* lab )
{
    return inst->__fxns->__sysp->__label(inst, lab);
}

/* Module_id */
static inline xdc_runtime_Types_ModuleId xdc_runtime_IInstance_Module_id( xdc_runtime_IInstance_Module mod )
{
    return mod->__sysp->__mid;
}


/*
 * ======== FUNCTION SELECTORS ========
 */


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Memory_HeapProxy_Module__diagsEnabled;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__diagsEnabled xdc_runtime_Memory_HeapProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Memory_HeapProxy_Module__diagsIncluded;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__diagsIncluded xdc_runtime_Memory_HeapProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Memory_HeapProxy_Module__diagsMask;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__diagsMask xdc_runtime_Memory_HeapProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Memory_HeapProxy_Module__gateObj;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__gateObj xdc_runtime_Memory_HeapProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Memory_HeapProxy_Module__gatePrms;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__gatePrms xdc_runtime_Memory_HeapProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Memory_HeapProxy_Module__id;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__id xdc_runtime_Memory_HeapProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Memory_HeapProxy_Module__loggerDefined;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__loggerDefined xdc_runtime_Memory_HeapProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Memory_HeapProxy_Module__loggerObj;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__loggerObj xdc_runtime_Memory_HeapProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn0;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn0 xdc_runtime_Memory_HeapProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn1;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn1 xdc_runtime_Memory_HeapProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn2;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn2 xdc_runtime_Memory_HeapProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn4;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn4 xdc_runtime_Memory_HeapProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn8;
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__loggerFxn8 xdc_runtime_Memory_HeapProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Memory_HeapProxy_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Memory_HeapProxy_Module__startupDoneFxn xdc_runtime_Memory_HeapProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Memory_HeapProxy_Object__count;
extern far const CT__xdc_runtime_Memory_HeapProxy_Object__count xdc_runtime_Memory_HeapProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Memory_HeapProxy_Object__heap;
extern far const CT__xdc_runtime_Memory_HeapProxy_Object__heap xdc_runtime_Memory_HeapProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Memory_HeapProxy_Object__sizeof;
extern far const CT__xdc_runtime_Memory_HeapProxy_Object__sizeof xdc_runtime_Memory_HeapProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Memory_HeapProxy_Object__table;
extern far const CT__xdc_runtime_Memory_HeapProxy_Object__table xdc_runtime_Memory_HeapProxy_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_Memory_HeapProxy_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct xdc_runtime_Memory_HeapProxy_Struct {
    const xdc_runtime_Memory_HeapProxy_Fxns__* __fxns;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_Memory_HeapProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Ptr (*alloc)(xdc_runtime_Memory_HeapProxy_Handle, xdc_SizeT, xdc_SizeT, xdc_runtime_Error_Block*);
    void (*free)(xdc_runtime_Memory_HeapProxy_Handle, xdc_Ptr, xdc_SizeT);
    xdc_Bool (*isBlocking)(xdc_runtime_Memory_HeapProxy_Handle);
    void (*getStats)(xdc_runtime_Memory_HeapProxy_Handle, xdc_runtime_Memory_Stats*);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const xdc_runtime_Memory_HeapProxy_Fxns__ xdc_runtime_Memory_HeapProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* xdc_runtime_Memory_HeapProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Memory_HeapProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr xdc_runtime_Memory_HeapProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void xdc_runtime_Memory_HeapProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void xdc_runtime_Memory_HeapProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr xdc_runtime_Memory_HeapProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr xdc_runtime_Memory_HeapProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr xdc_runtime_Memory_HeapProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void xdc_runtime_Memory_HeapProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool xdc_runtime_Memory_HeapProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr xdc_runtime_Memory_HeapProxy_Proxy__delegate__S( void );

/* alloc__E */

extern xdc_Ptr xdc_runtime_Memory_HeapProxy_alloc__E( xdc_runtime_Memory_HeapProxy_Handle __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

extern xdc_Ptr xdc_runtime_Memory_HeapProxy_alloc__R( xdc_runtime_Memory_HeapProxy_Handle __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

/* free__E */

extern void xdc_runtime_Memory_HeapProxy_free__E( xdc_runtime_Memory_HeapProxy_Handle __inst, xdc_Ptr block, xdc_SizeT size );

extern void xdc_runtime_Memory_HeapProxy_free__R( xdc_runtime_Memory_HeapProxy_Handle __inst, xdc_Ptr block, xdc_SizeT size );

/* isBlocking__E */

extern xdc_Bool xdc_runtime_Memory_HeapProxy_isBlocking__E( xdc_runtime_Memory_HeapProxy_Handle __inst );

extern xdc_Bool xdc_runtime_Memory_HeapProxy_isBlocking__R( xdc_runtime_Memory_HeapProxy_Handle __inst );

/* getStats__E */

extern void xdc_runtime_Memory_HeapProxy_getStats__E( xdc_runtime_Memory_HeapProxy_Handle __inst, xdc_runtime_Memory_Stats* stats );

extern void xdc_runtime_Memory_HeapProxy_getStats__R( xdc_runtime_Memory_HeapProxy_Handle __inst, xdc_runtime_Memory_Stats* stats );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* alloc_{FxnT,fxnP} */
typedef xdc_Ptr (*xdc_runtime_Memory_HeapProxy_alloc_FxnT)(void*, xdc_SizeT, xdc_SizeT, xdc_runtime_Error_Block*);
static inline xdc_runtime_Memory_HeapProxy_alloc_FxnT xdc_runtime_Memory_HeapProxy_alloc_fxnP( void )
{
    return (xdc_runtime_Memory_HeapProxy_alloc_FxnT)xdc_runtime_Memory_HeapProxy_alloc__E; 
}

/* free_{FxnT,fxnP} */
typedef void (*xdc_runtime_Memory_HeapProxy_free_FxnT)(void*, xdc_Ptr, xdc_SizeT);
static inline xdc_runtime_Memory_HeapProxy_free_FxnT xdc_runtime_Memory_HeapProxy_free_fxnP( void )
{
    return (xdc_runtime_Memory_HeapProxy_free_FxnT)xdc_runtime_Memory_HeapProxy_free__E; 
}

/* isBlocking_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_Memory_HeapProxy_isBlocking_FxnT)(void*);
static inline xdc_runtime_Memory_HeapProxy_isBlocking_FxnT xdc_runtime_Memory_HeapProxy_isBlocking_fxnP( void )
{
    return (xdc_runtime_Memory_HeapProxy_isBlocking_FxnT)xdc_runtime_Memory_HeapProxy_isBlocking__E; 
}

/* getStats_{FxnT,fxnP} */
typedef void (*xdc_runtime_Memory_HeapProxy_getStats_FxnT)(void*, xdc_runtime_Memory_Stats*);
static inline xdc_runtime_Memory_HeapProxy_getStats_FxnT xdc_runtime_Memory_HeapProxy_getStats_fxnP( void )
{
    return (xdc_runtime_Memory_HeapProxy_getStats_FxnT)xdc_runtime_Memory_HeapProxy_getStats__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IHeap_Module xdc_runtime_Memory_HeapProxy_Module_upCast( void )
{
    return (xdc_runtime_IHeap_Module)xdc_runtime_Memory_HeapProxy_Proxy__delegate__S();
}

/* Module_to_xdc_runtime_IHeap */

/* Handle_upCast */
static inline xdc_runtime_IHeap_Handle xdc_runtime_Memory_HeapProxy_Handle_upCast( xdc_runtime_Memory_HeapProxy_Handle i )
{
    return (xdc_runtime_IHeap_Handle)i;
}

/* Handle_to_xdc_runtime_IHeap */

/* Handle_downCast */
static inline xdc_runtime_Memory_HeapProxy_Handle xdc_runtime_Memory_HeapProxy_Handle_downCast( xdc_runtime_IHeap_Handle i )
{
    xdc_runtime_IHeap_Handle i2 = (xdc_runtime_IHeap_Handle)i;
if (xdc_runtime_Memory_HeapProxy_Proxy__abstract__S()) return (xdc_runtime_Memory_HeapProxy_Handle)i;
    return (void*)i2->__fxns == (void*)xdc_runtime_Memory_HeapProxy_Proxy__delegate__S() ? (xdc_runtime_Memory_HeapProxy_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IHeap */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Memory_HeapProxy_Module__id xdc_runtime_Memory_HeapProxy_Module_id( void ) 
{
    return xdc_runtime_Memory_HeapProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */

/* Params_init */
static inline void xdc_runtime_Memory_HeapProxy_Params_init( xdc_runtime_Memory_HeapProxy_Params* prms ) 
{
    if (prms) {
        xdc_runtime_Memory_HeapProxy_Params__init__S(prms, 0, sizeof(xdc_runtime_Memory_HeapProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void xdc_runtime_Memory_HeapProxy_Params_copy( xdc_runtime_Memory_HeapProxy_Params* dst, const xdc_runtime_Memory_HeapProxy_Params* src ) 
{
    if (dst) {
        xdc_runtime_Memory_HeapProxy_Params__init__S(dst, (xdc_Ptr)src, sizeof(xdc_runtime_Memory_HeapProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* create */
static inline xdc_runtime_Memory_HeapProxy_Handle xdc_runtime_Memory_HeapProxy_create( const xdc_runtime_Memory_HeapProxy_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (xdc_runtime_Memory_HeapProxy_Handle)xdc_runtime_Memory_HeapProxy_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(xdc_runtime_Memory_HeapProxy_Params), __eb);
}

/* delete */
static inline void xdc_runtime_Memory_HeapProxy_delete( xdc_runtime_Memory_HeapProxy_Handle* instp )
{
    xdc_runtime_Memory_HeapProxy_Object__delete__S(instp);
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Q_BLOCKING */

/* Size */
typedef xdc_UArg xdc_runtime_Memory_Size;

/* Stats */
struct xdc_runtime_Memory_Stats {
    xdc_runtime_Memory_Size totalSize;
    xdc_runtime_Memory_Size totalFreeSize;
    xdc_runtime_Memory_Size largestFreeSize;
};


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Memory_Module__diagsEnabled;
extern far const CT__xdc_runtime_Memory_Module__diagsEnabled xdc_runtime_Memory_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Memory_Module__diagsIncluded;
extern far const CT__xdc_runtime_Memory_Module__diagsIncluded xdc_runtime_Memory_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Memory_Module__diagsMask;
extern far const CT__xdc_runtime_Memory_Module__diagsMask xdc_runtime_Memory_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Memory_Module__gateObj;
extern far const CT__xdc_runtime_Memory_Module__gateObj xdc_runtime_Memory_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Memory_Module__gatePrms;
extern far const CT__xdc_runtime_Memory_Module__gatePrms xdc_runtime_Memory_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Memory_Module__id;
extern far const CT__xdc_runtime_Memory_Module__id xdc_runtime_Memory_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Memory_Module__loggerDefined;
extern far const CT__xdc_runtime_Memory_Module__loggerDefined xdc_runtime_Memory_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Memory_Module__loggerObj;
extern far const CT__xdc_runtime_Memory_Module__loggerObj xdc_runtime_Memory_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Memory_Module__loggerFxn0;
extern far const CT__xdc_runtime_Memory_Module__loggerFxn0 xdc_runtime_Memory_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Memory_Module__loggerFxn1;
extern far const CT__xdc_runtime_Memory_Module__loggerFxn1 xdc_runtime_Memory_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Memory_Module__loggerFxn2;
extern far const CT__xdc_runtime_Memory_Module__loggerFxn2 xdc_runtime_Memory_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Memory_Module__loggerFxn4;
extern far const CT__xdc_runtime_Memory_Module__loggerFxn4 xdc_runtime_Memory_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Memory_Module__loggerFxn8;
extern far const CT__xdc_runtime_Memory_Module__loggerFxn8 xdc_runtime_Memory_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Memory_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Memory_Module__startupDoneFxn xdc_runtime_Memory_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Memory_Object__count;
extern far const CT__xdc_runtime_Memory_Object__count xdc_runtime_Memory_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Memory_Object__heap;
extern far const CT__xdc_runtime_Memory_Object__heap xdc_runtime_Memory_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Memory_Object__sizeof;
extern far const CT__xdc_runtime_Memory_Object__sizeof xdc_runtime_Memory_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Memory_Object__table;
extern far const CT__xdc_runtime_Memory_Object__table xdc_runtime_Memory_Object__table__C;

/* defaultHeapInstance */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Memory_defaultHeapInstance;
extern far const CT__xdc_runtime_Memory_defaultHeapInstance xdc_runtime_Memory_defaultHeapInstance__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Memory_Module__startupDone__S( void );

/* alloc__E */

extern xdc_Ptr xdc_runtime_Memory_alloc__E( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

extern xdc_Ptr xdc_runtime_Memory_alloc__F( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );
extern xdc_Ptr xdc_runtime_Memory_alloc__R( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

/* calloc__E */

extern xdc_Ptr xdc_runtime_Memory_calloc__E( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

extern xdc_Ptr xdc_runtime_Memory_calloc__F( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );
extern xdc_Ptr xdc_runtime_Memory_calloc__R( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

/* free__E */

extern void xdc_runtime_Memory_free__E( xdc_runtime_IHeap_Handle heap, xdc_Ptr block, xdc_SizeT size );

extern void xdc_runtime_Memory_free__F( xdc_runtime_IHeap_Handle heap, xdc_Ptr block, xdc_SizeT size );
extern void xdc_runtime_Memory_free__R( xdc_runtime_IHeap_Handle heap, xdc_Ptr block, xdc_SizeT size );

/* getStats__E */

extern void xdc_runtime_Memory_getStats__E( xdc_runtime_IHeap_Handle heap, xdc_runtime_Memory_Stats* stats );

extern void xdc_runtime_Memory_getStats__F( xdc_runtime_IHeap_Handle heap, xdc_runtime_Memory_Stats* stats );
extern void xdc_runtime_Memory_getStats__R( xdc_runtime_IHeap_Handle heap, xdc_runtime_Memory_Stats* stats );

/* query__E */

extern xdc_Bool xdc_runtime_Memory_query__E( xdc_runtime_IHeap_Handle heap, xdc_Int qual );

extern xdc_Bool xdc_runtime_Memory_query__F( xdc_runtime_IHeap_Handle heap, xdc_Int qual );
extern xdc_Bool xdc_runtime_Memory_query__R( xdc_runtime_IHeap_Handle heap, xdc_Int qual );

/* getMaxDefaultTypeAlign__E */

extern xdc_SizeT xdc_runtime_Memory_getMaxDefaultTypeAlign__E( void );

extern xdc_SizeT xdc_runtime_Memory_getMaxDefaultTypeAlign__F( void );
extern xdc_SizeT xdc_runtime_Memory_getMaxDefaultTypeAlign__R( void );

/* valloc__E */

extern xdc_Ptr xdc_runtime_Memory_valloc__E( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_Char value, xdc_runtime_Error_Block* eb );

extern xdc_Ptr xdc_runtime_Memory_valloc__F( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_Char value, xdc_runtime_Error_Block* eb );
extern xdc_Ptr xdc_runtime_Memory_valloc__R( xdc_runtime_IHeap_Handle heap, xdc_SizeT size, xdc_SizeT align, xdc_Char value, xdc_runtime_Error_Block* eb );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Memory_Module__id xdc_runtime_Memory_Module_id( void ) 
{
    return xdc_runtime_Memory_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_Memory_Module_hasMask( void ) 
{
    return xdc_runtime_Memory_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_Memory_Module_getMask( void ) 
{
    return xdc_runtime_Memory_Module__diagsMask__C != 0 ? *xdc_runtime_Memory_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_Memory_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_Memory_Module__diagsMask__C != 0) *xdc_runtime_Memory_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_IHeap_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_IHeap_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Ptr (*alloc)(void*, xdc_SizeT, xdc_SizeT, xdc_runtime_Error_Block*);
    void (*free)(void*, xdc_Ptr, xdc_SizeT);
    xdc_Bool (*isBlocking)(void*);
    void (*getStats)(void*, xdc_runtime_Memory_Stats*);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base xdc_runtime_IHeap_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* create */
static inline xdc_runtime_IHeap_Handle xdc_runtime_IHeap_create( xdc_runtime_IHeap_Module __mod, const xdc_runtime_IHeap_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (xdc_runtime_IHeap_Handle) __mod->__sysp->__create(0, 0, 0, (const xdc_UChar*)__prms, sizeof (xdc_runtime_IHeap_Params), __eb);
}

/* delete */
static inline void xdc_runtime_IHeap_delete( xdc_runtime_IHeap_Handle* instp )
{
    (*instp)->__fxns->__sysp->__delete(instp);
}

/* Handle_to_Module */
static inline xdc_runtime_IHeap_Module xdc_runtime_IHeap_Handle_to_Module( xdc_runtime_IHeap_Handle inst )
{
    return inst->__fxns;
}

/* Handle_label */
static inline xdc_runtime_Types_Label* xdc_runtime_IHeap_Handle_label( xdc_runtime_IHeap_Handle inst, xdc_runtime_Types_Label* lab )
{
    return inst->__fxns->__sysp->__label(inst, lab);
}

/* Module_id */
static inline xdc_runtime_Types_ModuleId xdc_runtime_IHeap_Module_id( xdc_runtime_IHeap_Module mod )
{
    return mod->__sysp->__mid;
}

/* alloc */
static inline xdc_Ptr xdc_runtime_IHeap_alloc( xdc_runtime_IHeap_Handle __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb )
{
    return __inst->__fxns->alloc((void*)__inst, size, align, eb);
}

/* free */
static inline void xdc_runtime_IHeap_free( xdc_runtime_IHeap_Handle __inst, xdc_Ptr block, xdc_SizeT size )
{
    __inst->__fxns->free((void*)__inst, block, size);
}

/* isBlocking */
static inline xdc_Bool xdc_runtime_IHeap_isBlocking( xdc_runtime_IHeap_Handle __inst )
{
    return __inst->__fxns->isBlocking((void*)__inst);
}

/* getStats */
static inline void xdc_runtime_IHeap_getStats( xdc_runtime_IHeap_Handle __inst, xdc_runtime_Memory_Stats* stats )
{
    __inst->__fxns->getStats((void*)__inst, stats);
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* alloc_{FxnT,fxnP} */
typedef xdc_Ptr (*xdc_runtime_IHeap_alloc_FxnT)(void*, xdc_SizeT, xdc_SizeT, xdc_runtime_Error_Block*);
static inline xdc_runtime_IHeap_alloc_FxnT xdc_runtime_IHeap_alloc_fxnP( xdc_runtime_IHeap_Handle __inst )
{
    return (xdc_runtime_IHeap_alloc_FxnT)__inst->__fxns->alloc;
}

/* free_{FxnT,fxnP} */
typedef void (*xdc_runtime_IHeap_free_FxnT)(void*, xdc_Ptr, xdc_SizeT);
static inline xdc_runtime_IHeap_free_FxnT xdc_runtime_IHeap_free_fxnP( xdc_runtime_IHeap_Handle __inst )
{
    return (xdc_runtime_IHeap_free_FxnT)__inst->__fxns->free;
}

/* isBlocking_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_IHeap_isBlocking_FxnT)(void*);
static inline xdc_runtime_IHeap_isBlocking_FxnT xdc_runtime_IHeap_isBlocking_fxnP( xdc_runtime_IHeap_Handle __inst )
{
    return (xdc_runtime_IHeap_isBlocking_FxnT)__inst->__fxns->isBlocking;
}

/* getStats_{FxnT,fxnP} */
typedef void (*xdc_runtime_IHeap_getStats_FxnT)(void*, xdc_runtime_Memory_Stats*);
static inline xdc_runtime_IHeap_getStats_FxnT xdc_runtime_IHeap_getStats_fxnP( xdc_runtime_IHeap_Handle __inst )
{
    return (xdc_runtime_IHeap_getStats_FxnT)__inst->__fxns->getStats;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_IModule_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base xdc_runtime_IModule_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* Module_id */
static inline xdc_runtime_Types_ModuleId xdc_runtime_IModule_Module_id( xdc_runtime_IModule_Module mod )
{
    return mod->__sysp->__mid;
}


/*
 * ======== FUNCTION SELECTORS ========
 */


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Q_BLOCKING */

/* Q_PREEMPTING */


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_IGateProvider_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_IGateProvider_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*query)(xdc_Int);
    xdc_IArg (*enter)(void*);
    void (*leave)(void*, xdc_IArg);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base xdc_runtime_IGateProvider_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* create */
static inline xdc_runtime_IGateProvider_Handle xdc_runtime_IGateProvider_create( xdc_runtime_IGateProvider_Module __mod, const xdc_runtime_IGateProvider_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (xdc_runtime_IGateProvider_Handle) __mod->__sysp->__create(0, 0, 0, (const xdc_UChar*)__prms, sizeof (xdc_runtime_IGateProvider_Params), __eb);
}

/* delete */
static inline void xdc_runtime_IGateProvider_delete( xdc_runtime_IGateProvider_Handle* instp )
{
    (*instp)->__fxns->__sysp->__delete(instp);
}

/* Handle_to_Module */
static inline xdc_runtime_IGateProvider_Module xdc_runtime_IGateProvider_Handle_to_Module( xdc_runtime_IGateProvider_Handle inst )
{
    return inst->__fxns;
}

/* Handle_label */
static inline xdc_runtime_Types_Label* xdc_runtime_IGateProvider_Handle_label( xdc_runtime_IGateProvider_Handle inst, xdc_runtime_Types_Label* lab )
{
    return inst->__fxns->__sysp->__label(inst, lab);
}

/* Module_id */
static inline xdc_runtime_Types_ModuleId xdc_runtime_IGateProvider_Module_id( xdc_runtime_IGateProvider_Module mod )
{
    return mod->__sysp->__mid;
}

/* query */
static inline xdc_Bool xdc_runtime_IGateProvider_query( xdc_runtime_IGateProvider_Module __inst, xdc_Int qual )
{
    return __inst->query(qual);
}

/* enter */
static inline xdc_IArg xdc_runtime_IGateProvider_enter( xdc_runtime_IGateProvider_Handle __inst )
{
    return __inst->__fxns->enter((void*)__inst);
}

/* leave */
static inline void xdc_runtime_IGateProvider_leave( xdc_runtime_IGateProvider_Handle __inst, xdc_IArg key )
{
    __inst->__fxns->leave((void*)__inst, key);
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* query_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_IGateProvider_query_FxnT)(xdc_Int);
static inline xdc_runtime_IGateProvider_query_FxnT xdc_runtime_IGateProvider_query_fxnP( xdc_runtime_IGateProvider_Module __inst )
{
    return (xdc_runtime_IGateProvider_query_FxnT)__inst->query;
}

/* enter_{FxnT,fxnP} */
typedef xdc_IArg (*xdc_runtime_IGateProvider_enter_FxnT)(void*);
static inline xdc_runtime_IGateProvider_enter_FxnT xdc_runtime_IGateProvider_enter_fxnP( xdc_runtime_IGateProvider_Handle __inst )
{
    return (xdc_runtime_IGateProvider_enter_FxnT)__inst->__fxns->enter;
}

/* leave_{FxnT,fxnP} */
typedef void (*xdc_runtime_IGateProvider_leave_FxnT)(void*, xdc_IArg);
static inline xdc_runtime_IGateProvider_leave_FxnT xdc_runtime_IGateProvider_leave_fxnP( xdc_runtime_IGateProvider_Handle __inst )
{
    return (xdc_runtime_IGateProvider_leave_FxnT)__inst->__fxns->leave;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Q_BLOCKING */

/* Q_PREEMPTING */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Main_Module_GateProxy_Module__diagsEnabled;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__diagsEnabled xdc_runtime_Main_Module_GateProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Main_Module_GateProxy_Module__diagsIncluded;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__diagsIncluded xdc_runtime_Main_Module_GateProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Main_Module_GateProxy_Module__diagsMask;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__diagsMask xdc_runtime_Main_Module_GateProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Main_Module_GateProxy_Module__gateObj;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__gateObj xdc_runtime_Main_Module_GateProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Main_Module_GateProxy_Module__gatePrms;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__gatePrms xdc_runtime_Main_Module_GateProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Main_Module_GateProxy_Module__id;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__id xdc_runtime_Main_Module_GateProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Main_Module_GateProxy_Module__loggerDefined;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__loggerDefined xdc_runtime_Main_Module_GateProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Main_Module_GateProxy_Module__loggerObj;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__loggerObj xdc_runtime_Main_Module_GateProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn0;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn0 xdc_runtime_Main_Module_GateProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn1;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn1 xdc_runtime_Main_Module_GateProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn2;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn2 xdc_runtime_Main_Module_GateProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn4;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn4 xdc_runtime_Main_Module_GateProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn8;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__loggerFxn8 xdc_runtime_Main_Module_GateProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Main_Module_GateProxy_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Main_Module_GateProxy_Module__startupDoneFxn xdc_runtime_Main_Module_GateProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Main_Module_GateProxy_Object__count;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Object__count xdc_runtime_Main_Module_GateProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Main_Module_GateProxy_Object__heap;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Object__heap xdc_runtime_Main_Module_GateProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Main_Module_GateProxy_Object__sizeof;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Object__sizeof xdc_runtime_Main_Module_GateProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Main_Module_GateProxy_Object__table;
extern far const CT__xdc_runtime_Main_Module_GateProxy_Object__table xdc_runtime_Main_Module_GateProxy_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_Main_Module_GateProxy_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct xdc_runtime_Main_Module_GateProxy_Struct {
    const xdc_runtime_Main_Module_GateProxy_Fxns__* __fxns;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_Main_Module_GateProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*query)(xdc_Int);
    xdc_IArg (*enter)(xdc_runtime_Main_Module_GateProxy_Handle);
    void (*leave)(xdc_runtime_Main_Module_GateProxy_Handle, xdc_IArg);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const xdc_runtime_Main_Module_GateProxy_Fxns__ xdc_runtime_Main_Module_GateProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* xdc_runtime_Main_Module_GateProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Main_Module_GateProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr xdc_runtime_Main_Module_GateProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void xdc_runtime_Main_Module_GateProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void xdc_runtime_Main_Module_GateProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr xdc_runtime_Main_Module_GateProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr xdc_runtime_Main_Module_GateProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr xdc_runtime_Main_Module_GateProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void xdc_runtime_Main_Module_GateProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool xdc_runtime_Main_Module_GateProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr xdc_runtime_Main_Module_GateProxy_Proxy__delegate__S( void );

/* query__E */

extern xdc_Bool xdc_runtime_Main_Module_GateProxy_query__E( xdc_Int qual );

extern xdc_Bool xdc_runtime_Main_Module_GateProxy_query__R( xdc_Int qual );

/* enter__E */

extern xdc_IArg xdc_runtime_Main_Module_GateProxy_enter__E( xdc_runtime_Main_Module_GateProxy_Handle __inst );

extern xdc_IArg xdc_runtime_Main_Module_GateProxy_enter__R( xdc_runtime_Main_Module_GateProxy_Handle __inst );

/* leave__E */

extern void xdc_runtime_Main_Module_GateProxy_leave__E( xdc_runtime_Main_Module_GateProxy_Handle __inst, xdc_IArg key );

extern void xdc_runtime_Main_Module_GateProxy_leave__R( xdc_runtime_Main_Module_GateProxy_Handle __inst, xdc_IArg key );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enter_{FxnT,fxnP} */
typedef xdc_IArg (*xdc_runtime_Main_Module_GateProxy_enter_FxnT)(void*);
static inline xdc_runtime_Main_Module_GateProxy_enter_FxnT xdc_runtime_Main_Module_GateProxy_enter_fxnP( void )
{
    return (xdc_runtime_Main_Module_GateProxy_enter_FxnT)xdc_runtime_Main_Module_GateProxy_enter__E; 
}

/* leave_{FxnT,fxnP} */
typedef void (*xdc_runtime_Main_Module_GateProxy_leave_FxnT)(void*, xdc_IArg);
static inline xdc_runtime_Main_Module_GateProxy_leave_FxnT xdc_runtime_Main_Module_GateProxy_leave_fxnP( void )
{
    return (xdc_runtime_Main_Module_GateProxy_leave_FxnT)xdc_runtime_Main_Module_GateProxy_leave__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IGateProvider_Module xdc_runtime_Main_Module_GateProxy_Module_upCast( void )
{
    return (xdc_runtime_IGateProvider_Module)xdc_runtime_Main_Module_GateProxy_Proxy__delegate__S();
}

/* Module_to_xdc_runtime_IGateProvider */

/* Handle_upCast */
static inline xdc_runtime_IGateProvider_Handle xdc_runtime_Main_Module_GateProxy_Handle_upCast( xdc_runtime_Main_Module_GateProxy_Handle i )
{
    return (xdc_runtime_IGateProvider_Handle)i;
}

/* Handle_to_xdc_runtime_IGateProvider */

/* Handle_downCast */
static inline xdc_runtime_Main_Module_GateProxy_Handle xdc_runtime_Main_Module_GateProxy_Handle_downCast( xdc_runtime_IGateProvider_Handle i )
{
    xdc_runtime_IGateProvider_Handle i2 = (xdc_runtime_IGateProvider_Handle)i;
if (xdc_runtime_Main_Module_GateProxy_Proxy__abstract__S()) return (xdc_runtime_Main_Module_GateProxy_Handle)i;
    return (void*)i2->__fxns == (void*)xdc_runtime_Main_Module_GateProxy_Proxy__delegate__S() ? (xdc_runtime_Main_Module_GateProxy_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IGateProvider */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Main_Module_GateProxy_Module__id xdc_runtime_Main_Module_GateProxy_Module_id( void ) 
{
    return xdc_runtime_Main_Module_GateProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */

/* Params_init */
static inline void xdc_runtime_Main_Module_GateProxy_Params_init( xdc_runtime_Main_Module_GateProxy_Params* prms ) 
{
    if (prms) {
        xdc_runtime_Main_Module_GateProxy_Params__init__S(prms, 0, sizeof(xdc_runtime_Main_Module_GateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void xdc_runtime_Main_Module_GateProxy_Params_copy( xdc_runtime_Main_Module_GateProxy_Params* dst, const xdc_runtime_Main_Module_GateProxy_Params* src ) 
{
    if (dst) {
        xdc_runtime_Main_Module_GateProxy_Params__init__S(dst, (xdc_Ptr)src, sizeof(xdc_runtime_Main_Module_GateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* create */
static inline xdc_runtime_Main_Module_GateProxy_Handle xdc_runtime_Main_Module_GateProxy_create( const xdc_runtime_Main_Module_GateProxy_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (xdc_runtime_Main_Module_GateProxy_Handle)xdc_runtime_Main_Module_GateProxy_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(xdc_runtime_Main_Module_GateProxy_Params), __eb);
}

/* delete */
static inline void xdc_runtime_Main_Module_GateProxy_delete( xdc_runtime_Main_Module_GateProxy_Handle* instp )
{
    xdc_runtime_Main_Module_GateProxy_Object__delete__S(instp);
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Main_Module__diagsEnabled;
extern far const CT__xdc_runtime_Main_Module__diagsEnabled xdc_runtime_Main_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Main_Module__diagsIncluded;
extern far const CT__xdc_runtime_Main_Module__diagsIncluded xdc_runtime_Main_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Main_Module__diagsMask;
extern far const CT__xdc_runtime_Main_Module__diagsMask xdc_runtime_Main_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Main_Module__gateObj;
extern far const CT__xdc_runtime_Main_Module__gateObj xdc_runtime_Main_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Main_Module__gatePrms;
extern far const CT__xdc_runtime_Main_Module__gatePrms xdc_runtime_Main_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Main_Module__id;
extern far const CT__xdc_runtime_Main_Module__id xdc_runtime_Main_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Main_Module__loggerDefined;
extern far const CT__xdc_runtime_Main_Module__loggerDefined xdc_runtime_Main_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Main_Module__loggerObj;
extern far const CT__xdc_runtime_Main_Module__loggerObj xdc_runtime_Main_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Main_Module__loggerFxn0;
extern far const CT__xdc_runtime_Main_Module__loggerFxn0 xdc_runtime_Main_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Main_Module__loggerFxn1;
extern far const CT__xdc_runtime_Main_Module__loggerFxn1 xdc_runtime_Main_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Main_Module__loggerFxn2;
extern far const CT__xdc_runtime_Main_Module__loggerFxn2 xdc_runtime_Main_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Main_Module__loggerFxn4;
extern far const CT__xdc_runtime_Main_Module__loggerFxn4 xdc_runtime_Main_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Main_Module__loggerFxn8;
extern far const CT__xdc_runtime_Main_Module__loggerFxn8 xdc_runtime_Main_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Main_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Main_Module__startupDoneFxn xdc_runtime_Main_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Main_Object__count;
extern far const CT__xdc_runtime_Main_Object__count xdc_runtime_Main_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Main_Object__heap;
extern far const CT__xdc_runtime_Main_Object__heap xdc_runtime_Main_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Main_Object__sizeof;
extern far const CT__xdc_runtime_Main_Object__sizeof xdc_runtime_Main_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Main_Object__table;
extern far const CT__xdc_runtime_Main_Object__table xdc_runtime_Main_Object__table__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Main_Module__startupDone__S( void );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Main_Module__id xdc_runtime_Main_Module_id( void ) 
{
    return xdc_runtime_Main_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_Main_Module_hasMask( void ) 
{
    return xdc_runtime_Main_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_Main_Module_getMask( void ) 
{
    return xdc_runtime_Main_Module__diagsMask__C != 0 ? *xdc_runtime_Main_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_Main_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_Main_Module__diagsMask__C != 0) *xdc_runtime_Main_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  ======== xdc_runtime_Error_Id ========
 */
typedef xdc_Bits32 xdc_runtime_Error_Id;



/*
 *  ======== Module__MID ========
 *  This definition allows non-module code to
 *  use the Error module.  This symbol is normally defined in each
 *  module internal header (i.e., package/internal/<mod>.xdc.h).
 *
 *  Only do this if this file is not one that will be included in the Registry.
 *  This check ensures that Registry.h (which similarly defines these Module__*
 *  symbols) can be included in any order relative to other xdc.runtime 
 *  headers.
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Policy */
enum xdc_runtime_Error_Policy {
    xdc_runtime_Error_TERMINATE,
    xdc_runtime_Error_UNWIND
};
typedef enum xdc_runtime_Error_Policy xdc_runtime_Error_Policy;

/* Id */

/* HookFxn */
typedef void (*xdc_runtime_Error_HookFxn)(xdc_runtime_Error_Block*);

/* NUMARGS */

/* Data */
typedef xdc_IArg __T1_xdc_runtime_Error_Data__arg;
typedef xdc_IArg __ARRAY1_xdc_runtime_Error_Data__arg[2];
typedef __ARRAY1_xdc_runtime_Error_Data__arg __TA_xdc_runtime_Error_Data__arg;
struct xdc_runtime_Error_Data {
    __TA_xdc_runtime_Error_Data__arg arg;
};

/* Block */
typedef xdc_IArg __T1_xdc_runtime_Error_Block__xtra;
typedef xdc_IArg __ARRAY1_xdc_runtime_Error_Block__xtra[4];
typedef __ARRAY1_xdc_runtime_Error_Block__xtra __TA_xdc_runtime_Error_Block__xtra;
struct xdc_runtime_Error_Block {
    xdc_UInt16 unused;
    xdc_runtime_Error_Data data;
    xdc_runtime_Error_Id id;
    xdc_String msg;
    xdc_runtime_Types_Site site;
    __TA_xdc_runtime_Error_Block__xtra xtra;
};


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Error_Module__diagsEnabled;
extern far const CT__xdc_runtime_Error_Module__diagsEnabled xdc_runtime_Error_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Error_Module__diagsIncluded;
extern far const CT__xdc_runtime_Error_Module__diagsIncluded xdc_runtime_Error_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Error_Module__diagsMask;
extern far const CT__xdc_runtime_Error_Module__diagsMask xdc_runtime_Error_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Error_Module__gateObj;
extern far const CT__xdc_runtime_Error_Module__gateObj xdc_runtime_Error_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Error_Module__gatePrms;
extern far const CT__xdc_runtime_Error_Module__gatePrms xdc_runtime_Error_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Error_Module__id;
extern far const CT__xdc_runtime_Error_Module__id xdc_runtime_Error_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Error_Module__loggerDefined;
extern far const CT__xdc_runtime_Error_Module__loggerDefined xdc_runtime_Error_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Error_Module__loggerObj;
extern far const CT__xdc_runtime_Error_Module__loggerObj xdc_runtime_Error_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Error_Module__loggerFxn0;
extern far const CT__xdc_runtime_Error_Module__loggerFxn0 xdc_runtime_Error_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Error_Module__loggerFxn1;
extern far const CT__xdc_runtime_Error_Module__loggerFxn1 xdc_runtime_Error_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Error_Module__loggerFxn2;
extern far const CT__xdc_runtime_Error_Module__loggerFxn2 xdc_runtime_Error_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Error_Module__loggerFxn4;
extern far const CT__xdc_runtime_Error_Module__loggerFxn4 xdc_runtime_Error_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Error_Module__loggerFxn8;
extern far const CT__xdc_runtime_Error_Module__loggerFxn8 xdc_runtime_Error_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Error_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Error_Module__startupDoneFxn xdc_runtime_Error_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Error_Object__count;
extern far const CT__xdc_runtime_Error_Object__count xdc_runtime_Error_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Error_Object__heap;
extern far const CT__xdc_runtime_Error_Object__heap xdc_runtime_Error_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Error_Object__sizeof;
extern far const CT__xdc_runtime_Error_Object__sizeof xdc_runtime_Error_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Error_Object__table;
extern far const CT__xdc_runtime_Error_Object__table xdc_runtime_Error_Object__table__C;

/* E_generic */
typedef xdc_runtime_Error_Id CT__xdc_runtime_Error_E_generic;
extern far const CT__xdc_runtime_Error_E_generic xdc_runtime_Error_E_generic__C;

/* E_memory */
typedef xdc_runtime_Error_Id CT__xdc_runtime_Error_E_memory;
extern far const CT__xdc_runtime_Error_E_memory xdc_runtime_Error_E_memory__C;

/* E_msgCode */
typedef xdc_runtime_Error_Id CT__xdc_runtime_Error_E_msgCode;
extern far const CT__xdc_runtime_Error_E_msgCode xdc_runtime_Error_E_msgCode__C;

/* policy */
typedef xdc_runtime_Error_Policy CT__xdc_runtime_Error_policy;
extern far const CT__xdc_runtime_Error_policy xdc_runtime_Error_policy__C;

/* raiseHook */
typedef xdc_runtime_Error_HookFxn CT__xdc_runtime_Error_raiseHook;
extern far const CT__xdc_runtime_Error_raiseHook xdc_runtime_Error_raiseHook__C;

/* maxDepth */
typedef xdc_UInt16 CT__xdc_runtime_Error_maxDepth;
extern far const CT__xdc_runtime_Error_maxDepth xdc_runtime_Error_maxDepth__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Error_Module__startupDone__S( void );

/* check__E */

extern xdc_Bool xdc_runtime_Error_check__E( xdc_runtime_Error_Block* eb );

extern xdc_Bool xdc_runtime_Error_check__F( xdc_runtime_Error_Block* eb );
extern xdc_Bool xdc_runtime_Error_check__R( xdc_runtime_Error_Block* eb );

/* getData__E */

extern xdc_runtime_Error_Data* xdc_runtime_Error_getData__E( xdc_runtime_Error_Block* eb );

extern xdc_runtime_Error_Data* xdc_runtime_Error_getData__F( xdc_runtime_Error_Block* eb );
extern xdc_runtime_Error_Data* xdc_runtime_Error_getData__R( xdc_runtime_Error_Block* eb );

/* getCode__E */

extern xdc_UInt16 xdc_runtime_Error_getCode__E( xdc_runtime_Error_Block* eb );

extern xdc_UInt16 xdc_runtime_Error_getCode__F( xdc_runtime_Error_Block* eb );
extern xdc_UInt16 xdc_runtime_Error_getCode__R( xdc_runtime_Error_Block* eb );

/* getId__E */

extern xdc_runtime_Error_Id xdc_runtime_Error_getId__E( xdc_runtime_Error_Block* eb );

extern xdc_runtime_Error_Id xdc_runtime_Error_getId__F( xdc_runtime_Error_Block* eb );
extern xdc_runtime_Error_Id xdc_runtime_Error_getId__R( xdc_runtime_Error_Block* eb );

/* getMsg__E */

extern xdc_String xdc_runtime_Error_getMsg__E( xdc_runtime_Error_Block* eb );

extern xdc_String xdc_runtime_Error_getMsg__F( xdc_runtime_Error_Block* eb );
extern xdc_String xdc_runtime_Error_getMsg__R( xdc_runtime_Error_Block* eb );

/* getSite__E */

extern xdc_runtime_Types_Site* xdc_runtime_Error_getSite__E( xdc_runtime_Error_Block* eb );

extern xdc_runtime_Types_Site* xdc_runtime_Error_getSite__F( xdc_runtime_Error_Block* eb );
extern xdc_runtime_Types_Site* xdc_runtime_Error_getSite__R( xdc_runtime_Error_Block* eb );

/* init__E */

extern void xdc_runtime_Error_init__E( xdc_runtime_Error_Block* eb );

extern void xdc_runtime_Error_init__F( xdc_runtime_Error_Block* eb );
extern void xdc_runtime_Error_init__R( xdc_runtime_Error_Block* eb );

/* print__E */

extern void xdc_runtime_Error_print__E( xdc_runtime_Error_Block* eb );

extern void xdc_runtime_Error_print__F( xdc_runtime_Error_Block* eb );
extern void xdc_runtime_Error_print__R( xdc_runtime_Error_Block* eb );

/* raiseX__E */

extern void xdc_runtime_Error_raiseX__E( xdc_runtime_Error_Block* eb, xdc_runtime_Types_ModuleId mod, xdc_String file, xdc_Int line, xdc_runtime_Error_Id id, xdc_IArg arg1, xdc_IArg arg2 );

extern void xdc_runtime_Error_raiseX__F( xdc_runtime_Error_Block* eb, xdc_runtime_Types_ModuleId mod, xdc_String file, xdc_Int line, xdc_runtime_Error_Id id, xdc_IArg arg1, xdc_IArg arg2 );
extern void xdc_runtime_Error_raiseX__R( xdc_runtime_Error_Block* eb, xdc_runtime_Types_ModuleId mod, xdc_String file, xdc_Int line, xdc_runtime_Error_Id id, xdc_IArg arg1, xdc_IArg arg2 );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Error_Module__id xdc_runtime_Error_Module_id( void ) 
{
    return xdc_runtime_Error_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_Error_Module_hasMask( void ) 
{
    return xdc_runtime_Error_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_Error_Module_getMask( void ) 
{
    return xdc_runtime_Error_Module__diagsMask__C != 0 ? *xdc_runtime_Error_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_Error_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_Error_Module__diagsMask__C != 0) *xdc_runtime_Error_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */
/*
 *  ======== xdc_runtime_Error_raise ========
 *  Call underlying error handler with current module ID, file name, and
 *  line number.
 *
 *  Note use of xdc_FILE__ in lieu of __FILE__; this is done
 *  to prevent accumulation of file name strings in the application.  See
 *  xdc.h for details.
 */

/*
 *  ======== xdc_runtime_Error_idToCode ========
 */

/*
 *  ======== xdc_runtime_Error_idToUid ========
 */
/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */





/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */

/*
 *  ======== Diags__prologue.h ========
 *
 *  This header defines Module__* symbols for every Module__* value used
 *  by the Diags module's headers.  This allows non-module code to
 *  use the Diags module.  These symbols are normally defined in
 *  module internal headers (i.e., package/internal/<mod>.xdc.h) and they
 *  define a "current module context".
 */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/* 
 * Only define these symbols for xdc.runtime.Main if this file is not one that
 * will be included in the Registry. This check ensures that Registry.h (which
 * similarly defines these Module__* symbols) can be included in any order
 * relative to other xdc.runtime headers.
 */

/*
 *  ======== Module__DGSINCL ========
 *  The set of diags categories that are runtime controllable _or_ always on
 *
 *  This costant is computed at config time and enables us to eliminate
 *  expensive runtime time checks and unnecessary data (the module's diags 
 *  mask) when whole program optimization is used.
 */

/*
 *  ======== Module__DGSENAB ========
 *  The set of diags categories that are _always_ enabled
 *
 *  This costant is computed at config time and enables us to eliminate
 *  expensive runtime time checks and unnecessary data (the module's diags 
 *  mask) when whole program optimization is used.
 */

/*
 *  ======== Module__DGSMASK ========
 *  Pointer to the set of diags categories that are runtime controllable 
 */

/*
 *  ======== Module__MID ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Mask */
typedef xdc_runtime_Types_DiagsMask xdc_runtime_Diags_Mask;

/* ENTRY */

/* EXIT */

/* LIFECYCLE */

/* INTERNAL */

/* ASSERT */

/* STATUS */

/* LEVEL */

/* USER1 */

/* USER2 */

/* USER3 */

/* USER4 */

/* USER5 */

/* USER6 */

/* USER7 */

/* INFO */

/* USER8 */

/* ANALYSIS */

/* ALL */

/* ALL_LOGGING */

/* EventLevel */
enum xdc_runtime_Diags_EventLevel {
    xdc_runtime_Diags_LEVEL1 = 0x0,
    xdc_runtime_Diags_LEVEL2 = 0x20,
    xdc_runtime_Diags_LEVEL3 = 0x40,
    xdc_runtime_Diags_LEVEL4 = 0x60
};
typedef enum xdc_runtime_Diags_EventLevel xdc_runtime_Diags_EventLevel;

/* EMERGENCY */

/* CRITICAL */

/* ERROR */

/* WARNING */


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* DictElem */
struct xdc_runtime_Diags_DictElem {
    xdc_runtime_Types_ModuleId modId;
    xdc_runtime_Diags_Mask* maskAddr;
};


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Diags_Module__diagsEnabled;
extern far const CT__xdc_runtime_Diags_Module__diagsEnabled xdc_runtime_Diags_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Diags_Module__diagsIncluded;
extern far const CT__xdc_runtime_Diags_Module__diagsIncluded xdc_runtime_Diags_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Diags_Module__diagsMask;
extern far const CT__xdc_runtime_Diags_Module__diagsMask xdc_runtime_Diags_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Diags_Module__gateObj;
extern far const CT__xdc_runtime_Diags_Module__gateObj xdc_runtime_Diags_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Diags_Module__gatePrms;
extern far const CT__xdc_runtime_Diags_Module__gatePrms xdc_runtime_Diags_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Diags_Module__id;
extern far const CT__xdc_runtime_Diags_Module__id xdc_runtime_Diags_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Diags_Module__loggerDefined;
extern far const CT__xdc_runtime_Diags_Module__loggerDefined xdc_runtime_Diags_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Diags_Module__loggerObj;
extern far const CT__xdc_runtime_Diags_Module__loggerObj xdc_runtime_Diags_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Diags_Module__loggerFxn0;
extern far const CT__xdc_runtime_Diags_Module__loggerFxn0 xdc_runtime_Diags_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Diags_Module__loggerFxn1;
extern far const CT__xdc_runtime_Diags_Module__loggerFxn1 xdc_runtime_Diags_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Diags_Module__loggerFxn2;
extern far const CT__xdc_runtime_Diags_Module__loggerFxn2 xdc_runtime_Diags_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Diags_Module__loggerFxn4;
extern far const CT__xdc_runtime_Diags_Module__loggerFxn4 xdc_runtime_Diags_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Diags_Module__loggerFxn8;
extern far const CT__xdc_runtime_Diags_Module__loggerFxn8 xdc_runtime_Diags_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Diags_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Diags_Module__startupDoneFxn xdc_runtime_Diags_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Diags_Object__count;
extern far const CT__xdc_runtime_Diags_Object__count xdc_runtime_Diags_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Diags_Object__heap;
extern far const CT__xdc_runtime_Diags_Object__heap xdc_runtime_Diags_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Diags_Object__sizeof;
extern far const CT__xdc_runtime_Diags_Object__sizeof xdc_runtime_Diags_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Diags_Object__table;
extern far const CT__xdc_runtime_Diags_Object__table xdc_runtime_Diags_Object__table__C;

/* setMaskEnabled */
typedef xdc_Bool CT__xdc_runtime_Diags_setMaskEnabled;
extern far const CT__xdc_runtime_Diags_setMaskEnabled xdc_runtime_Diags_setMaskEnabled__C;

/* dictBase */
typedef xdc_runtime_Diags_DictElem* CT__xdc_runtime_Diags_dictBase;
extern far const CT__xdc_runtime_Diags_dictBase xdc_runtime_Diags_dictBase__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Diags_Module__startupDone__S( void );

/* setMask__E */

extern void xdc_runtime_Diags_setMask__E( xdc_String control );

extern void xdc_runtime_Diags_setMask__F( xdc_String control );
extern void xdc_runtime_Diags_setMask__R( xdc_String control );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Diags_Module__id xdc_runtime_Diags_Module_id( void ) 
{
    return xdc_runtime_Diags_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_Diags_Module_hasMask( void ) 
{
    return xdc_runtime_Diags_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_Diags_Module_getMask( void ) 
{
    return xdc_runtime_Diags_Module__diagsMask__C != 0 ? *xdc_runtime_Diags_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_Diags_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_Diags_Module__diagsMask__C != 0) *xdc_runtime_Diags_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */
/*
 *  ======== xdc_runtime_Diags_query ========
 *  Returns true iff: 
 *      1. the current module's included diags intersect evt's mask, and
 *      2. either the permanently enabled diags intersect evt's mask or
 *         the runtime controllable diags intersect evt's mask.
 *
 *  This macro relies on three "internal" macros which are defined in each
 *  module's internal header (e.g., package/internal/System.xdc.h):
 *      Module__DGSINCL - a const bit mask of bits that are _not_ ALWAYS_OFF
 *      Module__DGSENAB - a const bit mask of bits that are ALWAYS_ON
 *      Module__DGSMASK - a const pointer to a bit mask of currently enabled
 *                        diagnostics
 *  These macros reference module-specific variables generated at config
 *  time, when we know the value of these constants.
 *
 */

/*
 *  ======== xdc_runtime_Diags_getLevel ========
 *  Returns the event level set in the given diags mask. The level is a value
 *  stored using two bits of the diags mask.
 */

/*
 *  ======== xdc_runtime_Diags_compareLevels ========
 *  The definition of the diags levels assigns the value '0' to the highest
 *  priority events and '3' to the lowest, so the comparison is done backwards.
 *  For example, for (LEVEL4 (0), LEVEL1 (3)) this must return false.
 */
/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */





/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  ======== xdc_runtime_Log_Event ========
 *  Log_Event is an encoded type.  Log Events are encoded on the target as
 *  a 32-bit value:
 *
 *      | format rope | module ID or mask |
 *      | 31 ----- 16 | 15 ------------ 0 |
 *
 *  The lower 16-bits contain either a mask or a module ID; when the event
 *  is statically declared this field has a mask, when the event is passed
 *  to an ILogger this field is the module ID of the module that generated
 *  the event.
 *
 *  The upper 16-bits are an ID (rope) that that identifies the format
 *  string to use to render the event (and its arguments).
 */
typedef xdc_Bits32 xdc_runtime_Log_Event;

/*
 *  The following macros establish xdc.runtime.Main as the "default"
 *  module for all sources files not part of a module.
 *
 *      Module__MID     - the module's ID (see Text.xs)
 *      Module__LOGOBJ  - the module's logger object
 *      Module__LOGFXN0 - the module's logger's write0 function
 *      Module__LOGFXN1 - the module's logger's write1 function
 *      Module__LOGFXN2 - the module's logger's write2 function
 *      Module__LOGFXN4 - the module's logger's write4 function
 *      Module__LOGFXN8 - the module's logger's write8 function
 *      Module__LOGDEF  - 0 if the module has a logger, non-zero otherwise
 *
 *  Only define these symbols for xdc.runtime.Main if this file is not one that
 *  will be included in the Registry. This check ensures that Registry.h (which
 *  similarly defines these Module__* symbols) can be included in any order
 *  relative to other xdc.runtime headers.
 */
 


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* CordAddr */
typedef xdc_runtime_Types_CordAddr xdc_runtime_Text_CordAddr;

/* Label */
typedef xdc_runtime_Types_Label xdc_runtime_Text_Label;

/* RopeId */
typedef xdc_runtime_Types_RopeId xdc_runtime_Text_RopeId;


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* Node */
struct xdc_runtime_Text_Node {
    xdc_runtime_Types_RopeId left;
    xdc_runtime_Types_RopeId right;
};

/* RopeVisitor */
typedef xdc_Bool (*xdc_runtime_Text_RopeVisitor)(xdc_Ptr, xdc_String);

/* MatchVisState */
struct xdc_runtime_Text_MatchVisState {
    xdc_String pat;
    xdc_Int* lenp;
    xdc_Int res;
};

/* PrintVisState */
struct xdc_runtime_Text_PrintVisState {
    xdc_Char** bufp;
    xdc_Int len;
    xdc_Int res;
};

/* VisitRopeFxn */
typedef void (*xdc_runtime_Text_VisitRopeFxn)(xdc_runtime_Text_RopeId, xdc_Fxn, xdc_Ptr);

/* VisitRopeFxn2 */
typedef void (*xdc_runtime_Text_VisitRopeFxn2)(xdc_runtime_Text_RopeId, xdc_Fxn, xdc_Ptr, xdc_String[]);


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Text_Module__diagsEnabled;
extern far const CT__xdc_runtime_Text_Module__diagsEnabled xdc_runtime_Text_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Text_Module__diagsIncluded;
extern far const CT__xdc_runtime_Text_Module__diagsIncluded xdc_runtime_Text_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Text_Module__diagsMask;
extern far const CT__xdc_runtime_Text_Module__diagsMask xdc_runtime_Text_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Text_Module__gateObj;
extern far const CT__xdc_runtime_Text_Module__gateObj xdc_runtime_Text_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Text_Module__gatePrms;
extern far const CT__xdc_runtime_Text_Module__gatePrms xdc_runtime_Text_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Text_Module__id;
extern far const CT__xdc_runtime_Text_Module__id xdc_runtime_Text_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Text_Module__loggerDefined;
extern far const CT__xdc_runtime_Text_Module__loggerDefined xdc_runtime_Text_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Text_Module__loggerObj;
extern far const CT__xdc_runtime_Text_Module__loggerObj xdc_runtime_Text_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Text_Module__loggerFxn0;
extern far const CT__xdc_runtime_Text_Module__loggerFxn0 xdc_runtime_Text_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Text_Module__loggerFxn1;
extern far const CT__xdc_runtime_Text_Module__loggerFxn1 xdc_runtime_Text_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Text_Module__loggerFxn2;
extern far const CT__xdc_runtime_Text_Module__loggerFxn2 xdc_runtime_Text_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Text_Module__loggerFxn4;
extern far const CT__xdc_runtime_Text_Module__loggerFxn4 xdc_runtime_Text_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Text_Module__loggerFxn8;
extern far const CT__xdc_runtime_Text_Module__loggerFxn8 xdc_runtime_Text_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Text_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Text_Module__startupDoneFxn xdc_runtime_Text_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Text_Object__count;
extern far const CT__xdc_runtime_Text_Object__count xdc_runtime_Text_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Text_Object__heap;
extern far const CT__xdc_runtime_Text_Object__heap xdc_runtime_Text_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Text_Object__sizeof;
extern far const CT__xdc_runtime_Text_Object__sizeof xdc_runtime_Text_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Text_Object__table;
extern far const CT__xdc_runtime_Text_Object__table xdc_runtime_Text_Object__table__C;

/* nameUnknown */
typedef xdc_String CT__xdc_runtime_Text_nameUnknown;
extern far const CT__xdc_runtime_Text_nameUnknown xdc_runtime_Text_nameUnknown__C;

/* nameEmpty */
typedef xdc_String CT__xdc_runtime_Text_nameEmpty;
extern far const CT__xdc_runtime_Text_nameEmpty xdc_runtime_Text_nameEmpty__C;

/* nameStatic */
typedef xdc_String CT__xdc_runtime_Text_nameStatic;
extern far const CT__xdc_runtime_Text_nameStatic xdc_runtime_Text_nameStatic__C;

/* isLoaded */
typedef xdc_Bool CT__xdc_runtime_Text_isLoaded;
extern far const CT__xdc_runtime_Text_isLoaded xdc_runtime_Text_isLoaded__C;

/* charTab */
typedef xdc_Char __T1_xdc_runtime_Text_charTab;
typedef xdc_Char *__ARRAY1_xdc_runtime_Text_charTab;
typedef __ARRAY1_xdc_runtime_Text_charTab __TA_xdc_runtime_Text_charTab;
typedef __TA_xdc_runtime_Text_charTab CT__xdc_runtime_Text_charTab;
extern far const CT__xdc_runtime_Text_charTab xdc_runtime_Text_charTab__C;

/* nodeTab */
typedef xdc_runtime_Text_Node __T1_xdc_runtime_Text_nodeTab;
typedef xdc_runtime_Text_Node *__ARRAY1_xdc_runtime_Text_nodeTab;
typedef __ARRAY1_xdc_runtime_Text_nodeTab __TA_xdc_runtime_Text_nodeTab;
typedef __TA_xdc_runtime_Text_nodeTab CT__xdc_runtime_Text_nodeTab;
extern far const CT__xdc_runtime_Text_nodeTab xdc_runtime_Text_nodeTab__C;

/* charCnt */
typedef xdc_Int16 CT__xdc_runtime_Text_charCnt;
extern far const CT__xdc_runtime_Text_charCnt xdc_runtime_Text_charCnt__C;

/* nodeCnt */
typedef xdc_Int16 CT__xdc_runtime_Text_nodeCnt;
extern far const CT__xdc_runtime_Text_nodeCnt xdc_runtime_Text_nodeCnt__C;

/* unnamedModsLastId */
typedef xdc_UInt16 CT__xdc_runtime_Text_unnamedModsLastId;
extern far const CT__xdc_runtime_Text_unnamedModsLastId xdc_runtime_Text_unnamedModsLastId__C;

/* registryModsLastId */
typedef xdc_UInt16 CT__xdc_runtime_Text_registryModsLastId;
extern far const CT__xdc_runtime_Text_registryModsLastId xdc_runtime_Text_registryModsLastId__C;

/* visitRopeFxn */
typedef xdc_runtime_Text_VisitRopeFxn CT__xdc_runtime_Text_visitRopeFxn;
extern far const CT__xdc_runtime_Text_visitRopeFxn xdc_runtime_Text_visitRopeFxn__C;

/* visitRopeFxn2 */
typedef xdc_runtime_Text_VisitRopeFxn2 CT__xdc_runtime_Text_visitRopeFxn2;
extern far const CT__xdc_runtime_Text_visitRopeFxn2 xdc_runtime_Text_visitRopeFxn2__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Text_Module__startupDone__S( void );

/* cordText__E */

extern xdc_String xdc_runtime_Text_cordText__E( xdc_runtime_Text_CordAddr cord );

extern xdc_String xdc_runtime_Text_cordText__F( xdc_runtime_Text_CordAddr cord );
extern xdc_String xdc_runtime_Text_cordText__R( xdc_runtime_Text_CordAddr cord );

/* ropeText__E */

extern xdc_String xdc_runtime_Text_ropeText__E( xdc_runtime_Text_RopeId rope );

extern xdc_String xdc_runtime_Text_ropeText__F( xdc_runtime_Text_RopeId rope );
extern xdc_String xdc_runtime_Text_ropeText__R( xdc_runtime_Text_RopeId rope );

/* matchRope__E */

extern xdc_Int xdc_runtime_Text_matchRope__E( xdc_runtime_Text_RopeId rope, xdc_String pat, xdc_Int* lenp );

extern xdc_Int xdc_runtime_Text_matchRope__F( xdc_runtime_Text_RopeId rope, xdc_String pat, xdc_Int* lenp );
extern xdc_Int xdc_runtime_Text_matchRope__R( xdc_runtime_Text_RopeId rope, xdc_String pat, xdc_Int* lenp );

/* putLab__E */

extern xdc_Int xdc_runtime_Text_putLab__E( xdc_runtime_Types_Label* lab, xdc_Char** bufp, xdc_Int len );

extern xdc_Int xdc_runtime_Text_putLab__F( xdc_runtime_Types_Label* lab, xdc_Char** bufp, xdc_Int len );
extern xdc_Int xdc_runtime_Text_putLab__R( xdc_runtime_Types_Label* lab, xdc_Char** bufp, xdc_Int len );

/* putMod__E */

extern xdc_Int xdc_runtime_Text_putMod__E( xdc_runtime_Types_ModuleId mid, xdc_Char** bufp, xdc_Int len );

extern xdc_Int xdc_runtime_Text_putMod__F( xdc_runtime_Types_ModuleId mid, xdc_Char** bufp, xdc_Int len );
extern xdc_Int xdc_runtime_Text_putMod__R( xdc_runtime_Types_ModuleId mid, xdc_Char** bufp, xdc_Int len );

/* putSite__E */

extern xdc_Int xdc_runtime_Text_putSite__E( xdc_runtime_Types_Site* site, xdc_Char** bufp, xdc_Int len );

extern xdc_Int xdc_runtime_Text_putSite__F( xdc_runtime_Types_Site* site, xdc_Char** bufp, xdc_Int len );
extern xdc_Int xdc_runtime_Text_putSite__R( xdc_runtime_Types_Site* site, xdc_Char** bufp, xdc_Int len );

/* matchVisFxn__I */

extern xdc_Bool xdc_runtime_Text_matchVisFxn__I( xdc_Ptr p, xdc_String s );

/* printVisFxn__I */

extern xdc_Bool xdc_runtime_Text_printVisFxn__I( xdc_Ptr p, xdc_String s );

/* visitRope__I */

extern void xdc_runtime_Text_visitRope__I( xdc_runtime_Text_RopeId rope, xdc_Fxn visFxn, xdc_Ptr visState );

/* visitRope2__I */

extern void xdc_runtime_Text_visitRope2__I( xdc_runtime_Text_RopeId rope, xdc_Fxn visFxn, xdc_Ptr visState, xdc_String stack[] );

/* xprintf__I */

extern xdc_Int xdc_runtime_Text_xprintf__I( xdc_Char** bufp, xdc_String fmt, ... );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Text_Module__id xdc_runtime_Text_Module_id( void ) 
{
    return xdc_runtime_Text_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_Text_Module_hasMask( void ) 
{
    return xdc_runtime_Text_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_Text_Module_getMask( void ) 
{
    return xdc_runtime_Text_Module__diagsMask__C != 0 ? *xdc_runtime_Text_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_Text_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_Text_Module__diagsMask__C != 0) *xdc_runtime_Text_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* NUMARGS */

/* PRINTFID */

/* EventRec */
typedef xdc_IArg __T1_xdc_runtime_Log_EventRec__arg;
typedef xdc_IArg __ARRAY1_xdc_runtime_Log_EventRec__arg[8];
typedef __ARRAY1_xdc_runtime_Log_EventRec__arg __TA_xdc_runtime_Log_EventRec__arg;
struct xdc_runtime_Log_EventRec {
    xdc_runtime_Types_Timestamp64 tstamp;
    xdc_Bits32 serial;
    xdc_runtime_Types_Event evt;
    __TA_xdc_runtime_Log_EventRec__arg arg;
};

/* Event */

/* EventId */
typedef xdc_runtime_Types_RopeId xdc_runtime_Log_EventId;


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Log_Module__diagsEnabled;
extern far const CT__xdc_runtime_Log_Module__diagsEnabled xdc_runtime_Log_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Log_Module__diagsIncluded;
extern far const CT__xdc_runtime_Log_Module__diagsIncluded xdc_runtime_Log_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Log_Module__diagsMask;
extern far const CT__xdc_runtime_Log_Module__diagsMask xdc_runtime_Log_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Log_Module__gateObj;
extern far const CT__xdc_runtime_Log_Module__gateObj xdc_runtime_Log_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Log_Module__gatePrms;
extern far const CT__xdc_runtime_Log_Module__gatePrms xdc_runtime_Log_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Log_Module__id;
extern far const CT__xdc_runtime_Log_Module__id xdc_runtime_Log_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Log_Module__loggerDefined;
extern far const CT__xdc_runtime_Log_Module__loggerDefined xdc_runtime_Log_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Log_Module__loggerObj;
extern far const CT__xdc_runtime_Log_Module__loggerObj xdc_runtime_Log_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Log_Module__loggerFxn0;
extern far const CT__xdc_runtime_Log_Module__loggerFxn0 xdc_runtime_Log_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Log_Module__loggerFxn1;
extern far const CT__xdc_runtime_Log_Module__loggerFxn1 xdc_runtime_Log_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Log_Module__loggerFxn2;
extern far const CT__xdc_runtime_Log_Module__loggerFxn2 xdc_runtime_Log_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Log_Module__loggerFxn4;
extern far const CT__xdc_runtime_Log_Module__loggerFxn4 xdc_runtime_Log_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Log_Module__loggerFxn8;
extern far const CT__xdc_runtime_Log_Module__loggerFxn8 xdc_runtime_Log_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Log_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Log_Module__startupDoneFxn xdc_runtime_Log_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Log_Object__count;
extern far const CT__xdc_runtime_Log_Object__count xdc_runtime_Log_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Log_Object__heap;
extern far const CT__xdc_runtime_Log_Object__heap xdc_runtime_Log_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Log_Object__sizeof;
extern far const CT__xdc_runtime_Log_Object__sizeof xdc_runtime_Log_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Log_Object__table;
extern far const CT__xdc_runtime_Log_Object__table xdc_runtime_Log_Object__table__C;

/* L_construct */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_construct;
extern far const CT__xdc_runtime_Log_L_construct xdc_runtime_Log_L_construct__C;

/* L_create */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_create;
extern far const CT__xdc_runtime_Log_L_create xdc_runtime_Log_L_create__C;

/* L_destruct */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_destruct;
extern far const CT__xdc_runtime_Log_L_destruct xdc_runtime_Log_L_destruct__C;

/* L_delete */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_delete;
extern far const CT__xdc_runtime_Log_L_delete xdc_runtime_Log_L_delete__C;

/* L_error */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_error;
extern far const CT__xdc_runtime_Log_L_error xdc_runtime_Log_L_error__C;

/* L_warning */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_warning;
extern far const CT__xdc_runtime_Log_L_warning xdc_runtime_Log_L_warning__C;

/* L_info */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_info;
extern far const CT__xdc_runtime_Log_L_info xdc_runtime_Log_L_info__C;

/* L_start */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_start;
extern far const CT__xdc_runtime_Log_L_start xdc_runtime_Log_L_start__C;

/* L_stop */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_stop;
extern far const CT__xdc_runtime_Log_L_stop xdc_runtime_Log_L_stop__C;

/* L_startInstance */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_startInstance;
extern far const CT__xdc_runtime_Log_L_startInstance xdc_runtime_Log_L_startInstance__C;

/* L_stopInstance */
typedef xdc_runtime_Log_Event CT__xdc_runtime_Log_L_stopInstance;
extern far const CT__xdc_runtime_Log_L_stopInstance xdc_runtime_Log_L_stopInstance__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Log_Module__startupDone__S( void );

/* doPrint__E */

extern void xdc_runtime_Log_doPrint__E( xdc_runtime_Log_EventRec* evRec );

extern void xdc_runtime_Log_doPrint__F( xdc_runtime_Log_EventRec* evRec );
extern void xdc_runtime_Log_doPrint__R( xdc_runtime_Log_EventRec* evRec );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Log_Module__id xdc_runtime_Log_Module_id( void ) 
{
    return xdc_runtime_Log_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_Log_Module_hasMask( void ) 
{
    return xdc_runtime_Log_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_Log_Module_getMask( void ) 
{
    return xdc_runtime_Log_Module__diagsMask__C != 0 ? *xdc_runtime_Log_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_Log_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_Log_Module__diagsMask__C != 0) *xdc_runtime_Log_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */

/*
 *  ======== Log__epilogue.h ========
 *  Implementation of the Log_* macros
 *
 *  The implementation below relies on eight symbols defined by every module
 *  header.  Each of these symbols is a reference to a constant defined in a
 *  separate compilation unit.  The values of these constants are as follows:
 *
 *      Module__MID     - the module's ID (see Text.xs)
 *      Module__LOGOBJ  - the module's logger object
 *      Module__LOGFXN0 - the module's logger's write0 function
 *      Module__LOGFXN1 - the module's logger's write1 function 
 *      Module__LOGFXN2 - the module's logger's write2 function
 *      Module__LOGFXN4 - the module's logger's write4 function
 *      Module__LOGFXN8 - the module's logger's write8 function
 *      Module__LOGDEF  - 0 if the module has a logger, non-zero otherwise
 */

/*
 *  Define flags for compiling out all Log calls
 *
 *  The intent of these flags is to allow users to completely optimize logging
 *  out of their code even when not using whole program optimization. This is
 *  implemented by controlling the definitions of the Log macros. This will
 *  only affect code compiled with the flag(s) set, so it will not disable 
 *  logging in any precompiled libraries.
 *
 *  The DISABLE_ALL flag will have the effect of disabling all Log put, write, 
 *  print, error, warning, and info log calls. The flag just has to be defined,
 *  we give it a value of zero or one to use in the macros.
 *
 *  There are additional flags which can be used to disable all log calls
 *  "except for". We use the presence of the DISABLE_ALL flag and the presence
 *  of any ENABLE_ERROR, ENABLE_INFO, or ENABLE_WARNING flags to compute the
 *  value of ENABLE_ERROR, etc., as zero or one.
 *
 *  We ensure that all of the flags are ultimately defined and given a zero or
 *  one value. Then the macro definitions are conditional on the value of the
 *  appropriate flag.
 */

/* 
 * If DISABLE_ALL is defined, give it the value 1, and assign values to all
 * of the ENABLE flags based on whether they've been defined or not.
 */

/*
 *  ======== xdc_runtime_Log_getMask ========
 */

/*
 *  ======== xdc_runtime_Log_getRope ========
 */

/*
 *  ======== xdc_runtime_Log_getEventId ========
 */

/*
 *  ======== xdc_runtime_Log_doPut* ========
 *  The 'doPut' macros are the real implementation of the Log_put* APIs.
 *  The Log_put* macros are just stubs which point to these definitions. We do
 *  this so that we can disable the Log_put APIs but still leave their
 *  functionality available for any other Log macros which use them. 
 *  For example, if the flags DISABLE_ALL and ENABLE_ERROR were set, we'd want
 *  to disable the Log_put* macros, but not the Log_error* macros which are
 *  built on top of Log_put.
 */




   
/*
 *  ======== xdc_runtime_Log_put* ========
 *  See Log_doPut*
 */







/*
 *  ======== xdc_runtime_Log_doWrite* ========
 *  The real implementations of the Log_write* APIs. See Log_doPut* for an
 *  explanation of why we stub-out the Log_put* and Log_write* APIs.
 */

    
     
    




/*
 *  ======== xdc_runtime_Log_write* ========
 *  See Log_doWrite*
 */

 
    
    
    


    
    

    
  
/*
 *  ======== xdc_runtime_Log_print* ========
 *  Since "print" events do not have a rope, we use 0 (an invalid rope value)
 *  as the event Id and construct a Log_Event to pass to Log_put. This has the 
 *  benefit that the Log_Event is equal to just the mask: (0 | mask). For this 
 *  reason, we simply pass the 'mask' as the first argument to 'put'.
 *
 *  Each print function is mapped to a call to appropriate 'put' function.
 *  print0 -> put1
 *  print1 -> put2
 *  print2 -> print3 -> put4
 *  print3 -> put4
 *  print4 -> print6 -> put8
 *  print5 -> print6 -> put8
 *  print6 -> put8
 */

 
    
    





/*
 *  ======== xdc_runtime_Log_error* ========
 *  Log an error event
 */
 
 
        
    
    

    
/*
 *  ======== xdc_runtime_Log_warning* ========
 *  Log a warning event
 */

 
    
    
    

    
/*
 *  ======== xdc_runtime_Log_info* ========
 *  Log an informational event
 */

    
    
    

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */





/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */

/*  ============================================================================
 *  Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2006, 2008
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/** ============================================================================
 *   @file  cslr.h
 *
 *   @path  $(CSLPATH)\inc
 *
 *   @desc  This file contains the macro definations for Register layer
 *
 */

/* Register layer central -- contains field-manipulation macro definitions */


/* the "expression" macros */

/* the Field MaKe macro */

/* the Field EXTract macro */

/* the Field INSert macro */


/* the "token" macros */

/* the Field MaKe (Token) macro */

/* the Field INSert (Token) macro */


/* the "raw" macros */

/* the Field MaKe (Raw) macro */

/* the Field EXTract (Raw) macro */

/* the Field INSert (Raw) macro */


/*********************************************************************
 * Copyright (C) 2005 Texas Instruments Incorporated. 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/*
 *  ======== tistdtypes.h ========
 */

/*
 * These types are also defined by other TI components.  They are bracketed
 * with _TI_STD_TYPES to avoid warnings for duplicate definition.
 *
 * You may get warnings about duplicate type definitions when using this
 * header file with earlier versions of DSP/BIOS and CSL.
 *
 * You can use the '-pds303' compiler option to suppress these warnings.
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for Bank_Registers
\**************************************************************************/
typedef struct  {
    volatile Uint32 DIR;
    volatile Uint32 OUT_DATA;
    volatile Uint32 SET_DATA;
    volatile Uint32 CLR_DATA;
    volatile Uint32 IN_DATA;
    volatile Uint32 SET_RIS_TRIG;
    volatile Uint32 CLR_RIS_TRIG;
    volatile Uint32 SET_FAL_TRIG;
    volatile Uint32 CLR_FAL_TRIG;
    volatile Uint32 INTSTAT;
} CSL_GpioBank_registersRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 PID;
    volatile Uint32 PCR;
    volatile Uint32 BINTEN;
    volatile Uint8 RSVD0[4];
    CSL_GpioBank_registersRegs BANK_REGISTERS[4];
} CSL_GpioRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* DIR */




/* OUT_DATA */




/* SET_DATA */




/* CLR_DATA */




/* IN_DATA */




/* SET_RIS_TRIG */




/* CLR_RIS_TRIG */




/* SET_FAL_TRIG */




/* CLR_FAL_TRIG */




/* INTSTAT */




/* PID */









/* PCR */





/* BINTEN */









//#define EVM_BOARD

/* Need to change the Pin no as per Schematics */


//SPI ports
//GPIO pins


									//GPIO pinno for BOOT_RED LED


//Common GPIO pins


/*****************************************************************************/
/* stdarg.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/



/**
 *   @file  csl_cacheAux.h
 *
 *   @brief   
 *      This is the CACHE Auxilary Header File which exposes the various
 *      CSL Functional Layer API's to configure the CACHE Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2002, 2003, 2004, 2005, 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/**
 *   @file  csl_cache.h
 *
 *   @brief   
 *      This is the CACHE Auxilary Header File which exposes the various
 *      CSL Functional Layer API's to configure the CACHE Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2002, 2003, 2004, 2005, 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** @defgroup CSL_CACHE_API CACHE
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 * This page describes the Functions, Data Structures, Enumerations and Macros
 * within CACHE module.
 *
 * This module uses three cache architectures, Level 1 Program (L1P), Level 1
 * Data (L1D) and Level 2 CACHE architectures, The L1P and L1D can be
 * configured as 0K, 4K, 8K, 16K, or 32K CACHE size. The L2 can be configured
 * as 32KB, 64KB, 128KB, or 256KB CACHE size. This CACHE module supports the
 * Block and Global Coherence Operations.
 *
 * @subsection References
 *    -# TMS320TCI6484 Data Sheet SPRS438 (Dec 2007) 
 *
 */
 


/*  ===========================================================================
 *  Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2006, 2008
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** ============================================================================
 *   @file  csl.h
 *
 *   @path  $(CSLPATH)\inc
 *
 *   @desc  This file contains the Register Desciptions for CSL
 *
 */



/*  ============================================================================
 *  Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2006, 2008
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/** ============================================================================
 *   @file  csl_types.h
 *
 *   @path  $(CSLPATH)\inc
 *
 *   @desc  This file contains the Register Desciptions for CSL types
 *
 */
 




typedef Int16           CSL_Uid;
typedef Int16           CSL_ModuleId;
typedef Uint32          CSL_Xio;

typedef Uint8           CSL_BitMask8;
typedef Uint16          CSL_BitMask16;
typedef Uint32          CSL_BitMask32;

typedef volatile Uint8  CSL_Reg8;
typedef volatile Uint16 CSL_Reg16;
typedef volatile Uint32 CSL_Reg32;

typedef Int16           CSL_Status;
typedef Int16           CSL_InstNum;
typedef Int16           CSL_ChaNum;

typedef unsigned long long int  CSL_Uint64;

typedef enum {
  CSL_EXCLUSIVE = 0,
  CSL_SHARED    = 1
} CSL_OpenMode;

typedef enum {
  CSL_FAIL      = 0,
  CSL_PASS      = 1
} CSL_Test;



/*  ============================================================================
 *  Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2006, 2008
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/** ============================================================================
 *   @file  csl_error.h
 *
 *   @path  $(CSLPATH)\inc
 *
 *   @desc  This file contains the Register Desciptions for ERRORs
 *
 */

/* ---- File: <csl_error.h> ---- */

/* Below Error codes are Global across all CSL Modules. */

/* Peripheral IDs */

/* Error codes individual to various modules. */

/* Error code for DMA, individual error would be assigned as
 * eg: #define CSL_E<Peripheral name>_<error code>  CSL_EDMA_FIRST - 1
 */



















void
    CSL_sysInit (
        void
);



/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 *      b) The MAR0-MAR255 have been made into an array of MAR[256]
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 EVTFLAG[4];
    volatile Uint8 RSVD0[16];
    volatile Uint32 EVTSET[4];
    volatile Uint8 RSVD1[16];
    volatile Uint32 EVTCLR[4];
    volatile Uint8 RSVD2[48];
    volatile Uint32 EVTMASK[4];
    volatile Uint8 RSVD3[16];
    volatile Uint32 MEVTFLAG[4];
    volatile Uint8 RSVD4[16];
    volatile Uint32 EXPMASK[4];
    volatile Uint8 RSVD5[16];
    volatile Uint32 MEXPFLAG[4];
    volatile Uint8 RSVD6[20];
    volatile Uint32 INTMUX1;
    volatile Uint32 INTMUX2;
    volatile Uint32 INTMUX3;
    volatile Uint8 RSVD7[48];
    volatile Uint32 AEGMUX0;
    volatile Uint32 AEGMUX1;
    volatile Uint8 RSVD8[56];
    volatile Uint32 INTXSTAT;
    volatile Uint32 INTXCLR;
    volatile Uint32 INTDMASK;
    volatile Uint8 RSVD9[52];
    volatile Uint32 EVTASRT;
    volatile Uint8 RSVD10[65084];
    volatile Uint32 PDCCMD;
    volatile Uint8 RSVD11[8188];
    volatile Uint32 MM_REVID;
    volatile Uint8 RSVD12[57340];
    volatile Uint32 IDMA0_STAT;
    volatile Uint32 IDMA0_MASK;
    volatile Uint32 IDMA0_SOURCE;
    volatile Uint32 IDMA0_DEST;
    volatile Uint32 IDMA0_COUNT;
    volatile Uint8 RSVD13[236];
    volatile Uint32 IDMA1_STAT;
    volatile Uint8 RSVD14[4];
    volatile Uint32 IDMA1_SOURCE;
    volatile Uint32 IDMA1_DEST;
    volatile Uint32 IDMA1_COUNT;
    volatile Uint8 RSVD15[236];
    volatile Uint32 CPUARBE;
    volatile Uint32 IDMAARBE;
    volatile Uint32 SDMAARBE;
    volatile Uint8 RSVD16[4];
    volatile Uint32 ECFGARBE;
    volatile Uint8 RSVD17[236];
    volatile Uint32 ICFGMPFAR;
    volatile Uint32 ICFGMPFSR;
    volatile Uint32 ICFGMPFCR;
    volatile Uint8 RSVD18[252];
    volatile Uint32 ECFGERR;
    volatile Uint32 ECFGERRCLR;
    volatile Uint8 RSVD19[240];
    volatile Uint32 PAMAP0;
    volatile Uint32 PAMAP1;
    volatile Uint32 PAMAP2;
    volatile Uint32 PAMAP3;
    volatile Uint32 PAMAP4;
    volatile Uint32 PAMAP5;
    volatile Uint32 PAMAP6;
    volatile Uint32 PAMAP7;
    volatile Uint32 PAMAP8;
    volatile Uint32 PAMAP9;
    volatile Uint32 PAMAP10;
    volatile Uint32 PAMAP11;
    volatile Uint32 PAMAP12;
    volatile Uint32 PAMAP13;
    volatile Uint32 PAMAP14;
    volatile Uint32 PAMAP15;
    volatile Uint8 RSVD20[129728];
    volatile Uint32 L2CFG;
    volatile Uint8 RSVD21[28];
    volatile Uint32 L1PCFG;
    volatile Uint32 L1PCC;
    volatile Uint8 RSVD22[24];
    volatile Uint32 L1DCFG;
    volatile Uint32 L1DCC;
    volatile Uint8 RSVD23[4024];
    volatile Uint32 CPUARBU;
    volatile Uint32 IDMAARBU;
    volatile Uint32 SDMAARBU;
    volatile Uint32 UCARBU;
    volatile Uint32 MDMAARBU;
    volatile Uint8 RSVD24[44];
    volatile Uint32 CPUARBD;
    volatile Uint32 IDMAARBD;
    volatile Uint32 SDMAARBD;
    volatile Uint32 UCARBD;
    volatile Uint8 RSVD25[12208];
    volatile Uint32 L2WBAR;
    volatile Uint32 L2WWC;
    volatile Uint8 RSVD26[8];
    volatile Uint32 L2WIBAR;
    volatile Uint32 L2WIWC;
    volatile Uint32 L2IBAR;
    volatile Uint32 L2IWC;
    volatile Uint32 L1PIBAR;
    volatile Uint32 L1PIWC;
    volatile Uint8 RSVD27[8];
    volatile Uint32 L1DWIBAR;
    volatile Uint32 L1DWIWC;
    volatile Uint8 RSVD28[8];
    volatile Uint32 L1DWBAR;
    volatile Uint32 L1DWWC;
    volatile Uint32 L1DIBAR;
    volatile Uint32 L1DIWC;
    volatile Uint8 RSVD29[4016];
    volatile Uint32 L2WB;
    volatile Uint32 L2WBINV;
    volatile Uint32 L2INV;
    volatile Uint8 RSVD30[28];
    volatile Uint32 L1PINV;
    volatile Uint8 RSVD31[20];
    volatile Uint32 L1DWB;
    volatile Uint32 L1DWBINV;
    volatile Uint32 L1DINV;
    volatile Uint8 RSVD32[4024];
    volatile Uint32 L2EDSTAT;
    volatile Uint32 L2EDCMD;
    volatile Uint32 L2EDADDR;
    volatile Uint8 RSVD33[8];
    volatile Uint32 L2EDCPEC;
    volatile Uint32 L2EDCNEC;
    volatile Uint32 MDMAERR;
    volatile Uint32 MDMAERRCLR;
    volatile Uint8 RSVD34[8];
    volatile Uint32 L2EDCEN;
    volatile Uint8 RSVD35[976];
    volatile Uint32 L1PEDSTAT;
    volatile Uint32 L1PEDCMD;
    volatile Uint32 L1PEDADDR;
    volatile Uint8 RSVD36[7152];
    volatile Uint32 MAR[256];
    volatile Uint8 RSVD37[7168];
    volatile Uint32 L2MPFAR;
    volatile Uint32 L2MPFSR;
    volatile Uint32 L2MPFCR;
    volatile Uint8 RSVD38[500];
    volatile Uint32 L2MPPA[32];
    volatile Uint8 RSVD39[384];
    volatile Uint32 L1PMPFAR;
    volatile Uint32 L1PMPFSR;
    volatile Uint32 L1PMPFCR;
    volatile Uint8 RSVD40[564];
    volatile Uint32 L1PMPPA[16];
    volatile Uint8 RSVD41[1408];
    volatile Uint32 L1DMPFAR;
    volatile Uint32 L1DMPFSR;
    volatile Uint32 L1DMPFCR;
    volatile Uint8 RSVD42[244];
    volatile Uint32 MPLK[4];
    volatile Uint32 MPLKCMD;
    volatile Uint32 MPLKSTAT;
    volatile Uint8 RSVD43[296];
    volatile Uint32 L1DMPPA[16];
} CSL_CgemRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* EVTFLAG */



/* EVTSET */



/* EVTCLR */



/* EVTMASK */



/* MEVTFLAG */



/* EXPMASK */



/* MEXPFLAG */



/* INTMUX1 */










/* INTMUX2 */










/* INTMUX3 */










/* AEGMUX0 */






/* AEGMUX1 */






/* INTXSTAT */






/* INTXCLR */




/* INTDMASK */





/* EVTASRT */








/* PDCCMD */












/* MM_REVID */



/* IDMA0_STAT */





/* IDMA0_MASK */



/* IDMA0_SOURCE */




/* IDMA0_DEST */




/* IDMA0_COUNT */






/* IDMA1_STAT */





/* IDMA1_SOURCE */




/* IDMA1_DEST */




/* IDMA1_COUNT */








/* CPUARBE */






/* IDMAARBE */




/* SDMAARBE */




/* ECFGARBE */





/* ICFGMPFAR */



/* ICFGMPFSR */












/* ICFGMPFCR */




/* ECFGERR */







/* ECFGERRCLR */




/* PAMAP0 */




/* PAMAP1 */




/* PAMAP2 */




/* PAMAP3 */




/* PAMAP4 */




/* PAMAP5 */




/* PAMAP6 */




/* PAMAP7 */




/* PAMAP8 */




/* PAMAP9 */




/* PAMAP10 */




/* PAMAP11 */




/* PAMAP12 */




/* PAMAP13 */




/* PAMAP14 */




/* PAMAP15 */




/* L2CFG */








/* L1PCFG */




/* L1PCC */






/* L1DCFG */




/* L1DCC */






/* CPUARBU */






/* IDMAARBU */




/* SDMAARBU */




/* UCARBU */




/* MDMAARBU */







/* CPUARBD */






/* IDMAARBD */




/* SDMAARBD */




/* UCARBD */




/* L2WBAR */



/* L2WWC */




/* L2WIBAR */



/* L2WIWC */




/* L2IBAR */



/* L2IWC */




/* L1PIBAR */



/* L1PIWC */




/* L1DWIBAR */



/* L1DWIWC */




/* L1DWBAR */



/* L1DWWC */




/* L1DIBAR */



/* L1DIWC */




/* L2WB */




/* L2WBINV */




/* L2INV */




/* L1PINV */




/* L1DWB */




/* L1DWBINV */




/* L1DINV */




/* L2EDSTAT */














/* L2EDCMD */











/* L2EDADDR */






/* L2EDCPEC */




/* L2EDCNEC */




/* MDMAERR */







/* MDMAERRCLR */




/* L2EDCEN */








/* L1PEDSTAT */










/* L1PEDCMD */










/* L1PEDADDR */





/* MAR0 */







/* MAR1 */







/* MAR2 */







/* MAR3 */







/* MAR4 */







/* MAR5 */







/* MAR6 */







/* MAR7 */







/* MAR8 */







/* MAR9 */







/* MAR10 */







/* MAR11 */







/* MAR12 */







/* MAR13 */







/* MAR14 */







/* MAR15 */







/* MAR16 */







/* MAR17 */







/* MAR18 */







/* MAR19 */







/* MAR20 */







/* MAR21 */







/* MAR22 */







/* MAR23 */







/* MAR24 */







/* MAR25 */







/* MAR26 */







/* MAR27 */







/* MAR28 */







/* MAR29 */







/* MAR30 */







/* MAR31 */







/* MAR32 */







/* MAR33 */







/* MAR34 */







/* MAR35 */







/* MAR36 */







/* MAR37 */







/* MAR38 */







/* MAR39 */







/* MAR40 */







/* MAR41 */







/* MAR42 */







/* MAR43 */







/* MAR44 */







/* MAR45 */







/* MAR46 */







/* MAR47 */







/* MAR48 */







/* MAR49 */







/* MAR50 */







/* MAR51 */







/* MAR52 */







/* MAR53 */







/* MAR54 */







/* MAR55 */







/* MAR56 */







/* MAR57 */







/* MAR58 */







/* MAR59 */







/* MAR60 */







/* MAR61 */







/* MAR62 */







/* MAR63 */







/* MAR64 */







/* MAR65 */







/* MAR66 */







/* MAR67 */







/* MAR68 */







/* MAR69 */







/* MAR70 */







/* MAR71 */







/* MAR72 */







/* MAR73 */







/* MAR74 */







/* MAR75 */







/* MAR76 */







/* MAR77 */







/* MAR78 */







/* MAR79 */







/* MAR80 */







/* MAR81 */







/* MAR82 */







/* MAR83 */







/* MAR84 */







/* MAR85 */







/* MAR86 */







/* MAR87 */







/* MAR88 */







/* MAR89 */







/* MAR90 */







/* MAR91 */







/* MAR92 */







/* MAR93 */







/* MAR94 */







/* MAR95 */







/* MAR96 */







/* MAR97 */







/* MAR98 */







/* MAR99 */







/* MAR100 */







/* MAR101 */







/* MAR102 */







/* MAR103 */







/* MAR104 */







/* MAR105 */







/* MAR106 */







/* MAR107 */







/* MAR108 */







/* MAR109 */







/* MAR110 */







/* MAR111 */







/* MAR112 */







/* MAR113 */







/* MAR114 */







/* MAR115 */







/* MAR116 */







/* MAR117 */







/* MAR118 */







/* MAR119 */







/* MAR120 */







/* MAR121 */







/* MAR122 */







/* MAR123 */







/* MAR124 */







/* MAR125 */







/* MAR126 */







/* MAR127 */







/* MAR128 */







/* MAR129 */







/* MAR130 */







/* MAR131 */







/* MAR132 */







/* MAR133 */







/* MAR134 */







/* MAR135 */







/* MAR136 */







/* MAR137 */







/* MAR138 */







/* MAR139 */







/* MAR140 */







/* MAR141 */







/* MAR142 */







/* MAR143 */







/* MAR144 */







/* MAR145 */







/* MAR146 */







/* MAR147 */







/* MAR148 */







/* MAR149 */







/* MAR150 */







/* MAR151 */







/* MAR152 */







/* MAR153 */







/* MAR154 */







/* MAR155 */







/* MAR156 */







/* MAR157 */







/* MAR158 */







/* MAR159 */







/* MAR160 */







/* MAR161 */







/* MAR162 */







/* MAR163 */







/* MAR164 */







/* MAR165 */







/* MAR166 */







/* MAR167 */







/* MAR168 */







/* MAR169 */







/* MAR170 */







/* MAR171 */







/* MAR172 */







/* MAR173 */







/* MAR174 */







/* MAR175 */







/* MAR176 */







/* MAR177 */







/* MAR178 */







/* MAR179 */







/* MAR180 */







/* MAR181 */







/* MAR182 */







/* MAR183 */







/* MAR184 */







/* MAR185 */







/* MAR186 */







/* MAR187 */







/* MAR188 */







/* MAR189 */







/* MAR190 */







/* MAR191 */







/* MAR192 */







/* MAR193 */







/* MAR194 */







/* MAR195 */







/* MAR196 */







/* MAR197 */







/* MAR198 */







/* MAR199 */







/* MAR200 */







/* MAR201 */







/* MAR202 */







/* MAR203 */







/* MAR204 */







/* MAR205 */







/* MAR206 */







/* MAR207 */







/* MAR208 */







/* MAR209 */







/* MAR210 */







/* MAR211 */







/* MAR212 */







/* MAR213 */







/* MAR214 */







/* MAR215 */







/* MAR216 */







/* MAR217 */







/* MAR218 */







/* MAR219 */







/* MAR220 */







/* MAR221 */







/* MAR222 */







/* MAR223 */







/* MAR224 */







/* MAR225 */







/* MAR226 */







/* MAR227 */







/* MAR228 */







/* MAR229 */







/* MAR230 */







/* MAR231 */







/* MAR232 */







/* MAR233 */







/* MAR234 */







/* MAR235 */







/* MAR236 */







/* MAR237 */







/* MAR238 */







/* MAR239 */







/* MAR240 */







/* MAR241 */







/* MAR242 */







/* MAR243 */







/* MAR244 */







/* MAR245 */







/* MAR246 */







/* MAR247 */







/* MAR248 */







/* MAR249 */







/* MAR250 */







/* MAR251 */







/* MAR252 */







/* MAR253 */







/* MAR254 */







/* MAR255 */







/* L2MPFAR */



/* L2MPFSR */













/* L2MPFCR */




/* L2MPPA */



















/* L1PMPFAR */



/* L1PMPFSR */













/* L1PMPFCR */




/* L1PMPPA */



















/* L1DMPFAR */



/* L1DMPFSR */













/* L1DMPFCR */




/* MPLK */



/* MPLKCMD */






/* MPLKSTAT */





/* L1DMPPA */



















/**
 *   @file  soc.h
 *
 *   @brief
 *      This file contains SOC specific defintions.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/


/*  ============================================================================
 *  Copyright (c) Texas Instruments Incorporated 2002-2012
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/


/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Header files are included as per RTSC guidelines
 */


/**************************************************************************
* Memory Region Descriptions for the device
**************************************************************************/
/**************************************************************************
* Peripheral Instance counts
**************************************************************************/


/*************************************************************************** Peripheral Instance definitions.
\**************************************************************************/

/** @brief Instance number of internal RAM */

/** @brief Instance number of CGEM_0_5_LOCAL_REGISTERS */

/** @brief Peripheral Instance numbers of CP_TRACER */

/** @brief Peripheral Instance for AIF */

/** @brief Peripheral Instance for PA_SS */

/** @brief Peripheral Instance of Timer 64p */
/** @brief Instance number of PLL controller*/

/** @brief Peripheral Instance for GPIO */

/** @brief Peripheral Instance for SMARTREFLEX */

/** @brief Instance number of PSC controller */

/** @brief Instance number of MPU */

/** @brief Instance number of DEBUG_SS */

/** @brief Instance number of GEM_DEBUG */

/** @brief Instance number of SEC_CTL */

/** @brief Instance number of SEC_KEY_MGR */

/** @brief Peripheral Instance for I2C */

/** @brief Peripheral Instance of UART */

/** @brief Peripheral Instance numbers of CP_INTC */

/** @brief Peripheral Instance of BOOT_CFG */

/** @brief Peripheral Instance of SEMAPHORE */

/** @brief Peripheral Instance of TPCC instances */
/* Same as above - name changed to match data manuals */

/** @brief Peripheral Instance of TPTC instances */
/* Same as above - name changed to match data manuals */

/** @brief Peripheral Instance of SRIO */

/** @brief Peripheral Instance of QM_SS */

/** @brief Peripheral Instance of MSMC */

/** @brief Peripheral Instance of DSP0_GLOBAL */

/** @brief Peripheral Instance of DSP1_GLOBAL */

/** @brief Peripheral Instance of DSP2_GLOBAL */

/** @brief Peripheral Instance of DSP3_GLOBAL */

/** @brief Peripheral Instance of DSP4_GLOBAL */

/** @brief Peripheral Instance of DSP5_GLOBAL */

/** @brief Peripheral Instance of DSP6_GLOBAL */

/** @brief Peripheral Instance of DSP7_GLOBAL */

/** @brief Peripheral Instance of BOOT */

/** @brief Peripheral Instance of SPI */

/** @brief Peripheral Instance of TSIP */

/** @brief Peripheral Instance for DDR3 */

/** @brief Instance number of MCM */

/** @brief Peripheral Instance for PCIE_SS */

/** @brief Instance number of device configuration module */

/* PSC Definitions */
/* PSC Power Domain Assignment Definitions */

/* PSC LPSC Module Assignment Definitions */


/** @TPCC0 Configuration*/

/* Same as above - name changed to match data manuals */

/** @TPCC1 Configuration*/

/* Same as above - name changed to match data manuals */

/** @TPCC2 Configuration*/

/* Same as above - name changed to match data manuals */
/**************************************************************************
* Peripheral Base Address-0.1.6
**************************************************************************/

/**************************************************************************
* CHIP LEVEL INTC0 EVENT INPUT-0.1.10
**************************************************************************/



/**************************************************************************
* CHIP LEVEL INTC0 EVENT DEFINITION
**************************************************************************/
/* Same as above - name changed to match data manuals */
/* Same as above - name changed to match data manuals */
/* Same as above - name changed to match data manuals */
/**************************************************************************
* CHIP LEVEL INTC1 EVENT INPUT-0.1.10
**************************************************************************/



/**************************************************************************
* CHIP LEVEL INTC1 EVENT DEFINITION
**************************************************************************/


/**************************************************************************
* CHIP LEVEL INTC2 EVENT INPUT
**************************************************************************/



/**************************************************************************
* CHIP LEVEL INTC2 EVENT DEFINITION
**************************************************************************/

/**************************************************************************
* CHIP LEVEL INTC3 EVENT INPUT
**************************************************************************/



/**************************************************************************
* CHIP LEVEL INTC3 EVENT DEFINITION
**************************************************************************/

/**************************************************************************
* TPCC0 (CPU_2) EVENT INPUT
**************************************************************************/


/**************************************************************************
* EDMA3CC0 (CPU/2) EVENT INPUT
**************************************************************************/


/**************************************************************************
* TPCC0 (CPU_2) EVENT DEFINITION
**************************************************************************/

/**************************************************************************
* EDMA3CC0 (CPU_2) EVENT DEFINITION
**************************************************************************/

/**************************************************************************
* TPCC1 (CPU_3) EVENT INPUT
**************************************************************************/



/**************************************************************************
* TPCC1 (CPU_3) EVENT DEFINITION
**************************************************************************/

/* Same as above - name changed to match data manuals */
/**************************************************************************
* EDMA3CC1 (CPU/3) EVENT INPUT
**************************************************************************/


/**************************************************************************
* EDMA3CC1 (CPU_3) EVENT DEFINITION
**************************************************************************/


/**************************************************************************
* TPCC2 (CPU_3) EVENT INPUT
**************************************************************************/



/**************************************************************************
* TPCC2 (CPU_3) EVENT DEFINITION
**************************************************************************/

/* Same as above - name changed to match data manuals */
/**************************************************************************
* EDMA3CC2 (CPU/3) EVENT INPUT
**************************************************************************/


/**************************************************************************
* EDMA3CC2 (CPU_3) EVENT DEFINITION
**************************************************************************/


/**************************************************************************
* MCM EVENT INPUT
**************************************************************************/



/**************************************************************************
* MCM EVENT DEFINITION
**************************************************************************/


/**************************************************************************
* GEM EVENT INPUT
**************************************************************************/



/**************************************************************************
* GEM EVENT DEFINITION
**************************************************************************/
/* Same as above - name changed to match data manuals */
/* Same as above - name changed to match data manuals */
/* Same as above - name changed to match data manuals */
/* Same as above - name changed to match data manuals */

/**************************************************************************
* EOI Values
**************************************************************************/


/****************************************************************************** Static inline definition
\*****************************************************************************/




/**
@defgroup CSL_CACHE_SYMBOL  CACHE Symbols Defined
@ingroup CSL_CACHE_API
*/
/**
@defgroup CSL_CACHE_ENUM  CACHE Enumerated Data Types
@ingroup CSL_CACHE_API
*/
/**
@defgroup CSL_CACHE_FUNCTION  CACHE Functions
@ingroup CSL_CACHE_API
*/


/**
@addtogroup CSL_CACHE_SYMBOL
@{
*/
/** L2 Line Size */
/** L1D Line Size */
/** L1P Line Size */

/** Handle to the CGEM Register Layer */

/** Cache Round to Line size */        
/**
@}
*/

/******************************************************************************* global macro declarations
\******************************************************************************/

/** @addtogroup CSL_CACHE_ENUM
 @{ */
/** @brief Enumeration for Cache wait flags
 *
 *  This is used for specifying whether the cache operations should block till
 *  the desired operation is complete.
 */
typedef enum 
{
    /** No blocking, the call exits after programmation of the 
     *  control registers 
     */
    CACHE_NOWAIT = 0,
                         
    /** Blocking Call, the call exits after the relevant cache 
     *  status registers indicate completion. For block coherence
     *  this waits on the Word count register to be come 0.
     */
    CACHE_WAIT   = 1,

    /** Blocking Call, For block coherence this uses the MFENCE to 
     * wait for completion
     */
    CACHE_FENCE_WAIT  = 2    
}CACHE_Wait;

/** @brief Enumeration for L1 (P or D) Sizes */

typedef enum { 
    /** No Cache    */                 
    CACHE_L1_0KCACHE  = 0,
    /** 4KB Cache   */                               
    CACHE_L1_4KCACHE  = 1,
    /** 8KB Cache   */                 
    CACHE_L1_8KCACHE  = 2,
    /** 16KB Cache  */                                 
    CACHE_L1_16KCACHE = 3,
    /** 32KB Cache  */                
    CACHE_L1_32KCACHE = 4,
    /** MAX Cache Size */                
    CACHE_L1_MAXIM1   = 5,
    /** MAX Cache Size */                
    CACHE_L1_MAXIM2   = 6,      
    /** MAX Cache Size */                
    CACHE_L1_MAXIM3   = 7          
} CACHE_L1Size;

/** @brief Enumeration for L2 Sizes */

    /** For devices that have maximum caches less 
     * than the defined values, setting a higher value 
     * will map to maximum cache 
     */
typedef enum { 
    /** No Cache     */
    CACHE_0KCACHE   = 0,  
    /** 32KB Cache   */
    CACHE_32KCACHE  = 1, 
    /** 64KB Cache   */
    CACHE_64KCACHE  = 2, 
    /** 128KB Cache  */
    CACHE_128KCACHE = 3,
    /** 256KB Cache  */
    CACHE_256KCACHE = 4,
    /** 512KB Cache  */
    CACHE_512KCACHE = 5,
    /* 1024KB Cache  */
    CACHE_1024KCACHE = 6 
} CACHE_L2Size; 

/**
@}
*/



/** @addtogroup CSL_CACHE_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CACHE_enableCaching
 *
 *   @b Description
 *   @n This function enables caching for a specific memory region. 
 *
 *   @b Arguments
     @verbatim
          mar      Memory region for which cache is to be enabled.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n Memory region is now cacheable.
 *
 *   @b Writes
 *   @n CGEM_MAR0_PC=1
 *
 *   @b Example
 *   @verbatim
        CACHE_enableCaching (20);

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_enableCaching  (Uint8 mar)
{
    ((((CSL_CgemRegs *)(0x01800000))->MAR[mar]) = ((((CSL_CgemRegs *)(0x01800000))->MAR[mar]) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CACHE_disableCaching
 *
 *   @b Description
 *   @n This function disables caching for a specific memory region. 
 *
 *   @b Arguments
     @verbatim
          mar      Memory region for which cache is to be disabled.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n Memory region is now *not* cacheable.
 *
 *   @b Writes
 *   @n CGEM_MAR0_PC=0
 *
 *   @b Example
 *   @verbatim
        CACHE_disableCaching (20);

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_disableCaching (Uint8 mar)
{
    ((((CSL_CgemRegs *)(0x01800000))->MAR[mar]) = ((((CSL_CgemRegs *)(0x01800000))->MAR[mar]) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CACHE_getMemRegionInfo
 *
 *   @b Description
 *   @n This function is used to get memory region information.
 *
 *   @b Arguments
     @verbatim
          mar      Memory region for which the information is required.
          pcx      Is address cacheable in external cache (MSMC)
          pfx      Is address prefetchable 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n CGEM_MAR0_PCX, CGEM_MAR0_PFX
 *
 *   @b Example
 *   @verbatim
        
        Uint8 pcx;
        Uint8 pfx;

        // Get the memory region information for 20
        CACHE_getMemRegionInfo (20, &pcx, &pfx);

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_getMemRegionInfo (Uint8 mar, Uint8* pcx, Uint8* pfx)
{
    Uint32 value = ((CSL_CgemRegs *)(0x01800000))->MAR[mar];

    *pcx = (((value) & (0x00000004u)) >> (0x00000002u));
    *pfx = (((value) & (0x00000008u)) >> (0x00000003u));
}

/** ============================================================================
 *   @n@b CACHE_setMemRegionInfo
 *
 *   @b Description
 *   @n This function is used to set memory region information.
 *
 *   @b Arguments
     @verbatim
          mar      Memory region for which the information is required.
          pcx      Is address cacheable in external cache (MSMC)
          pfx      Is address prefetchable 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n CGEM_MAR0_PCX, CGEM_MAR0_PFX
 *
 *   @b Example
 *   @verbatim
        
        Uint8 pcx;
        Uint8 pfx;

        // Get the memory region information for 20
        CACHE_getMemRegionInfo (20, &pcx, &pfx);
        ...
        // Ensure Memory Region 20 is not prefetchable.
        CACHE_setMemRegionInfo(20, pcx, 0);
     @endverbatim
 * =============================================================================
 */
static inline void CACHE_setMemRegionInfo (Uint8 mar, Uint8 pcx, Uint8 pfx)
{
    ((((CSL_CgemRegs *)(0x01800000))->MAR[mar]) = ((((CSL_CgemRegs *)(0x01800000))->MAR[mar]) & ~(0x00000004u)) | (((pcx) << (0x00000002u)) & (0x00000004u)));
    ((((CSL_CgemRegs *)(0x01800000))->MAR[mar]) = ((((CSL_CgemRegs *)(0x01800000))->MAR[mar]) & ~(0x00000008u)) | (((pfx) << (0x00000003u)) & (0x00000008u)));
}

/** ============================================================================
 *   @n@b CACHE_setL1DSize
 *
 *   @b Description
 *   @n This function is used to set the L1 Data Cache Size.  
 *
 *   @b Arguments
      @verbatim
          newSize      Cache Size to be configured.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CGEM_L1DCFG_L1DMODE
 *
 *   @b Example
 *   @verbatim
        
        CACHE_setL1DSize(1); // Configure 4K Cache Size

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_setL1DSize (CACHE_L1Size newSize)
{
    ((((CSL_CgemRegs *)(0x01800000))->L1DCFG) = ((((CSL_CgemRegs *)(0x01800000))->L1DCFG) & ~(0x00000007u)) | (((newSize) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CACHE_getL1DSize
 *
 *   @b Description
 *   @n This function is used to get the L1 Data Cache Size.  
 *
 *   @b Arguments
 *   @n None
 * 
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CGEM_L1DCFG_L1DMODE
 *
 *   @b Example
 *   @verbatim
        CACHE_L1Size cacheSize;
        
        cacheSize = CACHE_getL1DSize();

     @endverbatim
 * =============================================================================
 */
static inline CACHE_L1Size CACHE_getL1DSize (void)
{
    return (CACHE_L1Size)(((((CSL_CgemRegs *)(0x01800000))->L1DCFG) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CACHE_freezeL1D
 *
 *   @b Description
 *   @n This function is used to freeze the L1D cache.  
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CGEM_L1DCC_OPER=1
 *
 *   @b Example
 *   @verbatim
        
        CACHE_freezeL1D();

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_freezeL1D(void)
{
    /* Set the Freeze Mode Enabled bit. */
    ((((CSL_CgemRegs *)(0x01800000))->L1DCC) = ((((CSL_CgemRegs *)(0x01800000))->L1DCC) & ~(0x00000007u)) | (((1) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CACHE_unfreezeL1D
 *
 *   @b Description
 *   @n This function is used to unfreeze the L1D cache.  
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CGEM_L1DCC_OPER=0
 *
 *   @b Example
 *   @verbatim
        
        CACHE_unfreezeL1D();

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_unfreezeL1D(void)
{
    /* Reset the Freeze Mode Enabled bit. */
    ((((CSL_CgemRegs *)(0x01800000))->L1DCC) = ((((CSL_CgemRegs *)(0x01800000))->L1DCC) & ~(0x00000007u)) | (((0) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CACHE_getPrevL1DMode
 *
 *   @b Description
 *   @n This function is used get the previous operating state of the L1D cache 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CGEM_L1DCC_POPER
 *
 *   @b Example
 *   @verbatim
        Uint32 prev;
        
        prev = CACHE_getPrevL1DMode();

     @endverbatim
 * =============================================================================
 */
static inline Uint32 CACHE_getPrevL1DMode(void)
{
    return (((((CSL_CgemRegs *)(0x01800000))->L1DCC) & (0x00070000u)) >> (0x00000010u));    
}

/** ============================================================================
 *   @n@b CACHE_invAllL1dWait
 *
 *   @b Description
 *   @n This function is used to wait for the L1D global invalidate operation
 *      to complete. This API should be used only if the CACHE_invAllL1d was called
 *      with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_invAllL1d(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CGEM_L1DINV_I=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_invAllL1d(CACHE_NOWAIT); // Invalidate the L1D cache
        ...        
        CACHE_invAllL1dWait();        // Wait for the invalidate operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invAllL1dWait (void)
{
    /* Wait for the Invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L1DINV) & (0xFFFFFFFFu)) >> (0x00000000u)) == 1);
}

/** ============================================================================
 *   @n@b CACHE_invAllL1d
 *
 *   @b Description
 *   @n This function is used to globally invalidate the L1D cache.  
 *
 *   @b Arguments
      @verbatim
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The L1D Cache is being invalidated. 
 *
 *   @b Writes
 *   @n CGEM_L1DINV_I=1
 *
 *   @b Example
 *   @verbatim
        
        CACHE_invAllL1d(CACHE_WAIT); // Invalidate the L1D cache 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invAllL1d (CACHE_Wait wait)
{
    /* Invalidate the Cache Line. */
    ((((CSL_CgemRegs *)(0x01800000))->L1DINV) = ((((CSL_CgemRegs *)(0x01800000))->L1DINV) & ~(0xFFFFFFFFu)) | (((1) << (0x00000000u)) & (0xFFFFFFFFu))); 
    
    /* Determine if we need to wait for the operation to complete. */
    if (wait)
        CACHE_invAllL1dWait();
}

/** ============================================================================
 *   @n@b CACHE_wbAllL1dWait
 *
 *   @b Description
 *   @n This function is used to wait for the L1D writeback operation
 *      to complete. This API should be used only if the CACHE_wbAllL1d was called
 *      with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_wbAllL1d(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The L1D Dirty lines are written back
 *
 *   @b Reads
 *   @n CGEM_L1DWB_C=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_wbAllL1d(CACHE_NOWAIT); // Writeback the L1D cache
        ...        
        CACHE_wbAllL1dWait();        // Wait for the writeback operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbAllL1dWait (void)
{
    /* Wait for the Writeback operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L1DWB) & (0xFFFFFFFFu)) >> (0x00000000u)) == 1);
}

/** ============================================================================
 *   @n@b CACHE_wbAllL1d
 *
 *   @b Description
 *   @n This function is used to writeback the dirty lines of the L1D Cache  
 *
 *   @b Arguments
      @verbatim
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The dirty lines of the L1D Cache are being written back 
 *
 *   @b Writes
 *   @n CGEM_L1DWB_C=1
 *
 *   @b Example
 *   @verbatim
        
        CACHE_wbAllL1d(CACHE_WAIT); // Writeback the Dirty Lines of the L1D cache 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbAllL1d (CACHE_Wait wait)
{
    /* Writeback the Cache Line. */
    ((((CSL_CgemRegs *)(0x01800000))->L1DWB) = ((((CSL_CgemRegs *)(0x01800000))->L1DWB) & ~(0xFFFFFFFFu)) | (((1) << (0x00000000u)) & (0xFFFFFFFFu))); 
    
    /* Determine if we need to wait for the operation to complete. */
    if (wait)
        CACHE_wbAllL1dWait();
}

/** ============================================================================
 *   @n@b CACHE_wbInvAllL1dWait
 *
 *   @b Description
 *   @n This function is used to wait for the L1D writeback invalidate operation
 *      to complete. This API should be used only if the CACHE_wbInvAllL1d was called
 *      with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_wbInvAllL1d(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The L1D Dirty lines are written back
 *
 *   @b Reads
 *   @n CGEM_L1DWBINV_C=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_wbInvAllL1d(CACHE_NOWAIT); // Invalidate/Writeback the L1D cache
        ...        
        CACHE_wbInvAllL1dWait();        // Wait for the Invalidate/Writeback operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbInvAllL1dWait (void)
{
    /* Wait for the Invalidate Writeback operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L1DWBINV) & (0xFFFFFFFFu)) >> (0x00000000u)) == 1);
}

/** ============================================================================
 *   @n@b CACHE_wbInvAllL1d
 *
 *   @b Description
 *   @n This function is used to invalidate and writeback the dirty lines of the 
 *      L1D Cache  
 *
 *   @b Arguments
      @verbatim
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Invalidates and Writebacks the dirty lines of the L1D Cache 
 *
 *   @b Writes
 *   @n CGEM_L1DWBINV_C=1
 *
 *   @b Example
 *   @verbatim
        
        CACHE_wbInvAllL1d(CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void  CACHE_wbInvAllL1d (CACHE_Wait wait)
{
    /* Invalidate and writeback the cache line. */
    ((((CSL_CgemRegs *)(0x01800000))->L1DWBINV) = ((((CSL_CgemRegs *)(0x01800000))->L1DWBINV) & ~(0xFFFFFFFFu)) | (((1) << (0x00000000u)) & (0xFFFFFFFFu))); 
    
    /* Determine if we need to wait for the operation to complete. */
    if (wait)
        CACHE_wbInvAllL1dWait();     
}

/** ============================================================================
 *   @n@b CACHE_invL1dWait
 *
 *   @b Description
 *   @n This function is used to wait for the L1D invalidate block operation to 
 *      complete. This API should be used only if the CACHE_invL1d was called 
 *      with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_invL1d(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The L1D Block Cache is invalidated. 
 *
 *   @b Reads
 *   @n CGEM_L1DIWC_WC=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_invL1d((void *)ptr_buffer, 128, CACHE_NOWAIT);
        ...        
        CACHE_invL1dWait();        // Wait for the Invalidate/Writeback operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invL1dWait (void)
{
    /* Wait for the Invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L1DIWC) & (0x0000FFFFu)) >> (0x00000000u)) != 0);
}

/** ============================================================================
 *   @n@b CACHE_invL1d
 *
 *   @b Description
 *   @n This function is used to invalidate a block in the L1D Cache. Although
 *      the block size can be specified in the number of bytes, the cache
 *      controller operates on whole cache lines. To prevent unintended behavior
 *      "blockPtr" should be aligned on the cache line size and "byteCnt" should
 *      be a multiple of the cache line size.
 *
 *   @b Arguments
      @verbatim
          blockPtr      Address of the block which is to be invalidated
          byteCnt       Size of the block to be invalidated.
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the blockPtr are being invalidated  
 *
 *   @b Writes
 *   @n CGEM_L1DIBAR_ADDR,CGEM_L1DIWC_WC
 *
 *   @b Example
 *   @verbatim
        
        Uint8* ptr_buffer;
                
        // Invalidate 128 bytes of the buffer.
        CACHE_invL1d((void *)ptr_buffer, 128, CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invL1d 
(
    void*       blockPtr,
    Uint32      byteCnt,
    CACHE_Wait  wait
)
{
    /* Setup the block address and length */
    ((CSL_CgemRegs *)(0x01800000))->L1DIBAR = ((((Uint32)blockPtr) << (0x00000000u)) & (0xFFFFFFFFu));
    ((CSL_CgemRegs *)(0x01800000))->L1DIWC  = ((((Uint32)((byteCnt+3)>>2)) << (0x00000000u)) & (0x0000FFFFu));

    /* Determine if we need to wait for the operation to complete. */
    if (wait == CACHE_WAIT)
        CACHE_invL1dWait();
    else if (wait == CACHE_FENCE_WAIT)
        _mfence();
}

/** ============================================================================
 *   @n@b CACHE_wbL1dWait
 *
 *   @b Description
 *   @n This function is used to wait for the L1D writeback block operation to 
 *      complete. This API should be used only if the CACHE_wbL1d was called 
 *      with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_wbL1d(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The dirty lines of the L1D Block Cache have been written back. 
 *
 *   @b Reads
 *   @n CGEM_L1DWWC_WC=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_wbL1d((void *)ptr_buffer, 128, CACHE_NOWAIT);
        ...        
        CACHE_wbL1dWait();        // Wait for the writeback operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbL1dWait (void)
{
    /* Wait for the Writeback operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L1DWWC) & (0x0000FFFFu)) >> (0x00000000u)) != 0);    
}

/** ============================================================================
 *   @n@b CACHE_wbL1d
 *
 *   @b Description
 *   @n This function is used to writeback the dirty lines of the block address.
 *      Although the block size can be specified in the number of bytes, the cache
 *      controller operates on whole cache lines. To prevent unintended behavior
 *      "blockPtr" should be aligned on the cache line size and "byteCnt" should
 *      be a multiple of the cache line size.
 *
 *   @b Arguments
      @verbatim
          blockPtr      Address of the block which is to be written back
          byteCnt       Size of the block to be written back.
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the blockPtr are being written back  
 *
 *   @b Writes
 *   @n CGEM_L1DWBAR_ADDR,CGEM_L1DWWC_WC
 *
 *   @b Example
 *   @verbatim
        
        Uint8* ptr_buffer;
                
        // Writeback 128 bytes of the buffer.
        CACHE_wbL1d((void *)ptr_buffer, 128, CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbL1d 
(
    void*       blockPtr,
    Uint32      byteCnt,
    CACHE_Wait  wait
)
{
    /* Setup the block address and length */
    ((CSL_CgemRegs *)(0x01800000))->L1DWBAR = ((((Uint32)blockPtr) << (0x00000000u)) & (0xFFFFFFFFu));
    ((CSL_CgemRegs *)(0x01800000))->L1DWWC  = ((((Uint32)((byteCnt+3)>>2)) << (0x00000000u)) & (0x0000FFFFu));

    /* Determine if we need to wait for the operation to complete. */
    if (wait == CACHE_WAIT)
        CACHE_wbL1dWait();
    else if (wait == CACHE_FENCE_WAIT)
        _mfence();
}

/** ============================================================================
 *   @n@b CACHE_wbInvL1dWait
 *
 *   @b Description
 *   @n This function is used to wait for the L1D invalidate/writeback block 
 *      operation to complete. This API should be used only if the CACHE_wbInvL1d 
 *      was called with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_wbInvL1d(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The dirty lines of the L1D Block Cache have been written back and the cache
 *       contents pointed to by the block address are also invalidated.
 *
 *   @b Reads
 *   @n CGEM_L1DWIWC_WC=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_wbInvL1d((void *)ptr_buffer, 128, CACHE_NOWAIT);
        ...        
        CACHE_wbInvL1dWait();        // Wait for the operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbInvL1dWait (void)
{
    /* Wait for the Block Writeback/Invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L1DWIWC) & (0x0000FFFFu)) >> (0x00000000u)) != 0);
}

/** ============================================================================
 *   @n@b CACHE_wbInvL1d
 *
 *   @b Description
 *   @n This function is used to invalidate and writeback the dirty lines 
 *      of the block address.  Although the block size can be specified in 
 *      the number of bytes, the cache controller operates on whole cache lines. 
 *      To prevent unintended behavior "blockPtr" should be aligned on the 
 *      cache line size and "byteCnt" should be a multiple of the cache line size.
 *
 *   @b Arguments
      @verbatim
          blockPtr      Address of the block which is to be invalidated/written back
          byteCnt       Size of the block to be invalidated/written back.
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the blockPtr are being invalidated and the dirty lines are
 *       written back  
 *
 *   @b Writes
 *   @n CGEM_L1DWIBAR_ADDR,CGEM_L1DWIWC_WC
 *
 *   @b Example
 *   @verbatim
        
        Uint8* ptr_buffer;
                
        // Writeback/Invalidate 128 bytes of the buffer.
        CACHE_wbInvL1d((void *)ptr_buffer, 128, CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbInvL1d 
(
    void*       blockPtr,
    Uint32      byteCnt,
    CACHE_Wait  wait
)
{
    /* Setup the block address and length */
    ((CSL_CgemRegs *)(0x01800000))->L1DWIBAR = ((((Uint32)blockPtr) << (0x00000000u)) & (0xFFFFFFFFu));
    ((CSL_CgemRegs *)(0x01800000))->L1DWIWC  = ((((Uint32)((byteCnt+3)>>2)) << (0x00000000u)) & (0x0000FFFFu));
 
    /* Determine if we need to wait for the operation to complete. */
    if (wait == CACHE_WAIT)
        CACHE_wbInvL1dWait();
    else if (wait == CACHE_FENCE_WAIT)
        _mfence();
}

/** ============================================================================
 *   @n@b CACHE_setL1PSize
 *
 *   @b Description
 *   @n This function is used to set the L1P Cache Size.  
 *
 *   @b Arguments
      @verbatim
          newSize      Cache Size to be configured.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CGEM_L1PCFG_L1PMODE
 *
 *   @b Example
 *   @verbatim
        
        CACHE_setL1PSize(1); // Configure 4K Cache Size

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_setL1PSize (CACHE_L1Size newSize)
{
    ((((CSL_CgemRegs *)(0x01800000))->L1PCFG) = ((((CSL_CgemRegs *)(0x01800000))->L1PCFG) & ~(0x00000007u)) | (((newSize) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CACHE_getL1PSize
 *
 *   @b Description
 *   @n This function is used to get the L1P Cache Size.  
 *
 *   @b Arguments
 *   @n None
 * 
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CGEM_L1PCFG_L1PMODE
 *
 *   @b Example
 *   @verbatim
        CACHE_L1Size cacheSize;
        
        cacheSize = CACHE_getL1PSize();

     @endverbatim
 * =============================================================================
 */
static inline CACHE_L1Size CACHE_getL1PSize (void)
{
    return (CACHE_L1Size)(((((CSL_CgemRegs *)(0x01800000))->L1PCFG) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CACHE_freezeL1P
 *
 *   @b Description
 *   @n This function is used to freeze the L1P cache.  
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CGEM_L1PCC_OPER=1
 *
 *   @b Example
 *   @verbatim
        
        CACHE_freezeL1P();

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_freezeL1P(void)
{
    /* Set the Freeze Mode Enabled bit. */
    ((((CSL_CgemRegs *)(0x01800000))->L1PCC) = ((((CSL_CgemRegs *)(0x01800000))->L1PCC) & ~(0x00000007u)) | (((1) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CACHE_unfreezeL1P
 *
 *   @b Description
 *   @n This function is used to unfreeze the L1D cache.  
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CGEM_L1PCC_OPER=0
 *
 *   @b Example
 *   @verbatim
        
        CACHE_unfreezeL1D();

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_unfreezeL1P(void)
{
    /* Reset the Freeze Mode Enabled bit. */
    ((((CSL_CgemRegs *)(0x01800000))->L1PCC) = ((((CSL_CgemRegs *)(0x01800000))->L1PCC) & ~(0x00000007u)) | (((0) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CACHE_getPrevL1PMode
 *
 *   @b Description
 *   @n This function is used get the previous operating state of the L1P cache 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CGEM_L1PCC_POPER
 *
 *   @b Example
 *   @verbatim
        Uint32  prev;
        
        prev = CACHE_getPrevL1PMode();

     @endverbatim
 * =============================================================================
 */
static inline Uint32 CACHE_getPrevL1PMode(void)
{
    return (((((CSL_CgemRegs *)(0x01800000))->L1PCC) & (0x00070000u)) >> (0x00000010u));    
}

/** ============================================================================
 *   @n@b CACHE_invL1pWait
 *
 *   @b Description
 *   @n This function is used to wait for the L1D invalidate block operation to 
 *      complete. This API should be used only if the CACHE_invL1p was called 
 *      with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_invL1p(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The L1D Block Cache is invalidated. 
 *
 *   @b Reads
 *   @n CGEM_L1PIWC_WC=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_invL1p((void *)&foo, 128, CACHE_NOWAIT);
        ...        
        CACHE_invL1pWait();        // Wait for the Invalidate operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invL1pWait (void)
{
    /* Wait for the Invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L1PIWC) & (0x0000FFFFu)) >> (0x00000000u)) != 0);    
}

/** ============================================================================
 *   @n@b CACHE_invL1p
 *
 *   @b Description
 *   @n This function is used to invalidate the L1P Cache pointed by the block 
 *      address. Although the block size can be specified in the number of bytes, 
 *      the cache controller operates on whole cache lines. To prevent unintended 
 *      behavior "blockPtr" should be aligned on the cache line size and "byteCnt" 
 *      should be a multiple of the cache line size.
 *
 *   @b Arguments
      @verbatim
          blockPtr      Address of the block which is to be invalidated
          byteCnt       Size of the block to be invalidated.
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the blockPtr are being invalidated
 *
 *   @b Writes
 *   @n CGEM_L1PIBAR_ADDR,CGEM_L1PIWC_WC
 *
 *   @b Example
 *   @verbatim
 
        // Invalidate the 128 bytes of the function 'foo'
        CACHE_invL1p((void *)&foo, 128, CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invL1p 
(
    void*       blockPtr,
    Uint32      byteCnt,
    CACHE_Wait  wait
)
{
    /* Setup the block address and length which is to be invalidated */
    ((CSL_CgemRegs *)(0x01800000))->L1PIBAR = ((((Uint32)blockPtr) << (0x00000000u)) & (0xFFFFFFFFu));
    ((CSL_CgemRegs *)(0x01800000))->L1PIWC  = ((((Uint32)((byteCnt+3)>>2)) << (0x00000000u)) & (0x0000FFFFu));

    /* Determine if we need to wait for the operation to complete. */
    if (wait == CACHE_WAIT)
        CACHE_invL1pWait();
    else if (wait == CACHE_FENCE_WAIT)
        _mfence();
}

/** ============================================================================
 *   @n@b CACHE_invAllL1pWait
 *
 *   @b Description
 *   @n This function is used to wait for the L1P invalidate operation to complete. 
 *      This API should be used only if the CACHE_invAllL1p was called with the 
 *      CACHE_NOWAIT argument.  
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_invAllL1p(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The L1P Cache is invalidated. 
 *
 *   @b Reads
 *   @n CGEM_L1PINV_I=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_invAllL1p(CACHE_NOWAIT);
        ...        
        CACHE_invAllL1pWait();        // Wait for the Invalidate operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invAllL1pWait (void)
{
    /* Wait for the Invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L1PINV) & (0xFFFFFFFFu)) >> (0x00000000u)) == 1);    
}

/** ============================================================================
 *   @n@b CACHE_invAllL1p
 *
 *   @b Description
 *   @n This function is used to invalidate the entire L1P Cache 
 *
 *   @b Arguments
      @verbatim
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The entire L1P cache is being invalidated.  
 *
 *   @b Writes
 *   @n CGEM_L1PINV_I=1
 *
 *   @b Example
 *   @verbatim
         
        CACHE_invAllL1p(CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invAllL1p (CACHE_Wait wait)
{
    /* Invalidate the L1P Cache. */
    ((((CSL_CgemRegs *)(0x01800000))->L1PINV) = ((((CSL_CgemRegs *)(0x01800000))->L1PINV) & ~(0xFFFFFFFFu)) | (((1) << (0x00000000u)) & (0xFFFFFFFFu)));    

    /* Determine if we need to wait for the operation to complete. */
    if (wait)
        CACHE_invAllL1pWait();
}

/** ============================================================================
 *   @n@b CACHE_setL2Size
 *
 *   @b Description
 *   @n This function is used to set the new size of the L2 Cache.  
 *
 *   @b Arguments
      @verbatim
          newSize   New Size of the L2 Cache to be set.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The L2 Cache is configured to use the new size.  
 *
 *   @b Writes
 *   @n CGEM_L2CFG_L2MODE
 *
 *   @b Example
 *   @verbatim
         
        CACHE_setL2Size(CACHE_32KCACHE); // Use 32K L2 Cache. 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_setL2Size (CACHE_L2Size newSize)
{
    /* Set the new L2 cache size. */
    ((((CSL_CgemRegs *)(0x01800000))->L2CFG) = ((((CSL_CgemRegs *)(0x01800000))->L2CFG) & ~(0x00000007u)) | (((newSize) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CACHE_getL2Size
 *
 *   @b Description
 *   @n This function is used to get the L2 cache size.  
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  CACHE_L2Size
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None  
 *
 *   @b Reads
 *   @n CGEM_L2CFG_L2MODE
 *
 *   @b Example
 *   @verbatim
        CACHE_L2Size size;
        
        size = CACHE_getL2Size(); 

     @endverbatim
 * =============================================================================
 */
static inline CACHE_L2Size CACHE_getL2Size (void)
{    
    return (CACHE_L2Size) (((((CSL_CgemRegs *)(0x01800000))->L2CFG) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CACHE_freezeL2
 *
 *   @b Description
 *   @n This function is used to freeze the L2 Cache  
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The L2 Cache is frozen.  
 *
 *   @b Example
 *   @verbatim
         
        CACHE_freezeL2(); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_freezeL2 (void)
{
    /* The RL File does not define the L2CC bit so we used the RAW macro to 
     * configure the corresponding bit. */
    ((((CSL_CgemRegs *)(0x01800000))->L2CFG) = ((((CSL_CgemRegs *)(0x01800000))->L2CFG) &~ (((1 << ((3) - (3) + 1)) - 1) << (3))) | (((1) & ((1 << ((3) - (3) + 1)) - 1)) << (3)));
}

/** ============================================================================
 *   @n@b CACHE_unfreezeL2
 *
 *   @b Description
 *   @n This function is used to unfreeze the L2 Cache  
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The L2 Cache is unfrozen  
 *
 *   @b Example
 *   @verbatim
         
        CACHE_unfreezeL2(); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_unfreezeL2 (void)
{
    /* The RL File does not define the L2CC bit so we used the RAW macro to 
     * configure the corresponding bit. */
    ((((CSL_CgemRegs *)(0x01800000))->L2CFG) = ((((CSL_CgemRegs *)(0x01800000))->L2CFG) &~ (((1 << ((3) - (3) + 1)) - 1) << (3))) | (((0) & ((1 << ((3) - (3) + 1)) - 1)) << (3)));
}

/** ============================================================================
 *   @n@b CACHE_wbL2Wait
 *
 *   @b Description
 *   @n This function is used to wait for the L2 writeback block operation to 
 *      complete. This API should be used only if the CACHE_wbL2 was called 
 *      with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_wbL2(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The dirty lines of the L1D Block Cache have been written back. 
 *
 *   @b Reads
 *   @n CGEM_L2WWC_WC=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_wbL2((void *)ptr_buffer, 128, CACHE_NOWAIT);
        ...        
        CACHE_wbL2Wait();        // Wait for the writeback operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbL2Wait (void)
{
    /* Wait for the Writeback operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L2WWC) & (0x0000FFFFu)) >> (0x00000000u)) != 0);        
}

/** ============================================================================
 *   @n@b CACHE_wbL2
 *
 *   @b Description
 *   @n This function is used to writeback the contents of the L2 Cache. Although 
 *      the block size can be specified in the number of bytes, the cache 
 *      controller operates on whole cache lines. To prevent unintended behavior 
 *      "blockPtr" should be aligned on the  cache line size and "byteCnt" 
 *      should be a multiple of the cache line size.
 *
 *   @b Arguments
      @verbatim
          blockPtr      Address of the block which is to be written back
          byteCnt       Size of the block to be written block.
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The dirty lines of the L2 Cache are being written back.   
 *
 *   @b Writes
 *   @n CGEM_L2WBAR_ADDR,CGEM_L2WWC_WC
 *
 *   @b Example
 *   @verbatim
        Uint8* ptr_buffer;
        
        // Writeback the contents of the buffer. 
        CACHE_wbL2(ptr_buffer, 100, CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbL2 
(
    void*       blockPtr,
    Uint32      byteCnt,
    CACHE_Wait  wait
)
{
    /* Setup the block address and length */
    ((CSL_CgemRegs *)(0x01800000))->L2WBAR = ((((Uint32)blockPtr) << (0x00000000u)) & (0xFFFFFFFFu));    
    ((CSL_CgemRegs *)(0x01800000))->L2WWC  = ((((Uint32)((byteCnt+3)>>2)) << (0x00000000u)) & (0x0000FFFFu));

    /* Determine if we need to wait for the operation to complete. */
    if (wait == CACHE_WAIT)
        CACHE_wbL2Wait();
    else if (wait == CACHE_FENCE_WAIT)
        _mfence();
}

/** ============================================================================
 *   @n@b CACHE_invL2Wait
 *
 *   @b Description
 *   @n This function is used to wait for the L2 invalidate block operation to 
 *      complete. This API should be used only if the CACHE_invL2 was called 
 *      with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_invL2(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  Invalidate the contents of the L2 Cache. 
 *
 *   @b Reads
 *   @n CGEM_L2IWC_WC=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_invL2((void *)ptr_buffer, 128, CACHE_NOWAIT);
        ...        
        CACHE_invL2Wait();        // Wait for the Invalidate operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invL2Wait (void)
{
    /* Wait for the Invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L2IWC) & (0x0000FFFFu)) >> (0x00000000u)) != 0);        
}

/** ============================================================================
 *   @n@b CACHE_invL2
 *
 *   @b Description
 *   @n This function is used to invalidate the contents of the L2 Cache. 
 *      Although the block size can be specified in  the number of bytes, 
 *      the cache controller operates on whole cache lines. To prevent unintended 
 *      behavior "blockPtr" should be aligned on the cache line size and "byteCnt" 
 *      should be a multiple of the cache line size.
 *
 *   @b Arguments
      @verbatim
          blockPtr      Address of the block which is to be invalidated
          byteCnt       Size of the block to be invalidated.
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the L2 Cache are being invalidated.   
 *
 *   @b Writes
 *   @n CGEM_L2IBAR_ADDR,CGEM_L2IWC_WC
 *
 *   @b Example
 *   @verbatim
        Uint8* ptr_buffer;
        
        // Invalidate the contents of the buffer. 
        CACHE_invL2(ptr_buffer, 100, CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invL2 
(
    void*       blockPtr,
    Uint32      byteCnt,
    CACHE_Wait  wait
)
{
    /* Setup the block address and length */
    ((CSL_CgemRegs *)(0x01800000))->L2IBAR = ((((Uint32)blockPtr) << (0x00000000u)) & (0xFFFFFFFFu));    
    ((CSL_CgemRegs *)(0x01800000))->L2IWC  = ((((Uint32)((byteCnt+3)>>2)) << (0x00000000u)) & (0x0000FFFFu));

    /* Determine if we need to wait for the operation to complete. */
    if (wait == CACHE_WAIT)
        CACHE_invL2Wait();
    else if (wait == CACHE_FENCE_WAIT)
        _mfence();
}

/** ============================================================================
 *   @n@b CACHE_wbInvL2Wait
 *
 *   @b Description
 *   @n This function is used to wait for the L2 Writeback & invalidate block 
 *      operation to complete. This API should be used only if the CACHE_wbInvL2 
 *      was called with the CACHE_NOWAIT argument. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_wbInvL2(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  Invalidate the contents of the L2 Cache. 
 *
 *   @b Reads
 *   @n CGEM_L2WIWC_WC=0
 *
 *   @b Example
 *   @verbatim
                
        CACHE_wbInvL2((void *)ptr_buffer, 128, CACHE_NOWAIT);
        ...        
        CACHE_wbInvL2Wait();  // Wait for the Writeback-Invalidate operation to complete.

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbInvL2Wait (void)
{
    /* Wait for the Writeback & Invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L2WIWC) & (0x0000FFFFu)) >> (0x00000000u)) != 0);        
}

/** ============================================================================
 *   @n@b CACHE_wbInvL2
 *
 *   @b Description
 *   @n This function is used to write back and invalidate the contents of the L2 Cache.
 *      Although the block size can be specified in the number of bytes, 
 *      the cache controller operates on whole cache lines. To prevent unintended 
 *      behavior "blockPtr" should be aligned on the cache line size and "byteCnt" 
 *      should be a multiple of the cache line size.
 *
 *   @b Arguments
      @verbatim
          blockPtr      Address of the block which is to be written back & invalidated
          byteCnt       Size of the block to be written back & invalidated.
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the L2 Cache are being written back & invalidated.   
 *
 *   @b Writes
 *   @n CGEM_L2WIBAR_ADDR,CGEM_L2WIWC_WC
 *
 *   @b Example
 *   @verbatim
        Uint8* ptr_buffer;
        
        // Invalidate the contents of the buffer. 
        CACHE_wbInvL2(ptr_buffer, 100, CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbInvL2 (
    void*       blockPtr,
    Uint32      byteCnt,
    CACHE_Wait  wait
)
{
    /* Setup the block address and length */
    ((CSL_CgemRegs *)(0x01800000))->L2WIBAR = ((((Uint32)blockPtr) << (0x00000000u)) & (0xFFFFFFFFu));
    ((CSL_CgemRegs *)(0x01800000))->L2WIWC  = ((((Uint32)((byteCnt+3)>>2)) << (0x00000000u)) & (0x0000FFFFu));
 
    /* Determine if we need to wait for the operation to complete. */
    if (wait == CACHE_WAIT)
        CACHE_wbInvL2Wait();
    else if (wait == CACHE_FENCE_WAIT)
        _mfence();
}

/** ============================================================================
 *   @n@b CACHE_wbAllL2Wait
 *
 *   @b Description
 *   @n This function is used to wait for the L2 Writeback & invalidate operation 
 *      to complete. This API should be used only if the CACHE_wbAllL2 was called 
 *      with the CACHE_NOWAIT argument.   
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_wbAllL2(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the L2 Cache have been written back
 *
 *   @b Reads
 *   @n CGEM_L2WB_C=0
 *
 *   @b Example
 *   @verbatim
        
        // Writeback the contents of the L2 Cache.
        CACHE_wbAllL2(CACHE_NOWAIT);
        
        // Wait for the operation to complete. 
        CACHE_wbAllL2Wait(); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbAllL2Wait (void)
{
    /* Wait for the writeback operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L2WB) & (0xFFFFFFFFu)) >> (0x00000000u)) == 1);    
}

/** ============================================================================
 *   @n@b CACHE_wbAllL2
 *
 *   @b Description
 *   @n This function is used to write back all the contents of the L2 Cache.  
 *
 *   @b Arguments
      @verbatim
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the L2 Cache are being written back.   
 *
 *   @b Writes
 *   @n CGEM_L2WB_C=1
 *
 *   @b Example
 *   @verbatim
        
        // Writeback the contents of the L2 Cache. 
        CACHE_wbAllL2(CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbAllL2 (CACHE_Wait wait)
{
    ((((CSL_CgemRegs *)(0x01800000))->L2WB) = ((((CSL_CgemRegs *)(0x01800000))->L2WB) & ~(0xFFFFFFFFu)) | (((1) << (0x00000000u)) & (0xFFFFFFFFu)));
    
    /* Determine if we need to wait for the operation to complete. */
    if (wait)
        CACHE_wbAllL2Wait();
}

/** ============================================================================
 *   @n@b CACHE_invAllL2Wait
 *
 *   @b Description
 *   @n This function is used to wait for the L2 Invalidate operation to complete. 
 *      This API should be used only if the CACHE_invAllL2 was called with the 
 *      CACHE_NOWAIT argument.   
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_invAllL2(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the L2 Cache have been invalidated   
 *
 *   @b Reads
 *   @n CGEM_L2INV_I=0
 *
 *   @b Example
 *   @verbatim
        
        // Invalidate the contents of the L2 Cache.
        CACHE_invAllL2(CACHE_NOWAIT);
        
        // Wait for the operation to complete. 
        CACHE_invAllL2Wait(); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invAllL2Wait (void)
{
    /* Wait for the invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L2INV) & (0xFFFFFFFFu)) >> (0x00000000u)) == 1);    
}

/** ============================================================================
 *   @n@b CACHE_invAllL2
 *
 *   @b Description
 *   @n This function is used to invalidate all the contents of the L2 Cache.  
 *
 *   @b Arguments
      @verbatim
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the L2 Cache are being invalidated.   
 *
 *   @b Writes
 *   @n CGEM_L2INV_I=1 
 *
 *   @b Example
 *   @verbatim
        
        // Invalidate the contents of the L2 Cache. 
        CACHE_invAllL2(CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_invAllL2 (CACHE_Wait wait)
{
    ((((CSL_CgemRegs *)(0x01800000))->L2INV) = ((((CSL_CgemRegs *)(0x01800000))->L2INV) & ~(0xFFFFFFFFu)) | (((1) << (0x00000000u)) & (0xFFFFFFFFu)));
    
    /* Determine if we need to wait for the operation to complete. */
    if (wait)
        CACHE_invAllL2Wait();    
}

/** ============================================================================
 *   @n@b CACHE_wbInvAllL2Wait
 *
 *   @b Description
 *   @n This function is used to wait for the L2 Writeback and Invalidate 
 *      operation to complete. This API should be used only if the CACHE_wbInvAllL2 was 
 *      called with the CACHE_NOWAIT argument.   
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CACHE_wbInvAllL2(wait=CACHE_NOWAIT) must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the L2 Cache have been invalidated and written back
 *
 *   @b Reads
 *   @n CGEM_L2WBINV_C=0
 *
 *   @b Example
 *   @verbatim
        
        // Writeback & Invalidate the contents of the L2 Cache.
        CACHE_wbInvAllL2(CACHE_NOWAIT);
        
        // Wait for the operation to complete. 
        CACHE_wbInvAllL2Wait(); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbInvAllL2Wait (void)
{
    /* Wait for the writeback-invalidate operation to complete. */
    while ((((((CSL_CgemRegs *)(0x01800000))->L2WBINV) & (0xFFFFFFFFu)) >> (0x00000000u)) == 1);    
}

/** ============================================================================
 *   @n@b CACHE_wbInvAllL2
 *
 *   @b Description
 *   @n This function is used to writeback and invalidate all the contents of the L2 Cache.  
 *
 *   @b Arguments
      @verbatim
          wait          Indicates if the call should block or not.
     @endverbatim 
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The contents of the L2 Cache are being written back & invalidated.   
 *
 *   @b Writes
 *   @n CGEM_L2WBINV_C=1
 *
 *   @b Example
 *   @verbatim
        
        // Invalidate the contents of the L2 Cache. 
        CACHE_wbInvAllL2(CACHE_WAIT); 

     @endverbatim
 * =============================================================================
 */
static inline void CACHE_wbInvAllL2 (CACHE_Wait wait)
{
    ((((CSL_CgemRegs *)(0x01800000))->L2WBINV) = ((((CSL_CgemRegs *)(0x01800000))->L2WBINV) & ~(0xFFFFFFFFu)) | (((1) << (0x00000000u)) & (0xFFFFFFFFu)));
    
    /* Determine if we need to wait for the operation to complete. */
    if (wait)
        CACHE_wbInvAllL2Wait();    
}

/**
@}
*/




extern void CACHE_wbAllL1dWait(void);
extern void CACHE_wbL2Wait(void);

extern void CACHE_invAllL1dWait(void);
extern void CACHE_invL2Wait(void);








//#define OLD_IIPC
//#define USE_MESSAGEQ
/////////////////////////////////////////////////////////////////////////////////////////////
			/////////////////// final configuration //////////////////////////////

//#define _CONFIG_TARGET_WITH_RELEASE_

//#define _CONFIG_POC_WITH_RELEASE_


////////////////////////////////////////////////////////////////////////////////////////////



// to put logs in all functions to find the exception error
//#define ToFindExcpError

extern void Eth_Debug2(const char *msg,CHAR *format, ...);
extern void uart_write(const char *fmt, ... );

//@@@@@@@@@@@@@@@@@@@@@@ Build Related definitions @@@@@@@@@@@@@@@@@@@@@@
//#define _STE_BOOT		//Build for Bootloader


extern volatile void *pEthObj;

//@@@@@@@@@@@@@@@@@@@@@@ Log related definitions @@@@@@@@@@@@@@@@@@@@@@
// #define LOG_MSG_BOX
//#define LOG_MSG_DEBUG
//#define LOG_MSG_DUMP
//#define LOG_MSG_EVENT
//#define LOG_MSG_FATAL
//#define LOG_MSG_TRACE
//#define LOG_MSG_WARN
//#define JTAG_TRACE
//#define JTAG_DUMP
//#define JTAG_EVENT
//#define	LOG_EVENT_CB(format,...) LOG_printf(&event, format, ##__VA_ARGS__)
//#define	LOG_TRACE_CB(format,...) LOG_printf(&trace, format, ##__VA_ARGS__)
//#define	LOG_FATAL_CB(format,...) LOG_printf(&fatal, format, ##__VA_ARGS__)
//#define LOG_EVENT_CB  





//#define	LOG_FATAL(format,...) LOG_printf(&fatal, format, ##__VA_ARGS__)





// USER CONFIGURATION FOR RX MANAGER

/* DO NOT CHANGE BELOW SETTINGS UNLESS REGRESSION TEST IS DONE */
/*******************************************************************/

/*******************************************************************/

//switch for Assembly Functions

//@@@@@@@@@@@@@@@@@@@@@@ Operation mode related definition @@@@@@@@@@@@@@@@@@@@@@
/* below two definition should be disabled for final configuration*/
//#define	SINGLE_CORE_OPERATION	//for enabling single core operation (PC simulation mode)
//#define 	SIMULATE_PAYLOAD		

//@@@@@@@@@@@@@@@@@@@@@@ Commmand related definitions @@@@@@@@@@@@@@@@@@@@@@
/* below three definition should be disabled for final configuration*/
//#define	SIMULATE_CMD_97_SUCCESS  //for generating command success for Rx tune(command 97)
//#define 	TESTING_CIPHER_WITH_IPU  //for enabling cipher when testing with IPU stub
//#define 	TESTING_HOPPING_WITH_IPU  //for enabling hopping when testing with IPU stub

//@@@@@@@@@@@@@@@@@@@@@@ SRIO related definitions @@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@ Ethernet related definitions @@@@@@@@@@@@@@@@@@@@@@
//#define	ENABLE_EMAC				//for enabling the NDK library
//#define	ETHBUFF_SIMULATE      	//for testing the ethernet dump
//#define     _USE_ETHERNET_INTERFACE  // to spawan ethernet related tasks/module




//@@@@@@@@@@@@@@@@@@@@@@ TX Manager related definitions @@@@@@@@@@@@@@@@@@@

//#define VBTS_SEND_ONLY_FCCH_ALL_FN	//for sending FCCH only
//#define VBTS_SEND_ONLY_SCH_WITH_FIXED_FN_ALL_FN	//for sending SCH only
//#define VBTS_SEND_ONLY_C0TO			//for sending on Timeslot 0 only
//#define VBTS_SEND_ONLY_DUMMY_C0TX  	//for sending Dummy burst on all Timeslot
//#define VBTS_SEND_ONLY_SCH_C0TX		//for sending SCH in all Timeslot
//#define VBTS_SEND_ONLY_FCCH_C0TX		//for sending FCCH in all Timeslot
//#define VBTS_FPGA_BYTE_SWAP			//Workaround for FPGA Byte swap
//#define VBTS_FPGA_NIBBLE_SWAP			//Workaround for FPGA Nibble swap
//#define AREA_JAMMING_TESTING

//@@@@@@@@@@@@@@@@@@@@@@ Rx Manager related definitions @@@@@@@@@@@@@@@@@@@@@@
//#define FIXED_BAND  			//for enabling PGSM band only
//#define FIXED_ARFCN   		//for testing in Simulate mode
//#define _FEED_TEST_VECTOR_    // feeding test vector in SCH burst against real
//#define SEARCH_ONLY_40			// search only arfcn 40

//#define ENABLE_RESET_TRX		// upon getting reset, all the associated rx and tx including beacon channels
								// gets dropped off


/////////////////////////////////////////////////////////////////////////////////////////////
			/////////////////// final configuration //////////////////////////////


//#define _CONFIG_POC_WITH_RELEASE_


////////////////////////////////////////////////////////////////////////////////////////////

extern void StatMgr_Fatal(void);





/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

//####below #define is the orginal for testing purpose its commenting : remesh
//#define MAX_QUEUE_NODES 131072 // num = 128 K total size = 8bytes*128 KB = 1MB // orginal
// #define MAX_QUEUE_NODES 134144  // increased to 131 K for testing : remesh
//#define MAX_QUEUE_NODES 343040 //increased to 335 K for testing : remesh // for 50
//#define MAX_QUEUE_NODES 633087 //increased to 619 K for testing : remesh //

//#define MAX_QUEUE_NODES 131072 + 50000 // num = 128 K total size = 8bytes*128 KB = 1MB


typedef struct Node
{
	struct Node	*pNext;
	void	*pData;
}Node;

typedef struct FIFO
{
	Node	*pHead;
	Node	*pTail;
	Node	*pFree;
	UINT16	nSize;
	UINT16  nMaxSize;  //Maximum size

}FIFO;

/* Version 2 APIs */
void FIFO_Init_v2( FIFO *pThis, UINT16  nMaxSize );
void FIFO_Put_v2( FIFO *pThis, void *pVal);
/* End of Version 2 APIs */


void FIFO_Init( FIFO *pThis, UINT16  nMaxSize );

UINT16 FIFO_GetSize( FIFO *pThis );

void	FIFO_Put( FIFO *pThis, void *pVal);

void	*FIFO_Get( FIFO *pThis );

void	FIFO_Print( FIFO *pThis);



/*
===============================================================================
//  Copyright(C):
//
//  FILENAME: <Task.h> (Utilities.pjt)
//
//  Subsystem: 
//
//  Purpose of file:
//  
//      To enable the user to have a well defined interface for creating 
//  tasks, Signals, Binary Sem Locks. This module shall be considered
//  as OS absraction.
//
//  Dependencies, Limitations, and Design Notes:
//  	
//
//=============================================================================
// Version   Date     Modification_History                               Author
//=============================================================================
//  
// 								   	
//
===============================================================================
*/


// #include <xdc\std.h> // its included in DataType.h
//#include <tsk.h>
/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:35; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== module ti.sysbios.knl.Clock ========
 */

typedef struct ti_sysbios_knl_Clock_Module_State ti_sysbios_knl_Clock_Module_State;
typedef struct ti_sysbios_knl_Clock_Params ti_sysbios_knl_Clock_Params;
typedef struct ti_sysbios_knl_Clock_Object ti_sysbios_knl_Clock_Object;
typedef struct ti_sysbios_knl_Clock_Struct ti_sysbios_knl_Clock_Struct;
typedef ti_sysbios_knl_Clock_Object* ti_sysbios_knl_Clock_Handle;
typedef struct ti_sysbios_knl_Clock_Object__ ti_sysbios_knl_Clock_Instance_State;
typedef ti_sysbios_knl_Clock_Object* ti_sysbios_knl_Clock_Instance;

/*
 * ======== module ti.sysbios.knl.Idle ========
 */


/*
 * ======== module ti.sysbios.knl.Intrinsics ========
 */

typedef struct ti_sysbios_knl_Intrinsics_Fxns__ ti_sysbios_knl_Intrinsics_Fxns__;
typedef const ti_sysbios_knl_Intrinsics_Fxns__* ti_sysbios_knl_Intrinsics_Module;

/*
 * ======== module ti.sysbios.knl.Event ========
 */

typedef struct ti_sysbios_knl_Event_PendElem ti_sysbios_knl_Event_PendElem;
typedef struct ti_sysbios_knl_Event_Params ti_sysbios_knl_Event_Params;
typedef struct ti_sysbios_knl_Event_Object ti_sysbios_knl_Event_Object;
typedef struct ti_sysbios_knl_Event_Struct ti_sysbios_knl_Event_Struct;
typedef ti_sysbios_knl_Event_Object* ti_sysbios_knl_Event_Handle;
typedef struct ti_sysbios_knl_Event_Object__ ti_sysbios_knl_Event_Instance_State;
typedef ti_sysbios_knl_Event_Object* ti_sysbios_knl_Event_Instance;

/*
 * ======== module ti.sysbios.knl.Mailbox ========
 */

typedef struct ti_sysbios_knl_Mailbox_MbxElem ti_sysbios_knl_Mailbox_MbxElem;
typedef struct ti_sysbios_knl_Mailbox_Params ti_sysbios_knl_Mailbox_Params;
typedef struct ti_sysbios_knl_Mailbox_Object ti_sysbios_knl_Mailbox_Object;
typedef struct ti_sysbios_knl_Mailbox_Struct ti_sysbios_knl_Mailbox_Struct;
typedef ti_sysbios_knl_Mailbox_Object* ti_sysbios_knl_Mailbox_Handle;
typedef struct ti_sysbios_knl_Mailbox_Object__ ti_sysbios_knl_Mailbox_Instance_State;
typedef ti_sysbios_knl_Mailbox_Object* ti_sysbios_knl_Mailbox_Instance;

/*
 * ======== module ti.sysbios.knl.Queue ========
 */

typedef struct ti_sysbios_knl_Queue_Elem ti_sysbios_knl_Queue_Elem;
typedef struct ti_sysbios_knl_Queue_Params ti_sysbios_knl_Queue_Params;
typedef struct ti_sysbios_knl_Queue_Object ti_sysbios_knl_Queue_Object;
typedef struct ti_sysbios_knl_Queue_Struct ti_sysbios_knl_Queue_Struct;
typedef ti_sysbios_knl_Queue_Object* ti_sysbios_knl_Queue_Handle;
typedef struct ti_sysbios_knl_Queue_Object__ ti_sysbios_knl_Queue_Instance_State;
typedef ti_sysbios_knl_Queue_Object* ti_sysbios_knl_Queue_Instance;

/*
 * ======== module ti.sysbios.knl.Semaphore ========
 */

typedef struct ti_sysbios_knl_Semaphore_PendElem ti_sysbios_knl_Semaphore_PendElem;
typedef struct ti_sysbios_knl_Semaphore_Params ti_sysbios_knl_Semaphore_Params;
typedef struct ti_sysbios_knl_Semaphore_Object ti_sysbios_knl_Semaphore_Object;
typedef struct ti_sysbios_knl_Semaphore_Struct ti_sysbios_knl_Semaphore_Struct;
typedef ti_sysbios_knl_Semaphore_Object* ti_sysbios_knl_Semaphore_Handle;
typedef struct ti_sysbios_knl_Semaphore_Object__ ti_sysbios_knl_Semaphore_Instance_State;
typedef ti_sysbios_knl_Semaphore_Object* ti_sysbios_knl_Semaphore_Instance;

/*
 * ======== module ti.sysbios.knl.Swi ========
 */

typedef struct ti_sysbios_knl_Swi_HookSet ti_sysbios_knl_Swi_HookSet;
typedef struct ti_sysbios_knl_Swi_Module_State ti_sysbios_knl_Swi_Module_State;
typedef struct ti_sysbios_knl_Swi_Params ti_sysbios_knl_Swi_Params;
typedef struct ti_sysbios_knl_Swi_Object ti_sysbios_knl_Swi_Object;
typedef struct ti_sysbios_knl_Swi_Struct ti_sysbios_knl_Swi_Struct;
typedef ti_sysbios_knl_Swi_Object* ti_sysbios_knl_Swi_Handle;
typedef struct ti_sysbios_knl_Swi_Object__ ti_sysbios_knl_Swi_Instance_State;
typedef ti_sysbios_knl_Swi_Object* ti_sysbios_knl_Swi_Instance;

/*
 * ======== module ti.sysbios.knl.Task ========
 */

typedef struct ti_sysbios_knl_Task_Stat ti_sysbios_knl_Task_Stat;
typedef struct ti_sysbios_knl_Task_HookSet ti_sysbios_knl_Task_HookSet;
typedef struct ti_sysbios_knl_Task_PendElem ti_sysbios_knl_Task_PendElem;
typedef struct ti_sysbios_knl_Task_Module_State ti_sysbios_knl_Task_Module_State;
typedef struct ti_sysbios_knl_Task_Params ti_sysbios_knl_Task_Params;
typedef struct ti_sysbios_knl_Task_Object ti_sysbios_knl_Task_Object;
typedef struct ti_sysbios_knl_Task_Struct ti_sysbios_knl_Task_Struct;
typedef ti_sysbios_knl_Task_Object* ti_sysbios_knl_Task_Handle;
typedef struct ti_sysbios_knl_Task_Object__ ti_sysbios_knl_Task_Instance_State;
typedef ti_sysbios_knl_Task_Object* ti_sysbios_knl_Task_Instance;

/*
 * ======== module ti.sysbios.knl.Intrinsics_SupportProxy ========
 */

typedef struct ti_sysbios_knl_Intrinsics_SupportProxy_Fxns__ ti_sysbios_knl_Intrinsics_SupportProxy_Fxns__;
typedef const ti_sysbios_knl_Intrinsics_SupportProxy_Fxns__* ti_sysbios_knl_Intrinsics_SupportProxy_Module;

/*
 * ======== module ti.sysbios.knl.Task_SupportProxy ========
 */

typedef struct ti_sysbios_knl_Task_SupportProxy_Fxns__ ti_sysbios_knl_Task_SupportProxy_Fxns__;
typedef const ti_sysbios_knl_Task_SupportProxy_Fxns__* ti_sysbios_knl_Task_SupportProxy_Module;



/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== interface ti.sysbios.interfaces.IHwi ========
 */

typedef struct ti_sysbios_interfaces_IHwi_HookSet ti_sysbios_interfaces_IHwi_HookSet;
typedef struct ti_sysbios_interfaces_IHwi_StackInfo ti_sysbios_interfaces_IHwi_StackInfo;
typedef struct ti_sysbios_interfaces_IHwi_Fxns__ ti_sysbios_interfaces_IHwi_Fxns__;
typedef const ti_sysbios_interfaces_IHwi_Fxns__* ti_sysbios_interfaces_IHwi_Module;
typedef struct ti_sysbios_interfaces_IHwi_Params ti_sysbios_interfaces_IHwi_Params;
typedef struct ti_sysbios_interfaces_IHwi___Object { ti_sysbios_interfaces_IHwi_Fxns__* __fxns; xdc_Bits32 __label; } *ti_sysbios_interfaces_IHwi_Handle;

/*
 * ======== interface ti.sysbios.interfaces.ITaskSupport ========
 */

typedef struct ti_sysbios_interfaces_ITaskSupport_Fxns__ ti_sysbios_interfaces_ITaskSupport_Fxns__;
typedef const ti_sysbios_interfaces_ITaskSupport_Fxns__* ti_sysbios_interfaces_ITaskSupport_Module;

/*
 * ======== interface ti.sysbios.interfaces.ITimer ========
 */

typedef struct ti_sysbios_interfaces_ITimer_Fxns__ ti_sysbios_interfaces_ITimer_Fxns__;
typedef const ti_sysbios_interfaces_ITimer_Fxns__* ti_sysbios_interfaces_ITimer_Module;
typedef struct ti_sysbios_interfaces_ITimer_Params ti_sysbios_interfaces_ITimer_Params;
typedef struct ti_sysbios_interfaces_ITimer___Object { ti_sysbios_interfaces_ITimer_Fxns__* __fxns; xdc_Bits32 __label; } *ti_sysbios_interfaces_ITimer_Handle;

/*
 * ======== interface ti.sysbios.interfaces.ITimerSupport ========
 */

typedef struct ti_sysbios_interfaces_ITimerSupport_Fxns__ ti_sysbios_interfaces_ITimerSupport_Fxns__;
typedef const ti_sysbios_interfaces_ITimerSupport_Fxns__* ti_sysbios_interfaces_ITimerSupport_Module;

/*
 * ======== interface ti.sysbios.interfaces.ITimestamp ========
 */

typedef struct ti_sysbios_interfaces_ITimestamp_Fxns__ ti_sysbios_interfaces_ITimestamp_Fxns__;
typedef const ti_sysbios_interfaces_ITimestamp_Fxns__* ti_sysbios_interfaces_ITimestamp_Module;

/*
 * ======== interface ti.sysbios.interfaces.IIntrinsicsSupport ========
 */

typedef struct ti_sysbios_interfaces_IIntrinsicsSupport_Fxns__ ti_sysbios_interfaces_IIntrinsicsSupport_Fxns__;
typedef const ti_sysbios_interfaces_IIntrinsicsSupport_Fxns__* ti_sysbios_interfaces_IIntrinsicsSupport_Module;

/*
 * ======== interface ti.sysbios.interfaces.ICache ========
 */

typedef struct ti_sysbios_interfaces_ICache_Fxns__ ti_sysbios_interfaces_ICache_Fxns__;
typedef const ti_sysbios_interfaces_ICache_Fxns__* ti_sysbios_interfaces_ICache_Module;



/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef void (*ti_sysbios_interfaces_ITaskSupport_FuncPtr)(void);


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_interfaces_ITaskSupport_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Ptr (*start)(xdc_Ptr, ti_sysbios_interfaces_ITaskSupport_FuncPtr, ti_sysbios_interfaces_ITaskSupport_FuncPtr, xdc_runtime_Error_Block*);
    void (*swap)(xdc_Ptr*, xdc_Ptr*);
    xdc_Bool (*checkStack)(xdc_Char*, xdc_SizeT);
    xdc_SizeT (*stackUsed)(xdc_Char*, xdc_SizeT);
    xdc_UInt (*getStackAlignment)(void);
    xdc_SizeT (*getDefaultStackSize)(void);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base ti_sysbios_interfaces_ITaskSupport_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* Module_id */
static inline xdc_runtime_Types_ModuleId ti_sysbios_interfaces_ITaskSupport_Module_id( ti_sysbios_interfaces_ITaskSupport_Module mod )
{
    return mod->__sysp->__mid;
}

/* start */
static inline xdc_Ptr ti_sysbios_interfaces_ITaskSupport_start( ti_sysbios_interfaces_ITaskSupport_Module __inst, xdc_Ptr curTask, ti_sysbios_interfaces_ITaskSupport_FuncPtr enter, ti_sysbios_interfaces_ITaskSupport_FuncPtr exit, xdc_runtime_Error_Block* eb )
{
    return __inst->start(curTask, enter, exit, eb);
}

/* swap */
static inline void ti_sysbios_interfaces_ITaskSupport_swap( ti_sysbios_interfaces_ITaskSupport_Module __inst, xdc_Ptr* oldtskContext, xdc_Ptr* newtskContext )
{
    __inst->swap(oldtskContext, newtskContext);
}

/* checkStack */
static inline xdc_Bool ti_sysbios_interfaces_ITaskSupport_checkStack( ti_sysbios_interfaces_ITaskSupport_Module __inst, xdc_Char* stack, xdc_SizeT size )
{
    return __inst->checkStack(stack, size);
}

/* stackUsed */
static inline xdc_SizeT ti_sysbios_interfaces_ITaskSupport_stackUsed( ti_sysbios_interfaces_ITaskSupport_Module __inst, xdc_Char* stack, xdc_SizeT size )
{
    return __inst->stackUsed(stack, size);
}

/* getStackAlignment */
static inline xdc_UInt ti_sysbios_interfaces_ITaskSupport_getStackAlignment( ti_sysbios_interfaces_ITaskSupport_Module __inst )
{
    return __inst->getStackAlignment();
}

/* getDefaultStackSize */
static inline xdc_SizeT ti_sysbios_interfaces_ITaskSupport_getDefaultStackSize( ti_sysbios_interfaces_ITaskSupport_Module __inst )
{
    return __inst->getDefaultStackSize();
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* start_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_interfaces_ITaskSupport_start_FxnT)(xdc_Ptr, ti_sysbios_interfaces_ITaskSupport_FuncPtr, ti_sysbios_interfaces_ITaskSupport_FuncPtr, xdc_runtime_Error_Block*);
static inline ti_sysbios_interfaces_ITaskSupport_start_FxnT ti_sysbios_interfaces_ITaskSupport_start_fxnP( ti_sysbios_interfaces_ITaskSupport_Module __inst )
{
    return (ti_sysbios_interfaces_ITaskSupport_start_FxnT)__inst->start;
}

/* swap_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITaskSupport_swap_FxnT)(xdc_Ptr*, xdc_Ptr*);
static inline ti_sysbios_interfaces_ITaskSupport_swap_FxnT ti_sysbios_interfaces_ITaskSupport_swap_fxnP( ti_sysbios_interfaces_ITaskSupport_Module __inst )
{
    return (ti_sysbios_interfaces_ITaskSupport_swap_FxnT)__inst->swap;
}

/* checkStack_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_interfaces_ITaskSupport_checkStack_FxnT)(xdc_Char*, xdc_SizeT);
static inline ti_sysbios_interfaces_ITaskSupport_checkStack_FxnT ti_sysbios_interfaces_ITaskSupport_checkStack_fxnP( ti_sysbios_interfaces_ITaskSupport_Module __inst )
{
    return (ti_sysbios_interfaces_ITaskSupport_checkStack_FxnT)__inst->checkStack;
}

/* stackUsed_{FxnT,fxnP} */
typedef xdc_SizeT (*ti_sysbios_interfaces_ITaskSupport_stackUsed_FxnT)(xdc_Char*, xdc_SizeT);
static inline ti_sysbios_interfaces_ITaskSupport_stackUsed_FxnT ti_sysbios_interfaces_ITaskSupport_stackUsed_fxnP( ti_sysbios_interfaces_ITaskSupport_Module __inst )
{
    return (ti_sysbios_interfaces_ITaskSupport_stackUsed_FxnT)__inst->stackUsed;
}

/* getStackAlignment_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_interfaces_ITaskSupport_getStackAlignment_FxnT)(void);
static inline ti_sysbios_interfaces_ITaskSupport_getStackAlignment_FxnT ti_sysbios_interfaces_ITaskSupport_getStackAlignment_fxnP( ti_sysbios_interfaces_ITaskSupport_Module __inst )
{
    return (ti_sysbios_interfaces_ITaskSupport_getStackAlignment_FxnT)__inst->getStackAlignment;
}

/* getDefaultStackSize_{FxnT,fxnP} */
typedef xdc_SizeT (*ti_sysbios_interfaces_ITaskSupport_getDefaultStackSize_FxnT)(void);
static inline ti_sysbios_interfaces_ITaskSupport_getDefaultStackSize_FxnT ti_sysbios_interfaces_ITaskSupport_getDefaultStackSize_fxnP( ti_sysbios_interfaces_ITaskSupport_Module __inst )
{
    return (ti_sysbios_interfaces_ITaskSupport_getDefaultStackSize_FxnT)__inst->getDefaultStackSize;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.interfaces; 2, 0, 0, 0,545; 3-20-2012 14:03:23; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */
/*
 *  ======== Assert__prologue.h ========
 */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  ======== xdc_runtime_Assert_Id ========
 */
typedef xdc_Bits32 xdc_runtime_Assert_Id;

/*
 *  ======== Module__MID ========
 *  This definition allows non-module code to
 *  use the Assert module.  This symbol is normally defined in each
 *  module internal header (i.e., package/internal/<mod>.xdc.h).
 *
 *  Only do this if this file is not one that will be included in the Registry.
 *  This check ensures that Registry.h (which similarly defines these Module__*
 *  symbols) can be included in any order relative to other xdc.runtime 
 *  headers.
 */
 

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Id */


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_Assert_Module__diagsEnabled;
extern far const CT__xdc_runtime_Assert_Module__diagsEnabled xdc_runtime_Assert_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_Assert_Module__diagsIncluded;
extern far const CT__xdc_runtime_Assert_Module__diagsIncluded xdc_runtime_Assert_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_Assert_Module__diagsMask;
extern far const CT__xdc_runtime_Assert_Module__diagsMask xdc_runtime_Assert_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_Assert_Module__gateObj;
extern far const CT__xdc_runtime_Assert_Module__gateObj xdc_runtime_Assert_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_Assert_Module__gatePrms;
extern far const CT__xdc_runtime_Assert_Module__gatePrms xdc_runtime_Assert_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_Assert_Module__id;
extern far const CT__xdc_runtime_Assert_Module__id xdc_runtime_Assert_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_Assert_Module__loggerDefined;
extern far const CT__xdc_runtime_Assert_Module__loggerDefined xdc_runtime_Assert_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_Assert_Module__loggerObj;
extern far const CT__xdc_runtime_Assert_Module__loggerObj xdc_runtime_Assert_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_Assert_Module__loggerFxn0;
extern far const CT__xdc_runtime_Assert_Module__loggerFxn0 xdc_runtime_Assert_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_Assert_Module__loggerFxn1;
extern far const CT__xdc_runtime_Assert_Module__loggerFxn1 xdc_runtime_Assert_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_Assert_Module__loggerFxn2;
extern far const CT__xdc_runtime_Assert_Module__loggerFxn2 xdc_runtime_Assert_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_Assert_Module__loggerFxn4;
extern far const CT__xdc_runtime_Assert_Module__loggerFxn4 xdc_runtime_Assert_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_Assert_Module__loggerFxn8;
extern far const CT__xdc_runtime_Assert_Module__loggerFxn8 xdc_runtime_Assert_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_Assert_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_Assert_Module__startupDoneFxn xdc_runtime_Assert_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_Assert_Object__count;
extern far const CT__xdc_runtime_Assert_Object__count xdc_runtime_Assert_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_Assert_Object__heap;
extern far const CT__xdc_runtime_Assert_Object__heap xdc_runtime_Assert_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_Assert_Object__sizeof;
extern far const CT__xdc_runtime_Assert_Object__sizeof xdc_runtime_Assert_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_Assert_Object__table;
extern far const CT__xdc_runtime_Assert_Object__table xdc_runtime_Assert_Object__table__C;

/* E_assertFailed */
typedef xdc_runtime_Error_Id CT__xdc_runtime_Assert_E_assertFailed;
extern far const CT__xdc_runtime_Assert_E_assertFailed xdc_runtime_Assert_E_assertFailed__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_Assert_Module__startupDone__S( void );

/* raise__I */

extern void xdc_runtime_Assert_raise__I( xdc_runtime_Types_ModuleId mod, xdc_String file, xdc_Int line, xdc_runtime_Assert_Id id );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_Assert_Module__id xdc_runtime_Assert_Module_id( void ) 
{
    return xdc_runtime_Assert_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_Assert_Module_hasMask( void ) 
{
    return xdc_runtime_Assert_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_Assert_Module_getMask( void ) 
{
    return xdc_runtime_Assert_Module__diagsMask__C != 0 ? *xdc_runtime_Assert_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_Assert_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_Assert_Module__diagsMask__C != 0) *xdc_runtime_Assert_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
 *  This program and the accompanying materials are made available under the 
 *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
 *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
 *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
 *  Distribution License is available at 
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 * */

/*
 *  ======== xdc_runtime_Assert_getMask ========
 *  Convert an id into a mask
 */

/*
 *  ======== xdc_runtime_Assert_isTrue ========
 */



/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */





/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== module ti.sysbios.hal.Hwi ========
 */

typedef struct ti_sysbios_hal_Hwi_Fxns__ ti_sysbios_hal_Hwi_Fxns__;
typedef const ti_sysbios_hal_Hwi_Fxns__* ti_sysbios_hal_Hwi_Module;
typedef struct ti_sysbios_hal_Hwi_Params ti_sysbios_hal_Hwi_Params;
typedef struct ti_sysbios_hal_Hwi_Object ti_sysbios_hal_Hwi_Object;
typedef struct ti_sysbios_hal_Hwi_Struct ti_sysbios_hal_Hwi_Struct;
typedef ti_sysbios_hal_Hwi_Object* ti_sysbios_hal_Hwi_Handle;
typedef struct ti_sysbios_hal_Hwi_Object__ ti_sysbios_hal_Hwi_Instance_State;
typedef ti_sysbios_hal_Hwi_Object* ti_sysbios_hal_Hwi_Instance;

/*
 * ======== module ti.sysbios.hal.Timer ========
 */

typedef struct ti_sysbios_hal_Timer_Fxns__ ti_sysbios_hal_Timer_Fxns__;
typedef const ti_sysbios_hal_Timer_Fxns__* ti_sysbios_hal_Timer_Module;
typedef struct ti_sysbios_hal_Timer_Params ti_sysbios_hal_Timer_Params;
typedef struct ti_sysbios_hal_Timer_Object ti_sysbios_hal_Timer_Object;
typedef struct ti_sysbios_hal_Timer_Struct ti_sysbios_hal_Timer_Struct;
typedef ti_sysbios_hal_Timer_Object* ti_sysbios_hal_Timer_Handle;
typedef struct ti_sysbios_hal_Timer_Object__ ti_sysbios_hal_Timer_Instance_State;
typedef ti_sysbios_hal_Timer_Object* ti_sysbios_hal_Timer_Instance;

/*
 * ======== module ti.sysbios.hal.TimerNull ========
 */

typedef struct ti_sysbios_hal_TimerNull_Fxns__ ti_sysbios_hal_TimerNull_Fxns__;
typedef const ti_sysbios_hal_TimerNull_Fxns__* ti_sysbios_hal_TimerNull_Module;
typedef struct ti_sysbios_hal_TimerNull_Params ti_sysbios_hal_TimerNull_Params;
typedef struct ti_sysbios_hal_TimerNull_Object ti_sysbios_hal_TimerNull_Object;
typedef struct ti_sysbios_hal_TimerNull_Struct ti_sysbios_hal_TimerNull_Struct;
typedef ti_sysbios_hal_TimerNull_Object* ti_sysbios_hal_TimerNull_Handle;
typedef struct ti_sysbios_hal_TimerNull_Object__ ti_sysbios_hal_TimerNull_Instance_State;
typedef ti_sysbios_hal_TimerNull_Object* ti_sysbios_hal_TimerNull_Instance;

/*
 * ======== module ti.sysbios.hal.Cache ========
 */

typedef struct ti_sysbios_hal_Cache_Fxns__ ti_sysbios_hal_Cache_Fxns__;
typedef const ti_sysbios_hal_Cache_Fxns__* ti_sysbios_hal_Cache_Module;

/*
 * ======== module ti.sysbios.hal.CacheNull ========
 */

typedef struct ti_sysbios_hal_CacheNull_Fxns__ ti_sysbios_hal_CacheNull_Fxns__;
typedef const ti_sysbios_hal_CacheNull_Fxns__* ti_sysbios_hal_CacheNull_Module;

/*
 * ======== module ti.sysbios.hal.Hwi_HwiProxy ========
 */

typedef struct ti_sysbios_hal_Hwi_HwiProxy_Fxns__ ti_sysbios_hal_Hwi_HwiProxy_Fxns__;
typedef const ti_sysbios_hal_Hwi_HwiProxy_Fxns__* ti_sysbios_hal_Hwi_HwiProxy_Module;
typedef struct ti_sysbios_hal_Hwi_HwiProxy_Params ti_sysbios_hal_Hwi_HwiProxy_Params;
typedef struct ti_sysbios_interfaces_IHwi___Object *ti_sysbios_hal_Hwi_HwiProxy_Handle;

/*
 * ======== module ti.sysbios.hal.Timer_TimerProxy ========
 */

typedef struct ti_sysbios_hal_Timer_TimerProxy_Fxns__ ti_sysbios_hal_Timer_TimerProxy_Fxns__;
typedef const ti_sysbios_hal_Timer_TimerProxy_Fxns__* ti_sysbios_hal_Timer_TimerProxy_Module;
typedef struct ti_sysbios_hal_Timer_TimerProxy_Params ti_sysbios_hal_Timer_TimerProxy_Params;
typedef struct ti_sysbios_interfaces_ITimer___Object *ti_sysbios_hal_Timer_TimerProxy_Handle;

/*
 * ======== module ti.sysbios.hal.Cache_CacheProxy ========
 */

typedef struct ti_sysbios_hal_Cache_CacheProxy_Fxns__ ti_sysbios_hal_Cache_CacheProxy_Fxns__;
typedef const ti_sysbios_hal_Cache_CacheProxy_Fxns__* ti_sysbios_hal_Cache_CacheProxy_Module;



/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef void (*ti_sysbios_interfaces_ITimer_FuncPtr)(xdc_UArg);

/* ANY */

/* StartMode */
enum ti_sysbios_interfaces_ITimer_StartMode {
    ti_sysbios_interfaces_ITimer_StartMode_AUTO,
    ti_sysbios_interfaces_ITimer_StartMode_USER
};
typedef enum ti_sysbios_interfaces_ITimer_StartMode ti_sysbios_interfaces_ITimer_StartMode;

/* RunMode */
enum ti_sysbios_interfaces_ITimer_RunMode {
    ti_sysbios_interfaces_ITimer_RunMode_CONTINUOUS,
    ti_sysbios_interfaces_ITimer_RunMode_ONESHOT,
    ti_sysbios_interfaces_ITimer_RunMode_DYNAMIC
};
typedef enum ti_sysbios_interfaces_ITimer_RunMode ti_sysbios_interfaces_ITimer_RunMode;

/* Status */
enum ti_sysbios_interfaces_ITimer_Status {
    ti_sysbios_interfaces_ITimer_Status_INUSE,
    ti_sysbios_interfaces_ITimer_Status_FREE
};
typedef enum ti_sysbios_interfaces_ITimer_Status ti_sysbios_interfaces_ITimer_Status;

/* PeriodType */
enum ti_sysbios_interfaces_ITimer_PeriodType {
    ti_sysbios_interfaces_ITimer_PeriodType_MICROSECS,
    ti_sysbios_interfaces_ITimer_PeriodType_COUNTS
};
typedef enum ti_sysbios_interfaces_ITimer_PeriodType ti_sysbios_interfaces_ITimer_PeriodType;


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_interfaces_ITimer_Args__create {
    xdc_Int id;
    ti_sysbios_interfaces_ITimer_FuncPtr tickFxn;
} ti_sysbios_interfaces_ITimer_Args__create;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_interfaces_ITimer_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    ti_sysbios_interfaces_ITimer_RunMode runMode;
    ti_sysbios_interfaces_ITimer_StartMode startMode;
    xdc_UArg arg;
    xdc_UInt32 period;
    ti_sysbios_interfaces_ITimer_PeriodType periodType;
    xdc_runtime_Types_FreqHz extFreq;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_interfaces_ITimer_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_UInt (*getNumTimers)(void);
    ti_sysbios_interfaces_ITimer_Status (*getStatus)(xdc_UInt);
    void (*startup)(void);
    xdc_UInt32 (*getMaxTicks)(void*, xdc_UInt32);
    void (*setNextTick)(void*, xdc_UInt32, xdc_UInt32);
    void (*start)(void*);
    void (*stop)(void*);
    void (*setPeriod)(void*, xdc_UInt32);
    xdc_Bool (*setPeriodMicroSecs)(void*, xdc_UInt32);
    xdc_UInt32 (*getPeriod)(void*);
    xdc_UInt32 (*getCount)(void*);
    void (*getFreq)(void*, xdc_runtime_Types_FreqHz*);
    ti_sysbios_interfaces_ITimer_FuncPtr (*getFunc)(void*, xdc_UArg*);
    void (*setFunc)(void*, ti_sysbios_interfaces_ITimer_FuncPtr, xdc_UArg);
    void (*trigger)(void*, xdc_UInt32);
    xdc_UInt32 (*getExpiredCounts)(void*);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base ti_sysbios_interfaces_ITimer_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* create */
static inline ti_sysbios_interfaces_ITimer_Handle ti_sysbios_interfaces_ITimer_create( ti_sysbios_interfaces_ITimer_Module __mod, xdc_Int id, ti_sysbios_interfaces_ITimer_FuncPtr tickFxn, const ti_sysbios_interfaces_ITimer_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_interfaces_ITimer_Args__create __args;
    __args.id = id;
    __args.tickFxn = tickFxn;
    return (ti_sysbios_interfaces_ITimer_Handle) __mod->__sysp->__create(0, 0, &__args, (const xdc_UChar*)__prms, sizeof (ti_sysbios_interfaces_ITimer_Params), __eb);
}

/* delete */
static inline void ti_sysbios_interfaces_ITimer_delete( ti_sysbios_interfaces_ITimer_Handle* instp )
{
    (*instp)->__fxns->__sysp->__delete(instp);
}

/* Handle_to_Module */
static inline ti_sysbios_interfaces_ITimer_Module ti_sysbios_interfaces_ITimer_Handle_to_Module( ti_sysbios_interfaces_ITimer_Handle inst )
{
    return inst->__fxns;
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_interfaces_ITimer_Handle_label( ti_sysbios_interfaces_ITimer_Handle inst, xdc_runtime_Types_Label* lab )
{
    return inst->__fxns->__sysp->__label(inst, lab);
}

/* Module_id */
static inline xdc_runtime_Types_ModuleId ti_sysbios_interfaces_ITimer_Module_id( ti_sysbios_interfaces_ITimer_Module mod )
{
    return mod->__sysp->__mid;
}

/* getNumTimers */
static inline xdc_UInt ti_sysbios_interfaces_ITimer_getNumTimers( ti_sysbios_interfaces_ITimer_Module __inst )
{
    return __inst->getNumTimers();
}

/* getStatus */
static inline ti_sysbios_interfaces_ITimer_Status ti_sysbios_interfaces_ITimer_getStatus( ti_sysbios_interfaces_ITimer_Module __inst, xdc_UInt id )
{
    return __inst->getStatus(id);
}

/* startup */
static inline void ti_sysbios_interfaces_ITimer_startup( ti_sysbios_interfaces_ITimer_Module __inst )
{
    __inst->startup();
}

/* getMaxTicks */
static inline xdc_UInt32 ti_sysbios_interfaces_ITimer_getMaxTicks( ti_sysbios_interfaces_ITimer_Handle __inst, xdc_UInt32 periodCounts )
{
    return __inst->__fxns->getMaxTicks((void*)__inst, periodCounts);
}

/* setNextTick */
static inline void ti_sysbios_interfaces_ITimer_setNextTick( ti_sysbios_interfaces_ITimer_Handle __inst, xdc_UInt32 newPeriod, xdc_UInt32 countsPerTick )
{
    __inst->__fxns->setNextTick((void*)__inst, newPeriod, countsPerTick);
}

/* start */
static inline void ti_sysbios_interfaces_ITimer_start( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    __inst->__fxns->start((void*)__inst);
}

/* stop */
static inline void ti_sysbios_interfaces_ITimer_stop( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    __inst->__fxns->stop((void*)__inst);
}

/* setPeriod */
static inline void ti_sysbios_interfaces_ITimer_setPeriod( ti_sysbios_interfaces_ITimer_Handle __inst, xdc_UInt32 period )
{
    __inst->__fxns->setPeriod((void*)__inst, period);
}

/* setPeriodMicroSecs */
static inline xdc_Bool ti_sysbios_interfaces_ITimer_setPeriodMicroSecs( ti_sysbios_interfaces_ITimer_Handle __inst, xdc_UInt32 microsecs )
{
    return __inst->__fxns->setPeriodMicroSecs((void*)__inst, microsecs);
}

/* getPeriod */
static inline xdc_UInt32 ti_sysbios_interfaces_ITimer_getPeriod( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return __inst->__fxns->getPeriod((void*)__inst);
}

/* getCount */
static inline xdc_UInt32 ti_sysbios_interfaces_ITimer_getCount( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return __inst->__fxns->getCount((void*)__inst);
}

/* getFreq */
static inline void ti_sysbios_interfaces_ITimer_getFreq( ti_sysbios_interfaces_ITimer_Handle __inst, xdc_runtime_Types_FreqHz* freq )
{
    __inst->__fxns->getFreq((void*)__inst, freq);
}

/* getFunc */
static inline ti_sysbios_interfaces_ITimer_FuncPtr ti_sysbios_interfaces_ITimer_getFunc( ti_sysbios_interfaces_ITimer_Handle __inst, xdc_UArg* arg )
{
    return __inst->__fxns->getFunc((void*)__inst, arg);
}

/* setFunc */
static inline void ti_sysbios_interfaces_ITimer_setFunc( ti_sysbios_interfaces_ITimer_Handle __inst, ti_sysbios_interfaces_ITimer_FuncPtr fxn, xdc_UArg arg )
{
    __inst->__fxns->setFunc((void*)__inst, fxn, arg);
}

/* trigger */
static inline void ti_sysbios_interfaces_ITimer_trigger( ti_sysbios_interfaces_ITimer_Handle __inst, xdc_UInt32 cycles )
{
    __inst->__fxns->trigger((void*)__inst, cycles);
}

/* getExpiredCounts */
static inline xdc_UInt32 ti_sysbios_interfaces_ITimer_getExpiredCounts( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return __inst->__fxns->getExpiredCounts((void*)__inst);
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getNumTimers_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_interfaces_ITimer_getNumTimers_FxnT)(void);
static inline ti_sysbios_interfaces_ITimer_getNumTimers_FxnT ti_sysbios_interfaces_ITimer_getNumTimers_fxnP( ti_sysbios_interfaces_ITimer_Module __inst )
{
    return (ti_sysbios_interfaces_ITimer_getNumTimers_FxnT)__inst->getNumTimers;
}

/* getStatus_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_ITimer_Status (*ti_sysbios_interfaces_ITimer_getStatus_FxnT)(xdc_UInt);
static inline ti_sysbios_interfaces_ITimer_getStatus_FxnT ti_sysbios_interfaces_ITimer_getStatus_fxnP( ti_sysbios_interfaces_ITimer_Module __inst )
{
    return (ti_sysbios_interfaces_ITimer_getStatus_FxnT)__inst->getStatus;
}

/* startup_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITimer_startup_FxnT)(void);
static inline ti_sysbios_interfaces_ITimer_startup_FxnT ti_sysbios_interfaces_ITimer_startup_fxnP( ti_sysbios_interfaces_ITimer_Module __inst )
{
    return (ti_sysbios_interfaces_ITimer_startup_FxnT)__inst->startup;
}

/* getMaxTicks_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_interfaces_ITimer_getMaxTicks_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_interfaces_ITimer_getMaxTicks_FxnT ti_sysbios_interfaces_ITimer_getMaxTicks_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_getMaxTicks_FxnT)__inst->__fxns->getMaxTicks;
}

/* setNextTick_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITimer_setNextTick_FxnT)(void*, xdc_UInt32, xdc_UInt32);
static inline ti_sysbios_interfaces_ITimer_setNextTick_FxnT ti_sysbios_interfaces_ITimer_setNextTick_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_setNextTick_FxnT)__inst->__fxns->setNextTick;
}

/* start_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITimer_start_FxnT)(void*);
static inline ti_sysbios_interfaces_ITimer_start_FxnT ti_sysbios_interfaces_ITimer_start_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_start_FxnT)__inst->__fxns->start;
}

/* stop_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITimer_stop_FxnT)(void*);
static inline ti_sysbios_interfaces_ITimer_stop_FxnT ti_sysbios_interfaces_ITimer_stop_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_stop_FxnT)__inst->__fxns->stop;
}

/* setPeriod_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITimer_setPeriod_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_interfaces_ITimer_setPeriod_FxnT ti_sysbios_interfaces_ITimer_setPeriod_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_setPeriod_FxnT)__inst->__fxns->setPeriod;
}

/* setPeriodMicroSecs_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_interfaces_ITimer_setPeriodMicroSecs_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_interfaces_ITimer_setPeriodMicroSecs_FxnT ti_sysbios_interfaces_ITimer_setPeriodMicroSecs_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_setPeriodMicroSecs_FxnT)__inst->__fxns->setPeriodMicroSecs;
}

/* getPeriod_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_interfaces_ITimer_getPeriod_FxnT)(void*);
static inline ti_sysbios_interfaces_ITimer_getPeriod_FxnT ti_sysbios_interfaces_ITimer_getPeriod_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_getPeriod_FxnT)__inst->__fxns->getPeriod;
}

/* getCount_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_interfaces_ITimer_getCount_FxnT)(void*);
static inline ti_sysbios_interfaces_ITimer_getCount_FxnT ti_sysbios_interfaces_ITimer_getCount_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_getCount_FxnT)__inst->__fxns->getCount;
}

/* getFreq_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITimer_getFreq_FxnT)(void*, xdc_runtime_Types_FreqHz*);
static inline ti_sysbios_interfaces_ITimer_getFreq_FxnT ti_sysbios_interfaces_ITimer_getFreq_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_getFreq_FxnT)__inst->__fxns->getFreq;
}

/* getFunc_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_ITimer_FuncPtr (*ti_sysbios_interfaces_ITimer_getFunc_FxnT)(void*, xdc_UArg*);
static inline ti_sysbios_interfaces_ITimer_getFunc_FxnT ti_sysbios_interfaces_ITimer_getFunc_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_getFunc_FxnT)__inst->__fxns->getFunc;
}

/* setFunc_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITimer_setFunc_FxnT)(void*, ti_sysbios_interfaces_ITimer_FuncPtr, xdc_UArg);
static inline ti_sysbios_interfaces_ITimer_setFunc_FxnT ti_sysbios_interfaces_ITimer_setFunc_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_setFunc_FxnT)__inst->__fxns->setFunc;
}

/* trigger_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_ITimer_trigger_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_interfaces_ITimer_trigger_FxnT ti_sysbios_interfaces_ITimer_trigger_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_trigger_FxnT)__inst->__fxns->trigger;
}

/* getExpiredCounts_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_interfaces_ITimer_getExpiredCounts_FxnT)(void*);
static inline ti_sysbios_interfaces_ITimer_getExpiredCounts_FxnT ti_sysbios_interfaces_ITimer_getExpiredCounts_fxnP( ti_sysbios_interfaces_ITimer_Handle __inst )
{
    return (ti_sysbios_interfaces_ITimer_getExpiredCounts_FxnT)__inst->__fxns->getExpiredCounts;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.interfaces; 2, 0, 0, 0,545; 3-20-2012 14:03:23; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.interfaces; 2, 0, 0, 0,545; 3-20-2012 14:03:23; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef ti_sysbios_interfaces_ITimer_FuncPtr ti_sysbios_hal_Timer_TimerProxy_FuncPtr;

/* ANY */

/* StartMode */
typedef ti_sysbios_interfaces_ITimer_StartMode ti_sysbios_hal_Timer_TimerProxy_StartMode;

/* RunMode */
typedef ti_sysbios_interfaces_ITimer_RunMode ti_sysbios_hal_Timer_TimerProxy_RunMode;

/* Status */
typedef ti_sysbios_interfaces_ITimer_Status ti_sysbios_hal_Timer_TimerProxy_Status;

/* PeriodType */
typedef ti_sysbios_interfaces_ITimer_PeriodType ti_sysbios_hal_Timer_TimerProxy_PeriodType;


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_hal_Timer_TimerProxy_Args__create {
    xdc_Int id;
    ti_sysbios_interfaces_ITimer_FuncPtr tickFxn;
} ti_sysbios_hal_Timer_TimerProxy_Args__create;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_hal_Timer_TimerProxy_Module__diagsEnabled;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__diagsEnabled ti_sysbios_hal_Timer_TimerProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_hal_Timer_TimerProxy_Module__diagsIncluded;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__diagsIncluded ti_sysbios_hal_Timer_TimerProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_hal_Timer_TimerProxy_Module__diagsMask;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__diagsMask ti_sysbios_hal_Timer_TimerProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_hal_Timer_TimerProxy_Module__gateObj;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__gateObj ti_sysbios_hal_Timer_TimerProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_hal_Timer_TimerProxy_Module__gatePrms;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__gatePrms ti_sysbios_hal_Timer_TimerProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_hal_Timer_TimerProxy_Module__id;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__id ti_sysbios_hal_Timer_TimerProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerDefined;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerDefined ti_sysbios_hal_Timer_TimerProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerObj;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerObj ti_sysbios_hal_Timer_TimerProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn0;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn0 ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn1;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn1 ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn2;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn2 ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn4;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn4 ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn8;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn8 ti_sysbios_hal_Timer_TimerProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_hal_Timer_TimerProxy_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Module__startupDoneFxn ti_sysbios_hal_Timer_TimerProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_hal_Timer_TimerProxy_Object__count;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Object__count ti_sysbios_hal_Timer_TimerProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_hal_Timer_TimerProxy_Object__heap;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Object__heap ti_sysbios_hal_Timer_TimerProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_hal_Timer_TimerProxy_Object__sizeof;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Object__sizeof ti_sysbios_hal_Timer_TimerProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_hal_Timer_TimerProxy_Object__table;
extern far const CT__ti_sysbios_hal_Timer_TimerProxy_Object__table ti_sysbios_hal_Timer_TimerProxy_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_hal_Timer_TimerProxy_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    ti_sysbios_interfaces_ITimer_RunMode runMode;
    ti_sysbios_interfaces_ITimer_StartMode startMode;
    xdc_UArg arg;
    xdc_UInt32 period;
    ti_sysbios_interfaces_ITimer_PeriodType periodType;
    xdc_runtime_Types_FreqHz extFreq;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_hal_Timer_TimerProxy_Struct {
    const ti_sysbios_hal_Timer_TimerProxy_Fxns__* __fxns;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_hal_Timer_TimerProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_UInt (*getNumTimers)(void);
    ti_sysbios_interfaces_ITimer_Status (*getStatus)(xdc_UInt);
    void (*startup)(void);
    xdc_UInt32 (*getMaxTicks)(ti_sysbios_hal_Timer_TimerProxy_Handle, xdc_UInt32);
    void (*setNextTick)(ti_sysbios_hal_Timer_TimerProxy_Handle, xdc_UInt32, xdc_UInt32);
    void (*start)(ti_sysbios_hal_Timer_TimerProxy_Handle);
    void (*stop)(ti_sysbios_hal_Timer_TimerProxy_Handle);
    void (*setPeriod)(ti_sysbios_hal_Timer_TimerProxy_Handle, xdc_UInt32);
    xdc_Bool (*setPeriodMicroSecs)(ti_sysbios_hal_Timer_TimerProxy_Handle, xdc_UInt32);
    xdc_UInt32 (*getPeriod)(ti_sysbios_hal_Timer_TimerProxy_Handle);
    xdc_UInt32 (*getCount)(ti_sysbios_hal_Timer_TimerProxy_Handle);
    void (*getFreq)(ti_sysbios_hal_Timer_TimerProxy_Handle, xdc_runtime_Types_FreqHz*);
    ti_sysbios_interfaces_ITimer_FuncPtr (*getFunc)(ti_sysbios_hal_Timer_TimerProxy_Handle, xdc_UArg*);
    void (*setFunc)(ti_sysbios_hal_Timer_TimerProxy_Handle, ti_sysbios_interfaces_ITimer_FuncPtr, xdc_UArg);
    void (*trigger)(ti_sysbios_hal_Timer_TimerProxy_Handle, xdc_UInt32);
    xdc_UInt32 (*getExpiredCounts)(ti_sysbios_hal_Timer_TimerProxy_Handle);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_hal_Timer_TimerProxy_Fxns__ ti_sysbios_hal_Timer_TimerProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_hal_Timer_TimerProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_hal_Timer_TimerProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_hal_Timer_TimerProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_hal_Timer_TimerProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_hal_Timer_TimerProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_hal_Timer_TimerProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_hal_Timer_TimerProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_hal_Timer_TimerProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_hal_Timer_TimerProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool ti_sysbios_hal_Timer_TimerProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr ti_sysbios_hal_Timer_TimerProxy_Proxy__delegate__S( void );

/* getNumTimers__E */

extern xdc_UInt ti_sysbios_hal_Timer_TimerProxy_getNumTimers__E( void );

extern xdc_UInt ti_sysbios_hal_Timer_TimerProxy_getNumTimers__R( void );

/* getStatus__E */

extern ti_sysbios_interfaces_ITimer_Status ti_sysbios_hal_Timer_TimerProxy_getStatus__E( xdc_UInt id );

extern ti_sysbios_interfaces_ITimer_Status ti_sysbios_hal_Timer_TimerProxy_getStatus__R( xdc_UInt id );

/* startup__E */

extern void ti_sysbios_hal_Timer_TimerProxy_startup__E( void );

extern void ti_sysbios_hal_Timer_TimerProxy_startup__R( void );

/* getMaxTicks__E */

extern xdc_UInt32 ti_sysbios_hal_Timer_TimerProxy_getMaxTicks__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 periodCounts );

extern xdc_UInt32 ti_sysbios_hal_Timer_TimerProxy_getMaxTicks__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 periodCounts );

/* setNextTick__E */

extern void ti_sysbios_hal_Timer_TimerProxy_setNextTick__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 newPeriod, xdc_UInt32 countsPerTick );

extern void ti_sysbios_hal_Timer_TimerProxy_setNextTick__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 newPeriod, xdc_UInt32 countsPerTick );

/* start__E */

extern void ti_sysbios_hal_Timer_TimerProxy_start__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

extern void ti_sysbios_hal_Timer_TimerProxy_start__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

/* stop__E */

extern void ti_sysbios_hal_Timer_TimerProxy_stop__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

extern void ti_sysbios_hal_Timer_TimerProxy_stop__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

/* setPeriod__E */

extern void ti_sysbios_hal_Timer_TimerProxy_setPeriod__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 period );

extern void ti_sysbios_hal_Timer_TimerProxy_setPeriod__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 period );

/* setPeriodMicroSecs__E */

extern xdc_Bool ti_sysbios_hal_Timer_TimerProxy_setPeriodMicroSecs__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 microsecs );

extern xdc_Bool ti_sysbios_hal_Timer_TimerProxy_setPeriodMicroSecs__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 microsecs );

/* getPeriod__E */

extern xdc_UInt32 ti_sysbios_hal_Timer_TimerProxy_getPeriod__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

extern xdc_UInt32 ti_sysbios_hal_Timer_TimerProxy_getPeriod__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

/* getCount__E */

extern xdc_UInt32 ti_sysbios_hal_Timer_TimerProxy_getCount__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

extern xdc_UInt32 ti_sysbios_hal_Timer_TimerProxy_getCount__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

/* getFreq__E */

extern void ti_sysbios_hal_Timer_TimerProxy_getFreq__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_runtime_Types_FreqHz* freq );

extern void ti_sysbios_hal_Timer_TimerProxy_getFreq__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_runtime_Types_FreqHz* freq );

/* getFunc__E */

extern ti_sysbios_interfaces_ITimer_FuncPtr ti_sysbios_hal_Timer_TimerProxy_getFunc__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UArg* arg );

extern ti_sysbios_interfaces_ITimer_FuncPtr ti_sysbios_hal_Timer_TimerProxy_getFunc__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UArg* arg );

/* setFunc__E */

extern void ti_sysbios_hal_Timer_TimerProxy_setFunc__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, ti_sysbios_interfaces_ITimer_FuncPtr fxn, xdc_UArg arg );

extern void ti_sysbios_hal_Timer_TimerProxy_setFunc__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, ti_sysbios_interfaces_ITimer_FuncPtr fxn, xdc_UArg arg );

/* trigger__E */

extern void ti_sysbios_hal_Timer_TimerProxy_trigger__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 cycles );

extern void ti_sysbios_hal_Timer_TimerProxy_trigger__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst, xdc_UInt32 cycles );

/* getExpiredCounts__E */

extern xdc_UInt32 ti_sysbios_hal_Timer_TimerProxy_getExpiredCounts__E( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );

extern xdc_UInt32 ti_sysbios_hal_Timer_TimerProxy_getExpiredCounts__R( ti_sysbios_hal_Timer_TimerProxy_Handle __inst );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getMaxTicks_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_hal_Timer_TimerProxy_getMaxTicks_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_hal_Timer_TimerProxy_getMaxTicks_FxnT ti_sysbios_hal_Timer_TimerProxy_getMaxTicks_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_getMaxTicks_FxnT)ti_sysbios_hal_Timer_TimerProxy_getMaxTicks__E; 
}

/* setNextTick_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_TimerProxy_setNextTick_FxnT)(void*, xdc_UInt32, xdc_UInt32);
static inline ti_sysbios_hal_Timer_TimerProxy_setNextTick_FxnT ti_sysbios_hal_Timer_TimerProxy_setNextTick_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_setNextTick_FxnT)ti_sysbios_hal_Timer_TimerProxy_setNextTick__E; 
}

/* start_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_TimerProxy_start_FxnT)(void*);
static inline ti_sysbios_hal_Timer_TimerProxy_start_FxnT ti_sysbios_hal_Timer_TimerProxy_start_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_start_FxnT)ti_sysbios_hal_Timer_TimerProxy_start__E; 
}

/* stop_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_TimerProxy_stop_FxnT)(void*);
static inline ti_sysbios_hal_Timer_TimerProxy_stop_FxnT ti_sysbios_hal_Timer_TimerProxy_stop_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_stop_FxnT)ti_sysbios_hal_Timer_TimerProxy_stop__E; 
}

/* setPeriod_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_TimerProxy_setPeriod_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_hal_Timer_TimerProxy_setPeriod_FxnT ti_sysbios_hal_Timer_TimerProxy_setPeriod_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_setPeriod_FxnT)ti_sysbios_hal_Timer_TimerProxy_setPeriod__E; 
}

/* setPeriodMicroSecs_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_hal_Timer_TimerProxy_setPeriodMicroSecs_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_hal_Timer_TimerProxy_setPeriodMicroSecs_FxnT ti_sysbios_hal_Timer_TimerProxy_setPeriodMicroSecs_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_setPeriodMicroSecs_FxnT)ti_sysbios_hal_Timer_TimerProxy_setPeriodMicroSecs__E; 
}

/* getPeriod_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_hal_Timer_TimerProxy_getPeriod_FxnT)(void*);
static inline ti_sysbios_hal_Timer_TimerProxy_getPeriod_FxnT ti_sysbios_hal_Timer_TimerProxy_getPeriod_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_getPeriod_FxnT)ti_sysbios_hal_Timer_TimerProxy_getPeriod__E; 
}

/* getCount_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_hal_Timer_TimerProxy_getCount_FxnT)(void*);
static inline ti_sysbios_hal_Timer_TimerProxy_getCount_FxnT ti_sysbios_hal_Timer_TimerProxy_getCount_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_getCount_FxnT)ti_sysbios_hal_Timer_TimerProxy_getCount__E; 
}

/* getFreq_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_TimerProxy_getFreq_FxnT)(void*, xdc_runtime_Types_FreqHz*);
static inline ti_sysbios_hal_Timer_TimerProxy_getFreq_FxnT ti_sysbios_hal_Timer_TimerProxy_getFreq_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_getFreq_FxnT)ti_sysbios_hal_Timer_TimerProxy_getFreq__E; 
}

/* getFunc_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_ITimer_FuncPtr (*ti_sysbios_hal_Timer_TimerProxy_getFunc_FxnT)(void*, xdc_UArg*);
static inline ti_sysbios_hal_Timer_TimerProxy_getFunc_FxnT ti_sysbios_hal_Timer_TimerProxy_getFunc_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_getFunc_FxnT)ti_sysbios_hal_Timer_TimerProxy_getFunc__E; 
}

/* setFunc_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_TimerProxy_setFunc_FxnT)(void*, ti_sysbios_interfaces_ITimer_FuncPtr, xdc_UArg);
static inline ti_sysbios_hal_Timer_TimerProxy_setFunc_FxnT ti_sysbios_hal_Timer_TimerProxy_setFunc_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_setFunc_FxnT)ti_sysbios_hal_Timer_TimerProxy_setFunc__E; 
}

/* trigger_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_TimerProxy_trigger_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_hal_Timer_TimerProxy_trigger_FxnT ti_sysbios_hal_Timer_TimerProxy_trigger_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_trigger_FxnT)ti_sysbios_hal_Timer_TimerProxy_trigger__E; 
}

/* getExpiredCounts_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_hal_Timer_TimerProxy_getExpiredCounts_FxnT)(void*);
static inline ti_sysbios_hal_Timer_TimerProxy_getExpiredCounts_FxnT ti_sysbios_hal_Timer_TimerProxy_getExpiredCounts_fxnP( void )
{
    return (ti_sysbios_hal_Timer_TimerProxy_getExpiredCounts_FxnT)ti_sysbios_hal_Timer_TimerProxy_getExpiredCounts__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline ti_sysbios_interfaces_ITimer_Module ti_sysbios_hal_Timer_TimerProxy_Module_upCast( void )
{
    return (ti_sysbios_interfaces_ITimer_Module)ti_sysbios_hal_Timer_TimerProxy_Proxy__delegate__S();
}

/* Module_to_ti_sysbios_interfaces_ITimer */

/* Handle_upCast */
static inline ti_sysbios_interfaces_ITimer_Handle ti_sysbios_hal_Timer_TimerProxy_Handle_upCast( ti_sysbios_hal_Timer_TimerProxy_Handle i )
{
    return (ti_sysbios_interfaces_ITimer_Handle)i;
}

/* Handle_to_ti_sysbios_interfaces_ITimer */

/* Handle_downCast */
static inline ti_sysbios_hal_Timer_TimerProxy_Handle ti_sysbios_hal_Timer_TimerProxy_Handle_downCast( ti_sysbios_interfaces_ITimer_Handle i )
{
    ti_sysbios_interfaces_ITimer_Handle i2 = (ti_sysbios_interfaces_ITimer_Handle)i;
if (ti_sysbios_hal_Timer_TimerProxy_Proxy__abstract__S()) return (ti_sysbios_hal_Timer_TimerProxy_Handle)i;
    return (void*)i2->__fxns == (void*)ti_sysbios_hal_Timer_TimerProxy_Proxy__delegate__S() ? (ti_sysbios_hal_Timer_TimerProxy_Handle)i : 0;
}

/* Handle_from_ti_sysbios_interfaces_ITimer */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_hal_Timer_TimerProxy_Module__id ti_sysbios_hal_Timer_TimerProxy_Module_id( void ) 
{
    return ti_sysbios_hal_Timer_TimerProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */

/* Params_init */
static inline void ti_sysbios_hal_Timer_TimerProxy_Params_init( ti_sysbios_hal_Timer_TimerProxy_Params* prms ) 
{
    if (prms) {
        ti_sysbios_hal_Timer_TimerProxy_Params__init__S(prms, 0, sizeof(ti_sysbios_hal_Timer_TimerProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_hal_Timer_TimerProxy_Params_copy( ti_sysbios_hal_Timer_TimerProxy_Params* dst, const ti_sysbios_hal_Timer_TimerProxy_Params* src ) 
{
    if (dst) {
        ti_sysbios_hal_Timer_TimerProxy_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_hal_Timer_TimerProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* create */
static inline ti_sysbios_hal_Timer_TimerProxy_Handle ti_sysbios_hal_Timer_TimerProxy_create( xdc_Int id, ti_sysbios_interfaces_ITimer_FuncPtr tickFxn, const ti_sysbios_hal_Timer_TimerProxy_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_hal_Timer_TimerProxy_Args__create __args;
    __args.id = id;
    __args.tickFxn = tickFxn;
    return (ti_sysbios_hal_Timer_TimerProxy_Handle)ti_sysbios_hal_Timer_TimerProxy_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_hal_Timer_TimerProxy_Params), __eb);
}

/* delete */
static inline void ti_sysbios_hal_Timer_TimerProxy_delete( ti_sysbios_hal_Timer_TimerProxy_Handle* instp )
{
    ti_sysbios_hal_Timer_TimerProxy_Object__delete__S(instp);
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef ti_sysbios_interfaces_ITimer_FuncPtr ti_sysbios_hal_Timer_FuncPtr;

/* ANY */

/* StartMode */
typedef ti_sysbios_interfaces_ITimer_StartMode ti_sysbios_hal_Timer_StartMode;

/* RunMode */
typedef ti_sysbios_interfaces_ITimer_RunMode ti_sysbios_hal_Timer_RunMode;

/* Status */
typedef ti_sysbios_interfaces_ITimer_Status ti_sysbios_hal_Timer_Status;

/* PeriodType */
typedef ti_sysbios_interfaces_ITimer_PeriodType ti_sysbios_hal_Timer_PeriodType;

/* StartMode_AUTO */

/* StartMode_USER */

/* RunMode_CONTINUOUS */

/* RunMode_ONESHOT */

/* RunMode_DYNAMIC */

/* Status_INUSE */

/* Status_FREE */

/* PeriodType_MICROSECS */

/* PeriodType_COUNTS */


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_hal_Timer_Args__create {
    xdc_Int id;
    ti_sysbios_hal_Timer_FuncPtr tickFxn;
} ti_sysbios_hal_Timer_Args__create;


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_hal_Timer_Module__diagsEnabled;
extern far const CT__ti_sysbios_hal_Timer_Module__diagsEnabled ti_sysbios_hal_Timer_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_hal_Timer_Module__diagsIncluded;
extern far const CT__ti_sysbios_hal_Timer_Module__diagsIncluded ti_sysbios_hal_Timer_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_hal_Timer_Module__diagsMask;
extern far const CT__ti_sysbios_hal_Timer_Module__diagsMask ti_sysbios_hal_Timer_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_hal_Timer_Module__gateObj;
extern far const CT__ti_sysbios_hal_Timer_Module__gateObj ti_sysbios_hal_Timer_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_hal_Timer_Module__gatePrms;
extern far const CT__ti_sysbios_hal_Timer_Module__gatePrms ti_sysbios_hal_Timer_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_hal_Timer_Module__id;
extern far const CT__ti_sysbios_hal_Timer_Module__id ti_sysbios_hal_Timer_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_hal_Timer_Module__loggerDefined;
extern far const CT__ti_sysbios_hal_Timer_Module__loggerDefined ti_sysbios_hal_Timer_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_hal_Timer_Module__loggerObj;
extern far const CT__ti_sysbios_hal_Timer_Module__loggerObj ti_sysbios_hal_Timer_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_hal_Timer_Module__loggerFxn0;
extern far const CT__ti_sysbios_hal_Timer_Module__loggerFxn0 ti_sysbios_hal_Timer_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_hal_Timer_Module__loggerFxn1;
extern far const CT__ti_sysbios_hal_Timer_Module__loggerFxn1 ti_sysbios_hal_Timer_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_hal_Timer_Module__loggerFxn2;
extern far const CT__ti_sysbios_hal_Timer_Module__loggerFxn2 ti_sysbios_hal_Timer_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_hal_Timer_Module__loggerFxn4;
extern far const CT__ti_sysbios_hal_Timer_Module__loggerFxn4 ti_sysbios_hal_Timer_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_hal_Timer_Module__loggerFxn8;
extern far const CT__ti_sysbios_hal_Timer_Module__loggerFxn8 ti_sysbios_hal_Timer_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_hal_Timer_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_hal_Timer_Module__startupDoneFxn ti_sysbios_hal_Timer_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_hal_Timer_Object__count;
extern far const CT__ti_sysbios_hal_Timer_Object__count ti_sysbios_hal_Timer_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_hal_Timer_Object__heap;
extern far const CT__ti_sysbios_hal_Timer_Object__heap ti_sysbios_hal_Timer_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_hal_Timer_Object__sizeof;
extern far const CT__ti_sysbios_hal_Timer_Object__sizeof ti_sysbios_hal_Timer_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_hal_Timer_Object__table;
extern far const CT__ti_sysbios_hal_Timer_Object__table ti_sysbios_hal_Timer_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_hal_Timer_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    ti_sysbios_interfaces_ITimer_RunMode runMode;
    ti_sysbios_interfaces_ITimer_StartMode startMode;
    xdc_UArg arg;
    xdc_UInt32 period;
    ti_sysbios_interfaces_ITimer_PeriodType periodType;
    xdc_runtime_Types_FreqHz extFreq;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_hal_Timer_Struct {
    const ti_sysbios_hal_Timer_Fxns__* __fxns;
    ti_sysbios_hal_Timer_TimerProxy_Handle __f0;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_hal_Timer_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_UInt (*getNumTimers)(void);
    ti_sysbios_interfaces_ITimer_Status (*getStatus)(xdc_UInt);
    void (*startup)(void);
    xdc_UInt32 (*getMaxTicks)(ti_sysbios_hal_Timer_Handle, xdc_UInt32);
    void (*setNextTick)(ti_sysbios_hal_Timer_Handle, xdc_UInt32, xdc_UInt32);
    void (*start)(ti_sysbios_hal_Timer_Handle);
    void (*stop)(ti_sysbios_hal_Timer_Handle);
    void (*setPeriod)(ti_sysbios_hal_Timer_Handle, xdc_UInt32);
    xdc_Bool (*setPeriodMicroSecs)(ti_sysbios_hal_Timer_Handle, xdc_UInt32);
    xdc_UInt32 (*getPeriod)(ti_sysbios_hal_Timer_Handle);
    xdc_UInt32 (*getCount)(ti_sysbios_hal_Timer_Handle);
    void (*getFreq)(ti_sysbios_hal_Timer_Handle, xdc_runtime_Types_FreqHz*);
    ti_sysbios_interfaces_ITimer_FuncPtr (*getFunc)(ti_sysbios_hal_Timer_Handle, xdc_UArg*);
    void (*setFunc)(ti_sysbios_hal_Timer_Handle, ti_sysbios_interfaces_ITimer_FuncPtr, xdc_UArg);
    void (*trigger)(ti_sysbios_hal_Timer_Handle, xdc_UInt32);
    xdc_UInt32 (*getExpiredCounts)(ti_sysbios_hal_Timer_Handle);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_hal_Timer_Fxns__ ti_sysbios_hal_Timer_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_hal_Timer_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_hal_Timer_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_hal_Timer_Module_startup__R( xdc_Int state );

/* Instance_init__F */

extern int ti_sysbios_hal_Timer_Instance_init__F( ti_sysbios_hal_Timer_Object*, xdc_Int id, ti_sysbios_hal_Timer_FuncPtr tickFxn, const ti_sysbios_hal_Timer_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__F */

extern void ti_sysbios_hal_Timer_Instance_finalize__F( ti_sysbios_hal_Timer_Object* , int );

/* Instance_init__R */

extern int ti_sysbios_hal_Timer_Instance_init__R( ti_sysbios_hal_Timer_Object*, xdc_Int id, ti_sysbios_hal_Timer_FuncPtr tickFxn, const ti_sysbios_hal_Timer_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__R */

extern void ti_sysbios_hal_Timer_Instance_finalize__R( ti_sysbios_hal_Timer_Object* , int );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_hal_Timer_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_hal_Timer_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_hal_Timer_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_hal_Timer_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_hal_Timer_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_hal_Timer_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_hal_Timer_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_hal_Timer_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_hal_Timer_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* getNumTimers__E */

extern xdc_UInt ti_sysbios_hal_Timer_getNumTimers__E( void );

extern xdc_UInt ti_sysbios_hal_Timer_getNumTimers__F( void );
extern xdc_UInt ti_sysbios_hal_Timer_getNumTimers__R( void );

/* getStatus__E */

extern ti_sysbios_interfaces_ITimer_Status ti_sysbios_hal_Timer_getStatus__E( xdc_UInt id );

extern ti_sysbios_interfaces_ITimer_Status ti_sysbios_hal_Timer_getStatus__F( xdc_UInt id );
extern ti_sysbios_interfaces_ITimer_Status ti_sysbios_hal_Timer_getStatus__R( xdc_UInt id );

/* startup__E */

extern void ti_sysbios_hal_Timer_startup__E( void );

extern void ti_sysbios_hal_Timer_startup__F( void );
extern void ti_sysbios_hal_Timer_startup__R( void );

/* getMaxTicks__E */

extern xdc_UInt32 ti_sysbios_hal_Timer_getMaxTicks__E( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 periodCounts );

extern xdc_UInt32 ti_sysbios_hal_Timer_getMaxTicks__F( ti_sysbios_hal_Timer_Object* __inst, xdc_UInt32 periodCounts );
extern xdc_UInt32 ti_sysbios_hal_Timer_getMaxTicks__R( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 periodCounts );

/* setNextTick__E */

extern void ti_sysbios_hal_Timer_setNextTick__E( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 newPeriod, xdc_UInt32 countsPerTick );

extern void ti_sysbios_hal_Timer_setNextTick__F( ti_sysbios_hal_Timer_Object* __inst, xdc_UInt32 newPeriod, xdc_UInt32 countsPerTick );
extern void ti_sysbios_hal_Timer_setNextTick__R( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 newPeriod, xdc_UInt32 countsPerTick );

/* start__E */

extern void ti_sysbios_hal_Timer_start__E( ti_sysbios_hal_Timer_Handle __inst );

extern void ti_sysbios_hal_Timer_start__F( ti_sysbios_hal_Timer_Object* __inst );
extern void ti_sysbios_hal_Timer_start__R( ti_sysbios_hal_Timer_Handle __inst );

/* stop__E */

extern void ti_sysbios_hal_Timer_stop__E( ti_sysbios_hal_Timer_Handle __inst );

extern void ti_sysbios_hal_Timer_stop__F( ti_sysbios_hal_Timer_Object* __inst );
extern void ti_sysbios_hal_Timer_stop__R( ti_sysbios_hal_Timer_Handle __inst );

/* setPeriod__E */

extern void ti_sysbios_hal_Timer_setPeriod__E( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 period );

extern void ti_sysbios_hal_Timer_setPeriod__F( ti_sysbios_hal_Timer_Object* __inst, xdc_UInt32 period );
extern void ti_sysbios_hal_Timer_setPeriod__R( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 period );

/* setPeriodMicroSecs__E */

extern xdc_Bool ti_sysbios_hal_Timer_setPeriodMicroSecs__E( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 microsecs );

extern xdc_Bool ti_sysbios_hal_Timer_setPeriodMicroSecs__F( ti_sysbios_hal_Timer_Object* __inst, xdc_UInt32 microsecs );
extern xdc_Bool ti_sysbios_hal_Timer_setPeriodMicroSecs__R( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 microsecs );

/* getPeriod__E */

extern xdc_UInt32 ti_sysbios_hal_Timer_getPeriod__E( ti_sysbios_hal_Timer_Handle __inst );

extern xdc_UInt32 ti_sysbios_hal_Timer_getPeriod__F( ti_sysbios_hal_Timer_Object* __inst );
extern xdc_UInt32 ti_sysbios_hal_Timer_getPeriod__R( ti_sysbios_hal_Timer_Handle __inst );

/* getCount__E */

extern xdc_UInt32 ti_sysbios_hal_Timer_getCount__E( ti_sysbios_hal_Timer_Handle __inst );

extern xdc_UInt32 ti_sysbios_hal_Timer_getCount__F( ti_sysbios_hal_Timer_Object* __inst );
extern xdc_UInt32 ti_sysbios_hal_Timer_getCount__R( ti_sysbios_hal_Timer_Handle __inst );

/* getFreq__E */

extern void ti_sysbios_hal_Timer_getFreq__E( ti_sysbios_hal_Timer_Handle __inst, xdc_runtime_Types_FreqHz* freq );

extern void ti_sysbios_hal_Timer_getFreq__F( ti_sysbios_hal_Timer_Object* __inst, xdc_runtime_Types_FreqHz* freq );
extern void ti_sysbios_hal_Timer_getFreq__R( ti_sysbios_hal_Timer_Handle __inst, xdc_runtime_Types_FreqHz* freq );

/* getFunc__E */

extern ti_sysbios_interfaces_ITimer_FuncPtr ti_sysbios_hal_Timer_getFunc__E( ti_sysbios_hal_Timer_Handle __inst, xdc_UArg* arg );

extern ti_sysbios_interfaces_ITimer_FuncPtr ti_sysbios_hal_Timer_getFunc__F( ti_sysbios_hal_Timer_Object* __inst, xdc_UArg* arg );
extern ti_sysbios_interfaces_ITimer_FuncPtr ti_sysbios_hal_Timer_getFunc__R( ti_sysbios_hal_Timer_Handle __inst, xdc_UArg* arg );

/* setFunc__E */

extern void ti_sysbios_hal_Timer_setFunc__E( ti_sysbios_hal_Timer_Handle __inst, ti_sysbios_interfaces_ITimer_FuncPtr fxn, xdc_UArg arg );

extern void ti_sysbios_hal_Timer_setFunc__F( ti_sysbios_hal_Timer_Object* __inst, ti_sysbios_interfaces_ITimer_FuncPtr fxn, xdc_UArg arg );
extern void ti_sysbios_hal_Timer_setFunc__R( ti_sysbios_hal_Timer_Handle __inst, ti_sysbios_interfaces_ITimer_FuncPtr fxn, xdc_UArg arg );

/* trigger__E */

extern void ti_sysbios_hal_Timer_trigger__E( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 cycles );

extern void ti_sysbios_hal_Timer_trigger__F( ti_sysbios_hal_Timer_Object* __inst, xdc_UInt32 cycles );
extern void ti_sysbios_hal_Timer_trigger__R( ti_sysbios_hal_Timer_Handle __inst, xdc_UInt32 cycles );

/* getExpiredCounts__E */

extern xdc_UInt32 ti_sysbios_hal_Timer_getExpiredCounts__E( ti_sysbios_hal_Timer_Handle __inst );

extern xdc_UInt32 ti_sysbios_hal_Timer_getExpiredCounts__F( ti_sysbios_hal_Timer_Object* __inst );
extern xdc_UInt32 ti_sysbios_hal_Timer_getExpiredCounts__R( ti_sysbios_hal_Timer_Handle __inst );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getMaxTicks_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_hal_Timer_getMaxTicks_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_hal_Timer_getMaxTicks_FxnT ti_sysbios_hal_Timer_getMaxTicks_fxnP( void )
{
    return (ti_sysbios_hal_Timer_getMaxTicks_FxnT)ti_sysbios_hal_Timer_getMaxTicks__E; 
}

/* setNextTick_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_setNextTick_FxnT)(void*, xdc_UInt32, xdc_UInt32);
static inline ti_sysbios_hal_Timer_setNextTick_FxnT ti_sysbios_hal_Timer_setNextTick_fxnP( void )
{
    return (ti_sysbios_hal_Timer_setNextTick_FxnT)ti_sysbios_hal_Timer_setNextTick__E; 
}

/* start_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_start_FxnT)(void*);
static inline ti_sysbios_hal_Timer_start_FxnT ti_sysbios_hal_Timer_start_fxnP( void )
{
    return (ti_sysbios_hal_Timer_start_FxnT)ti_sysbios_hal_Timer_start__E; 
}

/* stop_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_stop_FxnT)(void*);
static inline ti_sysbios_hal_Timer_stop_FxnT ti_sysbios_hal_Timer_stop_fxnP( void )
{
    return (ti_sysbios_hal_Timer_stop_FxnT)ti_sysbios_hal_Timer_stop__E; 
}

/* setPeriod_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_setPeriod_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_hal_Timer_setPeriod_FxnT ti_sysbios_hal_Timer_setPeriod_fxnP( void )
{
    return (ti_sysbios_hal_Timer_setPeriod_FxnT)ti_sysbios_hal_Timer_setPeriod__E; 
}

/* setPeriodMicroSecs_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_hal_Timer_setPeriodMicroSecs_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_hal_Timer_setPeriodMicroSecs_FxnT ti_sysbios_hal_Timer_setPeriodMicroSecs_fxnP( void )
{
    return (ti_sysbios_hal_Timer_setPeriodMicroSecs_FxnT)ti_sysbios_hal_Timer_setPeriodMicroSecs__E; 
}

/* getPeriod_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_hal_Timer_getPeriod_FxnT)(void*);
static inline ti_sysbios_hal_Timer_getPeriod_FxnT ti_sysbios_hal_Timer_getPeriod_fxnP( void )
{
    return (ti_sysbios_hal_Timer_getPeriod_FxnT)ti_sysbios_hal_Timer_getPeriod__E; 
}

/* getCount_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_hal_Timer_getCount_FxnT)(void*);
static inline ti_sysbios_hal_Timer_getCount_FxnT ti_sysbios_hal_Timer_getCount_fxnP( void )
{
    return (ti_sysbios_hal_Timer_getCount_FxnT)ti_sysbios_hal_Timer_getCount__E; 
}

/* getFreq_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_getFreq_FxnT)(void*, xdc_runtime_Types_FreqHz*);
static inline ti_sysbios_hal_Timer_getFreq_FxnT ti_sysbios_hal_Timer_getFreq_fxnP( void )
{
    return (ti_sysbios_hal_Timer_getFreq_FxnT)ti_sysbios_hal_Timer_getFreq__E; 
}

/* getFunc_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_ITimer_FuncPtr (*ti_sysbios_hal_Timer_getFunc_FxnT)(void*, xdc_UArg*);
static inline ti_sysbios_hal_Timer_getFunc_FxnT ti_sysbios_hal_Timer_getFunc_fxnP( void )
{
    return (ti_sysbios_hal_Timer_getFunc_FxnT)ti_sysbios_hal_Timer_getFunc__E; 
}

/* setFunc_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_setFunc_FxnT)(void*, ti_sysbios_interfaces_ITimer_FuncPtr, xdc_UArg);
static inline ti_sysbios_hal_Timer_setFunc_FxnT ti_sysbios_hal_Timer_setFunc_fxnP( void )
{
    return (ti_sysbios_hal_Timer_setFunc_FxnT)ti_sysbios_hal_Timer_setFunc__E; 
}

/* trigger_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Timer_trigger_FxnT)(void*, xdc_UInt32);
static inline ti_sysbios_hal_Timer_trigger_FxnT ti_sysbios_hal_Timer_trigger_fxnP( void )
{
    return (ti_sysbios_hal_Timer_trigger_FxnT)ti_sysbios_hal_Timer_trigger__E; 
}

/* getExpiredCounts_{FxnT,fxnP} */
typedef xdc_UInt32 (*ti_sysbios_hal_Timer_getExpiredCounts_FxnT)(void*);
static inline ti_sysbios_hal_Timer_getExpiredCounts_FxnT ti_sysbios_hal_Timer_getExpiredCounts_fxnP( void )
{
    return (ti_sysbios_hal_Timer_getExpiredCounts_FxnT)ti_sysbios_hal_Timer_getExpiredCounts__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline ti_sysbios_interfaces_ITimer_Module ti_sysbios_hal_Timer_Module_upCast( void )
{
    return (ti_sysbios_interfaces_ITimer_Module)&ti_sysbios_hal_Timer_Module__FXNS__C;
}

/* Module_to_ti_sysbios_interfaces_ITimer */

/* Handle_upCast */
static inline ti_sysbios_interfaces_ITimer_Handle ti_sysbios_hal_Timer_Handle_upCast( ti_sysbios_hal_Timer_Handle i )
{
    return (ti_sysbios_interfaces_ITimer_Handle)i;
}

/* Handle_to_ti_sysbios_interfaces_ITimer */

/* Handle_downCast */
static inline ti_sysbios_hal_Timer_Handle ti_sysbios_hal_Timer_Handle_downCast( ti_sysbios_interfaces_ITimer_Handle i )
{
    ti_sysbios_interfaces_ITimer_Handle i2 = (ti_sysbios_interfaces_ITimer_Handle)i;
    return (void*)i2->__fxns == (void*)&ti_sysbios_hal_Timer_Module__FXNS__C ? (ti_sysbios_hal_Timer_Handle)i : 0;
}

/* Handle_from_ti_sysbios_interfaces_ITimer */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_hal_Timer_Module__id ti_sysbios_hal_Timer_Module_id( void ) 
{
    return ti_sysbios_hal_Timer_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_hal_Timer_Module_hasMask( void ) 
{
    return ti_sysbios_hal_Timer_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_hal_Timer_Module_getMask( void ) 
{
    return ti_sysbios_hal_Timer_Module__diagsMask__C != 0 ? *ti_sysbios_hal_Timer_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_hal_Timer_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_hal_Timer_Module__diagsMask__C != 0) *ti_sysbios_hal_Timer_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_hal_Timer_Params_init( ti_sysbios_hal_Timer_Params* prms ) 
{
    if (prms) {
        ti_sysbios_hal_Timer_Params__init__S(prms, 0, sizeof(ti_sysbios_hal_Timer_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_hal_Timer_Params_copy( ti_sysbios_hal_Timer_Params* dst, const ti_sysbios_hal_Timer_Params* src ) 
{
    if (dst) {
        ti_sysbios_hal_Timer_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_hal_Timer_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_hal_Timer_Handle ti_sysbios_hal_Timer_Object_get( ti_sysbios_hal_Timer_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_hal_Timer_Handle)ti_sysbios_hal_Timer_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_hal_Timer_Handle ti_sysbios_hal_Timer_Object_first( void )
{
    return (ti_sysbios_hal_Timer_Handle)ti_sysbios_hal_Timer_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_hal_Timer_Handle ti_sysbios_hal_Timer_Object_next( ti_sysbios_hal_Timer_Object* obj )
{
    return (ti_sysbios_hal_Timer_Handle)ti_sysbios_hal_Timer_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_hal_Timer_Handle_label( ti_sysbios_hal_Timer_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_hal_Timer_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_hal_Timer_Handle_name( ti_sysbios_hal_Timer_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_hal_Timer_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_hal_Timer_Handle ti_sysbios_hal_Timer_create( xdc_Int id, ti_sysbios_hal_Timer_FuncPtr tickFxn, const ti_sysbios_hal_Timer_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_hal_Timer_Args__create __args;
    __args.id = id;
    __args.tickFxn = tickFxn;
    return (ti_sysbios_hal_Timer_Handle)ti_sysbios_hal_Timer_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_hal_Timer_Params), __eb);
}

/* construct */
static inline void ti_sysbios_hal_Timer_construct( ti_sysbios_hal_Timer_Struct* __obj, xdc_Int id, ti_sysbios_hal_Timer_FuncPtr tickFxn, const ti_sysbios_hal_Timer_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_hal_Timer_Args__create __args;
    __args.id = id;
    __args.tickFxn = tickFxn;
    ti_sysbios_hal_Timer_Object__create__S(__obj, sizeof (ti_sysbios_hal_Timer_Struct), &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_hal_Timer_Params), __eb);
}

/* delete */
static inline void ti_sysbios_hal_Timer_delete( ti_sysbios_hal_Timer_Handle* instp )
{
    ti_sysbios_hal_Timer_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_hal_Timer_destruct( ti_sysbios_hal_Timer_Struct* obj )
{
    ti_sysbios_hal_Timer_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_hal_Timer_Handle ti_sysbios_hal_Timer_handle( ti_sysbios_hal_Timer_Struct* str )
{
    return (ti_sysbios_hal_Timer_Handle)str;
}

/* struct */
static inline ti_sysbios_hal_Timer_Struct* ti_sysbios_hal_Timer_struct( ti_sysbios_hal_Timer_Handle inst )
{
    return (ti_sysbios_hal_Timer_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.hal; 2, 0, 0, 0,547; 3-20-2012 14:03:16; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Elem */
struct ti_sysbios_knl_Queue_Elem {
    ti_sysbios_knl_Queue_Elem*volatile  next;
    ti_sysbios_knl_Queue_Elem*volatile  prev;
};


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_knl_Queue_Module__diagsEnabled;
extern far const CT__ti_sysbios_knl_Queue_Module__diagsEnabled ti_sysbios_knl_Queue_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_knl_Queue_Module__diagsIncluded;
extern far const CT__ti_sysbios_knl_Queue_Module__diagsIncluded ti_sysbios_knl_Queue_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_knl_Queue_Module__diagsMask;
extern far const CT__ti_sysbios_knl_Queue_Module__diagsMask ti_sysbios_knl_Queue_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Queue_Module__gateObj;
extern far const CT__ti_sysbios_knl_Queue_Module__gateObj ti_sysbios_knl_Queue_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_knl_Queue_Module__gatePrms;
extern far const CT__ti_sysbios_knl_Queue_Module__gatePrms ti_sysbios_knl_Queue_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_knl_Queue_Module__id;
extern far const CT__ti_sysbios_knl_Queue_Module__id ti_sysbios_knl_Queue_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_knl_Queue_Module__loggerDefined;
extern far const CT__ti_sysbios_knl_Queue_Module__loggerDefined ti_sysbios_knl_Queue_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Queue_Module__loggerObj;
extern far const CT__ti_sysbios_knl_Queue_Module__loggerObj ti_sysbios_knl_Queue_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_knl_Queue_Module__loggerFxn0;
extern far const CT__ti_sysbios_knl_Queue_Module__loggerFxn0 ti_sysbios_knl_Queue_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_knl_Queue_Module__loggerFxn1;
extern far const CT__ti_sysbios_knl_Queue_Module__loggerFxn1 ti_sysbios_knl_Queue_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_knl_Queue_Module__loggerFxn2;
extern far const CT__ti_sysbios_knl_Queue_Module__loggerFxn2 ti_sysbios_knl_Queue_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_knl_Queue_Module__loggerFxn4;
extern far const CT__ti_sysbios_knl_Queue_Module__loggerFxn4 ti_sysbios_knl_Queue_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_knl_Queue_Module__loggerFxn8;
extern far const CT__ti_sysbios_knl_Queue_Module__loggerFxn8 ti_sysbios_knl_Queue_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_knl_Queue_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_knl_Queue_Module__startupDoneFxn ti_sysbios_knl_Queue_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_knl_Queue_Object__count;
extern far const CT__ti_sysbios_knl_Queue_Object__count ti_sysbios_knl_Queue_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_knl_Queue_Object__heap;
extern far const CT__ti_sysbios_knl_Queue_Object__heap ti_sysbios_knl_Queue_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_knl_Queue_Object__sizeof;
extern far const CT__ti_sysbios_knl_Queue_Object__sizeof ti_sysbios_knl_Queue_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_knl_Queue_Object__table;
extern far const CT__ti_sysbios_knl_Queue_Object__table ti_sysbios_knl_Queue_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_knl_Queue_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_knl_Queue_Struct {
    ti_sysbios_knl_Queue_Elem __f0;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Instance_init__F */

extern void ti_sysbios_knl_Queue_Instance_init__F( ti_sysbios_knl_Queue_Object*, const ti_sysbios_knl_Queue_Params* );

/* Instance_init__R */

extern void ti_sysbios_knl_Queue_Instance_init__R( ti_sysbios_knl_Queue_Object*, const ti_sysbios_knl_Queue_Params* );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_knl_Queue_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_knl_Queue_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_knl_Queue_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_knl_Queue_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_knl_Queue_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_knl_Queue_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_knl_Queue_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_knl_Queue_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_knl_Queue_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* elemClear__E */

extern void ti_sysbios_knl_Queue_elemClear__E( ti_sysbios_knl_Queue_Elem* qelem );

extern void ti_sysbios_knl_Queue_elemClear__F( ti_sysbios_knl_Queue_Elem* qelem );
extern void ti_sysbios_knl_Queue_elemClear__R( ti_sysbios_knl_Queue_Elem* qelem );

/* insert__E */

extern void ti_sysbios_knl_Queue_insert__E( ti_sysbios_knl_Queue_Elem* qelem, ti_sysbios_knl_Queue_Elem* elem );

extern void ti_sysbios_knl_Queue_insert__F( ti_sysbios_knl_Queue_Elem* qelem, ti_sysbios_knl_Queue_Elem* elem );
extern void ti_sysbios_knl_Queue_insert__R( ti_sysbios_knl_Queue_Elem* qelem, ti_sysbios_knl_Queue_Elem* elem );

/* next__E */

extern xdc_Ptr ti_sysbios_knl_Queue_next__E( ti_sysbios_knl_Queue_Elem* qelem );

extern xdc_Ptr ti_sysbios_knl_Queue_next__F( ti_sysbios_knl_Queue_Elem* qelem );
extern xdc_Ptr ti_sysbios_knl_Queue_next__R( ti_sysbios_knl_Queue_Elem* qelem );

/* prev__E */

extern xdc_Ptr ti_sysbios_knl_Queue_prev__E( ti_sysbios_knl_Queue_Elem* qelem );

extern xdc_Ptr ti_sysbios_knl_Queue_prev__F( ti_sysbios_knl_Queue_Elem* qelem );
extern xdc_Ptr ti_sysbios_knl_Queue_prev__R( ti_sysbios_knl_Queue_Elem* qelem );

/* remove__E */

extern void ti_sysbios_knl_Queue_remove__E( ti_sysbios_knl_Queue_Elem* qelem );

extern void ti_sysbios_knl_Queue_remove__F( ti_sysbios_knl_Queue_Elem* qelem );
extern void ti_sysbios_knl_Queue_remove__R( ti_sysbios_knl_Queue_Elem* qelem );

/* isQueued__E */

extern xdc_Bool ti_sysbios_knl_Queue_isQueued__E( ti_sysbios_knl_Queue_Elem* qelem );

extern xdc_Bool ti_sysbios_knl_Queue_isQueued__F( ti_sysbios_knl_Queue_Elem* qelem );
extern xdc_Bool ti_sysbios_knl_Queue_isQueued__R( ti_sysbios_knl_Queue_Elem* qelem );

/* dequeue__E */

extern xdc_Ptr ti_sysbios_knl_Queue_dequeue__E( ti_sysbios_knl_Queue_Handle __inst );

extern xdc_Ptr ti_sysbios_knl_Queue_dequeue__F( ti_sysbios_knl_Queue_Object* __inst );
extern xdc_Ptr ti_sysbios_knl_Queue_dequeue__R( ti_sysbios_knl_Queue_Handle __inst );

/* empty__E */

extern xdc_Bool ti_sysbios_knl_Queue_empty__E( ti_sysbios_knl_Queue_Handle __inst );

extern xdc_Bool ti_sysbios_knl_Queue_empty__F( ti_sysbios_knl_Queue_Object* __inst );
extern xdc_Bool ti_sysbios_knl_Queue_empty__R( ti_sysbios_knl_Queue_Handle __inst );

/* enqueue__E */

extern void ti_sysbios_knl_Queue_enqueue__E( ti_sysbios_knl_Queue_Handle __inst, ti_sysbios_knl_Queue_Elem* elem );

extern void ti_sysbios_knl_Queue_enqueue__F( ti_sysbios_knl_Queue_Object* __inst, ti_sysbios_knl_Queue_Elem* elem );
extern void ti_sysbios_knl_Queue_enqueue__R( ti_sysbios_knl_Queue_Handle __inst, ti_sysbios_knl_Queue_Elem* elem );

/* get__E */

extern xdc_Ptr ti_sysbios_knl_Queue_get__E( ti_sysbios_knl_Queue_Handle __inst );

extern xdc_Ptr ti_sysbios_knl_Queue_get__F( ti_sysbios_knl_Queue_Object* __inst );
extern xdc_Ptr ti_sysbios_knl_Queue_get__R( ti_sysbios_knl_Queue_Handle __inst );

/* head__E */

extern xdc_Ptr ti_sysbios_knl_Queue_head__E( ti_sysbios_knl_Queue_Handle __inst );

extern xdc_Ptr ti_sysbios_knl_Queue_head__F( ti_sysbios_knl_Queue_Object* __inst );
extern xdc_Ptr ti_sysbios_knl_Queue_head__R( ti_sysbios_knl_Queue_Handle __inst );

/* put__E */

extern void ti_sysbios_knl_Queue_put__E( ti_sysbios_knl_Queue_Handle __inst, ti_sysbios_knl_Queue_Elem* elem );

extern void ti_sysbios_knl_Queue_put__F( ti_sysbios_knl_Queue_Object* __inst, ti_sysbios_knl_Queue_Elem* elem );
extern void ti_sysbios_knl_Queue_put__R( ti_sysbios_knl_Queue_Handle __inst, ti_sysbios_knl_Queue_Elem* elem );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* dequeue_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_knl_Queue_dequeue_FxnT)(void*);
static inline ti_sysbios_knl_Queue_dequeue_FxnT ti_sysbios_knl_Queue_dequeue_fxnP( void )
{
    return (ti_sysbios_knl_Queue_dequeue_FxnT)ti_sysbios_knl_Queue_dequeue__E; 
}

/* empty_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_knl_Queue_empty_FxnT)(void*);
static inline ti_sysbios_knl_Queue_empty_FxnT ti_sysbios_knl_Queue_empty_fxnP( void )
{
    return (ti_sysbios_knl_Queue_empty_FxnT)ti_sysbios_knl_Queue_empty__E; 
}

/* enqueue_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Queue_enqueue_FxnT)(void*, ti_sysbios_knl_Queue_Elem*);
static inline ti_sysbios_knl_Queue_enqueue_FxnT ti_sysbios_knl_Queue_enqueue_fxnP( void )
{
    return (ti_sysbios_knl_Queue_enqueue_FxnT)ti_sysbios_knl_Queue_enqueue__E; 
}

/* get_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_knl_Queue_get_FxnT)(void*);
static inline ti_sysbios_knl_Queue_get_FxnT ti_sysbios_knl_Queue_get_fxnP( void )
{
    return (ti_sysbios_knl_Queue_get_FxnT)ti_sysbios_knl_Queue_get__E; 
}

/* head_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_knl_Queue_head_FxnT)(void*);
static inline ti_sysbios_knl_Queue_head_FxnT ti_sysbios_knl_Queue_head_fxnP( void )
{
    return (ti_sysbios_knl_Queue_head_FxnT)ti_sysbios_knl_Queue_head__E; 
}

/* put_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Queue_put_FxnT)(void*, ti_sysbios_knl_Queue_Elem*);
static inline ti_sysbios_knl_Queue_put_FxnT ti_sysbios_knl_Queue_put_fxnP( void )
{
    return (ti_sysbios_knl_Queue_put_FxnT)ti_sysbios_knl_Queue_put__E; 
}


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_knl_Queue_Module__id ti_sysbios_knl_Queue_Module_id( void ) 
{
    return ti_sysbios_knl_Queue_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_knl_Queue_Module_hasMask( void ) 
{
    return ti_sysbios_knl_Queue_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_knl_Queue_Module_getMask( void ) 
{
    return ti_sysbios_knl_Queue_Module__diagsMask__C != 0 ? *ti_sysbios_knl_Queue_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_knl_Queue_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_knl_Queue_Module__diagsMask__C != 0) *ti_sysbios_knl_Queue_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_knl_Queue_Params_init( ti_sysbios_knl_Queue_Params* prms ) 
{
    if (prms) {
        ti_sysbios_knl_Queue_Params__init__S(prms, 0, sizeof(ti_sysbios_knl_Queue_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_knl_Queue_Params_copy( ti_sysbios_knl_Queue_Params* dst, const ti_sysbios_knl_Queue_Params* src ) 
{
    if (dst) {
        ti_sysbios_knl_Queue_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_knl_Queue_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_knl_Queue_Handle ti_sysbios_knl_Queue_Object_get( ti_sysbios_knl_Queue_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_knl_Queue_Handle)ti_sysbios_knl_Queue_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_knl_Queue_Handle ti_sysbios_knl_Queue_Object_first( void )
{
    return (ti_sysbios_knl_Queue_Handle)ti_sysbios_knl_Queue_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_knl_Queue_Handle ti_sysbios_knl_Queue_Object_next( ti_sysbios_knl_Queue_Object* obj )
{
    return (ti_sysbios_knl_Queue_Handle)ti_sysbios_knl_Queue_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_knl_Queue_Handle_label( ti_sysbios_knl_Queue_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_knl_Queue_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_knl_Queue_Handle_name( ti_sysbios_knl_Queue_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_knl_Queue_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_knl_Queue_Handle ti_sysbios_knl_Queue_create( const ti_sysbios_knl_Queue_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (ti_sysbios_knl_Queue_Handle)ti_sysbios_knl_Queue_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Queue_Params), __eb);
}

/* construct */
static inline void ti_sysbios_knl_Queue_construct( ti_sysbios_knl_Queue_Struct* __obj, const ti_sysbios_knl_Queue_Params* __prms )
{
    ti_sysbios_knl_Queue_Object__create__S(__obj, sizeof (ti_sysbios_knl_Queue_Struct), 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Queue_Params), 0);
}

/* delete */
static inline void ti_sysbios_knl_Queue_delete( ti_sysbios_knl_Queue_Handle* instp )
{
    ti_sysbios_knl_Queue_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_knl_Queue_destruct( ti_sysbios_knl_Queue_Struct* obj )
{
    ti_sysbios_knl_Queue_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_knl_Queue_Handle ti_sysbios_knl_Queue_handle( ti_sysbios_knl_Queue_Struct* str )
{
    return (ti_sysbios_knl_Queue_Handle)str;
}

/* struct */
static inline ti_sysbios_knl_Queue_Struct* ti_sysbios_knl_Queue_struct( ti_sysbios_knl_Queue_Handle inst )
{
    return (ti_sysbios_knl_Queue_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef void (*ti_sysbios_knl_Swi_FuncPtr)(xdc_UArg, xdc_UArg);

/* HookSet */
struct ti_sysbios_knl_Swi_HookSet {
    void (*registerFxn)(xdc_Int);
    void (*createFxn)(ti_sysbios_knl_Swi_Handle, xdc_runtime_Error_Block*);
    void (*readyFxn)(ti_sysbios_knl_Swi_Handle);
    void (*beginFxn)(ti_sysbios_knl_Swi_Handle);
    void (*endFxn)(ti_sysbios_knl_Swi_Handle);
    void (*deleteFxn)(ti_sysbios_knl_Swi_Handle);
};


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_knl_Swi_Args__create {
    ti_sysbios_knl_Swi_FuncPtr fxn;
} ti_sysbios_knl_Swi_Args__create;


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* Instance_State */
typedef xdc_Ptr __T1_ti_sysbios_knl_Swi_Instance_State__hookEnv;
typedef xdc_Ptr *__ARRAY1_ti_sysbios_knl_Swi_Instance_State__hookEnv;
typedef __ARRAY1_ti_sysbios_knl_Swi_Instance_State__hookEnv __TA_ti_sysbios_knl_Swi_Instance_State__hookEnv;

/* Module_State */
typedef ti_sysbios_knl_Queue_Instance_State __T1_ti_sysbios_knl_Swi_Module_State__readyQ;
typedef ti_sysbios_knl_Queue_Instance_State *__ARRAY1_ti_sysbios_knl_Swi_Module_State__readyQ;
typedef __ARRAY1_ti_sysbios_knl_Swi_Module_State__readyQ __TA_ti_sysbios_knl_Swi_Module_State__readyQ;
typedef ti_sysbios_knl_Swi_Handle __T1_ti_sysbios_knl_Swi_Module_State__constructedSwis;
typedef ti_sysbios_knl_Swi_Handle *__ARRAY1_ti_sysbios_knl_Swi_Module_State__constructedSwis;
typedef __ARRAY1_ti_sysbios_knl_Swi_Module_State__constructedSwis __TA_ti_sysbios_knl_Swi_Module_State__constructedSwis;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_knl_Swi_Module__diagsEnabled;
extern far const CT__ti_sysbios_knl_Swi_Module__diagsEnabled ti_sysbios_knl_Swi_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_knl_Swi_Module__diagsIncluded;
extern far const CT__ti_sysbios_knl_Swi_Module__diagsIncluded ti_sysbios_knl_Swi_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_knl_Swi_Module__diagsMask;
extern far const CT__ti_sysbios_knl_Swi_Module__diagsMask ti_sysbios_knl_Swi_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Swi_Module__gateObj;
extern far const CT__ti_sysbios_knl_Swi_Module__gateObj ti_sysbios_knl_Swi_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_knl_Swi_Module__gatePrms;
extern far const CT__ti_sysbios_knl_Swi_Module__gatePrms ti_sysbios_knl_Swi_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_knl_Swi_Module__id;
extern far const CT__ti_sysbios_knl_Swi_Module__id ti_sysbios_knl_Swi_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_knl_Swi_Module__loggerDefined;
extern far const CT__ti_sysbios_knl_Swi_Module__loggerDefined ti_sysbios_knl_Swi_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Swi_Module__loggerObj;
extern far const CT__ti_sysbios_knl_Swi_Module__loggerObj ti_sysbios_knl_Swi_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_knl_Swi_Module__loggerFxn0;
extern far const CT__ti_sysbios_knl_Swi_Module__loggerFxn0 ti_sysbios_knl_Swi_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_knl_Swi_Module__loggerFxn1;
extern far const CT__ti_sysbios_knl_Swi_Module__loggerFxn1 ti_sysbios_knl_Swi_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_knl_Swi_Module__loggerFxn2;
extern far const CT__ti_sysbios_knl_Swi_Module__loggerFxn2 ti_sysbios_knl_Swi_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_knl_Swi_Module__loggerFxn4;
extern far const CT__ti_sysbios_knl_Swi_Module__loggerFxn4 ti_sysbios_knl_Swi_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_knl_Swi_Module__loggerFxn8;
extern far const CT__ti_sysbios_knl_Swi_Module__loggerFxn8 ti_sysbios_knl_Swi_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_knl_Swi_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_knl_Swi_Module__startupDoneFxn ti_sysbios_knl_Swi_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_knl_Swi_Object__count;
extern far const CT__ti_sysbios_knl_Swi_Object__count ti_sysbios_knl_Swi_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_knl_Swi_Object__heap;
extern far const CT__ti_sysbios_knl_Swi_Object__heap ti_sysbios_knl_Swi_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_knl_Swi_Object__sizeof;
extern far const CT__ti_sysbios_knl_Swi_Object__sizeof ti_sysbios_knl_Swi_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_knl_Swi_Object__table;
extern far const CT__ti_sysbios_knl_Swi_Object__table ti_sysbios_knl_Swi_Object__table__C;

/* LM_begin */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Swi_LM_begin;
extern far const CT__ti_sysbios_knl_Swi_LM_begin ti_sysbios_knl_Swi_LM_begin__C;

/* LD_end */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Swi_LD_end;
extern far const CT__ti_sysbios_knl_Swi_LD_end ti_sysbios_knl_Swi_LD_end__C;

/* LM_post */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Swi_LM_post;
extern far const CT__ti_sysbios_knl_Swi_LM_post ti_sysbios_knl_Swi_LM_post__C;

/* A_swiDisabled */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Swi_A_swiDisabled;
extern far const CT__ti_sysbios_knl_Swi_A_swiDisabled ti_sysbios_knl_Swi_A_swiDisabled__C;

/* A_badPriority */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Swi_A_badPriority;
extern far const CT__ti_sysbios_knl_Swi_A_badPriority ti_sysbios_knl_Swi_A_badPriority__C;

/* numPriorities */
typedef xdc_UInt CT__ti_sysbios_knl_Swi_numPriorities;
extern far const CT__ti_sysbios_knl_Swi_numPriorities ti_sysbios_knl_Swi_numPriorities__C;

/* hooks */
typedef ti_sysbios_knl_Swi_HookSet __T1_ti_sysbios_knl_Swi_hooks;
typedef struct { int length; ti_sysbios_knl_Swi_HookSet *elem; } __ARRAY1_ti_sysbios_knl_Swi_hooks;
typedef __ARRAY1_ti_sysbios_knl_Swi_hooks __TA_ti_sysbios_knl_Swi_hooks;
typedef __TA_ti_sysbios_knl_Swi_hooks CT__ti_sysbios_knl_Swi_hooks;
extern far const CT__ti_sysbios_knl_Swi_hooks ti_sysbios_knl_Swi_hooks__C;

/* taskDisable */
typedef xdc_UInt (*CT__ti_sysbios_knl_Swi_taskDisable)(void);
extern far const CT__ti_sysbios_knl_Swi_taskDisable ti_sysbios_knl_Swi_taskDisable__C;

/* taskRestore */
typedef void (*CT__ti_sysbios_knl_Swi_taskRestore)(xdc_UInt);
extern far const CT__ti_sysbios_knl_Swi_taskRestore ti_sysbios_knl_Swi_taskRestore__C;

/* numConstructedSwis */
typedef xdc_UInt CT__ti_sysbios_knl_Swi_numConstructedSwis;
extern far const CT__ti_sysbios_knl_Swi_numConstructedSwis ti_sysbios_knl_Swi_numConstructedSwis__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_knl_Swi_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_UArg arg0;
    xdc_UArg arg1;
    xdc_UInt priority;
    xdc_UInt trigger;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_knl_Swi_Struct {
    ti_sysbios_knl_Queue_Elem __f0;
    ti_sysbios_knl_Swi_FuncPtr __f1;
    xdc_UArg __f2;
    xdc_UArg __f3;
    xdc_UInt __f4;
    xdc_UInt __f5;
    xdc_Bool __f6;
    xdc_UInt __f7;
    xdc_UInt __f8;
    ti_sysbios_knl_Queue_Handle __f9;
    __TA_ti_sysbios_knl_Swi_Instance_State__hookEnv __f10;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_knl_Swi_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_knl_Swi_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_knl_Swi_Module_startup__R( xdc_Int state );

/* Instance_init__F */

extern int ti_sysbios_knl_Swi_Instance_init__F( ti_sysbios_knl_Swi_Object*, ti_sysbios_knl_Swi_FuncPtr fxn, const ti_sysbios_knl_Swi_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__F */

extern void ti_sysbios_knl_Swi_Instance_finalize__F( ti_sysbios_knl_Swi_Object* , int );

/* Instance_init__R */

extern int ti_sysbios_knl_Swi_Instance_init__R( ti_sysbios_knl_Swi_Object*, ti_sysbios_knl_Swi_FuncPtr fxn, const ti_sysbios_knl_Swi_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__R */

extern void ti_sysbios_knl_Swi_Instance_finalize__R( ti_sysbios_knl_Swi_Object* , int );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_knl_Swi_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_knl_Swi_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_knl_Swi_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_knl_Swi_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_knl_Swi_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_knl_Swi_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_knl_Swi_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_knl_Swi_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_knl_Swi_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* startup__E */

extern void ti_sysbios_knl_Swi_startup__E( void );

extern void ti_sysbios_knl_Swi_startup__F( void );
extern void ti_sysbios_knl_Swi_startup__R( void );

/* enabled__E */

extern xdc_Bool ti_sysbios_knl_Swi_enabled__E( void );

extern xdc_Bool ti_sysbios_knl_Swi_enabled__F( void );
extern xdc_Bool ti_sysbios_knl_Swi_enabled__R( void );

/* disable__E */

extern xdc_UInt ti_sysbios_knl_Swi_disable__E( void );

extern xdc_UInt ti_sysbios_knl_Swi_disable__F( void );
extern xdc_UInt ti_sysbios_knl_Swi_disable__R( void );

/* enable__E */

extern void ti_sysbios_knl_Swi_enable__E( void );

extern void ti_sysbios_knl_Swi_enable__F( void );
extern void ti_sysbios_knl_Swi_enable__R( void );

/* restore__E */

extern void ti_sysbios_knl_Swi_restore__E( xdc_UInt key );

extern void ti_sysbios_knl_Swi_restore__F( xdc_UInt key );
extern void ti_sysbios_knl_Swi_restore__R( xdc_UInt key );

/* restoreHwi__E */

extern void ti_sysbios_knl_Swi_restoreHwi__E( xdc_UInt key );

extern void ti_sysbios_knl_Swi_restoreHwi__F( xdc_UInt key );
extern void ti_sysbios_knl_Swi_restoreHwi__R( xdc_UInt key );

/* self__E */

extern ti_sysbios_knl_Swi_Handle ti_sysbios_knl_Swi_self__E( void );

extern ti_sysbios_knl_Swi_Handle ti_sysbios_knl_Swi_self__F( void );
extern ti_sysbios_knl_Swi_Handle ti_sysbios_knl_Swi_self__R( void );

/* getTrigger__E */

extern xdc_UInt ti_sysbios_knl_Swi_getTrigger__E( void );

extern xdc_UInt ti_sysbios_knl_Swi_getTrigger__F( void );
extern xdc_UInt ti_sysbios_knl_Swi_getTrigger__R( void );

/* raisePri__E */

extern xdc_UInt ti_sysbios_knl_Swi_raisePri__E( xdc_UInt priority );

extern xdc_UInt ti_sysbios_knl_Swi_raisePri__F( xdc_UInt priority );
extern xdc_UInt ti_sysbios_knl_Swi_raisePri__R( xdc_UInt priority );

/* restorePri__E */

extern void ti_sysbios_knl_Swi_restorePri__E( xdc_UInt key );

extern void ti_sysbios_knl_Swi_restorePri__F( xdc_UInt key );
extern void ti_sysbios_knl_Swi_restorePri__R( xdc_UInt key );

/* andn__E */

extern void ti_sysbios_knl_Swi_andn__E( ti_sysbios_knl_Swi_Handle __inst, xdc_UInt mask );

extern void ti_sysbios_knl_Swi_andn__F( ti_sysbios_knl_Swi_Object* __inst, xdc_UInt mask );
extern void ti_sysbios_knl_Swi_andn__R( ti_sysbios_knl_Swi_Handle __inst, xdc_UInt mask );

/* dec__E */

extern void ti_sysbios_knl_Swi_dec__E( ti_sysbios_knl_Swi_Handle __inst );

extern void ti_sysbios_knl_Swi_dec__F( ti_sysbios_knl_Swi_Object* __inst );
extern void ti_sysbios_knl_Swi_dec__R( ti_sysbios_knl_Swi_Handle __inst );

/* getHookContext__E */

extern xdc_Ptr ti_sysbios_knl_Swi_getHookContext__E( ti_sysbios_knl_Swi_Handle __inst, xdc_Int id );

extern xdc_Ptr ti_sysbios_knl_Swi_getHookContext__F( ti_sysbios_knl_Swi_Object* __inst, xdc_Int id );
extern xdc_Ptr ti_sysbios_knl_Swi_getHookContext__R( ti_sysbios_knl_Swi_Handle __inst, xdc_Int id );

/* setHookContext__E */

extern void ti_sysbios_knl_Swi_setHookContext__E( ti_sysbios_knl_Swi_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

extern void ti_sysbios_knl_Swi_setHookContext__F( ti_sysbios_knl_Swi_Object* __inst, xdc_Int id, xdc_Ptr hookContext );
extern void ti_sysbios_knl_Swi_setHookContext__R( ti_sysbios_knl_Swi_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

/* getPri__E */

extern xdc_UInt ti_sysbios_knl_Swi_getPri__E( ti_sysbios_knl_Swi_Handle __inst );

extern xdc_UInt ti_sysbios_knl_Swi_getPri__F( ti_sysbios_knl_Swi_Object* __inst );
extern xdc_UInt ti_sysbios_knl_Swi_getPri__R( ti_sysbios_knl_Swi_Handle __inst );

/* getFunc__E */

extern ti_sysbios_knl_Swi_FuncPtr ti_sysbios_knl_Swi_getFunc__E( ti_sysbios_knl_Swi_Handle __inst, xdc_UArg* arg0, xdc_UArg* arg1 );

extern ti_sysbios_knl_Swi_FuncPtr ti_sysbios_knl_Swi_getFunc__F( ti_sysbios_knl_Swi_Object* __inst, xdc_UArg* arg0, xdc_UArg* arg1 );
extern ti_sysbios_knl_Swi_FuncPtr ti_sysbios_knl_Swi_getFunc__R( ti_sysbios_knl_Swi_Handle __inst, xdc_UArg* arg0, xdc_UArg* arg1 );

/* inc__E */

extern void ti_sysbios_knl_Swi_inc__E( ti_sysbios_knl_Swi_Handle __inst );

extern void ti_sysbios_knl_Swi_inc__F( ti_sysbios_knl_Swi_Object* __inst );
extern void ti_sysbios_knl_Swi_inc__R( ti_sysbios_knl_Swi_Handle __inst );

/* or__E */

extern void ti_sysbios_knl_Swi_or__E( ti_sysbios_knl_Swi_Handle __inst, xdc_UInt mask );

extern void ti_sysbios_knl_Swi_or__F( ti_sysbios_knl_Swi_Object* __inst, xdc_UInt mask );
extern void ti_sysbios_knl_Swi_or__R( ti_sysbios_knl_Swi_Handle __inst, xdc_UInt mask );

/* post__E */

extern void ti_sysbios_knl_Swi_post__E( ti_sysbios_knl_Swi_Handle __inst );

extern void ti_sysbios_knl_Swi_post__F( ti_sysbios_knl_Swi_Object* __inst );
extern void ti_sysbios_knl_Swi_post__R( ti_sysbios_knl_Swi_Handle __inst );

/* schedule__I */

extern void ti_sysbios_knl_Swi_schedule__I( void );

/* run__I */

extern void ti_sysbios_knl_Swi_run__I( ti_sysbios_knl_Swi_Object* swi );

/* postInit__I */

extern xdc_Int ti_sysbios_knl_Swi_postInit__I( ti_sysbios_knl_Swi_Object* swi, xdc_runtime_Error_Block* eb );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* andn_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Swi_andn_FxnT)(void*, xdc_UInt);
static inline ti_sysbios_knl_Swi_andn_FxnT ti_sysbios_knl_Swi_andn_fxnP( void )
{
    return (ti_sysbios_knl_Swi_andn_FxnT)ti_sysbios_knl_Swi_andn__E; 
}

/* dec_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Swi_dec_FxnT)(void*);
static inline ti_sysbios_knl_Swi_dec_FxnT ti_sysbios_knl_Swi_dec_fxnP( void )
{
    return (ti_sysbios_knl_Swi_dec_FxnT)ti_sysbios_knl_Swi_dec__E; 
}

/* getHookContext_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_knl_Swi_getHookContext_FxnT)(void*, xdc_Int);
static inline ti_sysbios_knl_Swi_getHookContext_FxnT ti_sysbios_knl_Swi_getHookContext_fxnP( void )
{
    return (ti_sysbios_knl_Swi_getHookContext_FxnT)ti_sysbios_knl_Swi_getHookContext__E; 
}

/* setHookContext_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Swi_setHookContext_FxnT)(void*, xdc_Int, xdc_Ptr);
static inline ti_sysbios_knl_Swi_setHookContext_FxnT ti_sysbios_knl_Swi_setHookContext_fxnP( void )
{
    return (ti_sysbios_knl_Swi_setHookContext_FxnT)ti_sysbios_knl_Swi_setHookContext__E; 
}

/* getPri_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_knl_Swi_getPri_FxnT)(void*);
static inline ti_sysbios_knl_Swi_getPri_FxnT ti_sysbios_knl_Swi_getPri_fxnP( void )
{
    return (ti_sysbios_knl_Swi_getPri_FxnT)ti_sysbios_knl_Swi_getPri__E; 
}

/* getFunc_{FxnT,fxnP} */
typedef ti_sysbios_knl_Swi_FuncPtr (*ti_sysbios_knl_Swi_getFunc_FxnT)(void*, xdc_UArg*, xdc_UArg*);
static inline ti_sysbios_knl_Swi_getFunc_FxnT ti_sysbios_knl_Swi_getFunc_fxnP( void )
{
    return (ti_sysbios_knl_Swi_getFunc_FxnT)ti_sysbios_knl_Swi_getFunc__E; 
}

/* inc_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Swi_inc_FxnT)(void*);
static inline ti_sysbios_knl_Swi_inc_FxnT ti_sysbios_knl_Swi_inc_fxnP( void )
{
    return (ti_sysbios_knl_Swi_inc_FxnT)ti_sysbios_knl_Swi_inc__E; 
}

/* or_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Swi_or_FxnT)(void*, xdc_UInt);
static inline ti_sysbios_knl_Swi_or_FxnT ti_sysbios_knl_Swi_or_fxnP( void )
{
    return (ti_sysbios_knl_Swi_or_FxnT)ti_sysbios_knl_Swi_or__E; 
}

/* post_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Swi_post_FxnT)(void*);
static inline ti_sysbios_knl_Swi_post_FxnT ti_sysbios_knl_Swi_post_fxnP( void )
{
    return (ti_sysbios_knl_Swi_post_FxnT)ti_sysbios_knl_Swi_post__E; 
}


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_knl_Swi_Module__id ti_sysbios_knl_Swi_Module_id( void ) 
{
    return ti_sysbios_knl_Swi_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_knl_Swi_Module_hasMask( void ) 
{
    return ti_sysbios_knl_Swi_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_knl_Swi_Module_getMask( void ) 
{
    return ti_sysbios_knl_Swi_Module__diagsMask__C != 0 ? *ti_sysbios_knl_Swi_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_knl_Swi_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_knl_Swi_Module__diagsMask__C != 0) *ti_sysbios_knl_Swi_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_knl_Swi_Params_init( ti_sysbios_knl_Swi_Params* prms ) 
{
    if (prms) {
        ti_sysbios_knl_Swi_Params__init__S(prms, 0, sizeof(ti_sysbios_knl_Swi_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_knl_Swi_Params_copy( ti_sysbios_knl_Swi_Params* dst, const ti_sysbios_knl_Swi_Params* src ) 
{
    if (dst) {
        ti_sysbios_knl_Swi_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_knl_Swi_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_knl_Swi_Handle ti_sysbios_knl_Swi_Object_get( ti_sysbios_knl_Swi_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_knl_Swi_Handle)ti_sysbios_knl_Swi_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_knl_Swi_Handle ti_sysbios_knl_Swi_Object_first( void )
{
    return (ti_sysbios_knl_Swi_Handle)ti_sysbios_knl_Swi_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_knl_Swi_Handle ti_sysbios_knl_Swi_Object_next( ti_sysbios_knl_Swi_Object* obj )
{
    return (ti_sysbios_knl_Swi_Handle)ti_sysbios_knl_Swi_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_knl_Swi_Handle_label( ti_sysbios_knl_Swi_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_knl_Swi_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_knl_Swi_Handle_name( ti_sysbios_knl_Swi_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_knl_Swi_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_knl_Swi_Handle ti_sysbios_knl_Swi_create( ti_sysbios_knl_Swi_FuncPtr fxn, const ti_sysbios_knl_Swi_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_knl_Swi_Args__create __args;
    __args.fxn = fxn;
    return (ti_sysbios_knl_Swi_Handle)ti_sysbios_knl_Swi_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Swi_Params), __eb);
}

/* construct */
static inline void ti_sysbios_knl_Swi_construct( ti_sysbios_knl_Swi_Struct* __obj, ti_sysbios_knl_Swi_FuncPtr fxn, const ti_sysbios_knl_Swi_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_knl_Swi_Args__create __args;
    __args.fxn = fxn;
    ti_sysbios_knl_Swi_Object__create__S(__obj, sizeof (ti_sysbios_knl_Swi_Struct), &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Swi_Params), __eb);
}

/* delete */
static inline void ti_sysbios_knl_Swi_delete( ti_sysbios_knl_Swi_Handle* instp )
{
    ti_sysbios_knl_Swi_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_knl_Swi_destruct( ti_sysbios_knl_Swi_Struct* obj )
{
    ti_sysbios_knl_Swi_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_knl_Swi_Handle ti_sysbios_knl_Swi_handle( ti_sysbios_knl_Swi_Struct* str )
{
    return (ti_sysbios_knl_Swi_Handle)str;
}

/* struct */
static inline ti_sysbios_knl_Swi_Struct* ti_sysbios_knl_Swi_struct( ti_sysbios_knl_Swi_Handle inst )
{
    return (ti_sysbios_knl_Swi_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* TickSource */
enum ti_sysbios_knl_Clock_TickSource {
    ti_sysbios_knl_Clock_TickSource_TIMER,
    ti_sysbios_knl_Clock_TickSource_USER,
    ti_sysbios_knl_Clock_TickSource_NULL
};
typedef enum ti_sysbios_knl_Clock_TickSource ti_sysbios_knl_Clock_TickSource;

/* TickMode */
enum ti_sysbios_knl_Clock_TickMode {
    ti_sysbios_knl_Clock_TickMode_PERIODIC,
    ti_sysbios_knl_Clock_TickMode_DYNAMIC
};
typedef enum ti_sysbios_knl_Clock_TickMode ti_sysbios_knl_Clock_TickMode;

/* FuncPtr */
typedef void (*ti_sysbios_knl_Clock_FuncPtr)(xdc_UArg);


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_knl_Clock_Args__create {
    ti_sysbios_knl_Clock_FuncPtr clockFxn;
    xdc_UInt timeout;
} ti_sysbios_knl_Clock_Args__create;


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_knl_Clock_Module__diagsEnabled;
extern far const CT__ti_sysbios_knl_Clock_Module__diagsEnabled ti_sysbios_knl_Clock_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_knl_Clock_Module__diagsIncluded;
extern far const CT__ti_sysbios_knl_Clock_Module__diagsIncluded ti_sysbios_knl_Clock_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_knl_Clock_Module__diagsMask;
extern far const CT__ti_sysbios_knl_Clock_Module__diagsMask ti_sysbios_knl_Clock_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Clock_Module__gateObj;
extern far const CT__ti_sysbios_knl_Clock_Module__gateObj ti_sysbios_knl_Clock_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_knl_Clock_Module__gatePrms;
extern far const CT__ti_sysbios_knl_Clock_Module__gatePrms ti_sysbios_knl_Clock_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_knl_Clock_Module__id;
extern far const CT__ti_sysbios_knl_Clock_Module__id ti_sysbios_knl_Clock_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_knl_Clock_Module__loggerDefined;
extern far const CT__ti_sysbios_knl_Clock_Module__loggerDefined ti_sysbios_knl_Clock_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Clock_Module__loggerObj;
extern far const CT__ti_sysbios_knl_Clock_Module__loggerObj ti_sysbios_knl_Clock_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_knl_Clock_Module__loggerFxn0;
extern far const CT__ti_sysbios_knl_Clock_Module__loggerFxn0 ti_sysbios_knl_Clock_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_knl_Clock_Module__loggerFxn1;
extern far const CT__ti_sysbios_knl_Clock_Module__loggerFxn1 ti_sysbios_knl_Clock_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_knl_Clock_Module__loggerFxn2;
extern far const CT__ti_sysbios_knl_Clock_Module__loggerFxn2 ti_sysbios_knl_Clock_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_knl_Clock_Module__loggerFxn4;
extern far const CT__ti_sysbios_knl_Clock_Module__loggerFxn4 ti_sysbios_knl_Clock_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_knl_Clock_Module__loggerFxn8;
extern far const CT__ti_sysbios_knl_Clock_Module__loggerFxn8 ti_sysbios_knl_Clock_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_knl_Clock_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_knl_Clock_Module__startupDoneFxn ti_sysbios_knl_Clock_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_knl_Clock_Object__count;
extern far const CT__ti_sysbios_knl_Clock_Object__count ti_sysbios_knl_Clock_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_knl_Clock_Object__heap;
extern far const CT__ti_sysbios_knl_Clock_Object__heap ti_sysbios_knl_Clock_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_knl_Clock_Object__sizeof;
extern far const CT__ti_sysbios_knl_Clock_Object__sizeof ti_sysbios_knl_Clock_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_knl_Clock_Object__table;
extern far const CT__ti_sysbios_knl_Clock_Object__table ti_sysbios_knl_Clock_Object__table__C;

/* LW_delayed */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Clock_LW_delayed;
extern far const CT__ti_sysbios_knl_Clock_LW_delayed ti_sysbios_knl_Clock_LW_delayed__C;

/* LM_tick */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Clock_LM_tick;
extern far const CT__ti_sysbios_knl_Clock_LM_tick ti_sysbios_knl_Clock_LM_tick__C;

/* LM_begin */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Clock_LM_begin;
extern far const CT__ti_sysbios_knl_Clock_LM_begin ti_sysbios_knl_Clock_LM_begin__C;

/* A_clockDisabled */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Clock_A_clockDisabled;
extern far const CT__ti_sysbios_knl_Clock_A_clockDisabled ti_sysbios_knl_Clock_A_clockDisabled__C;

/* A_badThreadType */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Clock_A_badThreadType;
extern far const CT__ti_sysbios_knl_Clock_A_badThreadType ti_sysbios_knl_Clock_A_badThreadType__C;

/* tickSource */
typedef ti_sysbios_knl_Clock_TickSource CT__ti_sysbios_knl_Clock_tickSource;
extern far const CT__ti_sysbios_knl_Clock_tickSource ti_sysbios_knl_Clock_tickSource__C;

/* tickMode */
typedef ti_sysbios_knl_Clock_TickMode CT__ti_sysbios_knl_Clock_tickMode;
extern far const CT__ti_sysbios_knl_Clock_tickMode ti_sysbios_knl_Clock_tickMode__C;

/* timerId */
typedef xdc_UInt CT__ti_sysbios_knl_Clock_timerId;
extern far const CT__ti_sysbios_knl_Clock_timerId ti_sysbios_knl_Clock_timerId__C;

/* tickPeriod */
typedef xdc_UInt32 CT__ti_sysbios_knl_Clock_tickPeriod;
extern far const CT__ti_sysbios_knl_Clock_tickPeriod ti_sysbios_knl_Clock_tickPeriod__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_knl_Clock_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_Bool startFlag;
    xdc_UInt period;
    xdc_UArg arg;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_knl_Clock_Struct {
    ti_sysbios_knl_Queue_Elem __f0;
    xdc_UInt32 __f1;
    xdc_UInt32 __f2;
    xdc_UInt32 __f3;
    volatile xdc_Bool __f4;
    ti_sysbios_knl_Clock_FuncPtr __f5;
    xdc_UArg __f6;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_knl_Clock_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_knl_Clock_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_knl_Clock_Module_startup__R( xdc_Int state );

/* Instance_init__F */

extern void ti_sysbios_knl_Clock_Instance_init__F( ti_sysbios_knl_Clock_Object*, ti_sysbios_knl_Clock_FuncPtr clockFxn, xdc_UInt timeout, const ti_sysbios_knl_Clock_Params* );

/* Instance_finalize__F */

extern void ti_sysbios_knl_Clock_Instance_finalize__F( ti_sysbios_knl_Clock_Object* );

/* Instance_init__R */

extern void ti_sysbios_knl_Clock_Instance_init__R( ti_sysbios_knl_Clock_Object*, ti_sysbios_knl_Clock_FuncPtr clockFxn, xdc_UInt timeout, const ti_sysbios_knl_Clock_Params* );

/* Instance_finalize__R */

extern void ti_sysbios_knl_Clock_Instance_finalize__R( ti_sysbios_knl_Clock_Object* );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_knl_Clock_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_knl_Clock_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_knl_Clock_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_knl_Clock_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_knl_Clock_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_knl_Clock_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_knl_Clock_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_knl_Clock_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_knl_Clock_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* getTicks__E */

extern xdc_UInt32 ti_sysbios_knl_Clock_getTicks__E( void );

extern xdc_UInt32 ti_sysbios_knl_Clock_getTicks__F( void );
extern xdc_UInt32 ti_sysbios_knl_Clock_getTicks__R( void );

/* getTimerHandle__E */

extern ti_sysbios_hal_Timer_Handle ti_sysbios_knl_Clock_getTimerHandle__E( void );

extern ti_sysbios_hal_Timer_Handle ti_sysbios_knl_Clock_getTimerHandle__F( void );
extern ti_sysbios_hal_Timer_Handle ti_sysbios_knl_Clock_getTimerHandle__R( void );

/* tickStop__E */

extern void ti_sysbios_knl_Clock_tickStop__E( void );

extern void ti_sysbios_knl_Clock_tickStop__F( void );
extern void ti_sysbios_knl_Clock_tickStop__R( void );

/* tickReconfig__E */

extern xdc_Bool ti_sysbios_knl_Clock_tickReconfig__E( void );

extern xdc_Bool ti_sysbios_knl_Clock_tickReconfig__F( void );
extern xdc_Bool ti_sysbios_knl_Clock_tickReconfig__R( void );

/* tickStart__E */

extern void ti_sysbios_knl_Clock_tickStart__E( void );

extern void ti_sysbios_knl_Clock_tickStart__F( void );
extern void ti_sysbios_knl_Clock_tickStart__R( void );

/* tick__E */

extern void ti_sysbios_knl_Clock_tick__E( void );

extern void ti_sysbios_knl_Clock_tick__F( void );
extern void ti_sysbios_knl_Clock_tick__R( void );

/* workFunc__E */

extern void ti_sysbios_knl_Clock_workFunc__E( xdc_UArg arg0, xdc_UArg arg1 );

extern void ti_sysbios_knl_Clock_workFunc__F( xdc_UArg arg0, xdc_UArg arg1 );
extern void ti_sysbios_knl_Clock_workFunc__R( xdc_UArg arg0, xdc_UArg arg1 );

/* workFuncDynamic__E */

extern void ti_sysbios_knl_Clock_workFuncDynamic__E( xdc_UArg arg0, xdc_UArg arg1 );

extern void ti_sysbios_knl_Clock_workFuncDynamic__F( xdc_UArg arg0, xdc_UArg arg1 );
extern void ti_sysbios_knl_Clock_workFuncDynamic__R( xdc_UArg arg0, xdc_UArg arg1 );

/* logTick__E */

extern void ti_sysbios_knl_Clock_logTick__E( void );

extern void ti_sysbios_knl_Clock_logTick__F( void );
extern void ti_sysbios_knl_Clock_logTick__R( void );

/* getCompletedTicks__E */

extern xdc_UInt32 ti_sysbios_knl_Clock_getCompletedTicks__E( void );

extern xdc_UInt32 ti_sysbios_knl_Clock_getCompletedTicks__F( void );
extern xdc_UInt32 ti_sysbios_knl_Clock_getCompletedTicks__R( void );

/* getTickPeriod__E */

extern xdc_UInt32 ti_sysbios_knl_Clock_getTickPeriod__E( void );

extern xdc_UInt32 ti_sysbios_knl_Clock_getTickPeriod__F( void );
extern xdc_UInt32 ti_sysbios_knl_Clock_getTickPeriod__R( void );

/* setupTimerToSkipTicks__E */

extern void ti_sysbios_knl_Clock_setupTimerToSkipTicks__E( xdc_UInt skips );

extern void ti_sysbios_knl_Clock_setupTimerToSkipTicks__F( xdc_UInt skips );
extern void ti_sysbios_knl_Clock_setupTimerToSkipTicks__R( xdc_UInt skips );

/* start__E */

extern void ti_sysbios_knl_Clock_start__E( ti_sysbios_knl_Clock_Handle __inst );

extern void ti_sysbios_knl_Clock_start__F( ti_sysbios_knl_Clock_Object* __inst );
extern void ti_sysbios_knl_Clock_start__R( ti_sysbios_knl_Clock_Handle __inst );

/* startI__E */

extern void ti_sysbios_knl_Clock_startI__E( ti_sysbios_knl_Clock_Handle __inst );

extern void ti_sysbios_knl_Clock_startI__F( ti_sysbios_knl_Clock_Object* __inst );
extern void ti_sysbios_knl_Clock_startI__R( ti_sysbios_knl_Clock_Handle __inst );

/* stop__E */

extern void ti_sysbios_knl_Clock_stop__E( ti_sysbios_knl_Clock_Handle __inst );

extern void ti_sysbios_knl_Clock_stop__F( ti_sysbios_knl_Clock_Object* __inst );
extern void ti_sysbios_knl_Clock_stop__R( ti_sysbios_knl_Clock_Handle __inst );

/* setPeriod__E */

extern void ti_sysbios_knl_Clock_setPeriod__E( ti_sysbios_knl_Clock_Handle __inst, xdc_UInt period );

extern void ti_sysbios_knl_Clock_setPeriod__F( ti_sysbios_knl_Clock_Object* __inst, xdc_UInt period );
extern void ti_sysbios_knl_Clock_setPeriod__R( ti_sysbios_knl_Clock_Handle __inst, xdc_UInt period );

/* setTimeout__E */

extern void ti_sysbios_knl_Clock_setTimeout__E( ti_sysbios_knl_Clock_Handle __inst, xdc_UInt timeout );

extern void ti_sysbios_knl_Clock_setTimeout__F( ti_sysbios_knl_Clock_Object* __inst, xdc_UInt timeout );
extern void ti_sysbios_knl_Clock_setTimeout__R( ti_sysbios_knl_Clock_Handle __inst, xdc_UInt timeout );

/* setFunc__E */

extern void ti_sysbios_knl_Clock_setFunc__E( ti_sysbios_knl_Clock_Handle __inst, ti_sysbios_knl_Clock_FuncPtr fxn, xdc_UArg arg );

extern void ti_sysbios_knl_Clock_setFunc__F( ti_sysbios_knl_Clock_Object* __inst, ti_sysbios_knl_Clock_FuncPtr fxn, xdc_UArg arg );
extern void ti_sysbios_knl_Clock_setFunc__R( ti_sysbios_knl_Clock_Handle __inst, ti_sysbios_knl_Clock_FuncPtr fxn, xdc_UArg arg );

/* getPeriod__E */

extern xdc_UInt ti_sysbios_knl_Clock_getPeriod__E( ti_sysbios_knl_Clock_Handle __inst );

extern xdc_UInt ti_sysbios_knl_Clock_getPeriod__F( ti_sysbios_knl_Clock_Object* __inst );
extern xdc_UInt ti_sysbios_knl_Clock_getPeriod__R( ti_sysbios_knl_Clock_Handle __inst );

/* getTimeout__E */

extern xdc_UInt ti_sysbios_knl_Clock_getTimeout__E( ti_sysbios_knl_Clock_Handle __inst );

extern xdc_UInt ti_sysbios_knl_Clock_getTimeout__F( ti_sysbios_knl_Clock_Object* __inst );
extern xdc_UInt ti_sysbios_knl_Clock_getTimeout__R( ti_sysbios_knl_Clock_Handle __inst );

/* doTick__I */

extern void ti_sysbios_knl_Clock_doTick__I( xdc_UArg arg );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* start_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Clock_start_FxnT)(void*);
static inline ti_sysbios_knl_Clock_start_FxnT ti_sysbios_knl_Clock_start_fxnP( void )
{
    return (ti_sysbios_knl_Clock_start_FxnT)ti_sysbios_knl_Clock_start__E; 
}

/* startI_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Clock_startI_FxnT)(void*);
static inline ti_sysbios_knl_Clock_startI_FxnT ti_sysbios_knl_Clock_startI_fxnP( void )
{
    return (ti_sysbios_knl_Clock_startI_FxnT)ti_sysbios_knl_Clock_startI__E; 
}

/* stop_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Clock_stop_FxnT)(void*);
static inline ti_sysbios_knl_Clock_stop_FxnT ti_sysbios_knl_Clock_stop_fxnP( void )
{
    return (ti_sysbios_knl_Clock_stop_FxnT)ti_sysbios_knl_Clock_stop__E; 
}

/* setPeriod_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Clock_setPeriod_FxnT)(void*, xdc_UInt);
static inline ti_sysbios_knl_Clock_setPeriod_FxnT ti_sysbios_knl_Clock_setPeriod_fxnP( void )
{
    return (ti_sysbios_knl_Clock_setPeriod_FxnT)ti_sysbios_knl_Clock_setPeriod__E; 
}

/* setTimeout_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Clock_setTimeout_FxnT)(void*, xdc_UInt);
static inline ti_sysbios_knl_Clock_setTimeout_FxnT ti_sysbios_knl_Clock_setTimeout_fxnP( void )
{
    return (ti_sysbios_knl_Clock_setTimeout_FxnT)ti_sysbios_knl_Clock_setTimeout__E; 
}

/* setFunc_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Clock_setFunc_FxnT)(void*, ti_sysbios_knl_Clock_FuncPtr, xdc_UArg);
static inline ti_sysbios_knl_Clock_setFunc_FxnT ti_sysbios_knl_Clock_setFunc_fxnP( void )
{
    return (ti_sysbios_knl_Clock_setFunc_FxnT)ti_sysbios_knl_Clock_setFunc__E; 
}

/* getPeriod_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_knl_Clock_getPeriod_FxnT)(void*);
static inline ti_sysbios_knl_Clock_getPeriod_FxnT ti_sysbios_knl_Clock_getPeriod_fxnP( void )
{
    return (ti_sysbios_knl_Clock_getPeriod_FxnT)ti_sysbios_knl_Clock_getPeriod__E; 
}

/* getTimeout_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_knl_Clock_getTimeout_FxnT)(void*);
static inline ti_sysbios_knl_Clock_getTimeout_FxnT ti_sysbios_knl_Clock_getTimeout_fxnP( void )
{
    return (ti_sysbios_knl_Clock_getTimeout_FxnT)ti_sysbios_knl_Clock_getTimeout__E; 
}


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_knl_Clock_Module__id ti_sysbios_knl_Clock_Module_id( void ) 
{
    return ti_sysbios_knl_Clock_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_knl_Clock_Module_hasMask( void ) 
{
    return ti_sysbios_knl_Clock_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_knl_Clock_Module_getMask( void ) 
{
    return ti_sysbios_knl_Clock_Module__diagsMask__C != 0 ? *ti_sysbios_knl_Clock_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_knl_Clock_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_knl_Clock_Module__diagsMask__C != 0) *ti_sysbios_knl_Clock_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_knl_Clock_Params_init( ti_sysbios_knl_Clock_Params* prms ) 
{
    if (prms) {
        ti_sysbios_knl_Clock_Params__init__S(prms, 0, sizeof(ti_sysbios_knl_Clock_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_knl_Clock_Params_copy( ti_sysbios_knl_Clock_Params* dst, const ti_sysbios_knl_Clock_Params* src ) 
{
    if (dst) {
        ti_sysbios_knl_Clock_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_knl_Clock_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_knl_Clock_Handle ti_sysbios_knl_Clock_Object_get( ti_sysbios_knl_Clock_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_knl_Clock_Handle)ti_sysbios_knl_Clock_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_knl_Clock_Handle ti_sysbios_knl_Clock_Object_first( void )
{
    return (ti_sysbios_knl_Clock_Handle)ti_sysbios_knl_Clock_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_knl_Clock_Handle ti_sysbios_knl_Clock_Object_next( ti_sysbios_knl_Clock_Object* obj )
{
    return (ti_sysbios_knl_Clock_Handle)ti_sysbios_knl_Clock_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_knl_Clock_Handle_label( ti_sysbios_knl_Clock_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_knl_Clock_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_knl_Clock_Handle_name( ti_sysbios_knl_Clock_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_knl_Clock_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_knl_Clock_Handle ti_sysbios_knl_Clock_create( ti_sysbios_knl_Clock_FuncPtr clockFxn, xdc_UInt timeout, const ti_sysbios_knl_Clock_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_knl_Clock_Args__create __args;
    __args.clockFxn = clockFxn;
    __args.timeout = timeout;
    return (ti_sysbios_knl_Clock_Handle)ti_sysbios_knl_Clock_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Clock_Params), __eb);
}

/* construct */
static inline void ti_sysbios_knl_Clock_construct( ti_sysbios_knl_Clock_Struct* __obj, ti_sysbios_knl_Clock_FuncPtr clockFxn, xdc_UInt timeout, const ti_sysbios_knl_Clock_Params* __prms )
{
    ti_sysbios_knl_Clock_Args__create __args;
    __args.clockFxn = clockFxn;
    __args.timeout = timeout;
    ti_sysbios_knl_Clock_Object__create__S(__obj, sizeof (ti_sysbios_knl_Clock_Struct), &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Clock_Params), 0);
}

/* delete */
static inline void ti_sysbios_knl_Clock_delete( ti_sysbios_knl_Clock_Handle* instp )
{
    ti_sysbios_knl_Clock_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_knl_Clock_destruct( ti_sysbios_knl_Clock_Struct* obj )
{
    ti_sysbios_knl_Clock_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_knl_Clock_Handle ti_sysbios_knl_Clock_handle( ti_sysbios_knl_Clock_Struct* str )
{
    return (ti_sysbios_knl_Clock_Handle)str;
}

/* struct */
static inline ti_sysbios_knl_Clock_Struct* ti_sysbios_knl_Clock_struct( ti_sysbios_knl_Clock_Handle inst )
{
    return (ti_sysbios_knl_Clock_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:32; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.interfaces; 2, 0, 0, 0,545; 3-20-2012 14:03:23; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef ti_sysbios_interfaces_ITaskSupport_FuncPtr ti_sysbios_knl_Task_SupportProxy_FuncPtr;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_knl_Task_SupportProxy_Module__diagsEnabled;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__diagsEnabled ti_sysbios_knl_Task_SupportProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_knl_Task_SupportProxy_Module__diagsIncluded;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__diagsIncluded ti_sysbios_knl_Task_SupportProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_knl_Task_SupportProxy_Module__diagsMask;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__diagsMask ti_sysbios_knl_Task_SupportProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Task_SupportProxy_Module__gateObj;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__gateObj ti_sysbios_knl_Task_SupportProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_knl_Task_SupportProxy_Module__gatePrms;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__gatePrms ti_sysbios_knl_Task_SupportProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_knl_Task_SupportProxy_Module__id;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__id ti_sysbios_knl_Task_SupportProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerDefined;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerDefined ti_sysbios_knl_Task_SupportProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerObj;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerObj ti_sysbios_knl_Task_SupportProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn0;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn0 ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn1;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn1 ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn2;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn2 ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn4;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn4 ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn8;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn8 ti_sysbios_knl_Task_SupportProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_knl_Task_SupportProxy_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Module__startupDoneFxn ti_sysbios_knl_Task_SupportProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_knl_Task_SupportProxy_Object__count;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Object__count ti_sysbios_knl_Task_SupportProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_knl_Task_SupportProxy_Object__heap;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Object__heap ti_sysbios_knl_Task_SupportProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_knl_Task_SupportProxy_Object__sizeof;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Object__sizeof ti_sysbios_knl_Task_SupportProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_knl_Task_SupportProxy_Object__table;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_Object__table ti_sysbios_knl_Task_SupportProxy_Object__table__C;

/* defaultStackSize */
typedef xdc_SizeT CT__ti_sysbios_knl_Task_SupportProxy_defaultStackSize;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_defaultStackSize ti_sysbios_knl_Task_SupportProxy_defaultStackSize__C;

/* stackAlignment */
typedef xdc_UInt CT__ti_sysbios_knl_Task_SupportProxy_stackAlignment;
extern far const CT__ti_sysbios_knl_Task_SupportProxy_stackAlignment ti_sysbios_knl_Task_SupportProxy_stackAlignment__C;


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_knl_Task_SupportProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Ptr (*start)(xdc_Ptr, ti_sysbios_interfaces_ITaskSupport_FuncPtr, ti_sysbios_interfaces_ITaskSupport_FuncPtr, xdc_runtime_Error_Block*);
    void (*swap)(xdc_Ptr*, xdc_Ptr*);
    xdc_Bool (*checkStack)(xdc_Char*, xdc_SizeT);
    xdc_SizeT (*stackUsed)(xdc_Char*, xdc_SizeT);
    xdc_UInt (*getStackAlignment)(void);
    xdc_SizeT (*getDefaultStackSize)(void);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_knl_Task_SupportProxy_Fxns__ ti_sysbios_knl_Task_SupportProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_knl_Task_SupportProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_knl_Task_SupportProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_knl_Task_SupportProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_knl_Task_SupportProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_knl_Task_SupportProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_knl_Task_SupportProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_knl_Task_SupportProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_knl_Task_SupportProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_knl_Task_SupportProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool ti_sysbios_knl_Task_SupportProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr ti_sysbios_knl_Task_SupportProxy_Proxy__delegate__S( void );

/* start__E */

extern xdc_Ptr ti_sysbios_knl_Task_SupportProxy_start__E( xdc_Ptr curTask, ti_sysbios_interfaces_ITaskSupport_FuncPtr enter, ti_sysbios_interfaces_ITaskSupport_FuncPtr exit, xdc_runtime_Error_Block* eb );

extern xdc_Ptr ti_sysbios_knl_Task_SupportProxy_start__R( xdc_Ptr curTask, ti_sysbios_interfaces_ITaskSupport_FuncPtr enter, ti_sysbios_interfaces_ITaskSupport_FuncPtr exit, xdc_runtime_Error_Block* eb );

/* swap__E */

extern void ti_sysbios_knl_Task_SupportProxy_swap__E( xdc_Ptr* oldtskContext, xdc_Ptr* newtskContext );

extern void ti_sysbios_knl_Task_SupportProxy_swap__R( xdc_Ptr* oldtskContext, xdc_Ptr* newtskContext );

/* checkStack__E */

extern xdc_Bool ti_sysbios_knl_Task_SupportProxy_checkStack__E( xdc_Char* stack, xdc_SizeT size );

extern xdc_Bool ti_sysbios_knl_Task_SupportProxy_checkStack__R( xdc_Char* stack, xdc_SizeT size );

/* stackUsed__E */

extern xdc_SizeT ti_sysbios_knl_Task_SupportProxy_stackUsed__E( xdc_Char* stack, xdc_SizeT size );

extern xdc_SizeT ti_sysbios_knl_Task_SupportProxy_stackUsed__R( xdc_Char* stack, xdc_SizeT size );

/* getStackAlignment__E */

extern xdc_UInt ti_sysbios_knl_Task_SupportProxy_getStackAlignment__E( void );

extern xdc_UInt ti_sysbios_knl_Task_SupportProxy_getStackAlignment__R( void );

/* getDefaultStackSize__E */

extern xdc_SizeT ti_sysbios_knl_Task_SupportProxy_getDefaultStackSize__E( void );

extern xdc_SizeT ti_sysbios_knl_Task_SupportProxy_getDefaultStackSize__R( void );


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline ti_sysbios_interfaces_ITaskSupport_Module ti_sysbios_knl_Task_SupportProxy_Module_upCast( void )
{
    return (ti_sysbios_interfaces_ITaskSupport_Module)ti_sysbios_knl_Task_SupportProxy_Proxy__delegate__S();
}

/* Module_to_ti_sysbios_interfaces_ITaskSupport */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_knl_Task_SupportProxy_Module__id ti_sysbios_knl_Task_SupportProxy_Module_id( void ) 
{
    return ti_sysbios_knl_Task_SupportProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef void (*ti_sysbios_knl_Task_FuncPtr)(xdc_UArg, xdc_UArg);

/* AllBlockedFuncPtr */
typedef void (*ti_sysbios_knl_Task_AllBlockedFuncPtr)(void);

/* Mode */
enum ti_sysbios_knl_Task_Mode {
    ti_sysbios_knl_Task_Mode_RUNNING,
    ti_sysbios_knl_Task_Mode_READY,
    ti_sysbios_knl_Task_Mode_BLOCKED,
    ti_sysbios_knl_Task_Mode_TERMINATED,
    ti_sysbios_knl_Task_Mode_INACTIVE
};
typedef enum ti_sysbios_knl_Task_Mode ti_sysbios_knl_Task_Mode;

/* Stat */
struct ti_sysbios_knl_Task_Stat {
    xdc_Int priority;
    xdc_Ptr stack;
    xdc_SizeT stackSize;
    xdc_runtime_IHeap_Handle stackHeap;
    xdc_Ptr env;
    ti_sysbios_knl_Task_Mode mode;
    xdc_Ptr sp;
    xdc_SizeT used;
};

/* HookSet */
struct ti_sysbios_knl_Task_HookSet {
    void (*registerFxn)(xdc_Int);
    void (*createFxn)(ti_sysbios_knl_Task_Handle, xdc_runtime_Error_Block*);
    void (*readyFxn)(ti_sysbios_knl_Task_Handle);
    void (*switchFxn)(ti_sysbios_knl_Task_Handle, ti_sysbios_knl_Task_Handle);
    void (*exitFxn)(ti_sysbios_knl_Task_Handle);
    void (*deleteFxn)(ti_sysbios_knl_Task_Handle);
};


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_knl_Task_Args__create {
    ti_sysbios_knl_Task_FuncPtr fxn;
} ti_sysbios_knl_Task_Args__create;


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* PendElem */
struct ti_sysbios_knl_Task_PendElem {
    ti_sysbios_knl_Queue_Elem qElem;
    ti_sysbios_knl_Task_Handle task;
    ti_sysbios_knl_Clock_Handle clock;
};

/* Instance_State */
typedef xdc_Char __T1_ti_sysbios_knl_Task_Instance_State__stack;
typedef xdc_Char *__ARRAY1_ti_sysbios_knl_Task_Instance_State__stack;
typedef __ARRAY1_ti_sysbios_knl_Task_Instance_State__stack __TA_ti_sysbios_knl_Task_Instance_State__stack;
typedef xdc_Ptr __T1_ti_sysbios_knl_Task_Instance_State__hookEnv;
typedef xdc_Ptr *__ARRAY1_ti_sysbios_knl_Task_Instance_State__hookEnv;
typedef __ARRAY1_ti_sysbios_knl_Task_Instance_State__hookEnv __TA_ti_sysbios_knl_Task_Instance_State__hookEnv;

/* Module_State */
typedef ti_sysbios_knl_Queue_Instance_State __T1_ti_sysbios_knl_Task_Module_State__readyQ;
typedef ti_sysbios_knl_Queue_Instance_State *__ARRAY1_ti_sysbios_knl_Task_Module_State__readyQ;
typedef __ARRAY1_ti_sysbios_knl_Task_Module_State__readyQ __TA_ti_sysbios_knl_Task_Module_State__readyQ;
typedef ti_sysbios_knl_Task_Handle __T1_ti_sysbios_knl_Task_Module_State__constructedTasks;
typedef ti_sysbios_knl_Task_Handle *__ARRAY1_ti_sysbios_knl_Task_Module_State__constructedTasks;
typedef __ARRAY1_ti_sysbios_knl_Task_Module_State__constructedTasks __TA_ti_sysbios_knl_Task_Module_State__constructedTasks;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_knl_Task_Module__diagsEnabled;
extern far const CT__ti_sysbios_knl_Task_Module__diagsEnabled ti_sysbios_knl_Task_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_knl_Task_Module__diagsIncluded;
extern far const CT__ti_sysbios_knl_Task_Module__diagsIncluded ti_sysbios_knl_Task_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_knl_Task_Module__diagsMask;
extern far const CT__ti_sysbios_knl_Task_Module__diagsMask ti_sysbios_knl_Task_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Task_Module__gateObj;
extern far const CT__ti_sysbios_knl_Task_Module__gateObj ti_sysbios_knl_Task_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_knl_Task_Module__gatePrms;
extern far const CT__ti_sysbios_knl_Task_Module__gatePrms ti_sysbios_knl_Task_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_knl_Task_Module__id;
extern far const CT__ti_sysbios_knl_Task_Module__id ti_sysbios_knl_Task_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_knl_Task_Module__loggerDefined;
extern far const CT__ti_sysbios_knl_Task_Module__loggerDefined ti_sysbios_knl_Task_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Task_Module__loggerObj;
extern far const CT__ti_sysbios_knl_Task_Module__loggerObj ti_sysbios_knl_Task_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_knl_Task_Module__loggerFxn0;
extern far const CT__ti_sysbios_knl_Task_Module__loggerFxn0 ti_sysbios_knl_Task_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_knl_Task_Module__loggerFxn1;
extern far const CT__ti_sysbios_knl_Task_Module__loggerFxn1 ti_sysbios_knl_Task_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_knl_Task_Module__loggerFxn2;
extern far const CT__ti_sysbios_knl_Task_Module__loggerFxn2 ti_sysbios_knl_Task_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_knl_Task_Module__loggerFxn4;
extern far const CT__ti_sysbios_knl_Task_Module__loggerFxn4 ti_sysbios_knl_Task_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_knl_Task_Module__loggerFxn8;
extern far const CT__ti_sysbios_knl_Task_Module__loggerFxn8 ti_sysbios_knl_Task_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_knl_Task_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_knl_Task_Module__startupDoneFxn ti_sysbios_knl_Task_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_knl_Task_Object__count;
extern far const CT__ti_sysbios_knl_Task_Object__count ti_sysbios_knl_Task_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_knl_Task_Object__heap;
extern far const CT__ti_sysbios_knl_Task_Object__heap ti_sysbios_knl_Task_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_knl_Task_Object__sizeof;
extern far const CT__ti_sysbios_knl_Task_Object__sizeof ti_sysbios_knl_Task_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_knl_Task_Object__table;
extern far const CT__ti_sysbios_knl_Task_Object__table ti_sysbios_knl_Task_Object__table__C;

/* LM_switch */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Task_LM_switch;
extern far const CT__ti_sysbios_knl_Task_LM_switch ti_sysbios_knl_Task_LM_switch__C;

/* LM_sleep */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Task_LM_sleep;
extern far const CT__ti_sysbios_knl_Task_LM_sleep ti_sysbios_knl_Task_LM_sleep__C;

/* LD_ready */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Task_LD_ready;
extern far const CT__ti_sysbios_knl_Task_LD_ready ti_sysbios_knl_Task_LD_ready__C;

/* LD_block */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Task_LD_block;
extern far const CT__ti_sysbios_knl_Task_LD_block ti_sysbios_knl_Task_LD_block__C;

/* LM_yield */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Task_LM_yield;
extern far const CT__ti_sysbios_knl_Task_LM_yield ti_sysbios_knl_Task_LM_yield__C;

/* LM_setPri */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Task_LM_setPri;
extern far const CT__ti_sysbios_knl_Task_LM_setPri ti_sysbios_knl_Task_LM_setPri__C;

/* LD_exit */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Task_LD_exit;
extern far const CT__ti_sysbios_knl_Task_LD_exit ti_sysbios_knl_Task_LD_exit__C;

/* E_stackOverflow */
typedef xdc_runtime_Error_Id CT__ti_sysbios_knl_Task_E_stackOverflow;
extern far const CT__ti_sysbios_knl_Task_E_stackOverflow ti_sysbios_knl_Task_E_stackOverflow__C;

/* E_spOutOfBounds */
typedef xdc_runtime_Error_Id CT__ti_sysbios_knl_Task_E_spOutOfBounds;
extern far const CT__ti_sysbios_knl_Task_E_spOutOfBounds ti_sysbios_knl_Task_E_spOutOfBounds__C;

/* A_badThreadType */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Task_A_badThreadType;
extern far const CT__ti_sysbios_knl_Task_A_badThreadType ti_sysbios_knl_Task_A_badThreadType__C;

/* A_badTaskState */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Task_A_badTaskState;
extern far const CT__ti_sysbios_knl_Task_A_badTaskState ti_sysbios_knl_Task_A_badTaskState__C;

/* A_noPendElem */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Task_A_noPendElem;
extern far const CT__ti_sysbios_knl_Task_A_noPendElem ti_sysbios_knl_Task_A_noPendElem__C;

/* A_taskDisabled */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Task_A_taskDisabled;
extern far const CT__ti_sysbios_knl_Task_A_taskDisabled ti_sysbios_knl_Task_A_taskDisabled__C;

/* A_badPriority */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Task_A_badPriority;
extern far const CT__ti_sysbios_knl_Task_A_badPriority ti_sysbios_knl_Task_A_badPriority__C;

/* A_badTimeout */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Task_A_badTimeout;
extern far const CT__ti_sysbios_knl_Task_A_badTimeout ti_sysbios_knl_Task_A_badTimeout__C;

/* numPriorities */
typedef xdc_UInt CT__ti_sysbios_knl_Task_numPriorities;
extern far const CT__ti_sysbios_knl_Task_numPriorities ti_sysbios_knl_Task_numPriorities__C;

/* defaultStackSize */
typedef xdc_SizeT CT__ti_sysbios_knl_Task_defaultStackSize;
extern far const CT__ti_sysbios_knl_Task_defaultStackSize ti_sysbios_knl_Task_defaultStackSize__C;

/* defaultStackHeap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_knl_Task_defaultStackHeap;
extern far const CT__ti_sysbios_knl_Task_defaultStackHeap ti_sysbios_knl_Task_defaultStackHeap__C;

/* allBlockedFunc */
typedef ti_sysbios_knl_Task_AllBlockedFuncPtr CT__ti_sysbios_knl_Task_allBlockedFunc;
extern far const CT__ti_sysbios_knl_Task_allBlockedFunc ti_sysbios_knl_Task_allBlockedFunc__C;

/* initStackFlag */
typedef xdc_Bool CT__ti_sysbios_knl_Task_initStackFlag;
extern far const CT__ti_sysbios_knl_Task_initStackFlag ti_sysbios_knl_Task_initStackFlag__C;

/* deleteTerminatedTasks */
typedef xdc_Bool CT__ti_sysbios_knl_Task_deleteTerminatedTasks;
extern far const CT__ti_sysbios_knl_Task_deleteTerminatedTasks ti_sysbios_knl_Task_deleteTerminatedTasks__C;

/* hooks */
typedef ti_sysbios_knl_Task_HookSet __T1_ti_sysbios_knl_Task_hooks;
typedef struct { int length; ti_sysbios_knl_Task_HookSet *elem; } __ARRAY1_ti_sysbios_knl_Task_hooks;
typedef __ARRAY1_ti_sysbios_knl_Task_hooks __TA_ti_sysbios_knl_Task_hooks;
typedef __TA_ti_sysbios_knl_Task_hooks CT__ti_sysbios_knl_Task_hooks;
extern far const CT__ti_sysbios_knl_Task_hooks ti_sysbios_knl_Task_hooks__C;

/* numConstructedTasks */
typedef xdc_UInt CT__ti_sysbios_knl_Task_numConstructedTasks;
extern far const CT__ti_sysbios_knl_Task_numConstructedTasks ti_sysbios_knl_Task_numConstructedTasks__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_knl_Task_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_UArg arg0;
    xdc_UArg arg1;
    xdc_Int priority;
    xdc_Ptr stack;
    xdc_SizeT stackSize;
    xdc_runtime_IHeap_Handle stackHeap;
    xdc_Ptr env;
    xdc_Bool vitalTaskFlag;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_knl_Task_Struct {
    ti_sysbios_knl_Queue_Elem __f0;
    volatile xdc_Int __f1;
    xdc_UInt __f2;
    xdc_Ptr __f3;
    ti_sysbios_knl_Task_Mode __f4;
    ti_sysbios_knl_Task_PendElem* __f5;
    xdc_SizeT __f6;
    __TA_ti_sysbios_knl_Task_Instance_State__stack __f7;
    xdc_runtime_IHeap_Handle __f8;
    ti_sysbios_knl_Task_FuncPtr __f9;
    xdc_UArg __f10;
    xdc_UArg __f11;
    xdc_Ptr __f12;
    __TA_ti_sysbios_knl_Task_Instance_State__hookEnv __f13;
    xdc_Bool __f14;
    ti_sysbios_knl_Queue_Handle __f15;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_knl_Task_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_knl_Task_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_knl_Task_Module_startup__R( xdc_Int state );

/* Instance_init__F */

extern int ti_sysbios_knl_Task_Instance_init__F( ti_sysbios_knl_Task_Object*, ti_sysbios_knl_Task_FuncPtr fxn, const ti_sysbios_knl_Task_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__F */

extern void ti_sysbios_knl_Task_Instance_finalize__F( ti_sysbios_knl_Task_Object* , int );

/* Instance_init__R */

extern int ti_sysbios_knl_Task_Instance_init__R( ti_sysbios_knl_Task_Object*, ti_sysbios_knl_Task_FuncPtr fxn, const ti_sysbios_knl_Task_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__R */

extern void ti_sysbios_knl_Task_Instance_finalize__R( ti_sysbios_knl_Task_Object* , int );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_knl_Task_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_knl_Task_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_knl_Task_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_knl_Task_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_knl_Task_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_knl_Task_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_knl_Task_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_knl_Task_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_knl_Task_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* startup__E */

extern void ti_sysbios_knl_Task_startup__E( void );

extern void ti_sysbios_knl_Task_startup__F( void );
extern void ti_sysbios_knl_Task_startup__R( void );

/* disable__E */

extern xdc_UInt ti_sysbios_knl_Task_disable__E( void );

extern xdc_UInt ti_sysbios_knl_Task_disable__F( void );
extern xdc_UInt ti_sysbios_knl_Task_disable__R( void );

/* enable__E */

extern void ti_sysbios_knl_Task_enable__E( void );

extern void ti_sysbios_knl_Task_enable__F( void );
extern void ti_sysbios_knl_Task_enable__R( void );

/* restore__E */

extern void ti_sysbios_knl_Task_restore__E( xdc_UInt key );

extern void ti_sysbios_knl_Task_restore__F( xdc_UInt key );
extern void ti_sysbios_knl_Task_restore__R( xdc_UInt key );

/* restoreHwi__E */

extern void ti_sysbios_knl_Task_restoreHwi__E( xdc_UInt key );

extern void ti_sysbios_knl_Task_restoreHwi__F( xdc_UInt key );
extern void ti_sysbios_knl_Task_restoreHwi__R( xdc_UInt key );

/* self__E */

extern ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_self__E( void );

extern ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_self__F( void );
extern ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_self__R( void );

/* checkStacks__E */

extern void ti_sysbios_knl_Task_checkStacks__E( ti_sysbios_knl_Task_Handle oldTask, ti_sysbios_knl_Task_Handle newTask );

extern void ti_sysbios_knl_Task_checkStacks__F( ti_sysbios_knl_Task_Handle oldTask, ti_sysbios_knl_Task_Handle newTask );
extern void ti_sysbios_knl_Task_checkStacks__R( ti_sysbios_knl_Task_Handle oldTask, ti_sysbios_knl_Task_Handle newTask );

/* exit__E */

extern void ti_sysbios_knl_Task_exit__E( void );

extern void ti_sysbios_knl_Task_exit__F( void );
extern void ti_sysbios_knl_Task_exit__R( void );

/* sleep__E */

extern void ti_sysbios_knl_Task_sleep__E( xdc_UInt nticks );

extern void ti_sysbios_knl_Task_sleep__F( xdc_UInt nticks );
extern void ti_sysbios_knl_Task_sleep__R( xdc_UInt nticks );

/* yield__E */

extern void ti_sysbios_knl_Task_yield__E( void );

extern void ti_sysbios_knl_Task_yield__F( void );
extern void ti_sysbios_knl_Task_yield__R( void );

/* getIdleTask__E */

extern ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_getIdleTask__E( void );

extern ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_getIdleTask__F( void );
extern ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_getIdleTask__R( void );

/* getArg0__E */

extern xdc_UArg ti_sysbios_knl_Task_getArg0__E( ti_sysbios_knl_Task_Handle __inst );

extern xdc_UArg ti_sysbios_knl_Task_getArg0__F( ti_sysbios_knl_Task_Object* __inst );
extern xdc_UArg ti_sysbios_knl_Task_getArg0__R( ti_sysbios_knl_Task_Handle __inst );

/* getArg1__E */

extern xdc_UArg ti_sysbios_knl_Task_getArg1__E( ti_sysbios_knl_Task_Handle __inst );

extern xdc_UArg ti_sysbios_knl_Task_getArg1__F( ti_sysbios_knl_Task_Object* __inst );
extern xdc_UArg ti_sysbios_knl_Task_getArg1__R( ti_sysbios_knl_Task_Handle __inst );

/* getEnv__E */

extern xdc_Ptr ti_sysbios_knl_Task_getEnv__E( ti_sysbios_knl_Task_Handle __inst );

extern xdc_Ptr ti_sysbios_knl_Task_getEnv__F( ti_sysbios_knl_Task_Object* __inst );
extern xdc_Ptr ti_sysbios_knl_Task_getEnv__R( ti_sysbios_knl_Task_Handle __inst );

/* getHookContext__E */

extern xdc_Ptr ti_sysbios_knl_Task_getHookContext__E( ti_sysbios_knl_Task_Handle __inst, xdc_Int id );

extern xdc_Ptr ti_sysbios_knl_Task_getHookContext__F( ti_sysbios_knl_Task_Object* __inst, xdc_Int id );
extern xdc_Ptr ti_sysbios_knl_Task_getHookContext__R( ti_sysbios_knl_Task_Handle __inst, xdc_Int id );

/* getPri__E */

extern xdc_Int ti_sysbios_knl_Task_getPri__E( ti_sysbios_knl_Task_Handle __inst );

extern xdc_Int ti_sysbios_knl_Task_getPri__F( ti_sysbios_knl_Task_Object* __inst );
extern xdc_Int ti_sysbios_knl_Task_getPri__R( ti_sysbios_knl_Task_Handle __inst );

/* setArg0__E */

extern void ti_sysbios_knl_Task_setArg0__E( ti_sysbios_knl_Task_Handle __inst, xdc_UArg arg );

extern void ti_sysbios_knl_Task_setArg0__F( ti_sysbios_knl_Task_Object* __inst, xdc_UArg arg );
extern void ti_sysbios_knl_Task_setArg0__R( ti_sysbios_knl_Task_Handle __inst, xdc_UArg arg );

/* setArg1__E */

extern void ti_sysbios_knl_Task_setArg1__E( ti_sysbios_knl_Task_Handle __inst, xdc_UArg arg );

extern void ti_sysbios_knl_Task_setArg1__F( ti_sysbios_knl_Task_Object* __inst, xdc_UArg arg );
extern void ti_sysbios_knl_Task_setArg1__R( ti_sysbios_knl_Task_Handle __inst, xdc_UArg arg );

/* setEnv__E */

extern void ti_sysbios_knl_Task_setEnv__E( ti_sysbios_knl_Task_Handle __inst, xdc_Ptr env );

extern void ti_sysbios_knl_Task_setEnv__F( ti_sysbios_knl_Task_Object* __inst, xdc_Ptr env );
extern void ti_sysbios_knl_Task_setEnv__R( ti_sysbios_knl_Task_Handle __inst, xdc_Ptr env );

/* setHookContext__E */

extern void ti_sysbios_knl_Task_setHookContext__E( ti_sysbios_knl_Task_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

extern void ti_sysbios_knl_Task_setHookContext__F( ti_sysbios_knl_Task_Object* __inst, xdc_Int id, xdc_Ptr hookContext );
extern void ti_sysbios_knl_Task_setHookContext__R( ti_sysbios_knl_Task_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

/* setPri__E */

extern xdc_UInt ti_sysbios_knl_Task_setPri__E( ti_sysbios_knl_Task_Handle __inst, xdc_Int newpri );

extern xdc_UInt ti_sysbios_knl_Task_setPri__F( ti_sysbios_knl_Task_Object* __inst, xdc_Int newpri );
extern xdc_UInt ti_sysbios_knl_Task_setPri__R( ti_sysbios_knl_Task_Handle __inst, xdc_Int newpri );

/* stat__E */

extern void ti_sysbios_knl_Task_stat__E( ti_sysbios_knl_Task_Handle __inst, ti_sysbios_knl_Task_Stat* statbuf );

extern void ti_sysbios_knl_Task_stat__F( ti_sysbios_knl_Task_Object* __inst, ti_sysbios_knl_Task_Stat* statbuf );
extern void ti_sysbios_knl_Task_stat__R( ti_sysbios_knl_Task_Handle __inst, ti_sysbios_knl_Task_Stat* statbuf );

/* getMode__E */

extern ti_sysbios_knl_Task_Mode ti_sysbios_knl_Task_getMode__E( ti_sysbios_knl_Task_Handle __inst );

extern ti_sysbios_knl_Task_Mode ti_sysbios_knl_Task_getMode__F( ti_sysbios_knl_Task_Object* __inst );
extern ti_sysbios_knl_Task_Mode ti_sysbios_knl_Task_getMode__R( ti_sysbios_knl_Task_Handle __inst );

/* block__E */

extern void ti_sysbios_knl_Task_block__E( ti_sysbios_knl_Task_Handle __inst );

extern void ti_sysbios_knl_Task_block__F( ti_sysbios_knl_Task_Object* __inst );
extern void ti_sysbios_knl_Task_block__R( ti_sysbios_knl_Task_Handle __inst );

/* unblock__E */

extern void ti_sysbios_knl_Task_unblock__E( ti_sysbios_knl_Task_Handle __inst );

extern void ti_sysbios_knl_Task_unblock__F( ti_sysbios_knl_Task_Object* __inst );
extern void ti_sysbios_knl_Task_unblock__R( ti_sysbios_knl_Task_Handle __inst );

/* blockI__E */

extern void ti_sysbios_knl_Task_blockI__E( ti_sysbios_knl_Task_Handle __inst );

extern void ti_sysbios_knl_Task_blockI__F( ti_sysbios_knl_Task_Object* __inst );
extern void ti_sysbios_knl_Task_blockI__R( ti_sysbios_knl_Task_Handle __inst );

/* unblockI__E */

extern void ti_sysbios_knl_Task_unblockI__E( ti_sysbios_knl_Task_Handle __inst, xdc_UInt hwiKey );

extern void ti_sysbios_knl_Task_unblockI__F( ti_sysbios_knl_Task_Object* __inst, xdc_UInt hwiKey );
extern void ti_sysbios_knl_Task_unblockI__R( ti_sysbios_knl_Task_Handle __inst, xdc_UInt hwiKey );

/* schedule__I */

extern void ti_sysbios_knl_Task_schedule__I( void );

/* enter__I */

extern void ti_sysbios_knl_Task_enter__I( void );

/* sleepTimeout__I */

extern void ti_sysbios_knl_Task_sleepTimeout__I( xdc_UArg arg );

/* postInit__I */

extern xdc_Int ti_sysbios_knl_Task_postInit__I( ti_sysbios_knl_Task_Object* swi, xdc_runtime_Error_Block* eb );

/* allBlockedFunction__I */

extern void ti_sysbios_knl_Task_allBlockedFunction__I( void );

/* deleteTerminatedTasksFunc__I */

extern void ti_sysbios_knl_Task_deleteTerminatedTasksFunc__I( void );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getArg0_{FxnT,fxnP} */
typedef xdc_UArg (*ti_sysbios_knl_Task_getArg0_FxnT)(void*);
static inline ti_sysbios_knl_Task_getArg0_FxnT ti_sysbios_knl_Task_getArg0_fxnP( void )
{
    return (ti_sysbios_knl_Task_getArg0_FxnT)ti_sysbios_knl_Task_getArg0__E; 
}

/* getArg1_{FxnT,fxnP} */
typedef xdc_UArg (*ti_sysbios_knl_Task_getArg1_FxnT)(void*);
static inline ti_sysbios_knl_Task_getArg1_FxnT ti_sysbios_knl_Task_getArg1_fxnP( void )
{
    return (ti_sysbios_knl_Task_getArg1_FxnT)ti_sysbios_knl_Task_getArg1__E; 
}

/* getEnv_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_knl_Task_getEnv_FxnT)(void*);
static inline ti_sysbios_knl_Task_getEnv_FxnT ti_sysbios_knl_Task_getEnv_fxnP( void )
{
    return (ti_sysbios_knl_Task_getEnv_FxnT)ti_sysbios_knl_Task_getEnv__E; 
}

/* getHookContext_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_knl_Task_getHookContext_FxnT)(void*, xdc_Int);
static inline ti_sysbios_knl_Task_getHookContext_FxnT ti_sysbios_knl_Task_getHookContext_fxnP( void )
{
    return (ti_sysbios_knl_Task_getHookContext_FxnT)ti_sysbios_knl_Task_getHookContext__E; 
}

/* getPri_{FxnT,fxnP} */
typedef xdc_Int (*ti_sysbios_knl_Task_getPri_FxnT)(void*);
static inline ti_sysbios_knl_Task_getPri_FxnT ti_sysbios_knl_Task_getPri_fxnP( void )
{
    return (ti_sysbios_knl_Task_getPri_FxnT)ti_sysbios_knl_Task_getPri__E; 
}

/* setArg0_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_setArg0_FxnT)(void*, xdc_UArg);
static inline ti_sysbios_knl_Task_setArg0_FxnT ti_sysbios_knl_Task_setArg0_fxnP( void )
{
    return (ti_sysbios_knl_Task_setArg0_FxnT)ti_sysbios_knl_Task_setArg0__E; 
}

/* setArg1_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_setArg1_FxnT)(void*, xdc_UArg);
static inline ti_sysbios_knl_Task_setArg1_FxnT ti_sysbios_knl_Task_setArg1_fxnP( void )
{
    return (ti_sysbios_knl_Task_setArg1_FxnT)ti_sysbios_knl_Task_setArg1__E; 
}

/* setEnv_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_setEnv_FxnT)(void*, xdc_Ptr);
static inline ti_sysbios_knl_Task_setEnv_FxnT ti_sysbios_knl_Task_setEnv_fxnP( void )
{
    return (ti_sysbios_knl_Task_setEnv_FxnT)ti_sysbios_knl_Task_setEnv__E; 
}

/* setHookContext_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_setHookContext_FxnT)(void*, xdc_Int, xdc_Ptr);
static inline ti_sysbios_knl_Task_setHookContext_FxnT ti_sysbios_knl_Task_setHookContext_fxnP( void )
{
    return (ti_sysbios_knl_Task_setHookContext_FxnT)ti_sysbios_knl_Task_setHookContext__E; 
}

/* setPri_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_knl_Task_setPri_FxnT)(void*, xdc_Int);
static inline ti_sysbios_knl_Task_setPri_FxnT ti_sysbios_knl_Task_setPri_fxnP( void )
{
    return (ti_sysbios_knl_Task_setPri_FxnT)ti_sysbios_knl_Task_setPri__E; 
}

/* stat_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_stat_FxnT)(void*, ti_sysbios_knl_Task_Stat*);
static inline ti_sysbios_knl_Task_stat_FxnT ti_sysbios_knl_Task_stat_fxnP( void )
{
    return (ti_sysbios_knl_Task_stat_FxnT)ti_sysbios_knl_Task_stat__E; 
}

/* getMode_{FxnT,fxnP} */
typedef ti_sysbios_knl_Task_Mode (*ti_sysbios_knl_Task_getMode_FxnT)(void*);
static inline ti_sysbios_knl_Task_getMode_FxnT ti_sysbios_knl_Task_getMode_fxnP( void )
{
    return (ti_sysbios_knl_Task_getMode_FxnT)ti_sysbios_knl_Task_getMode__E; 
}

/* block_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_block_FxnT)(void*);
static inline ti_sysbios_knl_Task_block_FxnT ti_sysbios_knl_Task_block_fxnP( void )
{
    return (ti_sysbios_knl_Task_block_FxnT)ti_sysbios_knl_Task_block__E; 
}

/* unblock_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_unblock_FxnT)(void*);
static inline ti_sysbios_knl_Task_unblock_FxnT ti_sysbios_knl_Task_unblock_fxnP( void )
{
    return (ti_sysbios_knl_Task_unblock_FxnT)ti_sysbios_knl_Task_unblock__E; 
}

/* blockI_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_blockI_FxnT)(void*);
static inline ti_sysbios_knl_Task_blockI_FxnT ti_sysbios_knl_Task_blockI_fxnP( void )
{
    return (ti_sysbios_knl_Task_blockI_FxnT)ti_sysbios_knl_Task_blockI__E; 
}

/* unblockI_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Task_unblockI_FxnT)(void*, xdc_UInt);
static inline ti_sysbios_knl_Task_unblockI_FxnT ti_sysbios_knl_Task_unblockI_fxnP( void )
{
    return (ti_sysbios_knl_Task_unblockI_FxnT)ti_sysbios_knl_Task_unblockI__E; 
}


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_knl_Task_Module__id ti_sysbios_knl_Task_Module_id( void ) 
{
    return ti_sysbios_knl_Task_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_knl_Task_Module_hasMask( void ) 
{
    return ti_sysbios_knl_Task_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_knl_Task_Module_getMask( void ) 
{
    return ti_sysbios_knl_Task_Module__diagsMask__C != 0 ? *ti_sysbios_knl_Task_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_knl_Task_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_knl_Task_Module__diagsMask__C != 0) *ti_sysbios_knl_Task_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_knl_Task_Params_init( ti_sysbios_knl_Task_Params* prms ) 
{
    if (prms) {
        ti_sysbios_knl_Task_Params__init__S(prms, 0, sizeof(ti_sysbios_knl_Task_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_knl_Task_Params_copy( ti_sysbios_knl_Task_Params* dst, const ti_sysbios_knl_Task_Params* src ) 
{
    if (dst) {
        ti_sysbios_knl_Task_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_knl_Task_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_Object_get( ti_sysbios_knl_Task_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_knl_Task_Handle)ti_sysbios_knl_Task_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_Object_first( void )
{
    return (ti_sysbios_knl_Task_Handle)ti_sysbios_knl_Task_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_Object_next( ti_sysbios_knl_Task_Object* obj )
{
    return (ti_sysbios_knl_Task_Handle)ti_sysbios_knl_Task_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_knl_Task_Handle_label( ti_sysbios_knl_Task_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_knl_Task_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_knl_Task_Handle_name( ti_sysbios_knl_Task_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_knl_Task_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_create( ti_sysbios_knl_Task_FuncPtr fxn, const ti_sysbios_knl_Task_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_knl_Task_Args__create __args;
    __args.fxn = fxn;
    return (ti_sysbios_knl_Task_Handle)ti_sysbios_knl_Task_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Task_Params), __eb);
}

/* construct */
static inline void ti_sysbios_knl_Task_construct( ti_sysbios_knl_Task_Struct* __obj, ti_sysbios_knl_Task_FuncPtr fxn, const ti_sysbios_knl_Task_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_knl_Task_Args__create __args;
    __args.fxn = fxn;
    ti_sysbios_knl_Task_Object__create__S(__obj, sizeof (ti_sysbios_knl_Task_Struct), &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Task_Params), __eb);
}

/* delete */
static inline void ti_sysbios_knl_Task_delete( ti_sysbios_knl_Task_Handle* instp )
{
    ti_sysbios_knl_Task_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_knl_Task_destruct( ti_sysbios_knl_Task_Struct* obj )
{
    ti_sysbios_knl_Task_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_knl_Task_Handle ti_sysbios_knl_Task_handle( ti_sysbios_knl_Task_Struct* str )
{
    return (ti_sysbios_knl_Task_Handle)str;
}

/* struct */
static inline ti_sysbios_knl_Task_Struct* ti_sysbios_knl_Task_struct( ti_sysbios_knl_Task_Handle inst )
{
    return (ti_sysbios_knl_Task_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/*
 *  ======== Task_selfMacro ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:35; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */





/*
 * ======== STATE STRUCTURES ========
 */



/* Module_State */
struct ti_sysbios_knl_Task_Module_State {
    xdc_Bool locked;
    volatile xdc_UInt curSet;
    xdc_Bool workFlag;
    xdc_UInt vitalTasks;
    ti_sysbios_knl_Task_Handle curTask;
    ti_sysbios_knl_Queue_Handle curQ;
    __TA_ti_sysbios_knl_Task_Module_State__readyQ readyQ;
    ti_sysbios_knl_Task_Handle idleTask;
    __TA_ti_sysbios_knl_Task_Module_State__constructedTasks constructedTasks;
    char __dummy;
};

/* Module__state__V */
extern struct ti_sysbios_knl_Task_Module_State__ ti_sysbios_knl_Task_Module__state__V;

/* Object */
struct ti_sysbios_knl_Task_Object {
    ti_sysbios_knl_Queue_Elem qElem;
    volatile xdc_Int priority;
    xdc_UInt mask;
    xdc_Ptr context;
    ti_sysbios_knl_Task_Mode mode;
    ti_sysbios_knl_Task_PendElem* pendElem;
    xdc_SizeT stackSize;
    __TA_ti_sysbios_knl_Task_Instance_State__stack stack;
    xdc_runtime_IHeap_Handle stackHeap;
    ti_sysbios_knl_Task_FuncPtr fxn;
    xdc_UArg arg0;
    xdc_UArg arg1;
    xdc_Ptr env;
    __TA_ti_sysbios_knl_Task_Instance_State__hookEnv hookEnv;
    xdc_Bool vitalTaskFlag;
    ti_sysbios_knl_Queue_Handle readyQ;
};

/* Module_State_inactiveQ */
extern far const xdc_SizeT ti_sysbios_knl_Task_Module_State_inactiveQ__O;
static inline ti_sysbios_knl_Queue_Handle ti_sysbios_knl_Task_Module_State_inactiveQ()
{
    return (ti_sysbios_knl_Queue_Handle)(((char*)&ti_sysbios_knl_Task_Module__state__V) + ti_sysbios_knl_Task_Module_State_inactiveQ__O);
}

/* Module_State_terminatedQ */
extern far const xdc_SizeT ti_sysbios_knl_Task_Module_State_terminatedQ__O;
static inline ti_sysbios_knl_Queue_Handle ti_sysbios_knl_Task_Module_State_terminatedQ()
{
    return (ti_sysbios_knl_Queue_Handle)(((char*)&ti_sysbios_knl_Task_Module__state__V) + ti_sysbios_knl_Task_Module_State_terminatedQ__O);
}




/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

//D:\TInew\bios_6_33_04_39\packages#include <Task.h>
/*****************************************************************************/
/* string.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/


 




static __inline size_t  strlen(const char *_string);

static __inline char *strcpy(char *_dest, const char *_src);
static __inline char *strncpy(char *_to, const char *_from, size_t _n);
static __inline char *strcat(char *_string1, const char *_string2);
static __inline char *strncat(char *_to, const char *_from, size_t _n);
static __inline char *strchr(const char *_string, int _c);
static __inline char *strrchr(const char *_string, int _c);

static __inline int  strcmp(const char *_string1, const char *_string2);
static __inline int  strncmp(const char *_string1, const char *_string2, size_t _n);

 int     strcoll(const char *_string1, const char *_string2);
 size_t  strxfrm(char *_to, const char *_from, size_t _n);
 char   *strpbrk(const char *_string, const char *_chs);
 size_t  strspn(const char *_string, const char *_chs);
 size_t  strcspn(const char *_string, const char *_chs);
 char   *strstr(const char *_string1, const char *_string2);
 char   *strtok(char *_str1, const char *_str2);
 char   *strerror(int _errno);

 void   *memmove(void *_s1, const void *_s2, size_t _n);
 void   *memcpy(void *_s1, const void *_s2, size_t _n);

static __inline int     memcmp(const void *_cs, const void *_ct, size_t _n);
static __inline void   *memchr(const void *_cs, int _c, size_t _n);

 void   *memset(void *_mem, int _ch, size_t _n);







static __inline size_t strlen(const char *string)
{
   size_t      n = (size_t)-1;
   const char *s = string;

   do n++; while (*s++);
   return n;
}

static __inline char *strcpy(register char *dest, register const char *src)
{
     register char       *d = dest;     
     register const char *s = src;

     while (*d++ = *s++);
     return dest;
}

static __inline char *strncpy(register char *dest,
		     register const char *src,
		     register size_t n)
{
     if (n) 
     {
	 register char       *d = dest;
	 register const char *s = src;
	 while ((*d++ = *s++) && --n);              /* COPY STRING         */
	 if (n-- > 1) do *d++ = '\0'; while (--n);  /* TERMINATION PADDING */
     }
     return dest;
}

static __inline char *strcat(char *string1, const char *string2)
{
   char       *s1 = string1;
   const char *s2 = string2;

   while (*s1) s1++;		     /* FIND END OF STRING   */
   while (*s1++ = *s2++);	     /* APPEND SECOND STRING */
   return string1;
}

static __inline char *strncat(char *dest, const char *src, register size_t n)
{
    if (n)
    {
	char       *d = dest;
	const char *s = src;

	while (*d) d++;                      /* FIND END OF STRING   */

	while (n--)
	  if (!(*d++ = *s++)) return dest; /* APPEND SECOND STRING */
	*d = 0;
    }
    return dest;
}

static __inline char *strchr(const char *string, int c)
{
   char        tch, ch  = c;
   const char *s        = string;

   for (;;)
   {
       if ((tch = *s) == ch) return (char *) s;
       if (!tch)             return (char *) 0;
       s++;
   }
}

static __inline char *strrchr(const char *string, int c)
{
   char        tch, ch = c;
   char       *result  = 0;
   const char *s       = string;

   for (;;)
   {
      if ((tch = *s) == ch) result = (char *) s;
      if (!tch) break;
      s++;
   }

   return result;
}

static __inline int strcmp(register const char *string1,
		  register const char *string2)
{
   register int c1, res;

   for (;;)
   {
       c1  = (unsigned char)*string1++;
       res = c1 - (unsigned char)*string2++;

       if (c1 == 0 || res != 0) break;
   }

   return res;
}

static __inline int strncmp(const char *string1, const char *string2, size_t n)
{
     if (n) 
     {
	 const char *s1 = string1;
	 const char *s2 = string2;
	 unsigned char cp;
	 int         result;

	 do 
	    if (result = (unsigned char)*s1++ - (cp = (unsigned char)*s2++))
                return result;
	 while (cp && --n);
     }
     return 0;
}

static __inline int memcmp(const void *cs, const void *ct, size_t n)
{
   if (n) 
   {
       const unsigned char *mem1 = (unsigned char *)cs;
       const unsigned char *mem2 = (unsigned char *)ct;
       int                 cp1, cp2;

       while ((cp1 = *mem1++) == (cp2 = *mem2++) && --n);
       return cp1 - cp2;
   }
   return 0;
}

static __inline void *memchr(const void *cs, int c, size_t n)
{
   if (n)
   {
      const unsigned char *mem = (unsigned char *)cs;   
      unsigned char        ch  = c;

      do 
         if ( *mem == ch ) return (void *)mem;
         else mem++;
      while (--n);
   }
   return 0;
}







//#include <sys.h>
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_ISystemSupport_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    void (*abort)(xdc_String);
    void (*exit)(xdc_Int);
    void (*flush)(void);
    void (*putch)(xdc_Char);
    xdc_Bool (*ready)(void);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base xdc_runtime_ISystemSupport_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* Module_id */
static inline xdc_runtime_Types_ModuleId xdc_runtime_ISystemSupport_Module_id( xdc_runtime_ISystemSupport_Module mod )
{
    return mod->__sysp->__mid;
}

/* abort */
static inline void xdc_runtime_ISystemSupport_abort( xdc_runtime_ISystemSupport_Module __inst, xdc_String str )
{
    __inst->abort(str);
}

/* exit */
static inline void xdc_runtime_ISystemSupport_exit( xdc_runtime_ISystemSupport_Module __inst, xdc_Int stat )
{
    __inst->exit(stat);
}

/* flush */
static inline void xdc_runtime_ISystemSupport_flush( xdc_runtime_ISystemSupport_Module __inst )
{
    __inst->flush();
}

/* putch */
static inline void xdc_runtime_ISystemSupport_putch( xdc_runtime_ISystemSupport_Module __inst, xdc_Char ch )
{
    __inst->putch(ch);
}

/* ready */
static inline xdc_Bool xdc_runtime_ISystemSupport_ready( xdc_runtime_ISystemSupport_Module __inst )
{
    return __inst->ready();
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* abort_{FxnT,fxnP} */
typedef void (*xdc_runtime_ISystemSupport_abort_FxnT)(xdc_String);
static inline xdc_runtime_ISystemSupport_abort_FxnT xdc_runtime_ISystemSupport_abort_fxnP( xdc_runtime_ISystemSupport_Module __inst )
{
    return (xdc_runtime_ISystemSupport_abort_FxnT)__inst->abort;
}

/* exit_{FxnT,fxnP} */
typedef void (*xdc_runtime_ISystemSupport_exit_FxnT)(xdc_Int);
static inline xdc_runtime_ISystemSupport_exit_FxnT xdc_runtime_ISystemSupport_exit_fxnP( xdc_runtime_ISystemSupport_Module __inst )
{
    return (xdc_runtime_ISystemSupport_exit_FxnT)__inst->exit;
}

/* flush_{FxnT,fxnP} */
typedef void (*xdc_runtime_ISystemSupport_flush_FxnT)(void);
static inline xdc_runtime_ISystemSupport_flush_FxnT xdc_runtime_ISystemSupport_flush_fxnP( xdc_runtime_ISystemSupport_Module __inst )
{
    return (xdc_runtime_ISystemSupport_flush_FxnT)__inst->flush;
}

/* putch_{FxnT,fxnP} */
typedef void (*xdc_runtime_ISystemSupport_putch_FxnT)(xdc_Char);
static inline xdc_runtime_ISystemSupport_putch_FxnT xdc_runtime_ISystemSupport_putch_fxnP( xdc_runtime_ISystemSupport_Module __inst )
{
    return (xdc_runtime_ISystemSupport_putch_FxnT)__inst->putch;
}

/* ready_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_ISystemSupport_ready_FxnT)(void);
static inline xdc_runtime_ISystemSupport_ready_FxnT xdc_runtime_ISystemSupport_ready_fxnP( xdc_runtime_ISystemSupport_Module __inst )
{
    return (xdc_runtime_ISystemSupport_ready_FxnT)__inst->ready;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_System_SupportProxy_Module__diagsEnabled;
extern far const CT__xdc_runtime_System_SupportProxy_Module__diagsEnabled xdc_runtime_System_SupportProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_System_SupportProxy_Module__diagsIncluded;
extern far const CT__xdc_runtime_System_SupportProxy_Module__diagsIncluded xdc_runtime_System_SupportProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_System_SupportProxy_Module__diagsMask;
extern far const CT__xdc_runtime_System_SupportProxy_Module__diagsMask xdc_runtime_System_SupportProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_System_SupportProxy_Module__gateObj;
extern far const CT__xdc_runtime_System_SupportProxy_Module__gateObj xdc_runtime_System_SupportProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_System_SupportProxy_Module__gatePrms;
extern far const CT__xdc_runtime_System_SupportProxy_Module__gatePrms xdc_runtime_System_SupportProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_System_SupportProxy_Module__id;
extern far const CT__xdc_runtime_System_SupportProxy_Module__id xdc_runtime_System_SupportProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_System_SupportProxy_Module__loggerDefined;
extern far const CT__xdc_runtime_System_SupportProxy_Module__loggerDefined xdc_runtime_System_SupportProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_System_SupportProxy_Module__loggerObj;
extern far const CT__xdc_runtime_System_SupportProxy_Module__loggerObj xdc_runtime_System_SupportProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_System_SupportProxy_Module__loggerFxn0;
extern far const CT__xdc_runtime_System_SupportProxy_Module__loggerFxn0 xdc_runtime_System_SupportProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_System_SupportProxy_Module__loggerFxn1;
extern far const CT__xdc_runtime_System_SupportProxy_Module__loggerFxn1 xdc_runtime_System_SupportProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_System_SupportProxy_Module__loggerFxn2;
extern far const CT__xdc_runtime_System_SupportProxy_Module__loggerFxn2 xdc_runtime_System_SupportProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_System_SupportProxy_Module__loggerFxn4;
extern far const CT__xdc_runtime_System_SupportProxy_Module__loggerFxn4 xdc_runtime_System_SupportProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_System_SupportProxy_Module__loggerFxn8;
extern far const CT__xdc_runtime_System_SupportProxy_Module__loggerFxn8 xdc_runtime_System_SupportProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_System_SupportProxy_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_System_SupportProxy_Module__startupDoneFxn xdc_runtime_System_SupportProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_System_SupportProxy_Object__count;
extern far const CT__xdc_runtime_System_SupportProxy_Object__count xdc_runtime_System_SupportProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_System_SupportProxy_Object__heap;
extern far const CT__xdc_runtime_System_SupportProxy_Object__heap xdc_runtime_System_SupportProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_System_SupportProxy_Object__sizeof;
extern far const CT__xdc_runtime_System_SupportProxy_Object__sizeof xdc_runtime_System_SupportProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_System_SupportProxy_Object__table;
extern far const CT__xdc_runtime_System_SupportProxy_Object__table xdc_runtime_System_SupportProxy_Object__table__C;


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_System_SupportProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    void (*abort)(xdc_String);
    void (*exit)(xdc_Int);
    void (*flush)(void);
    void (*putch)(xdc_Char);
    xdc_Bool (*ready)(void);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const xdc_runtime_System_SupportProxy_Fxns__ xdc_runtime_System_SupportProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* xdc_runtime_System_SupportProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_System_SupportProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr xdc_runtime_System_SupportProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void xdc_runtime_System_SupportProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void xdc_runtime_System_SupportProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr xdc_runtime_System_SupportProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr xdc_runtime_System_SupportProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr xdc_runtime_System_SupportProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void xdc_runtime_System_SupportProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool xdc_runtime_System_SupportProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr xdc_runtime_System_SupportProxy_Proxy__delegate__S( void );

/* abort__E */

extern void xdc_runtime_System_SupportProxy_abort__E( xdc_String str );

extern void xdc_runtime_System_SupportProxy_abort__R( xdc_String str );

/* exit__E */

extern void xdc_runtime_System_SupportProxy_exit__E( xdc_Int stat );

extern void xdc_runtime_System_SupportProxy_exit__R( xdc_Int stat );

/* flush__E */

extern void xdc_runtime_System_SupportProxy_flush__E( void );

extern void xdc_runtime_System_SupportProxy_flush__R( void );

/* putch__E */

extern void xdc_runtime_System_SupportProxy_putch__E( xdc_Char ch );

extern void xdc_runtime_System_SupportProxy_putch__R( xdc_Char ch );

/* ready__E */

extern xdc_Bool xdc_runtime_System_SupportProxy_ready__E( void );

extern xdc_Bool xdc_runtime_System_SupportProxy_ready__R( void );


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_ISystemSupport_Module xdc_runtime_System_SupportProxy_Module_upCast( void )
{
    return (xdc_runtime_ISystemSupport_Module)xdc_runtime_System_SupportProxy_Proxy__delegate__S();
}

/* Module_to_xdc_runtime_ISystemSupport */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_System_SupportProxy_Module__id xdc_runtime_System_SupportProxy_Module_id( void ) 
{
    return xdc_runtime_System_SupportProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Q_BLOCKING */

/* Q_PREEMPTING */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_System_Module_GateProxy_Module__diagsEnabled;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__diagsEnabled xdc_runtime_System_Module_GateProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_System_Module_GateProxy_Module__diagsIncluded;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__diagsIncluded xdc_runtime_System_Module_GateProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_System_Module_GateProxy_Module__diagsMask;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__diagsMask xdc_runtime_System_Module_GateProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_System_Module_GateProxy_Module__gateObj;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__gateObj xdc_runtime_System_Module_GateProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_System_Module_GateProxy_Module__gatePrms;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__gatePrms xdc_runtime_System_Module_GateProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_System_Module_GateProxy_Module__id;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__id xdc_runtime_System_Module_GateProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_System_Module_GateProxy_Module__loggerDefined;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__loggerDefined xdc_runtime_System_Module_GateProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_System_Module_GateProxy_Module__loggerObj;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__loggerObj xdc_runtime_System_Module_GateProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn0;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn0 xdc_runtime_System_Module_GateProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn1;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn1 xdc_runtime_System_Module_GateProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn2;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn2 xdc_runtime_System_Module_GateProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn4;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn4 xdc_runtime_System_Module_GateProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn8;
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__loggerFxn8 xdc_runtime_System_Module_GateProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_System_Module_GateProxy_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_System_Module_GateProxy_Module__startupDoneFxn xdc_runtime_System_Module_GateProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_System_Module_GateProxy_Object__count;
extern far const CT__xdc_runtime_System_Module_GateProxy_Object__count xdc_runtime_System_Module_GateProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_System_Module_GateProxy_Object__heap;
extern far const CT__xdc_runtime_System_Module_GateProxy_Object__heap xdc_runtime_System_Module_GateProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_System_Module_GateProxy_Object__sizeof;
extern far const CT__xdc_runtime_System_Module_GateProxy_Object__sizeof xdc_runtime_System_Module_GateProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_System_Module_GateProxy_Object__table;
extern far const CT__xdc_runtime_System_Module_GateProxy_Object__table xdc_runtime_System_Module_GateProxy_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_System_Module_GateProxy_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct xdc_runtime_System_Module_GateProxy_Struct {
    const xdc_runtime_System_Module_GateProxy_Fxns__* __fxns;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_System_Module_GateProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*query)(xdc_Int);
    xdc_IArg (*enter)(xdc_runtime_System_Module_GateProxy_Handle);
    void (*leave)(xdc_runtime_System_Module_GateProxy_Handle, xdc_IArg);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const xdc_runtime_System_Module_GateProxy_Fxns__ xdc_runtime_System_Module_GateProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* xdc_runtime_System_Module_GateProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_System_Module_GateProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr xdc_runtime_System_Module_GateProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void xdc_runtime_System_Module_GateProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void xdc_runtime_System_Module_GateProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr xdc_runtime_System_Module_GateProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr xdc_runtime_System_Module_GateProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr xdc_runtime_System_Module_GateProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void xdc_runtime_System_Module_GateProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool xdc_runtime_System_Module_GateProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr xdc_runtime_System_Module_GateProxy_Proxy__delegate__S( void );

/* query__E */

extern xdc_Bool xdc_runtime_System_Module_GateProxy_query__E( xdc_Int qual );

extern xdc_Bool xdc_runtime_System_Module_GateProxy_query__R( xdc_Int qual );

/* enter__E */

extern xdc_IArg xdc_runtime_System_Module_GateProxy_enter__E( xdc_runtime_System_Module_GateProxy_Handle __inst );

extern xdc_IArg xdc_runtime_System_Module_GateProxy_enter__R( xdc_runtime_System_Module_GateProxy_Handle __inst );

/* leave__E */

extern void xdc_runtime_System_Module_GateProxy_leave__E( xdc_runtime_System_Module_GateProxy_Handle __inst, xdc_IArg key );

extern void xdc_runtime_System_Module_GateProxy_leave__R( xdc_runtime_System_Module_GateProxy_Handle __inst, xdc_IArg key );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enter_{FxnT,fxnP} */
typedef xdc_IArg (*xdc_runtime_System_Module_GateProxy_enter_FxnT)(void*);
static inline xdc_runtime_System_Module_GateProxy_enter_FxnT xdc_runtime_System_Module_GateProxy_enter_fxnP( void )
{
    return (xdc_runtime_System_Module_GateProxy_enter_FxnT)xdc_runtime_System_Module_GateProxy_enter__E; 
}

/* leave_{FxnT,fxnP} */
typedef void (*xdc_runtime_System_Module_GateProxy_leave_FxnT)(void*, xdc_IArg);
static inline xdc_runtime_System_Module_GateProxy_leave_FxnT xdc_runtime_System_Module_GateProxy_leave_fxnP( void )
{
    return (xdc_runtime_System_Module_GateProxy_leave_FxnT)xdc_runtime_System_Module_GateProxy_leave__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IGateProvider_Module xdc_runtime_System_Module_GateProxy_Module_upCast( void )
{
    return (xdc_runtime_IGateProvider_Module)xdc_runtime_System_Module_GateProxy_Proxy__delegate__S();
}

/* Module_to_xdc_runtime_IGateProvider */

/* Handle_upCast */
static inline xdc_runtime_IGateProvider_Handle xdc_runtime_System_Module_GateProxy_Handle_upCast( xdc_runtime_System_Module_GateProxy_Handle i )
{
    return (xdc_runtime_IGateProvider_Handle)i;
}

/* Handle_to_xdc_runtime_IGateProvider */

/* Handle_downCast */
static inline xdc_runtime_System_Module_GateProxy_Handle xdc_runtime_System_Module_GateProxy_Handle_downCast( xdc_runtime_IGateProvider_Handle i )
{
    xdc_runtime_IGateProvider_Handle i2 = (xdc_runtime_IGateProvider_Handle)i;
if (xdc_runtime_System_Module_GateProxy_Proxy__abstract__S()) return (xdc_runtime_System_Module_GateProxy_Handle)i;
    return (void*)i2->__fxns == (void*)xdc_runtime_System_Module_GateProxy_Proxy__delegate__S() ? (xdc_runtime_System_Module_GateProxy_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IGateProvider */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_System_Module_GateProxy_Module__id xdc_runtime_System_Module_GateProxy_Module_id( void ) 
{
    return xdc_runtime_System_Module_GateProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */

/* Params_init */
static inline void xdc_runtime_System_Module_GateProxy_Params_init( xdc_runtime_System_Module_GateProxy_Params* prms ) 
{
    if (prms) {
        xdc_runtime_System_Module_GateProxy_Params__init__S(prms, 0, sizeof(xdc_runtime_System_Module_GateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void xdc_runtime_System_Module_GateProxy_Params_copy( xdc_runtime_System_Module_GateProxy_Params* dst, const xdc_runtime_System_Module_GateProxy_Params* src ) 
{
    if (dst) {
        xdc_runtime_System_Module_GateProxy_Params__init__S(dst, (xdc_Ptr)src, sizeof(xdc_runtime_System_Module_GateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* create */
static inline xdc_runtime_System_Module_GateProxy_Handle xdc_runtime_System_Module_GateProxy_create( const xdc_runtime_System_Module_GateProxy_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (xdc_runtime_System_Module_GateProxy_Handle)xdc_runtime_System_Module_GateProxy_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(xdc_runtime_System_Module_GateProxy_Params), __eb);
}

/* delete */
static inline void xdc_runtime_System_Module_GateProxy_delete( xdc_runtime_System_Module_GateProxy_Handle* instp )
{
    xdc_runtime_System_Module_GateProxy_Object__delete__S(instp);
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* AtexitHandler */
typedef void (*xdc_runtime_System_AtexitHandler)(xdc_Int);

/* STATUS_UNKNOWN */


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* ParseData */
struct xdc_runtime_System_ParseData {
    xdc_Int width;
    xdc_Bool lFlag;
    xdc_Bool lJust;
    xdc_Int precis;
    xdc_Int len;
    xdc_Int zpad;
    xdc_Char* end;
    xdc_Bool aFlag;
    xdc_Char* ptr;
};

/* ExtendFxn */
typedef xdc_Int (*xdc_runtime_System_ExtendFxn)(xdc_Char**, xdc_Char**, xdc_VaList*, xdc_runtime_System_ParseData*);

/* Module_State */
typedef xdc_runtime_System_AtexitHandler __T1_xdc_runtime_System_Module_State__atexitHandlers;
typedef xdc_runtime_System_AtexitHandler *__ARRAY1_xdc_runtime_System_Module_State__atexitHandlers;
typedef __ARRAY1_xdc_runtime_System_Module_State__atexitHandlers __TA_xdc_runtime_System_Module_State__atexitHandlers;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_System_Module__diagsEnabled;
extern far const CT__xdc_runtime_System_Module__diagsEnabled xdc_runtime_System_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_System_Module__diagsIncluded;
extern far const CT__xdc_runtime_System_Module__diagsIncluded xdc_runtime_System_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_System_Module__diagsMask;
extern far const CT__xdc_runtime_System_Module__diagsMask xdc_runtime_System_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_System_Module__gateObj;
extern far const CT__xdc_runtime_System_Module__gateObj xdc_runtime_System_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_System_Module__gatePrms;
extern far const CT__xdc_runtime_System_Module__gatePrms xdc_runtime_System_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_System_Module__id;
extern far const CT__xdc_runtime_System_Module__id xdc_runtime_System_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_System_Module__loggerDefined;
extern far const CT__xdc_runtime_System_Module__loggerDefined xdc_runtime_System_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_System_Module__loggerObj;
extern far const CT__xdc_runtime_System_Module__loggerObj xdc_runtime_System_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_System_Module__loggerFxn0;
extern far const CT__xdc_runtime_System_Module__loggerFxn0 xdc_runtime_System_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_System_Module__loggerFxn1;
extern far const CT__xdc_runtime_System_Module__loggerFxn1 xdc_runtime_System_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_System_Module__loggerFxn2;
extern far const CT__xdc_runtime_System_Module__loggerFxn2 xdc_runtime_System_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_System_Module__loggerFxn4;
extern far const CT__xdc_runtime_System_Module__loggerFxn4 xdc_runtime_System_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_System_Module__loggerFxn8;
extern far const CT__xdc_runtime_System_Module__loggerFxn8 xdc_runtime_System_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_System_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_System_Module__startupDoneFxn xdc_runtime_System_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_System_Object__count;
extern far const CT__xdc_runtime_System_Object__count xdc_runtime_System_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_System_Object__heap;
extern far const CT__xdc_runtime_System_Object__heap xdc_runtime_System_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_System_Object__sizeof;
extern far const CT__xdc_runtime_System_Object__sizeof xdc_runtime_System_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_System_Object__table;
extern far const CT__xdc_runtime_System_Object__table xdc_runtime_System_Object__table__C;

/* A_cannotFitIntoArg */
typedef xdc_runtime_Assert_Id CT__xdc_runtime_System_A_cannotFitIntoArg;
extern far const CT__xdc_runtime_System_A_cannotFitIntoArg xdc_runtime_System_A_cannotFitIntoArg__C;

/* maxAtexitHandlers */
typedef xdc_Int CT__xdc_runtime_System_maxAtexitHandlers;
extern far const CT__xdc_runtime_System_maxAtexitHandlers xdc_runtime_System_maxAtexitHandlers__C;

/* extendFxn */
typedef xdc_runtime_System_ExtendFxn CT__xdc_runtime_System_extendFxn;
extern far const CT__xdc_runtime_System_extendFxn xdc_runtime_System_extendFxn__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int xdc_runtime_System_Module_startup__E( xdc_Int state );

extern xdc_Int xdc_runtime_System_Module_startup__F( xdc_Int state );

extern xdc_Int xdc_runtime_System_Module_startup__R( xdc_Int state );

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_System_Module__startupDone__S( void );

/* abort__E */

extern void xdc_runtime_System_abort__E( xdc_String str );

extern void xdc_runtime_System_abort__F( xdc_String str );
extern void xdc_runtime_System_abort__R( xdc_String str );

/* atexit__E */

extern xdc_Bool xdc_runtime_System_atexit__E( xdc_runtime_System_AtexitHandler handler );

extern xdc_Bool xdc_runtime_System_atexit__F( xdc_runtime_System_AtexitHandler handler );
extern xdc_Bool xdc_runtime_System_atexit__R( xdc_runtime_System_AtexitHandler handler );

/* exit__E */

extern void xdc_runtime_System_exit__E( xdc_Int stat );

extern void xdc_runtime_System_exit__F( xdc_Int stat );
extern void xdc_runtime_System_exit__R( xdc_Int stat );

/* putch__E */

extern void xdc_runtime_System_putch__E( xdc_Char ch );

extern void xdc_runtime_System_putch__F( xdc_Char ch );
extern void xdc_runtime_System_putch__R( xdc_Char ch );

/* flush__E */

extern void xdc_runtime_System_flush__E( void );

extern void xdc_runtime_System_flush__F( void );
extern void xdc_runtime_System_flush__R( void );

/* printf__E */

extern xdc_Int xdc_runtime_System_printf__E( xdc_String fmt, ... );

extern xdc_Int xdc_runtime_System_printf_va__E( xdc_String fmt, va_list _va );

extern xdc_Int xdc_runtime_System_printf_va__F( xdc_String fmt, va_list _va );
extern xdc_Int xdc_runtime_System_printf_va__R( xdc_String fmt, va_list _va );

/* aprintf__E */

extern xdc_Int xdc_runtime_System_aprintf__E( xdc_String fmt, ... );

extern xdc_Int xdc_runtime_System_aprintf_va__E( xdc_String fmt, va_list _va );

extern xdc_Int xdc_runtime_System_aprintf_va__F( xdc_String fmt, va_list _va );
extern xdc_Int xdc_runtime_System_aprintf_va__R( xdc_String fmt, va_list _va );

/* sprintf__E */

extern xdc_Int xdc_runtime_System_sprintf__E( xdc_Char buf[], xdc_String fmt, ... );

extern xdc_Int xdc_runtime_System_sprintf_va__E( xdc_Char buf[], xdc_String fmt, va_list _va );

extern xdc_Int xdc_runtime_System_sprintf_va__F( xdc_Char buf[], xdc_String fmt, va_list _va );
extern xdc_Int xdc_runtime_System_sprintf_va__R( xdc_Char buf[], xdc_String fmt, va_list _va );

/* asprintf__E */

extern xdc_Int xdc_runtime_System_asprintf__E( xdc_Char buf[], xdc_String fmt, ... );

extern xdc_Int xdc_runtime_System_asprintf_va__E( xdc_Char buf[], xdc_String fmt, va_list _va );

extern xdc_Int xdc_runtime_System_asprintf_va__F( xdc_Char buf[], xdc_String fmt, va_list _va );
extern xdc_Int xdc_runtime_System_asprintf_va__R( xdc_Char buf[], xdc_String fmt, va_list _va );

/* vprintf__E */

extern xdc_Int xdc_runtime_System_vprintf__E( xdc_String fmt, xdc_VaList va );

extern xdc_Int xdc_runtime_System_vprintf__F( xdc_String fmt, xdc_VaList va );
extern xdc_Int xdc_runtime_System_vprintf__R( xdc_String fmt, xdc_VaList va );

/* avprintf__E */

extern xdc_Int xdc_runtime_System_avprintf__E( xdc_String fmt, xdc_VaList va );

extern xdc_Int xdc_runtime_System_avprintf__F( xdc_String fmt, xdc_VaList va );
extern xdc_Int xdc_runtime_System_avprintf__R( xdc_String fmt, xdc_VaList va );

/* vsprintf__E */

extern xdc_Int xdc_runtime_System_vsprintf__E( xdc_Char buf[], xdc_String fmt, xdc_VaList va );

extern xdc_Int xdc_runtime_System_vsprintf__F( xdc_Char buf[], xdc_String fmt, xdc_VaList va );
extern xdc_Int xdc_runtime_System_vsprintf__R( xdc_Char buf[], xdc_String fmt, xdc_VaList va );

/* avsprintf__E */

extern xdc_Int xdc_runtime_System_avsprintf__E( xdc_Char buf[], xdc_String fmt, xdc_VaList va );

extern xdc_Int xdc_runtime_System_avsprintf__F( xdc_Char buf[], xdc_String fmt, xdc_VaList va );
extern xdc_Int xdc_runtime_System_avsprintf__R( xdc_Char buf[], xdc_String fmt, xdc_VaList va );

/* printfExtend__I */

extern xdc_Int xdc_runtime_System_printfExtend__I( xdc_Char** bufp, xdc_Char** fmt, xdc_VaList* va, xdc_runtime_System_ParseData* parse );

/* doPrint__I */

extern xdc_Int xdc_runtime_System_doPrint__I( xdc_Char buf[], xdc_String fmt, xdc_VaList* pva, xdc_Bool aFlag );

/* formatNum__I */

extern xdc_Char* xdc_runtime_System_formatNum__I( xdc_Char* ptr, xdc_UInt32 n, xdc_Int zpad, xdc_Int base );

/* lastFxn__I */

extern void xdc_runtime_System_lastFxn__I( void );

/* putchar__I */

extern void xdc_runtime_System_putchar__I( xdc_Char** bufp, xdc_Char ch );

/* rtsExit__I */

extern void xdc_runtime_System_rtsExit__I( void );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_System_Module__id xdc_runtime_System_Module_id( void ) 
{
    return xdc_runtime_System_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_System_Module_hasMask( void ) 
{
    return xdc_runtime_System_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_System_Module_getMask( void ) 
{
    return xdc_runtime_System_Module__diagsMask__C != 0 ? *xdc_runtime_System_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_System_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_System_Module__diagsMask__C != 0) *xdc_runtime_System_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

//#include <sem.h>
/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:32; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Id_00 */

/* Id_01 */

/* Id_02 */

/* Id_03 */

/* Id_04 */

/* Id_05 */

/* Id_06 */

/* Id_07 */

/* Id_08 */

/* Id_09 */

/* Id_10 */

/* Id_11 */

/* Id_12 */

/* Id_13 */

/* Id_14 */

/* Id_15 */

/* Id_16 */

/* Id_17 */

/* Id_18 */

/* Id_19 */

/* Id_20 */

/* Id_21 */

/* Id_22 */

/* Id_23 */

/* Id_24 */

/* Id_25 */

/* Id_26 */

/* Id_27 */

/* Id_28 */

/* Id_29 */

/* Id_30 */

/* Id_31 */

/* Id_NONE */


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* PendState */
enum ti_sysbios_knl_Event_PendState {
    ti_sysbios_knl_Event_PendState_TIMEOUT = 0,
    ti_sysbios_knl_Event_PendState_POSTED = 1,
    ti_sysbios_knl_Event_PendState_CLOCK_WAIT = 2,
    ti_sysbios_knl_Event_PendState_WAIT_FOREVER = 3
};
typedef enum ti_sysbios_knl_Event_PendState ti_sysbios_knl_Event_PendState;

/* PendElem */
struct ti_sysbios_knl_Event_PendElem {
    ti_sysbios_knl_Task_PendElem tpElem;
    ti_sysbios_knl_Event_PendState pendState;
    xdc_UInt matchingEvents;
    xdc_UInt andMask;
    xdc_UInt orMask;
};


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_knl_Event_Module__diagsEnabled;
extern far const CT__ti_sysbios_knl_Event_Module__diagsEnabled ti_sysbios_knl_Event_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_knl_Event_Module__diagsIncluded;
extern far const CT__ti_sysbios_knl_Event_Module__diagsIncluded ti_sysbios_knl_Event_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_knl_Event_Module__diagsMask;
extern far const CT__ti_sysbios_knl_Event_Module__diagsMask ti_sysbios_knl_Event_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Event_Module__gateObj;
extern far const CT__ti_sysbios_knl_Event_Module__gateObj ti_sysbios_knl_Event_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_knl_Event_Module__gatePrms;
extern far const CT__ti_sysbios_knl_Event_Module__gatePrms ti_sysbios_knl_Event_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_knl_Event_Module__id;
extern far const CT__ti_sysbios_knl_Event_Module__id ti_sysbios_knl_Event_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_knl_Event_Module__loggerDefined;
extern far const CT__ti_sysbios_knl_Event_Module__loggerDefined ti_sysbios_knl_Event_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Event_Module__loggerObj;
extern far const CT__ti_sysbios_knl_Event_Module__loggerObj ti_sysbios_knl_Event_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_knl_Event_Module__loggerFxn0;
extern far const CT__ti_sysbios_knl_Event_Module__loggerFxn0 ti_sysbios_knl_Event_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_knl_Event_Module__loggerFxn1;
extern far const CT__ti_sysbios_knl_Event_Module__loggerFxn1 ti_sysbios_knl_Event_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_knl_Event_Module__loggerFxn2;
extern far const CT__ti_sysbios_knl_Event_Module__loggerFxn2 ti_sysbios_knl_Event_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_knl_Event_Module__loggerFxn4;
extern far const CT__ti_sysbios_knl_Event_Module__loggerFxn4 ti_sysbios_knl_Event_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_knl_Event_Module__loggerFxn8;
extern far const CT__ti_sysbios_knl_Event_Module__loggerFxn8 ti_sysbios_knl_Event_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_knl_Event_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_knl_Event_Module__startupDoneFxn ti_sysbios_knl_Event_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_knl_Event_Object__count;
extern far const CT__ti_sysbios_knl_Event_Object__count ti_sysbios_knl_Event_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_knl_Event_Object__heap;
extern far const CT__ti_sysbios_knl_Event_Object__heap ti_sysbios_knl_Event_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_knl_Event_Object__sizeof;
extern far const CT__ti_sysbios_knl_Event_Object__sizeof ti_sysbios_knl_Event_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_knl_Event_Object__table;
extern far const CT__ti_sysbios_knl_Event_Object__table ti_sysbios_knl_Event_Object__table__C;

/* LM_post */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Event_LM_post;
extern far const CT__ti_sysbios_knl_Event_LM_post ti_sysbios_knl_Event_LM_post__C;

/* LM_pend */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Event_LM_pend;
extern far const CT__ti_sysbios_knl_Event_LM_pend ti_sysbios_knl_Event_LM_pend__C;

/* A_nullEventMasks */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Event_A_nullEventMasks;
extern far const CT__ti_sysbios_knl_Event_A_nullEventMasks ti_sysbios_knl_Event_A_nullEventMasks__C;

/* A_nullEventId */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Event_A_nullEventId;
extern far const CT__ti_sysbios_knl_Event_A_nullEventId ti_sysbios_knl_Event_A_nullEventId__C;

/* A_eventInUse */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Event_A_eventInUse;
extern far const CT__ti_sysbios_knl_Event_A_eventInUse ti_sysbios_knl_Event_A_eventInUse__C;

/* A_badContext */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Event_A_badContext;
extern far const CT__ti_sysbios_knl_Event_A_badContext ti_sysbios_knl_Event_A_badContext__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_knl_Event_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_knl_Event_Struct {
    volatile xdc_UInt __f0;
    ti_sysbios_knl_Queue_Struct __f1;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Instance_init__F */

extern void ti_sysbios_knl_Event_Instance_init__F( ti_sysbios_knl_Event_Object*, const ti_sysbios_knl_Event_Params* );

/* Instance_init__R */

extern void ti_sysbios_knl_Event_Instance_init__R( ti_sysbios_knl_Event_Object*, const ti_sysbios_knl_Event_Params* );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_knl_Event_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_knl_Event_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_knl_Event_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_knl_Event_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_knl_Event_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_knl_Event_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_knl_Event_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_knl_Event_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_knl_Event_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* pend__E */

extern xdc_UInt ti_sysbios_knl_Event_pend__E( ti_sysbios_knl_Event_Handle __inst, xdc_UInt andMask, xdc_UInt orMask, xdc_UInt timeout );

extern xdc_UInt ti_sysbios_knl_Event_pend__F( ti_sysbios_knl_Event_Object* __inst, xdc_UInt andMask, xdc_UInt orMask, xdc_UInt timeout );
extern xdc_UInt ti_sysbios_knl_Event_pend__R( ti_sysbios_knl_Event_Handle __inst, xdc_UInt andMask, xdc_UInt orMask, xdc_UInt timeout );

/* post__E */

extern void ti_sysbios_knl_Event_post__E( ti_sysbios_knl_Event_Handle __inst, xdc_UInt eventMask );

extern void ti_sysbios_knl_Event_post__F( ti_sysbios_knl_Event_Object* __inst, xdc_UInt eventMask );
extern void ti_sysbios_knl_Event_post__R( ti_sysbios_knl_Event_Handle __inst, xdc_UInt eventMask );

/* getPostedEvents__E */

extern xdc_UInt ti_sysbios_knl_Event_getPostedEvents__E( ti_sysbios_knl_Event_Handle __inst );

extern xdc_UInt ti_sysbios_knl_Event_getPostedEvents__F( ti_sysbios_knl_Event_Object* __inst );
extern xdc_UInt ti_sysbios_knl_Event_getPostedEvents__R( ti_sysbios_knl_Event_Handle __inst );

/* sync__E */

extern void ti_sysbios_knl_Event_sync__E( ti_sysbios_knl_Event_Handle __inst, xdc_UInt eventId, xdc_UInt count );

extern void ti_sysbios_knl_Event_sync__F( ti_sysbios_knl_Event_Object* __inst, xdc_UInt eventId, xdc_UInt count );
extern void ti_sysbios_knl_Event_sync__R( ti_sysbios_knl_Event_Handle __inst, xdc_UInt eventId, xdc_UInt count );

/* pendTimeout__I */

extern void ti_sysbios_knl_Event_pendTimeout__I( xdc_UArg arg );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* pend_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_knl_Event_pend_FxnT)(void*, xdc_UInt, xdc_UInt, xdc_UInt);
static inline ti_sysbios_knl_Event_pend_FxnT ti_sysbios_knl_Event_pend_fxnP( void )
{
    return (ti_sysbios_knl_Event_pend_FxnT)ti_sysbios_knl_Event_pend__E; 
}

/* post_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Event_post_FxnT)(void*, xdc_UInt);
static inline ti_sysbios_knl_Event_post_FxnT ti_sysbios_knl_Event_post_fxnP( void )
{
    return (ti_sysbios_knl_Event_post_FxnT)ti_sysbios_knl_Event_post__E; 
}

/* getPostedEvents_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_knl_Event_getPostedEvents_FxnT)(void*);
static inline ti_sysbios_knl_Event_getPostedEvents_FxnT ti_sysbios_knl_Event_getPostedEvents_fxnP( void )
{
    return (ti_sysbios_knl_Event_getPostedEvents_FxnT)ti_sysbios_knl_Event_getPostedEvents__E; 
}

/* sync_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Event_sync_FxnT)(void*, xdc_UInt, xdc_UInt);
static inline ti_sysbios_knl_Event_sync_FxnT ti_sysbios_knl_Event_sync_fxnP( void )
{
    return (ti_sysbios_knl_Event_sync_FxnT)ti_sysbios_knl_Event_sync__E; 
}


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_knl_Event_Module__id ti_sysbios_knl_Event_Module_id( void ) 
{
    return ti_sysbios_knl_Event_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_knl_Event_Module_hasMask( void ) 
{
    return ti_sysbios_knl_Event_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_knl_Event_Module_getMask( void ) 
{
    return ti_sysbios_knl_Event_Module__diagsMask__C != 0 ? *ti_sysbios_knl_Event_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_knl_Event_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_knl_Event_Module__diagsMask__C != 0) *ti_sysbios_knl_Event_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_knl_Event_Params_init( ti_sysbios_knl_Event_Params* prms ) 
{
    if (prms) {
        ti_sysbios_knl_Event_Params__init__S(prms, 0, sizeof(ti_sysbios_knl_Event_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_knl_Event_Params_copy( ti_sysbios_knl_Event_Params* dst, const ti_sysbios_knl_Event_Params* src ) 
{
    if (dst) {
        ti_sysbios_knl_Event_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_knl_Event_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_knl_Event_Handle ti_sysbios_knl_Event_Object_get( ti_sysbios_knl_Event_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_knl_Event_Handle)ti_sysbios_knl_Event_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_knl_Event_Handle ti_sysbios_knl_Event_Object_first( void )
{
    return (ti_sysbios_knl_Event_Handle)ti_sysbios_knl_Event_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_knl_Event_Handle ti_sysbios_knl_Event_Object_next( ti_sysbios_knl_Event_Object* obj )
{
    return (ti_sysbios_knl_Event_Handle)ti_sysbios_knl_Event_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_knl_Event_Handle_label( ti_sysbios_knl_Event_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_knl_Event_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_knl_Event_Handle_name( ti_sysbios_knl_Event_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_knl_Event_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_knl_Event_Handle ti_sysbios_knl_Event_create( const ti_sysbios_knl_Event_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (ti_sysbios_knl_Event_Handle)ti_sysbios_knl_Event_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Event_Params), __eb);
}

/* construct */
static inline void ti_sysbios_knl_Event_construct( ti_sysbios_knl_Event_Struct* __obj, const ti_sysbios_knl_Event_Params* __prms )
{
    ti_sysbios_knl_Event_Object__create__S(__obj, sizeof (ti_sysbios_knl_Event_Struct), 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Event_Params), 0);
}

/* delete */
static inline void ti_sysbios_knl_Event_delete( ti_sysbios_knl_Event_Handle* instp )
{
    ti_sysbios_knl_Event_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_knl_Event_destruct( ti_sysbios_knl_Event_Struct* obj )
{
    ti_sysbios_knl_Event_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_knl_Event_Handle ti_sysbios_knl_Event_handle( ti_sysbios_knl_Event_Struct* str )
{
    return (ti_sysbios_knl_Event_Handle)str;
}

/* struct */
static inline ti_sysbios_knl_Event_Struct* ti_sysbios_knl_Event_struct( ti_sysbios_knl_Event_Handle inst )
{
    return (ti_sysbios_knl_Event_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */





/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:32; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:32; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Mode */
enum ti_sysbios_knl_Semaphore_Mode {
    ti_sysbios_knl_Semaphore_Mode_COUNTING,
    ti_sysbios_knl_Semaphore_Mode_BINARY
};
typedef enum ti_sysbios_knl_Semaphore_Mode ti_sysbios_knl_Semaphore_Mode;


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_knl_Semaphore_Args__create {
    xdc_Int count;
} ti_sysbios_knl_Semaphore_Args__create;


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* PendState */
enum ti_sysbios_knl_Semaphore_PendState {
    ti_sysbios_knl_Semaphore_PendState_TIMEOUT = 0,
    ti_sysbios_knl_Semaphore_PendState_POSTED = 1,
    ti_sysbios_knl_Semaphore_PendState_CLOCK_WAIT = 2,
    ti_sysbios_knl_Semaphore_PendState_WAIT_FOREVER = 3
};
typedef enum ti_sysbios_knl_Semaphore_PendState ti_sysbios_knl_Semaphore_PendState;

/* PendElem */
struct ti_sysbios_knl_Semaphore_PendElem {
    ti_sysbios_knl_Task_PendElem tpElem;
    ti_sysbios_knl_Semaphore_PendState pendState;
};


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_knl_Semaphore_Module__diagsEnabled;
extern far const CT__ti_sysbios_knl_Semaphore_Module__diagsEnabled ti_sysbios_knl_Semaphore_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_knl_Semaphore_Module__diagsIncluded;
extern far const CT__ti_sysbios_knl_Semaphore_Module__diagsIncluded ti_sysbios_knl_Semaphore_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_knl_Semaphore_Module__diagsMask;
extern far const CT__ti_sysbios_knl_Semaphore_Module__diagsMask ti_sysbios_knl_Semaphore_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Semaphore_Module__gateObj;
extern far const CT__ti_sysbios_knl_Semaphore_Module__gateObj ti_sysbios_knl_Semaphore_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_knl_Semaphore_Module__gatePrms;
extern far const CT__ti_sysbios_knl_Semaphore_Module__gatePrms ti_sysbios_knl_Semaphore_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_knl_Semaphore_Module__id;
extern far const CT__ti_sysbios_knl_Semaphore_Module__id ti_sysbios_knl_Semaphore_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_knl_Semaphore_Module__loggerDefined;
extern far const CT__ti_sysbios_knl_Semaphore_Module__loggerDefined ti_sysbios_knl_Semaphore_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_knl_Semaphore_Module__loggerObj;
extern far const CT__ti_sysbios_knl_Semaphore_Module__loggerObj ti_sysbios_knl_Semaphore_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_knl_Semaphore_Module__loggerFxn0;
extern far const CT__ti_sysbios_knl_Semaphore_Module__loggerFxn0 ti_sysbios_knl_Semaphore_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_knl_Semaphore_Module__loggerFxn1;
extern far const CT__ti_sysbios_knl_Semaphore_Module__loggerFxn1 ti_sysbios_knl_Semaphore_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_knl_Semaphore_Module__loggerFxn2;
extern far const CT__ti_sysbios_knl_Semaphore_Module__loggerFxn2 ti_sysbios_knl_Semaphore_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_knl_Semaphore_Module__loggerFxn4;
extern far const CT__ti_sysbios_knl_Semaphore_Module__loggerFxn4 ti_sysbios_knl_Semaphore_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_knl_Semaphore_Module__loggerFxn8;
extern far const CT__ti_sysbios_knl_Semaphore_Module__loggerFxn8 ti_sysbios_knl_Semaphore_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_knl_Semaphore_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_knl_Semaphore_Module__startupDoneFxn ti_sysbios_knl_Semaphore_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_knl_Semaphore_Object__count;
extern far const CT__ti_sysbios_knl_Semaphore_Object__count ti_sysbios_knl_Semaphore_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_knl_Semaphore_Object__heap;
extern far const CT__ti_sysbios_knl_Semaphore_Object__heap ti_sysbios_knl_Semaphore_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_knl_Semaphore_Object__sizeof;
extern far const CT__ti_sysbios_knl_Semaphore_Object__sizeof ti_sysbios_knl_Semaphore_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_knl_Semaphore_Object__table;
extern far const CT__ti_sysbios_knl_Semaphore_Object__table ti_sysbios_knl_Semaphore_Object__table__C;

/* LM_post */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Semaphore_LM_post;
extern far const CT__ti_sysbios_knl_Semaphore_LM_post ti_sysbios_knl_Semaphore_LM_post__C;

/* LM_pend */
typedef xdc_runtime_Log_Event CT__ti_sysbios_knl_Semaphore_LM_pend;
extern far const CT__ti_sysbios_knl_Semaphore_LM_pend ti_sysbios_knl_Semaphore_LM_pend__C;

/* A_noEvents */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Semaphore_A_noEvents;
extern far const CT__ti_sysbios_knl_Semaphore_A_noEvents ti_sysbios_knl_Semaphore_A_noEvents__C;

/* A_invTimeout */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Semaphore_A_invTimeout;
extern far const CT__ti_sysbios_knl_Semaphore_A_invTimeout ti_sysbios_knl_Semaphore_A_invTimeout__C;

/* A_badContext */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_knl_Semaphore_A_badContext;
extern far const CT__ti_sysbios_knl_Semaphore_A_badContext ti_sysbios_knl_Semaphore_A_badContext__C;

/* supportsEvents */
typedef xdc_Bool CT__ti_sysbios_knl_Semaphore_supportsEvents;
extern far const CT__ti_sysbios_knl_Semaphore_supportsEvents ti_sysbios_knl_Semaphore_supportsEvents__C;

/* eventPost */
typedef void (*CT__ti_sysbios_knl_Semaphore_eventPost)(ti_sysbios_knl_Event_Handle, xdc_UInt);
extern far const CT__ti_sysbios_knl_Semaphore_eventPost ti_sysbios_knl_Semaphore_eventPost__C;

/* eventSync */
typedef void (*CT__ti_sysbios_knl_Semaphore_eventSync)(ti_sysbios_knl_Event_Handle, xdc_UInt, xdc_UInt);
extern far const CT__ti_sysbios_knl_Semaphore_eventSync ti_sysbios_knl_Semaphore_eventSync__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_knl_Semaphore_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    ti_sysbios_knl_Event_Handle event;
    xdc_UInt eventId;
    ti_sysbios_knl_Semaphore_Mode mode;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_knl_Semaphore_Struct {
    ti_sysbios_knl_Event_Handle __f0;
    xdc_UInt __f1;
    ti_sysbios_knl_Semaphore_Mode __f2;
    volatile xdc_UInt16 __f3;
    ti_sysbios_knl_Queue_Struct __f4;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Instance_init__F */

extern void ti_sysbios_knl_Semaphore_Instance_init__F( ti_sysbios_knl_Semaphore_Object*, xdc_Int count, const ti_sysbios_knl_Semaphore_Params* );

/* Instance_finalize__F */

extern void ti_sysbios_knl_Semaphore_Instance_finalize__F( ti_sysbios_knl_Semaphore_Object* );

/* Instance_init__R */

extern void ti_sysbios_knl_Semaphore_Instance_init__R( ti_sysbios_knl_Semaphore_Object*, xdc_Int count, const ti_sysbios_knl_Semaphore_Params* );

/* Instance_finalize__R */

extern void ti_sysbios_knl_Semaphore_Instance_finalize__R( ti_sysbios_knl_Semaphore_Object* );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_knl_Semaphore_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_knl_Semaphore_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_knl_Semaphore_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_knl_Semaphore_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_knl_Semaphore_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_knl_Semaphore_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_knl_Semaphore_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_knl_Semaphore_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_knl_Semaphore_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* getCount__E */

extern xdc_Int ti_sysbios_knl_Semaphore_getCount__E( ti_sysbios_knl_Semaphore_Handle __inst );

extern xdc_Int ti_sysbios_knl_Semaphore_getCount__F( ti_sysbios_knl_Semaphore_Object* __inst );
extern xdc_Int ti_sysbios_knl_Semaphore_getCount__R( ti_sysbios_knl_Semaphore_Handle __inst );

/* pend__E */

extern xdc_Bool ti_sysbios_knl_Semaphore_pend__E( ti_sysbios_knl_Semaphore_Handle __inst, xdc_UInt timeout );

extern xdc_Bool ti_sysbios_knl_Semaphore_pend__F( ti_sysbios_knl_Semaphore_Object* __inst, xdc_UInt timeout );
extern xdc_Bool ti_sysbios_knl_Semaphore_pend__R( ti_sysbios_knl_Semaphore_Handle __inst, xdc_UInt timeout );

/* post__E */

extern void ti_sysbios_knl_Semaphore_post__E( ti_sysbios_knl_Semaphore_Handle __inst );

extern void ti_sysbios_knl_Semaphore_post__F( ti_sysbios_knl_Semaphore_Object* __inst );
extern void ti_sysbios_knl_Semaphore_post__R( ti_sysbios_knl_Semaphore_Handle __inst );

/* registerEvent__E */

extern void ti_sysbios_knl_Semaphore_registerEvent__E( ti_sysbios_knl_Semaphore_Handle __inst, ti_sysbios_knl_Event_Handle event, xdc_UInt eventId );

extern void ti_sysbios_knl_Semaphore_registerEvent__F( ti_sysbios_knl_Semaphore_Object* __inst, ti_sysbios_knl_Event_Handle event, xdc_UInt eventId );
extern void ti_sysbios_knl_Semaphore_registerEvent__R( ti_sysbios_knl_Semaphore_Handle __inst, ti_sysbios_knl_Event_Handle event, xdc_UInt eventId );

/* reset__E */

extern void ti_sysbios_knl_Semaphore_reset__E( ti_sysbios_knl_Semaphore_Handle __inst, xdc_Int count );

extern void ti_sysbios_knl_Semaphore_reset__F( ti_sysbios_knl_Semaphore_Object* __inst, xdc_Int count );
extern void ti_sysbios_knl_Semaphore_reset__R( ti_sysbios_knl_Semaphore_Handle __inst, xdc_Int count );

/* pendTimeout__I */

extern void ti_sysbios_knl_Semaphore_pendTimeout__I( xdc_UArg arg );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getCount_{FxnT,fxnP} */
typedef xdc_Int (*ti_sysbios_knl_Semaphore_getCount_FxnT)(void*);
static inline ti_sysbios_knl_Semaphore_getCount_FxnT ti_sysbios_knl_Semaphore_getCount_fxnP( void )
{
    return (ti_sysbios_knl_Semaphore_getCount_FxnT)ti_sysbios_knl_Semaphore_getCount__E; 
}

/* pend_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_knl_Semaphore_pend_FxnT)(void*, xdc_UInt);
static inline ti_sysbios_knl_Semaphore_pend_FxnT ti_sysbios_knl_Semaphore_pend_fxnP( void )
{
    return (ti_sysbios_knl_Semaphore_pend_FxnT)ti_sysbios_knl_Semaphore_pend__E; 
}

/* post_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Semaphore_post_FxnT)(void*);
static inline ti_sysbios_knl_Semaphore_post_FxnT ti_sysbios_knl_Semaphore_post_fxnP( void )
{
    return (ti_sysbios_knl_Semaphore_post_FxnT)ti_sysbios_knl_Semaphore_post__E; 
}

/* registerEvent_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Semaphore_registerEvent_FxnT)(void*, ti_sysbios_knl_Event_Handle, xdc_UInt);
static inline ti_sysbios_knl_Semaphore_registerEvent_FxnT ti_sysbios_knl_Semaphore_registerEvent_fxnP( void )
{
    return (ti_sysbios_knl_Semaphore_registerEvent_FxnT)ti_sysbios_knl_Semaphore_registerEvent__E; 
}

/* reset_{FxnT,fxnP} */
typedef void (*ti_sysbios_knl_Semaphore_reset_FxnT)(void*, xdc_Int);
static inline ti_sysbios_knl_Semaphore_reset_FxnT ti_sysbios_knl_Semaphore_reset_fxnP( void )
{
    return (ti_sysbios_knl_Semaphore_reset_FxnT)ti_sysbios_knl_Semaphore_reset__E; 
}


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_knl_Semaphore_Module__id ti_sysbios_knl_Semaphore_Module_id( void ) 
{
    return ti_sysbios_knl_Semaphore_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_knl_Semaphore_Module_hasMask( void ) 
{
    return ti_sysbios_knl_Semaphore_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_knl_Semaphore_Module_getMask( void ) 
{
    return ti_sysbios_knl_Semaphore_Module__diagsMask__C != 0 ? *ti_sysbios_knl_Semaphore_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_knl_Semaphore_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_knl_Semaphore_Module__diagsMask__C != 0) *ti_sysbios_knl_Semaphore_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_knl_Semaphore_Params_init( ti_sysbios_knl_Semaphore_Params* prms ) 
{
    if (prms) {
        ti_sysbios_knl_Semaphore_Params__init__S(prms, 0, sizeof(ti_sysbios_knl_Semaphore_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_knl_Semaphore_Params_copy( ti_sysbios_knl_Semaphore_Params* dst, const ti_sysbios_knl_Semaphore_Params* src ) 
{
    if (dst) {
        ti_sysbios_knl_Semaphore_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_knl_Semaphore_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_knl_Semaphore_Handle ti_sysbios_knl_Semaphore_Object_get( ti_sysbios_knl_Semaphore_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_knl_Semaphore_Handle)ti_sysbios_knl_Semaphore_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_knl_Semaphore_Handle ti_sysbios_knl_Semaphore_Object_first( void )
{
    return (ti_sysbios_knl_Semaphore_Handle)ti_sysbios_knl_Semaphore_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_knl_Semaphore_Handle ti_sysbios_knl_Semaphore_Object_next( ti_sysbios_knl_Semaphore_Object* obj )
{
    return (ti_sysbios_knl_Semaphore_Handle)ti_sysbios_knl_Semaphore_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_knl_Semaphore_Handle_label( ti_sysbios_knl_Semaphore_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_knl_Semaphore_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_knl_Semaphore_Handle_name( ti_sysbios_knl_Semaphore_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_knl_Semaphore_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_knl_Semaphore_Handle ti_sysbios_knl_Semaphore_create( xdc_Int count, const ti_sysbios_knl_Semaphore_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_knl_Semaphore_Args__create __args;
    __args.count = count;
    return (ti_sysbios_knl_Semaphore_Handle)ti_sysbios_knl_Semaphore_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Semaphore_Params), __eb);
}

/* construct */
static inline void ti_sysbios_knl_Semaphore_construct( ti_sysbios_knl_Semaphore_Struct* __obj, xdc_Int count, const ti_sysbios_knl_Semaphore_Params* __prms )
{
    ti_sysbios_knl_Semaphore_Args__create __args;
    __args.count = count;
    ti_sysbios_knl_Semaphore_Object__create__S(__obj, sizeof (ti_sysbios_knl_Semaphore_Struct), &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_knl_Semaphore_Params), 0);
}

/* delete */
static inline void ti_sysbios_knl_Semaphore_delete( ti_sysbios_knl_Semaphore_Handle* instp )
{
    ti_sysbios_knl_Semaphore_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_knl_Semaphore_destruct( ti_sysbios_knl_Semaphore_Struct* obj )
{
    ti_sysbios_knl_Semaphore_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_knl_Semaphore_Handle ti_sysbios_knl_Semaphore_handle( ti_sysbios_knl_Semaphore_Struct* str )
{
    return (ti_sysbios_knl_Semaphore_Handle)str;
}

/* struct */
static inline ti_sysbios_knl_Semaphore_Struct* ti_sysbios_knl_Semaphore_struct( ti_sysbios_knl_Semaphore_Handle inst )
{
    return (ti_sysbios_knl_Semaphore_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

//D:\TInew\bios_6_33_04_39\packages
/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */

/*
 *  @(#) ti.sysbios; 2, 0, 0, 0,566; 3-20-2012 14:01:21; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== module ti.sysbios.BIOS ========
 */

typedef struct ti_sysbios_BIOS_intSize ti_sysbios_BIOS_intSize;
typedef struct ti_sysbios_BIOS_Module_State ti_sysbios_BIOS_Module_State;

/*
 * ======== module ti.sysbios.BIOS_RtsGateProxy ========
 */

typedef struct ti_sysbios_BIOS_RtsGateProxy_Fxns__ ti_sysbios_BIOS_RtsGateProxy_Fxns__;
typedef const ti_sysbios_BIOS_RtsGateProxy_Fxns__* ti_sysbios_BIOS_RtsGateProxy_Module;
typedef struct ti_sysbios_BIOS_RtsGateProxy_Params ti_sysbios_BIOS_RtsGateProxy_Params;
typedef struct xdc_runtime_IGateProvider___Object *ti_sysbios_BIOS_RtsGateProxy_Handle;



/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Q_BLOCKING */

/* Q_PREEMPTING */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_BIOS_RtsGateProxy_Module__diagsEnabled;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__diagsEnabled ti_sysbios_BIOS_RtsGateProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_BIOS_RtsGateProxy_Module__diagsIncluded;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__diagsIncluded ti_sysbios_BIOS_RtsGateProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_BIOS_RtsGateProxy_Module__diagsMask;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__diagsMask ti_sysbios_BIOS_RtsGateProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_BIOS_RtsGateProxy_Module__gateObj;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__gateObj ti_sysbios_BIOS_RtsGateProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_BIOS_RtsGateProxy_Module__gatePrms;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__gatePrms ti_sysbios_BIOS_RtsGateProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_BIOS_RtsGateProxy_Module__id;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__id ti_sysbios_BIOS_RtsGateProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerDefined;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerDefined ti_sysbios_BIOS_RtsGateProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerObj;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerObj ti_sysbios_BIOS_RtsGateProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn0;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn0 ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn1;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn1 ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn2;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn2 ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn4;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn4 ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn8;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn8 ti_sysbios_BIOS_RtsGateProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_BIOS_RtsGateProxy_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Module__startupDoneFxn ti_sysbios_BIOS_RtsGateProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_BIOS_RtsGateProxy_Object__count;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Object__count ti_sysbios_BIOS_RtsGateProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_BIOS_RtsGateProxy_Object__heap;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Object__heap ti_sysbios_BIOS_RtsGateProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_BIOS_RtsGateProxy_Object__sizeof;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Object__sizeof ti_sysbios_BIOS_RtsGateProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_BIOS_RtsGateProxy_Object__table;
extern far const CT__ti_sysbios_BIOS_RtsGateProxy_Object__table ti_sysbios_BIOS_RtsGateProxy_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_BIOS_RtsGateProxy_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_BIOS_RtsGateProxy_Struct {
    const ti_sysbios_BIOS_RtsGateProxy_Fxns__* __fxns;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_BIOS_RtsGateProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*query)(xdc_Int);
    xdc_IArg (*enter)(ti_sysbios_BIOS_RtsGateProxy_Handle);
    void (*leave)(ti_sysbios_BIOS_RtsGateProxy_Handle, xdc_IArg);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_BIOS_RtsGateProxy_Fxns__ ti_sysbios_BIOS_RtsGateProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_BIOS_RtsGateProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_BIOS_RtsGateProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_BIOS_RtsGateProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_BIOS_RtsGateProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_BIOS_RtsGateProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_BIOS_RtsGateProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_BIOS_RtsGateProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_BIOS_RtsGateProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_BIOS_RtsGateProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool ti_sysbios_BIOS_RtsGateProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr ti_sysbios_BIOS_RtsGateProxy_Proxy__delegate__S( void );

/* query__E */

extern xdc_Bool ti_sysbios_BIOS_RtsGateProxy_query__E( xdc_Int qual );

extern xdc_Bool ti_sysbios_BIOS_RtsGateProxy_query__R( xdc_Int qual );

/* enter__E */

extern xdc_IArg ti_sysbios_BIOS_RtsGateProxy_enter__E( ti_sysbios_BIOS_RtsGateProxy_Handle __inst );

extern xdc_IArg ti_sysbios_BIOS_RtsGateProxy_enter__R( ti_sysbios_BIOS_RtsGateProxy_Handle __inst );

/* leave__E */

extern void ti_sysbios_BIOS_RtsGateProxy_leave__E( ti_sysbios_BIOS_RtsGateProxy_Handle __inst, xdc_IArg key );

extern void ti_sysbios_BIOS_RtsGateProxy_leave__R( ti_sysbios_BIOS_RtsGateProxy_Handle __inst, xdc_IArg key );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enter_{FxnT,fxnP} */
typedef xdc_IArg (*ti_sysbios_BIOS_RtsGateProxy_enter_FxnT)(void*);
static inline ti_sysbios_BIOS_RtsGateProxy_enter_FxnT ti_sysbios_BIOS_RtsGateProxy_enter_fxnP( void )
{
    return (ti_sysbios_BIOS_RtsGateProxy_enter_FxnT)ti_sysbios_BIOS_RtsGateProxy_enter__E; 
}

/* leave_{FxnT,fxnP} */
typedef void (*ti_sysbios_BIOS_RtsGateProxy_leave_FxnT)(void*, xdc_IArg);
static inline ti_sysbios_BIOS_RtsGateProxy_leave_FxnT ti_sysbios_BIOS_RtsGateProxy_leave_fxnP( void )
{
    return (ti_sysbios_BIOS_RtsGateProxy_leave_FxnT)ti_sysbios_BIOS_RtsGateProxy_leave__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IGateProvider_Module ti_sysbios_BIOS_RtsGateProxy_Module_upCast( void )
{
    return (xdc_runtime_IGateProvider_Module)ti_sysbios_BIOS_RtsGateProxy_Proxy__delegate__S();
}

/* Module_to_xdc_runtime_IGateProvider */

/* Handle_upCast */
static inline xdc_runtime_IGateProvider_Handle ti_sysbios_BIOS_RtsGateProxy_Handle_upCast( ti_sysbios_BIOS_RtsGateProxy_Handle i )
{
    return (xdc_runtime_IGateProvider_Handle)i;
}

/* Handle_to_xdc_runtime_IGateProvider */

/* Handle_downCast */
static inline ti_sysbios_BIOS_RtsGateProxy_Handle ti_sysbios_BIOS_RtsGateProxy_Handle_downCast( xdc_runtime_IGateProvider_Handle i )
{
    xdc_runtime_IGateProvider_Handle i2 = (xdc_runtime_IGateProvider_Handle)i;
if (ti_sysbios_BIOS_RtsGateProxy_Proxy__abstract__S()) return (ti_sysbios_BIOS_RtsGateProxy_Handle)i;
    return (void*)i2->__fxns == (void*)ti_sysbios_BIOS_RtsGateProxy_Proxy__delegate__S() ? (ti_sysbios_BIOS_RtsGateProxy_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IGateProvider */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_BIOS_RtsGateProxy_Module__id ti_sysbios_BIOS_RtsGateProxy_Module_id( void ) 
{
    return ti_sysbios_BIOS_RtsGateProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */

/* Params_init */
static inline void ti_sysbios_BIOS_RtsGateProxy_Params_init( ti_sysbios_BIOS_RtsGateProxy_Params* prms ) 
{
    if (prms) {
        ti_sysbios_BIOS_RtsGateProxy_Params__init__S(prms, 0, sizeof(ti_sysbios_BIOS_RtsGateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_BIOS_RtsGateProxy_Params_copy( ti_sysbios_BIOS_RtsGateProxy_Params* dst, const ti_sysbios_BIOS_RtsGateProxy_Params* src ) 
{
    if (dst) {
        ti_sysbios_BIOS_RtsGateProxy_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_BIOS_RtsGateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* create */
static inline ti_sysbios_BIOS_RtsGateProxy_Handle ti_sysbios_BIOS_RtsGateProxy_create( const ti_sysbios_BIOS_RtsGateProxy_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (ti_sysbios_BIOS_RtsGateProxy_Handle)ti_sysbios_BIOS_RtsGateProxy_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_BIOS_RtsGateProxy_Params), __eb);
}

/* delete */
static inline void ti_sysbios_BIOS_RtsGateProxy_delete( ti_sysbios_BIOS_RtsGateProxy_Handle* instp )
{
    ti_sysbios_BIOS_RtsGateProxy_Object__delete__S(instp);
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* ThreadType */
enum ti_sysbios_BIOS_ThreadType {
    ti_sysbios_BIOS_ThreadType_Hwi,
    ti_sysbios_BIOS_ThreadType_Swi,
    ti_sysbios_BIOS_ThreadType_Task,
    ti_sysbios_BIOS_ThreadType_Main
};
typedef enum ti_sysbios_BIOS_ThreadType ti_sysbios_BIOS_ThreadType;

/* RtsLockType */
enum ti_sysbios_BIOS_RtsLockType {
    ti_sysbios_BIOS_NoLocking,
    ti_sysbios_BIOS_GateHwi,
    ti_sysbios_BIOS_GateSwi,
    ti_sysbios_BIOS_GateMutex,
    ti_sysbios_BIOS_GateMutexPri
};
typedef enum ti_sysbios_BIOS_RtsLockType ti_sysbios_BIOS_RtsLockType;

/* LibType */
enum ti_sysbios_BIOS_LibType {
    ti_sysbios_BIOS_LibType_Instrumented,
    ti_sysbios_BIOS_LibType_NonInstrumented,
    ti_sysbios_BIOS_LibType_Custom,
    ti_sysbios_BIOS_LibType_Debug
};
typedef enum ti_sysbios_BIOS_LibType ti_sysbios_BIOS_LibType;

/* WAIT_FOREVER */

/* NO_WAIT */

/* StartupFuncPtr */
typedef void (*ti_sysbios_BIOS_StartupFuncPtr)(void);


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* intSize */
struct ti_sysbios_BIOS_intSize {
    xdc_Int intSize;
};

/* StartFuncPtr */
typedef void (*ti_sysbios_BIOS_StartFuncPtr)(void);


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_BIOS_Module__diagsEnabled;
extern far const CT__ti_sysbios_BIOS_Module__diagsEnabled ti_sysbios_BIOS_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_BIOS_Module__diagsIncluded;
extern far const CT__ti_sysbios_BIOS_Module__diagsIncluded ti_sysbios_BIOS_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_BIOS_Module__diagsMask;
extern far const CT__ti_sysbios_BIOS_Module__diagsMask ti_sysbios_BIOS_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_BIOS_Module__gateObj;
extern far const CT__ti_sysbios_BIOS_Module__gateObj ti_sysbios_BIOS_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_BIOS_Module__gatePrms;
extern far const CT__ti_sysbios_BIOS_Module__gatePrms ti_sysbios_BIOS_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_BIOS_Module__id;
extern far const CT__ti_sysbios_BIOS_Module__id ti_sysbios_BIOS_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_BIOS_Module__loggerDefined;
extern far const CT__ti_sysbios_BIOS_Module__loggerDefined ti_sysbios_BIOS_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_BIOS_Module__loggerObj;
extern far const CT__ti_sysbios_BIOS_Module__loggerObj ti_sysbios_BIOS_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_BIOS_Module__loggerFxn0;
extern far const CT__ti_sysbios_BIOS_Module__loggerFxn0 ti_sysbios_BIOS_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_BIOS_Module__loggerFxn1;
extern far const CT__ti_sysbios_BIOS_Module__loggerFxn1 ti_sysbios_BIOS_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_BIOS_Module__loggerFxn2;
extern far const CT__ti_sysbios_BIOS_Module__loggerFxn2 ti_sysbios_BIOS_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_BIOS_Module__loggerFxn4;
extern far const CT__ti_sysbios_BIOS_Module__loggerFxn4 ti_sysbios_BIOS_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_BIOS_Module__loggerFxn8;
extern far const CT__ti_sysbios_BIOS_Module__loggerFxn8 ti_sysbios_BIOS_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_BIOS_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_BIOS_Module__startupDoneFxn ti_sysbios_BIOS_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_BIOS_Object__count;
extern far const CT__ti_sysbios_BIOS_Object__count ti_sysbios_BIOS_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_BIOS_Object__heap;
extern far const CT__ti_sysbios_BIOS_Object__heap ti_sysbios_BIOS_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_BIOS_Object__sizeof;
extern far const CT__ti_sysbios_BIOS_Object__sizeof ti_sysbios_BIOS_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_BIOS_Object__table;
extern far const CT__ti_sysbios_BIOS_Object__table ti_sysbios_BIOS_Object__table__C;

/* smpEnabled */
typedef xdc_Bool CT__ti_sysbios_BIOS_smpEnabled;
extern far const CT__ti_sysbios_BIOS_smpEnabled ti_sysbios_BIOS_smpEnabled__C;

/* cpuFreq */
typedef xdc_runtime_Types_FreqHz CT__ti_sysbios_BIOS_cpuFreq;
extern far const CT__ti_sysbios_BIOS_cpuFreq ti_sysbios_BIOS_cpuFreq__C;

/* taskEnabled */
typedef xdc_Bool CT__ti_sysbios_BIOS_taskEnabled;
extern far const CT__ti_sysbios_BIOS_taskEnabled ti_sysbios_BIOS_taskEnabled__C;

/* swiEnabled */
typedef xdc_Bool CT__ti_sysbios_BIOS_swiEnabled;
extern far const CT__ti_sysbios_BIOS_swiEnabled ti_sysbios_BIOS_swiEnabled__C;

/* clockEnabled */
typedef xdc_Bool CT__ti_sysbios_BIOS_clockEnabled;
extern far const CT__ti_sysbios_BIOS_clockEnabled ti_sysbios_BIOS_clockEnabled__C;

/* heapSize */
typedef xdc_SizeT CT__ti_sysbios_BIOS_heapSize;
extern far const CT__ti_sysbios_BIOS_heapSize ti_sysbios_BIOS_heapSize__C;

/* heapSection */
typedef xdc_String CT__ti_sysbios_BIOS_heapSection;
extern far const CT__ti_sysbios_BIOS_heapSection ti_sysbios_BIOS_heapSection__C;

/* installedErrorHook */
typedef void (*CT__ti_sysbios_BIOS_installedErrorHook)(xdc_runtime_Error_Block*);
extern far const CT__ti_sysbios_BIOS_installedErrorHook ti_sysbios_BIOS_installedErrorHook__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_BIOS_Module__startupDone__S( void );

/* start__E */

extern void ti_sysbios_BIOS_start__E( void );

extern void ti_sysbios_BIOS_start__F( void );
extern void ti_sysbios_BIOS_start__R( void );

/* exit__E */

extern void ti_sysbios_BIOS_exit__E( xdc_Int stat );

extern void ti_sysbios_BIOS_exit__F( xdc_Int stat );
extern void ti_sysbios_BIOS_exit__R( xdc_Int stat );

/* getThreadType__E */

extern ti_sysbios_BIOS_ThreadType ti_sysbios_BIOS_getThreadType__E( void );

extern ti_sysbios_BIOS_ThreadType ti_sysbios_BIOS_getThreadType__F( void );
extern ti_sysbios_BIOS_ThreadType ti_sysbios_BIOS_getThreadType__R( void );

/* setThreadType__E */

extern ti_sysbios_BIOS_ThreadType ti_sysbios_BIOS_setThreadType__E( ti_sysbios_BIOS_ThreadType ttype );

extern ti_sysbios_BIOS_ThreadType ti_sysbios_BIOS_setThreadType__F( ti_sysbios_BIOS_ThreadType ttype );
extern ti_sysbios_BIOS_ThreadType ti_sysbios_BIOS_setThreadType__R( ti_sysbios_BIOS_ThreadType ttype );

/* setCpuFreq__E */

extern void ti_sysbios_BIOS_setCpuFreq__E( xdc_runtime_Types_FreqHz* freq );

extern void ti_sysbios_BIOS_setCpuFreq__F( xdc_runtime_Types_FreqHz* freq );
extern void ti_sysbios_BIOS_setCpuFreq__R( xdc_runtime_Types_FreqHz* freq );

/* getCpuFreq__E */

extern void ti_sysbios_BIOS_getCpuFreq__E( xdc_runtime_Types_FreqHz* freq );

extern void ti_sysbios_BIOS_getCpuFreq__F( xdc_runtime_Types_FreqHz* freq );
extern void ti_sysbios_BIOS_getCpuFreq__R( xdc_runtime_Types_FreqHz* freq );

/* errorRaiseHook__I */

extern void ti_sysbios_BIOS_errorRaiseHook__I( xdc_runtime_Error_Block* eb );

/* startFunc__I */

extern void ti_sysbios_BIOS_startFunc__I( void );

/* registerRTSLock__I */

extern void ti_sysbios_BIOS_registerRTSLock__I( void );

/* removeRTSLock__I */

extern void ti_sysbios_BIOS_removeRTSLock__I( void );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_BIOS_Module__id ti_sysbios_BIOS_Module_id( void ) 
{
    return ti_sysbios_BIOS_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_BIOS_Module_hasMask( void ) 
{
    return ti_sysbios_BIOS_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_BIOS_Module_getMask( void ) 
{
    return ti_sysbios_BIOS_Module__diagsMask__C != 0 ? *ti_sysbios_BIOS_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_BIOS_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_BIOS_Module__diagsMask__C != 0) *ti_sysbios_BIOS_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */


/*
 *  @(#) ti.sysbios; 2, 0, 0, 0,566; 3-20-2012 14:01:21; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */





/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/*
 *  @(#) ti.sysbios; 2, 0, 0, 0,566; 3-20-2012 14:01:20; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */







typedef void (*pfnTask)(void *);

typedef enum TaskStack
{
	TSK_STACKSIZE_1024 = 1024,
	TSK_STACKSIZE_2048 = 2048,
	TSK_STACKSIZE_3072 = 3072,
	TSK_STACKSIZE_4096 = 4096,
	TSK_STACKSIZE_8192 = 8192
}TaskStack;

typedef enum TaskPri
{
	TSK_PRIORITY_0   = 0,
	TSK_PRIORITY_1,
	TSK_PRIORITY_2,
	TSK_PRIORITY_3,
	TSK_PRIORITY_4,
	TSK_PRIORITY_5,
	TSK_PRIORITY_6,
	TSK_PRIORITY_7,
	TSK_PRIORITY_8,
	TSK_PRIORITY_9,
	TSK_PRIORITY_10,
	TSK_PRIORITY_11,
	TSK_PRIORITY_12,
	TSK_PRIORITY_13,
	TSK_PRIORITY_14,
	TSK_PRIORITY_15
}TaskPri;

typedef struct stSteTask
{
	UINT8       Name[20];
	TaskPri     hPriority;
	//TSK_Handle Handle;
	ti_sysbios_knl_Task_Handle Handle;
	//TSK_Attrs  tskattrs;
	ti_sysbios_knl_Task_Params tskattrs;
    void (*pfnTask)(void *);
}Task;

// Creates a task in a non-running state
extern BOOL Task_Init(Task *pThis, String sName,  pfnTask pfn , void *pArg);
// Creates a task in a non-running state - Different version has prio and stack size
extern BOOL Task_Init1(Task *pThis, String Name,  pfnTask pfn , void *pArg, TaskStack  eStacksize, TaskPri ePriority );

/* Start the Task */
void Task_Start(Task *pThis);

/* Stop the Task */
extern void Task_Stop(Task *pThis);

/*Given the task, Sets Task priority */
extern void Task_SetPri(Task *pThis, TaskPri ePriority);

/*Mutex and Sigal based on the Semaphore. */

typedef struct stMutex
{
	char Name[20];
	//volatile SEM_Handle Handle;
	volatile ti_sysbios_knl_Semaphore_Handle Handle;
}Mutex;


extern BOOL Mutex_Init( Mutex *pThis , char *name, UINT8 InitState);
extern void Mutex_Lock( Mutex *pThis );
extern void Mutex_Unlock( Mutex *pThis );
extern BOOL Mutex_Lock_Timeout( Mutex *pThis);


/* A wrapper intertask signal based on Semaphore variable */
typedef Mutex Signal;

extern BOOL Signal_Init( Signal *pThis, String name);
extern void Signal_Pend( Signal *pThis);
extern void Signal_Enable(Signal *pThis);
extern BOOL Signal_Poll( Signal *pThis, UINT16 nTimeout);
extern void Signal_Post( Signal *pThis );

extern void Signal_Broadcast( Signal *pThis);



/**
 *   @file  csl_gpio.h
 *
 *   @brief
 *      This is the main Header File for the GPIO Module which defines all
 *      the data structures and exported API.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/** @defgroup CSL_GPIO_API GPIO
 *
 * @section Introduction
 *
 * @subsection 
 *  None
 *
 * @subsection References
 *  None
 *
 */

/**
@defgroup CSL_GPIO_DATASTRUCT  GPIO Data structures
@ingroup  CSL_GPIO_API
*/

/**
@defgroup CSL_GPIO_FUNCTION  GPIO Functions
@ingroup  CSL_GPIO_API
*/

/**
@addtogroup CSL_GPIO_DATASTRUCT  
@{
*/

/** @brief This is the handle to the GPIO instance */
typedef volatile CSL_GpioRegs*   CSL_GpioHandle;

/**
@}
*/

/* Device specific API which opens the GPIO instance and returns a handle used in all subsequent calls */
extern CSL_GpioHandle CSL_GPIO_open (Int32 instNum);
        




/*  ============================================================================
 *   Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2008
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
 
/** ============================================================================
 *   @file  csl_intc.h
 *
 *   @path  $(CSLPATH)\inc
 *
 *   @desc  Header file for functional layer CSL of INTC
 *
 */

/** @defgroup CSL_INTC_API INTC  
 *
 *  @section Introduction 
 *  
 * The CPU has one exception input, one non-maskable interrupt, 12 maskable
 * interrupts, and two dedicated emulation interrupts.The Interrupt Controller
 * supports up to 128 system events. There are 128 system events that act as
 * inputs to the Interrupt Controller. They consist of both internally-generated
 * events (within the megamodule) and chip-level events. In addition to these
 * 128 events, INTC also receives (and routes straight through to the CPU) the
 * non-maskable and reset events.From these event inputs, the Interrupt
 * Controller outputs signals to the CPU:
 *   - One maskable, hardware exception (EXCEP)
 *   - Twelve maskable hardware interrupts (INT4 ... INT15)
 *   - One non-maskable signal which can be used as either an interrupt or
 * exception (NMI)
 *   - One reset signal (RESET)
 * 
 * NOTE: The CSL 3.0 INTC module is delivered as a separate library from the
 * remaining CSL modules. When using an embedded operating system that contains
 * interrupt controller/dispatcher support, do not link in the INTC library.
 * For interrupt controller support, DSP/BIOS users should use the HWI
 * (Hardware Interrupt) and ECM (Event Combiner Manager) modules supported
 * under DSP/BIOS v5.21 or later.
 *  
 *  @subsection References
 *     -# CSL 3.x Technical Requirements Specifications Version 0.5, dated
 *        May 14th, 2003
 *     -# TMS320C64x+ DSP Megamodule SPRU871I.pdf (May 2008)
 *  
 *  @subsection Assumptions
 *     The abbreviations INTC, Intc and intc have been used throughout this
 *     document to refer to Interrupt Controller
 */


/* =============================================================================
 *  Revision History
 *  ===============
 *  12-Jun-2004 Ruchika Kharwar File Created
 *  14-Mar-2005 brn Moved the Event Ids to soc64plus.h
 *  16-Mar-2005 brn modified for doxygen documentation
 *  19-Nov-2008 Updated for Doxygen
 * =============================================================================
 */


/*  ===========================================================================
 *  Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2006, 2008
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** ============================================================================
 *   @file  cslr_intc.h
 *
 *   @path  $(CSLPATH)\inc
 *
 *   @desc  This file contains the Register Desciptions for INTC
 *
 */


/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 EVTFLAG[4];
    volatile Uint8 RSVD0[16];
    volatile Uint32 EVTSET[4];
    volatile Uint8 RSVD1[16];
    volatile Uint32 EVTCLR[4];
    volatile Uint8 RSVD2[48];
    volatile Uint32 EVTMASK[4];
    volatile Uint8 RSVD3[16];
    volatile Uint32 MEVTFLAG[4];
    volatile Uint8 RSVD4[16];
    volatile Uint32 EXPMASK[4];
    volatile Uint8 RSVD5[16];
    volatile Uint32 MEXPFLAG[4];
    volatile Uint8 RSVD6[20];
    volatile Uint32 INTMUX1;
    volatile Uint32 INTMUX2;
    volatile Uint32 INTMUX3;
    volatile Uint8 RSVD7[112];
    volatile Uint32 INTXSTAT;
    volatile Uint32 INTXCLR;
    volatile Uint32 INTDMASK;
} CSL_IntcRegs;

typedef volatile CSL_IntcRegs         *CSL_IntcRegsOvly;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* EVTFLAG */


































/* EVTSET */


































/* EVTCLR */


































/* EVTMASK */


































/* MEVTFLAG */


































/* EXPMASK */


































/* MEXPFLAG */


































/* INTMUX1 */






/* INTMUX2 */






/* INTMUX3 */






/* INTXSTAT */


/*----SYSINT Tokens----*/


/*----CPUINT Tokens----*/



/*----DROP Tokens----*/


/* INTXCLR */




/* INTDMASK */















/**
@defgroup CSL_INTC_DATASTRUCT  INTC Data Structures
@ingroup CSL_INTC_API
*/
/**
@defgroup CSL_INTC_SYMBOL  INTC Symbols Defined
@ingroup CSL_INTC_API
*/
/**
@defgroup CSL_INTC_ENUM  INTC Enumerated Data Types
@ingroup CSL_INTC_API
*/

/**
@defgroup CSL_INTC_FUNCTION  INTC Functions
@ingroup CSL_INTC_API
*/

/**
@addtogroup CSL_INTC_SYMBOL
@{
*/
        
/** Number of Events in the System */

/** Indicates there is no associated event-handler */

/** Invalid handle */

/** None mapped */

/**
@}
*/

/** @addtogroup CSL_INTC_ENUM
 @{ */
        
/**
 *  Interrupt Vector IDs
 */
typedef enum {
    /** Should be used only along with CSL_intcHookIsr() */
    CSL_INTC_VECTID_NMI      =   1,   
    /** CPU Vector 4 */
    CSL_INTC_VECTID_4        =   4,
    /** CPU Vector 5 */   
    CSL_INTC_VECTID_5        =   5,   
    /** CPU Vector 6 */
    CSL_INTC_VECTID_6        =   6,   
    /** CPU Vector 7 */
    CSL_INTC_VECTID_7        =   7,   
    /** CPU Vector 8 */
    CSL_INTC_VECTID_8        =   8,
    /** CPU Vector 9 */
    CSL_INTC_VECTID_9        =   9,
    /** CPU Vector 10 */   
    CSL_INTC_VECTID_10       =   10,
    /** CPU Vector 11 */   
    CSL_INTC_VECTID_11       =   11,
    /** CPU Vector 12 */  
    CSL_INTC_VECTID_12       =   12,
    /** CPU Vector 13 */  
    CSL_INTC_VECTID_13       =   13,  
    /** CPU Vector 14 */    
    CSL_INTC_VECTID_14       =   14,
    /** CPU Vector 15 */  
    CSL_INTC_VECTID_15       =   15,  
    /** Should be used at the time of opening an Event handle
     *  to specify that the event needs to go to the combiner
     */
    CSL_INTC_VECTID_COMBINE  =   16,  
    /** Should be used at the time of opening an Event handle
     * to specify that the event needs to go to the exception
     * combiner.
     */
    CSL_INTC_VECTID_EXCEP    =   17   
} CSL_IntcVectId; 

/**
 *  Interrupt Event IDs
 */
typedef Int     CSL_IntcEventId; 


/**
 *  Enumeration of the control commands
 *
 *  These are the control commands that could be used with
 *  CSL_intcHwControl(..). Some of the commands expect an
 *  argument as documented along-side the description of
 *  the command.
 */
typedef enum {
        /**
         * @brief   Enables the event
         * @param   CSL_IntcEnableState
         */
    CSL_INTC_CMD_EVTENABLE      = 0,
        /**
         * @brief   Disables the event
         * @param   CSL_IntcEnableState
         */
    CSL_INTC_CMD_EVTDISABLE     = 1,
        /**
         * @brief   Sets the event manually
         * @param   None
         */   
    CSL_INTC_CMD_EVTSET         =2,
        /**
         * @brief   Clears the event (if pending)
         * @param   None
         */
    CSL_INTC_CMD_EVTCLEAR       =3,
        /**
         * @brief   Enables the Drop Event detection feature for this event
         * @param   None
         */    
    CSL_INTC_CMD_EVTDROPENABLE  =4,
        /**
         * @brief   Disables the Drop Event detection feature for this event
         * @param   None
         */       
    CSL_INTC_CMD_EVTDROPDISABLE =5,
        /**
         * @brief   To be used ONLY to invoke the associated Function handle 
         * with Event when the user is writing an exception handling routine. 
         * @param   None
         */             
    CSL_INTC_CMD_EVTINVOKEFUNCTION = 6
} CSL_IntcHwControlCmd;


/**
 *  Enumeration of the queries
 *
 *  These are the queries that could be used with CSL_intcGetHwStatus(..).
 *  The queries return a value through the object pointed to by the pointer
 *  that it takes as an argument. The argument supported by the query is
 *  documented along-side the description of the query.
 */
typedef enum {
        /**
         * @brief   The Pend Status of the Event is queried 
         * @param   Bool
         */  
    CSL_INTC_QUERY_PENDSTATUS
}CSL_IntcHwStatusQuery;


/**
 *  Enumeration of the exception mask registers
 *
 *  These are the symbols used along with the value to be programmed
 *  into the Exception mask register.
 */
typedef enum {
        /**
         * @brief   Symbol for EXPMASK[0]
         * @param   BitMask for EXPMASK0
         */
    CSL_INTC_EXCEP_0TO31 = 0,
        /**
         * @brief   Symbol for EXPMASK[1]
         * @param   BitMask for EXPMASK1
         */
    CSL_INTC_EXCEP_32TO63 = 1,
        /**
         * @brief   Symbol for EXPMASK[2]
         * @param   BitMask for EXPMASK2
         */   
    CSL_INTC_EXCEP_64TO95 = 2,
        /**
         * @brief   Symbol for EXPMASK[3]
         * @param   BitMask for EXPMASK3
         */
    CSL_INTC_EXCEP_96TO127 = 3
} CSL_IntcExcepEn;

/**
 *  Enumeration of the exception
 * These are the symbols used along with the Exception Clear API
 */
typedef enum {
        /**
         * @brief   Symbol for NMI
         * @param   None
         */ 
    CSL_INTC_EXCEPTION_NMI = 31,
        /**
         * @brief   Symbol for External Exception
         * @param   None
         */ 
    CSL_INTC_EXCEPTION_EXT = 30,
        /**
         * @brief   Symbol for Internal Exception
         * @param   None
         */ 
    CSL_INTC_EXCEPTION_INT = 1,
        /**
         * @brief   Symbol for Software Exception
         * @param   None
         */ 
    CSL_INTC_EXCEPTION_SW = 0
} CSL_IntcExcep;

/**
@}
*/

/** @addtogroup CSL_INTC_DATASTRUCT
 @{ */

/**
 *  Event Handler pointer
 *
 *  Event handlers ought to conform to this type
 */
typedef void (* CSL_IntcEventHandler)(void *);


/**
 *  Event Handler Record
 *
 *  Used to set-up the event-handler using CSL_intcPlugEventHandler(..)
 */
typedef struct  {
    /** pointer to the event handler */
    CSL_IntcEventHandler    handler;
    /** the argument to be passed to the handler when it is invoked */  
    void *                  arg;        
                                          
} CSL_IntcEventHandlerRecord;

/**
 *  INTC Module Context. 
 */
typedef struct {
    /** Pointer to the event handle record */
    CSL_IntcEventHandlerRecord* eventhandlerRecord;

    /** Event allocation mask */
    CSL_BitMask32   eventAllocMask[(128 + 31) / 32];

    /** Number of event entries */
    Uint16          numEvtEntries;

    /** Reserved */
    Int8            offsetResv[128];
} CSL_IntcContext;


/**
 *  Event enable state
 */
typedef Uint32 CSL_IntcEventEnableState;


/**
 *  Global Interrupt enable state
 */
typedef Uint32 CSL_IntcGlobalEnableState;

/**
 *  The interrupt handle object
 *  This object is used by the handle to identify the event.
 */
typedef struct CSL_IntcObj {
    /** The event-id */
    CSL_IntcEventId eventId;
    /** The vector-id */    
    CSL_IntcVectId   vectId;    
} CSL_IntcObj;

/**
 *  The drop status structure
 *
 *  This object is used along with the CSL_intcQueryDropStatus()
 *  API.
 */
typedef struct {
    /** whether dropped/not */
    Bool drop;
    /** The event-id */                  
    CSL_IntcEventId eventId;
    /** The vect-id */    
    CSL_IntcVectId  vectId;     
}CSL_IntcDropStatus;

/**
 *  INTC module parameters for open
 *
 *  This is equivalent to the Vector Id for the event number.
 */
typedef CSL_IntcVectId CSL_IntcParam;

/**
 *  The interrupt handle
 *
 *  This is returned by the CSL_intcOpen(..) API. The handle is used
 *  to identify the event of interest in all INTC calls.
 */
typedef struct CSL_IntcObj*   CSL_IntcHandle;

/**
@}
*/

/** @addtogroup CSL_INTC_FUNCTION
 @{ */

/*  ============================================================================
 *   @n@b CSL_intcInit
 *
 *   @b Description
 *   @n This is the initialization function for the INTC. This function is
 *      idempotent in that calling it many times is same as calling it once.
 *      This function initializes the CSL data structures, and doesn't affect
 *      the H/W.
 *
 *   @b Arguments
 *   @verbatim
              pContext     Pointer to module-context structure
             
    @endverbatim
 *
 *   <b> Return Value </b>  CSL_Status
 *   @li                    CSL_SOK - Always returns
 *
 *   <b> Pre Condition </b>
 *   @n  This function should be called before using any of the CSL INTC APIs. 
 *       The context should be initialized such that numEvtEntries is equal to 
 *       the number of records capable of being held in the eventhandlerRecord
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n  None
 *
 *   @b Example
 *   @verbatim
    CSL_IntcContext context; 
    CSL_Status intStat;
    CSL_IntcParam vectId;
    CSL_IntcEventHandlerRecord recordTable[10];
    
    context.numEvtEntries = 10;
    context.eventhandlerRecord = &recordTable;

    // Init Module
    ...
    if (CSL_intcInit(&context) != CSL_SOK) {
       exit;
    }
     @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcInit (
    CSL_IntcContext     *pContext 
);

/*  ============================================================================
 *   @n@b CSL_intcOpen
 *
 *   @b Description
 *   @n The API would reserve an interrupt-event for use. It returns
 *      a valid handle to the event only if the event is not currently
 *      allocated. The user could release the event after use by calling
 *      CSL_intcClose(..). The CSL-object ('intcObj') that the user
 *      passes would be used to store information pertaining handle.
 *
 *   @b Arguments
 *   @verbatim
              pIntcObj     pointer to the CSL-object allocated by the user

              eventId      the event-id of the interrupt

              param        pointer to the Intc specific parameter

              pStatus      (optional) pointer for returning status of the
                           function call
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_IntcHandle
 *   @n                     Valid INTC handle identifying the event
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n   1.    INTC object structure is populated
 *   @n   2.    The status is returned in the status variable. If status
 *              returned is
 *   @li            CSL_SOK             Valid intc handle is returned
 *   @li            CSL_ESYS_FAIL       The open command failed
 *
 *   @b Writes
 *   @n    1. The status variable
 *   @n    2. INTC object structure
 *
 * @b Example:
 * @verbatim

        CSL_IntcObj                 intcObj20;
        CSL_IntcGlobalEnableState   state;
        CSL_IntcContext             context;
        CSL_Status                  intStat;
        CSL_IntcParam               vectId;

        context.numEvtEntries = 0;
        context.eventhandlerRecord = NULL;
        // Init Module
        CSL_intcInit(&context);

        // NMI Enable
        CSL_intcGlobalNmiEnable();

        // Enable Global Interrupts
        intStat = CSL_intcGlobalEnable(&state);

        // Opening a handle for the Event 20 at vector id 4

        vectId = CSL_INTC_VECTID_4;
        hIntc20 = CSL_intcOpen (&intcObj20, CSL_INTC_EVENTID_20, &vectId , NULL);

        // Close handle
        CSL_IntcClose(hIntc20);
   @endverbatim
 * =============================================================================
 */
CSL_IntcHandle   CSL_intcOpen (
    CSL_IntcObj        *intcObj,    
    CSL_IntcEventId     eventId,    
    CSL_IntcParam      *params,     
    CSL_Status         *status
);

/* =============================================================================
 *   @n@b CSL_intcClose
 *
 *   @b Description
 *   @n This intc Handle can no longer be used to access the event. The event is 
 *    de-allocated and further access to the event resources are possible only after
 *    opening the event object again.
 *
 *   @b Arguments
 *   @verbatim
            hIntc            Handle identifying the event
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_Status
 *   @li                    CSL_SOK             - Close successful
 *   @li                    CSL_ESYS_FAIL       - Close failed
 *
 *   @b Example
 *   @verbatim
        CSL_IntcContext             context; 
        CSL_Status                  intStat;
        CSL_IntcParam               vectId;
        CSL_IntcObj                 intcObj20;
        CSL_IntcHandle              hIntc20;
        CSL_IntcEventHandlerRecord  recordTable[10];

        context.numEvtEntries = 10;
        context.eventhandlerRecord = &recordTable;

        // Init Module
        ...
        if (CSL_intcInit(&context) != CSL_SOK) {
           exit;
        // Opening a handle for the Event 20 at vector id 4

        vectId = CSL_INTC_VECTID_4;
        hIntc20 = CSL_intcOpen (&intcObj20, CSL_INTC_EVENTID_20, &vectId , NULL);

        // Close handle
        CSL_IntcClose(hIntc20);    
               
     @endverbatim
 * =============================================================================
 */
CSL_Status  CSL_intcClose (
    CSL_IntcHandle      hIntc   
);

/*  ============================================================================
 *  @n@b CSL_intcPlugEventHandler
 *
 *  @b Description
 *  @n Associate an event-handler with an event
 *     CSL_intcPlugEventHandler(..) ties an event-handler to an event; so
 *     that the occurence of the event, would result in the event-handler
 *     being invoked.
 *
 *  @b Arguments
 *  @verbatim
        hIntc                Handle identying the interrupt-event

        eventHandlerRecord   Provides the details of the event-handler
    @endverbatim
 *
 *  <b> Return Value </b>
 *  @n  Returns the address of the previous handler
 *
 *  @b Example:
 *  @verbatim
        CSL_IntcObj                 intcObj20;
        CSL_IntcGlobalEnableState   state;
        CSL_IntcContext             context; 
        CSL_Status                  intStat;
        CSL_IntcParam               vectId;

        context.numEvtEntries = 0;
        context.eventhandlerRecord = NULL;
        // Init Module
        CSL_intcInit(&context);

        // NMI Enable   
        CSL_intcGlobalNmiEnable();

        // Enable Global Interrupts 
        intStat = CSL_intcGlobalEnable(&state);

        // Opening a handle for the Event 20 at vector id 4

        vectId = CSL_INTC_VECTID_4;
        hIntc20 = CSL_intcOpen (&intcObj20, CSL_INTC_EVENTID_20, &vectId , NULL);

        EventRecord.handler = &event20Handler;
        EventRecord.arg = hIntc20;
        CSL_intcPlugEventHandler(hIntc20,&EventRecord); 
        // Close handle
        CSL_IntcClose(hIntc20);
        }

        void event20Handler( CSL_IntcHandle hIntc)
        {

        }
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcPlugEventHandler (
    CSL_IntcHandle                  hIntc,
    CSL_IntcEventHandlerRecord      *eventHandlerRecord
);

/*  ============================================================================
 *  @n@b CSL_intcHookIsr
 *
 *  @b Description
 *  @n Hook up an exception handler
 *     This API hooks up the handler to the specified exception.
 *     Note: In this case, it is done by inserting a B(ranch) instruction
 *     to the handler. Because of the restriction in the instruction
 *     th handler must be within 32MB of the exception vector.
 *     Also, the function assumes that the exception vector table is
 *     located at its default ("low") address.
 *
 *  @b Arguments
 *  @verbatim
        vectId       Interrupt Vector identifier

        isrAddr      Pointer to the handler
    @endverbatim
 *
 *  @b Example:
 *  @verbatim
        CSL_IntcContext             context; 
        CSL_Status                  intStat;
        CSL_IntcParam               vectId;
        CSL_IntcObj                 intcObj20;
        CSL_IntcHandle              hIntc20;
        CSL_IntcDropStatus          drop;
        CSL_IntcEventHandlerRecord  recordTable[10];
        CSL_IntcGlobalEnableState   state;
        Uint32 intrStat;

        context.numEvtEntries = 10;
        context.eventhandlerRecord = &recordTable;

        // Init Module
        ...
        if (CSL_intcInit(&context) != CSL_SOK)
           exit;
        // Opening a handle for the Event 20 at vector id 4

        vectId = CSL_INTC_VECTID_4;
        hIntc20 = CSL_intcOpen (&intcObj20, CSL_INTC_EVENTID_20, &vectId , NULL);

        CSL_intcNmiEnable();
        // Enable Global Interrupts 
        intStat = CSL_intcGlobalEnable(&state);

        // Hook Isr appropriately
        CSL_intcHookIsr(CSL_INTC_VECTID_4,&isrVect4);
        ...
         }
        interrupt void isrVect4()
        {

        }
        @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcHookIsr (
    CSL_IntcVectId  vectId,
    void            *isrAddr
);

/*  ============================================================================
 *   @n@b CSL_intcHwControl
 *
 *   @b Description
 *   @n Perform a control-operation. This API is used to invoke any of the
 *      supported control-operations supported by the module.
 *
 *   @b Arguments
 *   @verbatim
            hIntc           Handle identifying the event

            command         The command to this API indicates the action to be
                            taken on INTC.

            commandArg      An optional argument.
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_Status
 *   @li                    CSL_SOK             - HwControl successful.
 *   @li                    CSL_ESYS_BADHANDLE  - Invalid handle
 *   @li                    CSL_ESYS_INVCMD     - Invalid command
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_intcOpen() must be invoked before this call.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n The hardware registers of INTC.
 *
 *   @b Example
 *   @verbatim
        CSL_IntcObj                 intcObj20;
        CSL_IntcGlobalEnableState   state;
        CSL_IntcContext             context; 
        CSL_Status                  intStat;
        CSL_IntcParam               vectId;
        
        context.numEvtEntries = 0;
        context.eventhandlerRecord = NULL;
        
        // Init Module
        CSL_intcInit(&context);

        // NMI Enable   
        CSL_intcGlobalNmiEnable();

        // Enable Global Interrupts 
        intStat = CSL_intcGlobalEnable(&state);

        // Opening a handle for the Event 20 at vector id 4

        vectId = CSL_INTC_VECTID_4;
        hIntc20 = CSL_intcOpen (&intcObj20, CSL_INTC_EVENTID_20, &vectId , NULL);

        CSL_intcHwControl(hIntc20,CSL_INTC_CMD_EVTENABLE,NULL);
     @endverbatim
 * =============================================================================
 */

CSL_Status CSL_intcHwControl (
    CSL_IntcHandle          hIntc,      
    CSL_IntcHwControlCmd    command,    
    void                   *commandArg  
);

/*  ============================================================================
 *   @n@b CSL_intcGetHwStatus
 *
 *   @b Description
 *   @n Queries the peripheral for status. The CSL_intcGetHwStatus(..) API
 *      could be used to retrieve status or configuration information from
 *      the peripheral. The user must allocate an object that would hold
 *      the retrieved information and pass a pointer to it to the function.
 *      The type of the object is specific to the query-command.
 *
 *   @b Arguments
 *   @verbatim
            hIntc           Handle identifying the event

            query           The query to this API of INTC which indicates the
                            status to be returned.

            answer          Placeholder to return the status.
     @endverbatim
 *
 *   <b> Return Value </b> CSL_Status
 *   @li                   CSL_SOK               - Status info return successful
 *   @li                   CSL_ESYS_BADHANDLE    - Invalid handle
 *   @li                   CSL_ESYS_INVQUERY     - Invalid query
 *   @li                   CSL_ESYS_NOTSUPPORTED - Action not supported
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n None
 *
 *   @b Example:
 *   @verbatim
        CSL_IntcContext             context; 
        CSL_Status                  intStat;
        CSL_IntcParam               vectId;
        CSL_IntcObj                 intcObj20;
        CSL_IntcHandle              hIntc20;
        CSL_IntcEventHandlerRecord  recordTable[10];
        CSL_IntcGlobalEnableState   state;
        Uint32                      intrStat;

        context.numEvtEntries = 10;
        context.eventhandlerRecord = &recordTable;

        // Init Module
        ...
        if (CSL_intcInit(&context) != CSL_SOK)
           exit;
        // Opening a handle for the Event 20 at vector id 4

        vectId = CSL_INTC_VECTID_4;
        hIntc20 = CSL_intcOpen (&intcObj20, CSL_INTC_EVENTID_20, &vectId , NULL);

        // NMI Enable   
        CSL_intcGlobalNmiEnable();

        // Enable Global Interrupts 
        intStat = CSL_intcGlobalEnable(&state);

        do {
           CSL_intcGetHwStatus(hIntc20,CSL_INTC_QUERY_PENDSTATUS,                               (void*)&intrStat);
        } while (!stat);

        // Close handle
        CSL_IntcClose(hIntc20);

    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcGetHwStatus (
    CSL_IntcHandle          hIntc,      
    CSL_IntcHwStatusQuery   query,      
    void                    *response    
);

/**  ============================================================================
 *  @n@b CSL_intcGlobalEnable
 *
 *  @b Description
 *  @n Globally enable interrupts.
 *     The API enables the global interrupt by manipulating the processor's
 *     global interrupt enable/disable flag. If the user wishes to restore
 *     the enable-state at a later point, they may store the current state
 *     using the parameter, which could be used with CSL_intcGlobalRestore(..).
 *     CSL_intcGlobalEnable(..) must be called from a privileged mode.
 *
 *  @b Arguments
 *  @verbatim
        prevState   (Optional) Pointer to object that would store current
                    stateObject that contains information about previous state
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
        CSL_intcGlobalEnable(NULL);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcGlobalEnable (
    CSL_IntcGlobalEnableState * prevState   

);

/** ============================================================================
 *  @n@b CSL_intcGlobalDisable
 *
 *  @b Description
 *  @n Globally disable interrupts.
 *     The API disables the global interrupt by manipulating the processor's
 *     global interrupt enable/disable flag. If the user wishes to restore
 *     the enable-state at a later point, they may store the current state
 *     using the parameter, which could be used with CSL_intcGlobalRestore(..).
 *     CSL_intcGlobalDisable(..) must be called from a privileged mode.
 *
 *  @b Arguments
 *  @verbatim
        prevState   (Optional) Pointer to object that would store current
                    stateObject that contains information about previous state
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
        
        CSL_intcGlobalDisable(NULL);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcGlobalDisable (
    CSL_IntcGlobalEnableState   *prevState   
);

/** ============================================================================
 *  @n@b CSL_intcGlobalRestore
 *
 *  @b Description
 *  @n Restore global interrupt enable/disable to a previous state.
 *     The API restores the global interrupt enable/disable state to a previous
 *     state as recorded by the global-event-enable state passed as an argument.
 *     CSL_intcGlobalRestore(..) must be called from a privileged mode.
 *
 *  @b Arguments
 *  @verbatim
        prevState   Object containing information about previous state
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
        CSL_IntcGlobalEnableState   prevState;
 
        CSL_intcGlobalRestore(prevState);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcGlobalRestore (
    CSL_IntcGlobalEnableState   prevState
);

/** ============================================================================
 *  @n@b CSL_intcGlobalNmiEnable
 *
 *  @b Description
 *  @n This API enables global NMI
 *     
 *
 *  @b Arguments
 *  @verbatim
        None
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
        
        CSL_intcGlobalNmiEnable();
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcGlobalNmiEnable (void);

/** ============================================================================
 *  @n@b CSL_intcGlobalExcepEnable
 *
 *  @b Description
 *  @n This API enables global exception
 *     
 *
 *  @b Arguments
 *  @verbatim
        None
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
       CSL_intcGlobalExcepEnable();
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcGlobalExcepEnable (void);  

/** ============================================================================
 *  @n@b CSL_intcGlobalExtExcepEnable
 *
 *  @b Description
 *  @n This API enables external exception
 *     
 *
 *  @b Arguments
 *  @verbatim
        None
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
        
        CSL_intcGlobalExtExcepEnable();
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcGlobalExtExcepEnable (void);  

/** ============================================================================
 *  @n@b CSL_intcGlobalExcepClear
 *
 *  @b Description
 *  @n This API clears Global Exceptions
 *     
 *
 *  @b Arguments
 *  @verbatim
        exc     Exception to be cleared NMI/SW/EXT/INT 
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
        CSL_intcGlobalExcepClear(exc);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcGlobalExcepClear (
    CSL_IntcExcep       exc
);

/*  ============================================================================
 *  @n@b CSL_intcExcepAllEnable
 *
 *  @b Description
 *  @n This API enables all exceptions
 *     
 *
 *  @b Arguments
 *  @verbatim
         excepMask    Exception Mask
         excVal       Event Value
         prevState    Pre state information 
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
        CSL_IntcExcepEn   excepMask;                  
        CSL_BitMask32         excVal;            
        CSL_IntcEventEnableState *prevState;
     
        CSL_intcExcepAllEnable(excepMask, excVal, prevState);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcExcepAllEnable (
    CSL_IntcExcepEn     excepMask,
    CSL_BitMask32       excVal,
    CSL_BitMask32       *prevState    
);

/*  ============================================================================
 *  @n@b CSL_intcExcepAllDisable
 *
 *  @b Description
 *  @n This API disables all exceptions
 *     
 *
 *  @b Arguments
 *  @verbatim
         excepMask    Exception Mask
         excVal       Event Value
         prevState    Pre state informationT 
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
    CSL_IntcExcepEn   excepMask;                  
    CSL_BitMask32     excVal;            
    CSL_IntcEventEnableState *prevState;
     
        CSL_intcExcepAllDisable(excepMask, excVal, prevState);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcExcepAllDisable (
    CSL_IntcExcepEn             excepMask,
    CSL_BitMask32               excVal,
    CSL_BitMask32               *prevState
);

/*  ============================================================================
 *  @n@b CSL_intcExcepAllRestore
 *
 *  @b Description
 *  @n This API restores all exceptions 
 *     
 *
 *  @b Arguments
 *  @verbatim
         excepMask    Exception Mask 0/1/2/3
         
         prevState    BitMask to be restored
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
    CSL_IntcExcepEn   excepMask;                  
    CSL_IntcEventEnableState *prevState;
     
        CSL_intcExcepAllRestore(excepMask, prevState);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcExcepAllRestore (
    CSL_IntcExcepEn             excepMask,
    CSL_IntcGlobalEnableState   restoreVal
);

/*  ============================================================================
 *  @n@b CSL_intcExcepAllClear
 *
 *  @b Description
 *  @n This API clears all exceptions
 *     
 *
 *  @b Arguments
 *  @verbatim
         excepMask    Exception Mask
         
         excVal       Holder for the event bitmask to be cleared
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
    CSL_IntcExcepEn   excepMask;                  
    CSL_BitMask32     excVal;
     
        CSL_intcExcepAllClear(excepMask, excVal);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcExcepAllClear (
    CSL_IntcExcepEn excepMask,  
    CSL_BitMask32   excVal      
);

/*  ============================================================================
 *  @n@b CSL_intcExcepAllStatus
 *
 *  @b Description
 *  @n This API is to get the exception status query
 *     
 *
 *  @b Arguments
 *  @verbatim
         excepMask    Exception Mask
         
         status       status of exception
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
    CSL_IntcExcepEn   excepMask;                  
    CSL_BitMask32     *status;
     
        CSL_intcExcepAllStatus(excepMask, status);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcExcepAllStatus (
    CSL_IntcExcepEn     excepMask,
    CSL_BitMask32       *status   
);      

/*  ============================================================================
 *  @n@b CSL_intcQueryDropStatus
 *
 *  @b Description
 *  @n This API is to get the exception drop status query
 *     
 *
 *  @b Arguments
 *  @verbatim
         dropStat     place holder for the drop status
               
    @endverbatim
 *
 *  <b> Return Value </b> CSL_Status
 *  @li                   CSL_SOK on success
 *
 *  @b Example:
 *  @verbatim
        CSL_IntcDropStatus   *dropStat;
     
        CSL_intcQueryDropStatus(dropStat);
    @endverbatim
 * =============================================================================
 */
CSL_Status CSL_intcQueryDropStatus (
    CSL_IntcDropStatus   *dropStat
);

/**
@}
*/


/*****************************************************************************/
/* STDIO.H v7.3.4                                                            */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/* string.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/



/*  ============================================================================
 *   Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2008
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
 
/* @file csl_intcAux.h
 *
 * @brief   Header file for functional layer of CSL
 *
 *  PATH  $(CSLPATH)\\inc
 */
 
/* =============================================================================
 *  Revision History
 *  ===============
 *  12-Jun-2004 Ruchika Kharwar File Created
 *  16-Mar-2005 brn modified for doxygen documentation and removed redundant 
                    CSL_intcInterruptEnable, CSL_intcInterruptDisable and 
                    CSL_intcInterruptRestore functions.
    27-Mar-2006 ds  Removed Read access to Write only EVTSET[3] and EVTCLR[3] 
                    registers 
 * =============================================================================
 */
 



/* External definition for _CSL_intcEventOffsetMap */
extern Int8 *_CSL_intcEventOffsetMap;

/* External definition for _CSL_intcAllocMask */
extern CSL_BitMask32*    _CSL_intcAllocMask;

/* External definition for _CSL_intcEventHandlerRecord */
extern CSL_IntcEventHandlerRecord* _CSL_intcEventHandlerRecord;

/* External definition for _CSL_intcNumEvents */
extern Uint16 _CSL_intcNumEvents;

/*  ============================================================================
 *   @n@b CSL_intcMapEventVector
 *
 *   @b Description
 *      This API Maps the event to the given CPU vector
 *      
 *   @b Arguments
 *   @verbatim
        hInts    Handle to the intcs
        vectId   Intc vector identifier 
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Maps the event to the given CPU vector 
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcHandle     hIntc;
        CSL_IntcVectId     vectId;
        ...
        CSL_intcMapEventVector (hIntc, vectId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_intcMapEventVector (
    CSL_IntcEventId    eventId,
    CSL_IntcVectId     vectId
)
{
    
    Int         bitLow;
    
    if (vectId < CSL_INTC_VECTID_8) {
        bitLow = (vectId - 4) * 8;
        ((((CSL_IntcRegsOvly)(0x01800000))->INTMUX1) = ((((CSL_IntcRegsOvly)(0x01800000))->INTMUX1) &~ (((1 << ((bitLow+6) - (bitLow) + 1)) - 1) << (bitLow))) | (((eventId) & ((1 << ((bitLow+6) - (bitLow) + 1)) - 1)) << (bitLow)));
    } 
    else {
        if (vectId < CSL_INTC_VECTID_12) {
            bitLow = (vectId - 8) * 8;
            ((((CSL_IntcRegsOvly)(0x01800000))->INTMUX2) = ((((CSL_IntcRegsOvly)(0x01800000))->INTMUX2) &~ (((1 << ((bitLow+6) - (bitLow) + 1)) - 1) << (bitLow))) | (((eventId) & ((1 << ((bitLow+6) - (bitLow) + 1)) - 1)) << (bitLow)));
        } 
        else {
            bitLow = (vectId - 12) * 8;
            ((((CSL_IntcRegsOvly)(0x01800000))->INTMUX3) = ((((CSL_IntcRegsOvly)(0x01800000))->INTMUX3) &~ (((1 << ((bitLow+6) - (bitLow) + 1)) - 1) << (bitLow))) | (((eventId) & ((1 << ((bitLow+6) - (bitLow) + 1)) - 1)) << (bitLow)));
        }   
    }
}

/*  ============================================================================
 *   @n@b CSL_intcEventEnable
 *
 *   @b Description
 *      This API enables particular event (EVTMASK0/1/2/3 bit programmation)
 *      
 *   @b Arguments
 *   @verbatim
        eventId   event identifier
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_IntcEventEnableState - Previous state 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  particular event will be enabled
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        CSL_IntcEventEnableState   eventStat;
        ...
        eventStat = CSL_intcEventEnable (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_IntcEventEnableState CSL_intcEventEnable (
    CSL_IntcEventId     eventId
)
{
    Int                      _x;
    Int                      _y;
    Int                      _regVal;
    CSL_IntcEventEnableState _oldState;
    
    _y = eventId >> 5;
    _x = eventId & 0x1f;
    _regVal = ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[_y];
    _oldState = (((_regVal) >> (_x)) & ((1 << ((_x) - (_x) + 1)) - 1));
    ((_regVal) = ((_regVal) &~ (((1 << ((_x) - (_x) + 1)) - 1) << (_x))) | (((0) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x)));
    ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[_y] = _regVal;
    
    return _oldState;
}

/*  ============================================================================
 *   @n@b CSL_intcEventDisable
 *
 *   @b Description
 *      This API disables particular event (EVTMASK0/1/2/3 bit programmation)
 *      
 *   @b Arguments
 *   @verbatim
        eventId   event identifier
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_IntcEventEnableState - Previous state 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  particular event will be disabled
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        CSL_IntcEventEnableState   eventStat;
        ...
        eventStat = CSL_intcEventDisable (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_IntcEventEnableState  CSL_intcEventDisable (
    CSL_IntcEventId            eventId
)
{
    Int                       _x;
    Int                       _y;
    Int                      _regVal;
    CSL_IntcEventEnableState oldState;
    
    _y = eventId >> 5;
    _x = eventId & 0x1f;
    _regVal = ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[_y];
    oldState = (((_regVal) >> (_x)) & ((1 << ((_x) - (_x) + 1)) - 1));
    ((_regVal) = ((_regVal) &~ (((1 << ((_x) - (_x) + 1)) - 1) << (_x))) | (((1) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x)));
    ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[_y] = _regVal;
    
    return oldState;
}

/*  ============================================================================
 *   @n@b CSL_intcEventRestore
 *
 *   @b Description
 *      This API restores particular event (EVTMASK0/1/2/3 bit programmation)
 *      
 *   @b Arguments
 *   @verbatim
        eventId   event identifier
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_IntcEventEnableState - Previous state 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  particular event will be restored
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        CSL_IntcEventEnableState   restoreVal;
        CSL_IntcEventEnableState   eventStat;
        ...
        eventStat = CSL_intcEventRestore (eventId, restoreVal);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void  CSL_intcEventRestore(
    CSL_IntcEventId               eventId,
    CSL_IntcEventEnableState      restoreVal
)
{
    Int     _x;
    Int     _y;
    
    _y = eventId >> 5;
    _x = eventId & 0x1F;
    
    ((((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[_y]) = ((((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[_y]) &~ (((1 << ((_x) - (_x) + 1)) - 1) << (_x))) | (((restoreVal) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x)));
}

/*  ============================================================================
 *   @n@b CSL_intcEventSet
 *
 *   @b Description
 *      This API sets Event  (EVTMASK0/1/2/3 bit programmation)
 *      
 *   @b Arguments
 *   @verbatim
        eventId   event identifier
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  particular event will set
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        ...
        CSL_intcEventSet (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void  CSL_intcEventSet(
    CSL_IntcEventId               eventId
)
{
    Int     _x;
    Int     _y;
    
    _y = eventId >> 5;
    _x = eventId & 0x1F;
    
    ((CSL_IntcRegsOvly)(0x01800000))->EVTSET[_y] = (((1) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x));
}

/*  ============================================================================
 *   @n@b CSL_intcEventClear
 *
 *   @b Description
 *      This API clears particular event (EVTMASK0/1/2/3 bit programmation)
 *      
 *   @b Arguments
 *   @verbatim
        eventId   event identifier
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  particular event will be cleared
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        ...
        CSL_intcEventClear (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void  CSL_intcEventClear (
    CSL_IntcEventId               eventId
)
{
    Int     _x;
    Int     _y;
    
    _y = eventId >> 5;
    _x = eventId & 0x1F;
    
    ((CSL_IntcRegsOvly)(0x01800000))->EVTCLR[_y] = (((1) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x));
}

/*  ============================================================================
 *   @n@b CSL_intcCombinedEventClear
 *
 *   @b Description
 *      This API clears particular combined events 
 *      (EVTMASK0/1/2/3 bit programmation)
 *      
 *   @b Arguments
 *   @verbatim
        eventId     event identifier
        clearMask   BitMask of events to be cleared
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  particular combined event will be cleared
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        ...
        CSL_intcCombinedEventClear (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */

static inline void  CSL_intcCombinedEventClear(
    CSL_IntcEventId               eventId,
    CSL_BitMask32                 clearMask
)
{
    ((CSL_IntcRegsOvly)(0x01800000))->EVTCLR[eventId] = clearMask;
}

/*  ============================================================================
 *   @n@b CSL_intcCombinedEventGet
 *
 *   @b Description
 *      This API gets particular combined events 
 *      (EVTMASK0/1/2/3 bit programmation)
 *      
 *   @b Arguments
 *   @verbatim
        eventId     event identifier
                
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_BitMask32 - The combined events information 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        CSL_BitMask32              combEvntStat;
        ...
        combEvntStat = CSL_intcCombinedEventGet (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_BitMask32  CSL_intcCombinedEventGet(
   CSL_IntcEventId               eventId
)
{
    return (((CSL_IntcRegsOvly)(0x01800000))->MEVTFLAG[eventId]);
}

/*  ============================================================================
 *   @n@b CSL_intcCombinedEventEnable
 *
 *   @b Description
 *      This API enables particular combined events 
 *      
 *   @b Arguments
 *   @verbatim
        eventId     event identifier
        enableMask  BitMask of events to be enabled     
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_BitMask32 - previous state 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        CSL_BitMask32              enableMask;
        CSL_BitMask32              combEvntStat;
        ...
        combEvntStat = CSL_intcCombinedEventEnable (eventId, enableMask);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_BitMask32  CSL_intcCombinedEventEnable(
    CSL_IntcEventId               eventId,
    CSL_BitMask32                 enableMask
)
{
    CSL_BitMask32 evtMask = 
            ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[eventId];
    ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[eventId] = ~enableMask;
    
    return evtMask;
}

/** ============================================================================
 *   @n@b CSL_intcCombinedEventDisable
 *
 *   @b Description
 *      This API disables particular combined events 
 *      
 *   @b Arguments
 *   @verbatim
        eventId     event identifier
        enableMask  BitMask of events to be disabled     
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_BitMask32 - previous state 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        CSL_BitMask32              enableMask;
        CSL_BitMask32              combEvntStat;
        
        ...
        combEvntStat = CSL_intcCombinedEventDisable (eventId, enableMask);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_BitMask32  CSL_intcCombinedEventDisable (
    CSL_IntcEventId               eventId,
    CSL_BitMask32                 enableMask
)
{
    CSL_BitMask32 evtMask = 
            ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[eventId];
    ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[eventId] = enableMask;
    
    return evtMask ;    
}

/*  ============================================================================
 *   @n@b CSL_intcCombinedEventRestore
 *
 *   @b Description
 *      This API restores particular combined events 
 *      
 *   @b Arguments
 *   @verbatim
        eventId      event identifier
        restoreMask  BitMask of events to be restored     
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId             eventId;
        CSL_BitMask32              restoreMask
        ...
        CSL_intcCombinedEventRestore (eventId, restoreMask);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void  CSL_intcCombinedEventRestore(
    CSL_IntcEventId               eventId,
    CSL_BitMask32                 restoreMask
)
{
    ((CSL_IntcRegsOvly)(0x01800000))->EVTMASK[eventId] = restoreMask;

}

/*  ============================================================================
 *   @n@b CSL_intcIntrDropEnable
 *
 *   @b Description
 *      This API enables interrupts for which drop detection 
 *      
 *   @b Arguments
 *   @verbatim
        dropMask  Vector id mask
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_BitMask32              dropMask
        ...
        CSL_intcIntrDropEnable (dropMask);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void  CSL_intcInterruptDropEnable (
    CSL_BitMask32                dropMask        
)
{
    ((CSL_IntcRegsOvly)(0x01800000))->INTDMASK &= ~dropMask;
    
}

/*  ============================================================================
 *   @n@b CSL_intcIntrDropDisable
 *
 *   @b Description
 *      This API disables interrupts for which drop detection 
 *      
 *   @b Arguments
 *   @verbatim
        dropMask  Vector id mask
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_BitMask32              dropMask
        ...
        CSL_intcIntrDropDisable (dropMask);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void  CSL_intcInterruptDropDisable (
    CSL_BitMask32                dropMask        
)
{
    ((CSL_IntcRegsOvly)(0x01800000))->INTDMASK  |= dropMask;
    
}

/*  ============================================================================
 *   @n@b CSL_intcInvokeEventHandle
 *
 *   @b Description
 *     This API is for the purpose of excption handler which will need to be
 * written by the user. This API invokes the event handler regisered by 
 *      the user at the time of event Open and event handler registration 
 *      
 *   @b Arguments
 *   @verbatim
        evtId  Event Id of the function to be invoked
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_SOK
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcEventId              evtId;
        CSL_Status                   status;
        ...
        status = CSL_intcInvokeEventHandle (evtId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_Status CSL_intcInvokeEventHandle (
    CSL_IntcEventId     evtId
)
{

    if (_CSL_intcEventOffsetMap[evtId] != (-1)) 
        _CSL_intcEventHandlerRecord[_CSL_intcEventOffsetMap[evtId]].handler (
            _CSL_intcEventHandlerRecord[_CSL_intcEventOffsetMap[evtId]].arg );
          
     return (1);
}

/*  ============================================================================
 *   @n@b CSL_intcQueryEventStatus
 *
 *   @b Description
 *      This API is to check whether a specified event is enabled or not 
 *
 *   @b Arguments
 *   @verbatim
        evtId      Event Id of the query event
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       Bool
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcEventId              evtId;
        Bool                         return;
        ...
        return = CSL_intcQueryEventStatus (evtId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline Bool CSL_intcQueryEventStatus(CSL_IntcEventId eventId)
{
    Int     _x;
    Int     _y;
    
    _y = eventId >> 5;
    _x = eventId & 0x1F;
    
    return ((Bool)((((((CSL_IntcRegsOvly)(0x01800000))->EVTFLAG[_y]) >> (_x)) & ((1 << ((_x) - (_x) + 1)) - 1))));
}

/* CPU Interrupt Handling routines */

/*  ============================================================================
 *   @n@b CSL_intcInterruptEnable
 *
 *   @b Description
 *      This API is enables Interrupt 
 *      
 *   @b Arguments
 *   @verbatim
        vectId      Vector Id of the query event
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       Uint32     - previous state
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId              vectId;
        Uint32                      return;
        ...
        return = CSL_intcInterruptEnable (vectId);
        ...
     @endverbatim
 * ===========================================================================
 */
Uint32 CSL_intcInterruptEnable (
    CSL_IntcVectId vectId
);

/*  ============================================================================
 *   @n@b CSL_intcInterruptDisable
 *
 *   @b Description
 *      This API is disables Interrupt 
 *      
 *   @b Arguments
 *   @verbatim
        vectId      Vector Id of the query event
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       Uint32     - previous state
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId              vectId;
        Uint32                      return;
        ...
        return = CSL_intcInterruptDisable (vectId);
        ...
     @endverbatim
 * ===========================================================================
 */
Uint32 CSL_intcInterruptDisable (
    CSL_IntcVectId vectId
);

/*  ============================================================================
 *   @n@b CSL_intcInterruptRestore
 *
 *   @b Description
 *      This API is restores Interrupt 
 *      
 *   @b Arguments
 *   @verbatim
        vectId      Vector Id of the query event
        restoreVal  Value to be restored
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None
 *       
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId              vectId;
        Uint32                      restore;
        ...
        CSL_intcInterruptRestore (vectId, restore);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_intcInterruptRestore ( 
    CSL_IntcVectId      vectId,
    Uint32              restoreVal
);

/*  ============================================================================
 *   @n@b CSL_intcInterruptSet
 *
 *   @b Description
 *      This API is sets interrupt(ISR) 
 *
 *   @b Arguments
 *   @verbatim
        vectId       Vector id to set

     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None
 *       
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId              vectId;
        ...
        CSL_intcInterruptSet (vectId);
        ...
     @endverbatim
 * ===========================================================================
 */
void CSL_intcInterruptSet ( 
    CSL_IntcVectId      vectId
);

/*  ============================================================================
 *   @n@b CSL_intcInterruptClear
 *
 *   @b Description
 *      This API is clears specified interrupt  
 *      
 *   @b Arguments
 *   @verbatim
        vectId       Vector id to cleared
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId              vectId;
        ...
        CSL_intcInterruptClear (vectId);
        ...
     @endverbatim
 * ===========================================================================
 */
void CSL_intcInterruptClear ( 
    CSL_IntcVectId      vectId
);

/*  ============================================================================
 *   @n@b CSL_intcQueryInterruptStatus
 *
 *   @b Description
 *      This API is to check whether a specified CPU interrupt is pending or not  
 *
 *   @b Arguments
 *   @verbatim
        vectId       Vector id to cleared

     @endverbatim
 *
 *   <b> Return Value </b> 
 *       Bool
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcVectId              vectId;
        Bool                        return;
        ...
        return = CSL_intcQueryInterruptStatus (vectId);
        ...
     @endverbatim
 * ===========================================================================
 */
Bool  CSL_intcQueryInterruptStatus (
    CSL_IntcVectId      vectId
);


/* Exception handling routines */

/*  ============================================================================
 *   @n@b CSL_intcExcepEnable
 *
 *   @b Description
 *      This API is enables the specific exception event  
 *      
 *   @b Arguments
 *   @verbatim
        eventId       event id to be enabled
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_IntcEventEnableState
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcEventId             eventId;
        CSL_IntcEventEnableState    return;
        ...
        return = CSL_intcExcepEnable (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_IntcEventEnableState  CSL_intcExcepEnable (
    CSL_IntcEventId      eventId
)
{
    Int                         _x;
    Int                         _y;
    Int                         _regVal;
    CSL_IntcEventEnableState    _oldState;
    
    _y = eventId >> 5;
    _x = eventId & 0x1f;
    _regVal = ((CSL_IntcRegsOvly)(0x01800000))->EXPMASK[_y];
    _oldState = (((_regVal) >> (_x)) & ((1 << ((_x) - (_x) + 1)) - 1));
    ((_regVal) = ((_regVal) &~ (((1 << ((_x) - (_x) + 1)) - 1) << (_x))) | (((0) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x)));
    ((CSL_IntcRegsOvly)(0x01800000))->EXPMASK[_y] = _regVal;
    
    return _oldState;
}

/*  ============================================================================
 *   @n@b CSL_intcExcepDisable
 *
 *   @b Description
 *      This API is disables the specific exception event  
 *      
 *   @b Arguments
 *   @verbatim
        eventId       event id to be disabled
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_IntcEventEnableState
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcEventId             eventId;
        CSL_IntcEventEnableState    return;
        ...
        return = CSL_intcExcepDisable (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_IntcEventEnableState  CSL_intcExcepDisable (
    CSL_IntcEventId            eventId
)
{
    Int                         _x;
    Int                         _y;
    Int                         _regVal;
    CSL_IntcEventEnableState    oldState;
    
    _y = eventId >> 5;
    _x = eventId & 0x1f;
    _regVal = ((CSL_IntcRegsOvly)(0x01800000))->EXPMASK[_y];
    oldState = (((_regVal) >> (_x)) & ((1 << ((_x) - (_x) + 1)) - 1));
    ((_regVal) = ((_regVal) &~ (((1 << ((_x) - (_x) + 1)) - 1) << (_x))) | (((1) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x)));
    ((CSL_IntcRegsOvly)(0x01800000))->EXPMASK[_y] = _regVal;
    
    return oldState;
}

/*  ============================================================================
 *   @n@b CSL_intcExcepRestore
 *
 *   @b Description
 *      This API restores the specific exception event 
 *      
 *   @b Arguments
 *   @verbatim
        eventId       event id to be restored 
        restoreVal    restore value
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcEventId             eventId;
        
        ...
        CSL_intcExcepRestore (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void  CSL_intcExcepRestore (
    CSL_IntcEventId               eventId,
    Uint32                        restoreVal
)
{
    Int         _x;
    Int         _y;
    
    _y = eventId >> 5;
    _x = eventId & 0x1F;
    ((((CSL_IntcRegsOvly)(0x01800000))->EXPMASK[_y]) = ((((CSL_IntcRegsOvly)(0x01800000))->EXPMASK[_y]) &~ (((1 << ((_x) - (_x) + 1)) - 1) << (_x))) | (((restoreVal) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x)));
}

/*  ============================================================================
 *   @n@b CSL_intcExcepClear
 *
 *   @b Description
 *      This API clears the specific exception event 
 *      
 *   @b Arguments
 *   @verbatim
        eventId       event id to be cleared 
        
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  None
 *
 *   @b  Example
 *   @verbatim
        CSL_IntcEventId             eventId;
        
        ...
        CSL_intcExcepClear (eventId);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void  CSL_intcExcepClear (
    CSL_IntcEventId         eventId
)
{
    Int         _x;
    Int         _y;
    
    _y = eventId >> 5;
    _x = eventId & 0x1F;
    ((CSL_IntcRegsOvly)(0x01800000))->EVTCLR[_y] = (((1) & ((1 << ((_x) - (_x) + 1)) - 1)) << (_x));
}

/**
 *   @file  csl_semAux.h
 *
 *   @brief   
 *      This is the SEM Auxilary Header File which exposes the various
 *      CSL Functional Layer API's to configure the SEM Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/


/**
 *   @file  csl_sem.h
 *
 *   @brief
 *      This is the main Header File for the SEM Module which defines all
 *      the data structures and exported API.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/


/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 SEM_PID;
    volatile Uint32 SEM_SCRATCH;
    volatile Uint32 SEM_RST_RUN;
    volatile Uint32 SEM_EOI;
    volatile Uint8 RSVD0[240];
    volatile Uint32 SEM[32];
    volatile Uint8 RSVD1[128];
    volatile Uint32 ISEM[32];
    volatile Uint8 RSVD2[128];
    volatile Uint32 QSEM[32];
    volatile Uint8 RSVD3[128];
    volatile Uint32 SEMFLAGL_CLEAR[4];
    volatile Uint8 RSVD4[112];
    volatile Uint32 SEMFLAGL_SET[4];
    volatile Uint8 RSVD5[112];
    volatile Uint32 SEMERR;
    volatile Uint32 SEMERR_CLEAR;
    volatile Uint32 SEMERR_SET;
} CSL_SemRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* SEM_PID */









/* SEM_SCRATCH */



/* SEM_RST_RUN */




/* SEM_EOI */


/*----SELECT_INTERRUPT_REARM Tokens----*/


/* SEM */






/* ISEM */






/* QSEM */






/* SEMFLAGL */



































/* SEMFLAGL_CLEAR */



































/* SEMFLAGL_SET */

































/*----F Tokens----*/


/* SEMERR */




/*----ERR Tokens----*/


/* SEMERR_CLEAR */


/*----CLRERR Tokens----*/


/* SEMERR_SET */




/*----ERR Tokens----*/



/** @defgroup CSL_SEM_API Semaphore
 *
 * @section Introduction
 *
 * @subsection 
 *  None
 *
 * @subsection References
 *  None
 *
 */

/**
@defgroup CSL_SEM_SYMBOL  SEM Symbols Defined
@ingroup  CSL_SEM_API
*/
/**
@defgroup CSL_SEM_FUNCTION  SEM Functions
@ingroup  CSL_SEM_API
*/
/**
@addtogroup CSL_SEM_SYMBOL
@{
*/

/**
 *  Handle to access SEM registers.
 */

/**
@}
*/






/** @addtogroup CSL_SEM_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_semSetEoi
 *
 *   @b Description
 *   @n This function sets the SEM Module EOI Register to rearm the interrupt line
 *      after processing an existing interrupt.
 *
 *   @b Arguments
     @verbatim
          eoiVal   Value to be written to the EOI register.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n SEM_SEM_EOI_SELECT_INTERRUPT_REARM
 *
 *   <b> Post Condition </b>
 *   @n Semaphore interrupts to the specific Master are reenabled.
 *
 *   @b Example
 *   @verbatim

        // Reenable Semaphore interrupts for CPU Core 0.
        CSL_semSetEoi (semHandle, CSL_SEM_REARM_SEMINT0);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_semSetEoi (Uint8 eoiVal)
{
    ((CSL_SemRegs*)(0x02640000))->SEM_EOI = (((eoiVal) << (0x00000000u)) & (0x000000FFu));
}         

/** ============================================================================
 *   @n@b CSL_semAcquireDirect
 *
 *   @b Description
 *   @n This function acquires a semaphore for direct access.
 *
 *   @b Arguments
     @verbatim
          semNum      Semaphore which is to be acquired.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  1 - Resource was available and has been allocated to the Master
 *   @n  0 - Resource was NOT available and has NOT been allocated to the Master
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n Semaphore is allocated to the Master on Success.
 *
 *   @b Reads
 *   @n SEM_SEM_FREE
 *
 *   @b Example
 *   @verbatim

        Uint8 status;

        // Acquire the semaphore number 2.
        status = CSL_semAcquireDirect (2);

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_semAcquireDirect (Uint8 semNum)
{
    /* Direct Access Request: Read from the SEMn register */
    return (((((CSL_SemRegs*)(0x02640000))->SEM[semNum]) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_semAcquireIndirect
 *
 *   @b Description
 *   @n This function acquires a semaphore for indirect access.
 *
 *   @b Arguments
     @verbatim
          semNum      Semaphore which is to be acquired.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n Semaphore is placed into the request queue to be acquired.
 *
 *   @b Writes
 *   @n SEM_SEM_FREE=0
 *
 *   @b Example
 *   @verbatim

        // Acquire the semaphore number 2.
        CSL_semAcquireIndirect (2);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_semAcquireIndirect (Uint8 semNum)
{
    /* Indirect Access Request: Write a 0 to the SEMn register; to request for the resource. */
    ((CSL_SemRegs*)(0x02640000))->SEM[semNum] = (((0) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_semAcquireCombined
 *
 *   @b Description
 *   @n This function acquires a semaphore for combined access. 
 *
 *   @b Arguments
     @verbatim
          semNum      Semaphore which is to be acquired.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n Semaphore is acquired immediately if free else it is  placed into the request 
 *      queue to be acquired.
 *
 *   @b Reads
 *   @n SEM_ISEM_FREE
 *
 *   @b Example
 *   @verbatim

        Uint8 status;

        // Acquire the semaphore number 2.
        status = CSL_semAcquireCombined (2);

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_semAcquireCombined(Uint8 semNum)
{
    /* Combined Access Request: Read from the Indirect register */
    return (((((CSL_SemRegs*)(0x02640000))->ISEM[semNum]) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_semReleaseSemaphore
 *
 *   @b Description
 *   @n This function is used to release a sempahore which had been acquired
 *      previously.
 *
 *   @b Arguments
     @verbatim
          semNum      Semaphore which is to be released.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n @a CSL_semAcquireDirect() or @a CSL_semAcquireCombined() @a CSL_semAcquireIndirect()
 *      must be called.
 *
 *   <b> Post Condition </b>
 *   @n Semaphore resource is freed up 
 *
 *   @b Writes
 *   @n SEM_SEM_FREE=1
 *
 *   @b Example
 *   @verbatim

        // Acquire the semaphore using the direct method. 
        CSL_semAcquireDirect (2);
        ...
        // Release the semaphore.
        CSL_semReleaseSemaphore (2);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_semReleaseSemaphore (Uint8 semNum)
{
    /* Semaphore is released up by writing a 1 to the SEMn register */
    ((CSL_SemRegs*)(0x02640000))->SEM[semNum] = (((1) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_semIsFree
 *
 *   @b Description
 *   @n This function checks if the specified semaphore is acquired or not?
 *
 *   @b Arguments
     @verbatim
          semNum      Semaphore which is to be queried.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  TRUE  - Semaphore is Free
 *   @n  FALSE - Semaphore is Available   
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n SEM_QSEM_FREE
 *
 *   @b Example
 *   @verbatim

        Bool isFree;

        // Check if Semaphore is available.
        isFree = CSL_semIsFree (2);

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_semIsFree(Uint8 semNum)
{
    /* Read the Query Status register to determine the semaphore status. */
    return (Bool)(((((CSL_SemRegs*)(0x02640000))->QSEM[semNum]) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_semGetResourceOwner
 *
 *   @b Description
 *   @n This function returns the resource owner for the specific semaphore.
 *
 *   @b Arguments
     @verbatim
          semNum      Semaphore Number whose resource owner is to be retreived.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Semaphore Resource Owner.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n SEM_QSEM_OWNER
 *
 *   @b Example
 *   @verbatim

        Bool    isFree;
        Uint8   owner;

        // Check if Semaphore is available.
        isFree = CSL_semIsFree (2);
        if (isFree == FALSE)
        {
            // Resource is acquired. Get the owner 
            owner = CSL_semGetResourceOwner(2);
        }

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_semGetResourceOwner(Uint8 semNum)
{
    return (Uint8)(((((CSL_SemRegs*)(0x02640000))->QSEM[semNum]) & (0x0000FF00u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_semGetFlags
 *
 *   @b Description
 *   @n This function returns the contents of the SEMFLAG register for a specific
 *      master. This is used in the indirect or combined access method to determine
 *      if a resource has been acquired. The corresponding bit indicates that the 
 *      specific resource number which had been requested is now available.
 *
 *   @b Arguments
     @verbatim
          masterId      Master ID for which the SEMFLAG register is read.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n SEM_SEMFLAGL_CLEAR
 *
 *   @b Example
 *   @verbatim

        Uint32  semFlags;

        // Read the bits of the semaphore flag register for master 0.
        semFlags = CSL_semGetFlags(0);

     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_semGetFlags(Uint8 masterId)
{
    return (Uint32)((CSL_SemRegs*)(0x02640000))->SEMFLAGL_CLEAR[masterId];
}

/** ============================================================================
 *   @n@b CSL_semClearFlags
 *
 *   @b Description
 *   @n This function is used by the host by the host to inform the SEM Module 
 *      that the resource which had been marked as FREE has been processed by
 *      the host.
 *
 *   @b Arguments
     @verbatim
          masterId      Master ID for which the SEMFLAG register is read.
          semFlags      Semaphore Flags retreived through the CSL_semGetFlags API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n SEM_SEMFLAGL_CLEAR
 *
 *   @b Affects
 *   @n SEM_SEMFLAGL_CLEAR
 *
 *   @b Example
 *   @verbatim

        Uint32  semFlags;

        // Read the bits of the semaphore flag register for master 0.
        semFlags = CSL_semGetFlags(0);
        ...
        // Clear the bits of the semaphore flag register for master 0.
        CSL_semClearFlags (0, semFlags);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_semClearFlags(Uint8 masterId, Uint32 semFlags)
{
    /* Write the value to the CLEAR Register. */ 
    ((CSL_SemRegs*)(0x02640000))->SEMFLAGL_CLEAR[masterId] = semFlags;
}

/** ============================================================================
 *   @n@b CSL_semGetErrorCode
 *
 *   @b Description
 *   @n This function is used to get the Error code.
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>
 *   @n  Error Code 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n SEM_SEMERR_ERR
 *
 *   @b Example
 *   @verbatim

        Uint8  errCode;

        // Check if there is an error which has been reported.
        errCode = CSL_semGetErrorCode();
        if (errCode != 0)
        {
            // Semaphore Module has reported an Error. 
        }

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_semGetErrorCode (void)
{
    return (Uint8)(((((CSL_SemRegs*)(0x02640000))->SEMERR) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_semGetErrorSemaphoreNumber
 *
 *   @b Description
 *   @n This function is used to get the semaphore number which is in error.
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>
 *   @n  Semaphore Number which caused the error.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n SEM_SEMERR_SEMNUM
 *
 *   @b Example
 *   @verbatim

        Uint8  errCode;
        Uint8  semNumber;

        // Check if there is an error which has been reported.
        errCode = CSL_semGetErrorCode();
        if (errCode != 0)
        {
            // Semaphore Module has reported an error; get the semaphore number. 
            semNumber = CSL_semGetErrorSemaphoreNumber(); 
            ...
        }

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_semGetErrorSemaphoreNumber (void)
{
    return (Uint8)(((((CSL_SemRegs*)(0x02640000))->SEMERR) & (0x000001F8u)) >> (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_semGetErrorFaultID
 *
 *   @b Description
 *   @n This function is used to get the resource owner which caused the error.
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>
 *   @n  Resource Number which caused the error.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n SEM_SEMERR_FAULTID
 *
 *   @b Example
 *   @verbatim

        Uint8  errCode;
        Uint8  semNumber;
        Uint8  faultId;

        // Check if there is an error which has been reported.
        errCode = CSL_semGetErrorCode();
        if (errCode != 0)
        {
            // Semaphore Module has reported an error; get the semaphore number. 
            semNumber = CSL_semGetErrorSemaphoreNumber(); 

            // Get the fault id. 
            faultId = CSL_semGetErrorFaultID();
            ...
        }

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_semGetErrorFaultID (void)
{
    return (Uint8)(((((CSL_SemRegs*)(0x02640000))->SEMERR) & (0x0000FE00u)) >> (0x00000009u));
}

/** ============================================================================
 *   @n@b CSL_semClearError
 *
 *   @b Description
 *   @n This function is used to clear the semaphore module error.
 *
 *   @b Arguments
 *   @n  None
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n SEM_SEMERR_CLEAR_CLRERR=1
 *
 *   @b Example
 *   @verbatim

        Uint8  errCode;
        Uint8  semNumber;
        Uint8  faultId;

        // Check if there is an error which has been reported.
        errCode = CSL_semGetErrorCode();
        if (errCode != 0)
        {
            // Semaphore Module has reported an error; get the semaphore number. 
            semNumber = CSL_semGetErrorSemaphoreNumber(); 

            // Get the fault id. 
            faultId = CSL_semGetErrorFaultID();
            ...

            // Clear the error.
            CSL_semClearError ();
        }

     @endverbatim
 * =============================================================================
 */
static inline void CSL_semClearError (void)
{
    ((CSL_SemRegs*)(0x02640000))->SEMERR_CLEAR = (((1) << (0x00000000u)) & (0x00000001u));
}

/**
@}
*/



/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


typedef enum HSEM_NUM
{
	HSEM_IIPC = 0,
	
	HSEM_COMMAND_C0,
	HSEM_COMMAND_C1,
	HSEM_COMMAND_C2,
	HSEM_COMMAND_C3,
	HSEM_COMMAND_C4,
	HSEM_COMMAND_C5,
	HSEM_COMMAND_C6,
	HSEM_COMMAND_C7,

	HSEM_BURSTINFO_C1,
	HSEM_BURSTINFO_C2,
	HSEM_BURSTINFO_C3,
	HSEM_BURSTINFO_C4,
	HSEM_BURSTINFO_C5,
	HSEM_BURSTINFO_C6,
	HSEM_BURSTINFO_C7,


	HSEM_BURST_C0,
	HSEM_L2PACKET_C1,
	HSEM_L2PACKET_C2,
	HSEM_L2PACKET_C3,
	HSEM_L2PACKET_C4,
	HSEM_L2PACKET_C5,
	HSEM_L2PACKET_C6,
	HSEM_L2PACKET_C7,
//###### commented for testing : by remesh
//	HSEM_L2PACKET_C0,
//	HSEM_BURST_C1,
//	HSEM_BURST_C2,
//	HSEM_BURST_C3,
//	HSEM_BURST_C4,
//	HSEM_BURST_C5,
//	HSEM_BURST_C6,
//	HSEM_BURST_C7,
// end of commented lines
	HSEM_GBTS,
	HSEM_EMAC,

	HSEM_TJOB =28,
	HSEM_LAST = 29,
	MAX_SEM = 32,
	HSEM_INVALID
}HSEM_NUM;

typedef struct stHSEM
{
	//CSL_SemObj    oSemObj; // not required in c6678
	//CSL_SemParam  oParam; // not required in c6678
	//volatile CSL_SemHandle hSemHandle; // not required in c6678
	HSEM_NUM Sem_Number; // included by remesh to make HSEM_Init(),HSEM_Lock(),HSEM_Unlock() compactable with c6678 CSL APIs
}Hsem;


extern void HSEM_ModuleInit();
extern void HSEM_Init(Hsem *pThis, UINT8 nSemNum);
extern void HSEM_Lock(Hsem *pThis);
extern void HSEM_Unlock(Hsem *pThis);



typedef struct MemHashInfo
				{
					UINT16 Hash_id;
					UINT16 BytesInBlock;
					UINT16 NoOfBlocks; //This is redundant info. Also maintained in FIFO struc
					void   *MemSource;
					FIFO   freelist;
				} MemHashInfo;

/* Version 2 APIs */
extern UINT16 Initialize_HashNewBucket_v2(UINT16 BytesInBlock,
										UINT16 NoOfBlocks,
										void *MemSource);
extern void* Alloc_v2(int HashNum );
extern void Free_v2(int HashNum, void *ptr);

/* End of version 2 APIs */


extern UINT16 Initialize_HashNewBucket(UINT16 BytesInBlock,
						UINT16 NoOfBlocks,
						void *MemSource);
extern void* Alloc(int HashNum );
extern void* Alloc_CoreSafe(int HashNum, Hsem *pThis);
extern void Free(int HashNum, void *ptr);

extern void Free_CoreSafe(MemHashInfo *MemQptr , void *ptr, Hsem *pThis);

extern void * GetHashInfoHandler(UINT16 nDesc);
extern UINT16 GetCurrentHNum();
extern UINT16 GetMaxBuckets();
void SetMutexObjHashLib(Mutex *pThis);






//#include <std.h>
//#include <xdc/std.h> // this file is included in DataType.h
 //#include <log.h>
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

//#include <swi.h>
/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

//#include <sys.h>
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

//#include <msgq.h> // i think this include file is not required ;)
/**
 *   @file  csl_bootcfg.h
 *
 *   @brief
 *      This is the main Header File for the BOOTCFG Module which defines all
 *      the data structures and exported API.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/


/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Header files are included as per RTSC guidelines
 *      b) Changed BOOTADDR_GEM0_REG-BOOTADDR_GEM7_REG to an array BOOTADDR_GEM_REG[8]
 *      c) Changed RSTMUX0-RSTMUX7 to an array RSTMUX[8]
 *      d) Changed NMIGR_0-NMIGR_3 to an array NMIGR[8]
 *      e) Changed IPCGR0-IPCGR3 to an array IPCGR[8]
 *      f) Changed IPCAR0-IPCAR3 to an array IPCAR[8]
 *      g) Changed DDR3_CONFIG_REG_0-DDR3_CONFIG_REG_24 to an array DDR3_CONFIG_REG[25]
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 REVISION_REG;
    volatile Uint8 RSVD0[4];
    volatile Uint32 DIE_ID_REG0;
    volatile Uint32 DIE_ID_REG1;
    volatile Uint32 DIE_ID_REG2;
    volatile Uint32 DIE_ID_REG3;
    volatile Uint32 DEVICE_ID_REG0;
    volatile Uint32 DEVICE_ID_REG1;
    volatile Uint32 BOOT_REG0;
    volatile Uint8 RSVD1[20];
    volatile Uint32 KICK_REG0;
    volatile Uint32 KICK_REG1;
    volatile Uint32 BOOTADDR_GEM_REG[8];
    volatile Uint8 RSVD2[128];
    volatile Uint32 INTR_RAW_STATUS_REG;
    volatile Uint32 INTR_ENABLED_STATUS_REG;
    volatile Uint32 INTR_ENABLE_REG;
    volatile Uint32 INTR_ENABLE_CLR_REG;
    volatile Uint32 EOI_REG;
    volatile Uint32 FAULT_ADDRESS_REG;
    volatile Uint32 FAULT_STATUS_REG;
    volatile Uint32 FAULT_CLEAR_REG;
    volatile Uint8 RSVD3[16];
    volatile Uint32 EMAC_ID1;
    volatile Uint32 EMAC_ID2;
    volatile Uint32 SI_REV;
    volatile Uint8 RSVD4[20];
    volatile Uint32 LRSTNMISTAT_CLR;
    volatile Uint32 RESET_STAT_CLR;
    volatile Uint32 BOOT_LATCH;
    volatile Uint32 BOOT_COMPLETE;
    volatile Uint32 BOOT_PROGRESS;
    volatile Uint32 RESET_STAT;
    volatile Uint32 LRSTNMISTAT;
    volatile Uint32 DEVCFG;
    volatile Uint32 PWR_STAT;
    volatile Uint32 STS_SRIO;
    volatile Uint32 STS_SGMII;
    volatile Uint32 STS_PCIE;
    volatile Uint32 STS_VUSR;
    volatile Uint8 RSVD5[28];
    volatile Uint32 CLASS0_EFUSE_REG;
    volatile Uint8 RSVD6[12];
    volatile Uint32 EFUSE_REG0;
    volatile Uint32 EFUSE_REG1;
    volatile Uint32 EFUSE_REG2;
    volatile Uint32 EFUSE_REG3;
    volatile Uint32 EFUSE_REG4;
    volatile Uint32 EFUSE_REG5;
    volatile Uint32 EFUSE_REG6;
    volatile Uint32 EFUSE_REG7;
    volatile Uint32 EFUSE_REG8;
    volatile Uint32 EFUSE_REG9;
    volatile Uint32 EFUSE_REG10;
    volatile Uint32 EFUSE_REG11;
    volatile Uint32 EFUSE_REG12;
    volatile Uint32 EFUSE_REG13;
    volatile Uint32 EFUSE_REG14;
    volatile Uint32 EFUSE_REG15;
    volatile Uint8 RSVD7[48];
    volatile Uint32 NMIGR[8];
    volatile Uint8 RSVD8[32];
    volatile Uint32 IPCGR[8];
    volatile Uint8 RSVD9[28];
    volatile Uint32 IPCGRH;
    volatile Uint32 IPCAR[8];
    volatile Uint8 RSVD10[28];
    volatile Uint32 IPCARH;
    volatile Uint8 RSVD11[64];
    volatile Uint32 TINPSEL;
    volatile Uint32 TOUTSEL;
    volatile Uint32 RSTMUX[8];
    volatile Uint32 CORE_PLL_CTL0;
    volatile Uint32 CORE_PLL_CTL1;
    volatile Uint32 DDR3_PLL_CTL0;
    volatile Uint32 DDR3_PLL_CTL1;
    volatile Uint32 PA_PLL_CTL0;
    volatile Uint32 PA_PLL_CTL1;
    volatile Uint32 SGMII_CFGPLL;
    volatile Uint32 SGMII_CFGRX0;
    volatile Uint32 SGMII_CFGTX0;
    volatile Uint32 SGMII_CFGRX1;
    volatile Uint32 SGMII_CFGTX1;
    volatile Uint32 SGMII_RSVD;
    volatile Uint32 PCIE_CFGPLL;
    volatile Uint32 PCIE_SERDES_RSVD;
    volatile Uint32 SRIO_SERDES_CFGPLL;
    volatile Uint32 SRIO_SERDES_CFGRX0;
    volatile Uint32 SRIO_SERDES_CFGTX0;
    volatile Uint32 SRIO_SERDES_CFGRX1;
    volatile Uint32 SRIO_SERDES_CFGTX1;
    volatile Uint32 SRIO_SERDES_CFGRX2;
    volatile Uint32 SRIO_SERDES_CFGTX2;
    volatile Uint32 SRIO_SERDES_CFGRX3;
    volatile Uint32 SRIO_SERDES_CFGTX3;
    volatile Uint32 SRIO_SERDES_RSVD;
    volatile Uint32 LED_GEM_PASSDONE;
    volatile Uint32 LED_PLLLOCK;
    volatile Uint32 LED_CHIP_PASSDONE;
    volatile Uint32 TDIODE;
    volatile Uint32 MARGIN;
    volatile Uint32 SECURE_CONTROL;
    volatile Uint8 RSVD12[4];
    volatile Uint32 EFUSE_SECROM_CHKSUM0;
    volatile Uint32 EFUSE_SECROM_CHKSUM1;
    volatile Uint32 OBSCLK_CTL;
    volatile Uint8 RSVD13[4];
    volatile Uint32 VUSR_CFGPLL;
    volatile Uint32 VUSR_CFGRX0;
    volatile Uint32 VUSR_CFGTX0;
    volatile Uint32 VUSR_CFGRX1;
    volatile Uint32 VUSR_CFGTX1;
    volatile Uint32 VUSR_CFGRX2;
    volatile Uint32 VUSR_CFGTX2;
    volatile Uint32 VUSR_CFGRX3;
    volatile Uint32 VUSR_CFGTX3;
    volatile Uint32 VUSR_SERDES_RSVD;
    volatile Uint32 LED_GPIO_CLR;
    volatile Uint32 LED_GPIO;
    volatile Uint8 RSVD14[12];
    volatile Uint32 EFUSE_RSVD0;
    volatile Uint32 EFUSE_RSVD1;
    volatile Uint32 EFUSE_RSVD2;
    volatile Uint32 EFUSE_RSVD3;
    volatile Uint32 CHIP_MISC;
    volatile Uint32 DDR3_CONFIG_REG[25];
    volatile Uint8 RSVD15[7063];
    volatile Uint32 END_POINT;
} CSL_BootcfgRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* revision_reg */








/* die_id_reg0 */



/* die_id_reg1 */



/* die_id_reg2 */



/* die_id_reg3 */



/* device_id_reg0 */



/* device_id_reg1 */



/* boot_reg0 */







/* kick_reg0 */



/* kick_reg1 */



/* bootaddr_gem0_reg */




/* bootaddr_gem1_reg */




/* bootaddr_gem2_reg */




/* bootaddr_gem3_reg */




/* bootaddr_gem4_reg */




/* bootaddr_gem5_reg */




/* bootaddr_gem6_reg */




/* bootaddr_gem7_reg */




/* intr_raw_status_reg */




/* intr_enabled_status_reg */




/* intr_enable_reg */




/* intr_enable_clr_reg */




/* eoi_reg */



/* fault_address_reg */



/* fault_status_reg */







/* fault_clear_reg */



/* emac_id1 */



/* emac_id2 */



/* si_rev */



/* lrstnmistat_clr */


















/* reset_stat_clr */











/* boot_latch */



/* boot_complete */










/* boot_progress */



/* reset_stat */











/* lrstnmistat */


















/* devcfg */



/* pwr_stat */






/* sts_srio */



/* sts_sgmii */



/* sts_pcie */





/* sts_vusr */



/* class0_efuse_reg */



/* efuse_reg0 */



/* efuse_reg1 */



/* efuse_reg2 */



/* efuse_reg3 */



/* efuse_reg4 */



/* efuse_reg5 */



/* efuse_reg6 */



/* efuse_reg7 */



/* efuse_reg8 */



/* efuse_reg9 */



/* efuse_reg10 */



/* efuse_reg11 */



/* efuse_reg12 */



/* efuse_reg13 */



/* efuse_reg14 */



/* efuse_reg15 */



/* nmigr_0 */



/* nmigr_1 */



/* nmigr_2 */



/* nmigr_3 */



/* nmigr_4 */



/* nmigr_5 */



/* nmigr_6 */



/* nmigr_7 */



/* ipcgr0 */




/* ipcgr1 */




/* ipcgr2 */




/* ipcgr3 */




/* ipcgr4 */




/* ipcgr5 */




/* ipcgr6 */




/* ipcgr7 */




/* ipcgrh */




/* ipcar0 */



/* ipcar1 */



/* ipcar2 */



/* ipcar3 */



/* ipcar4 */



/* ipcar5 */



/* ipcar6 */



/* ipcar7 */



/* ipcarh */



/* tinpsel */



/* toutsel */





/* rstmux0 */







/* rstmux1 */







/* rstmux2 */







/* rstmux3 */







/* rstmux4 */







/* rstmux5 */







/* rstmux6 */







/* rstmux7 */







/* core_pll_ctl0 */



/* core_pll_ctl1 */



/* ddr3_pll_ctl0 */



/* ddr3_pll_ctl1 */



/* pa_pll_ctl0 */



/* pa_pll_ctl1 */



/* sgmii_cfgpll */



/* sgmii_cfgrx0 */



/* sgmii_cfgtx0 */



/* sgmii_cfgrx1 */



/* sgmii_cfgtx1 */



/* sgmii_rsvd */



/* pcie_cfgpll */



/* pcie_serdes_rsvd */



/* srio_serdes_cfgpll */



/* srio_serdes_cfgrx0 */



/* srio_serdes_cfgtx0 */



/* srio_serdes_cfgrx1 */



/* srio_serdes_cfgtx1 */



/* srio_serdes_cfgrx2 */



/* srio_serdes_cfgtx2 */



/* srio_serdes_cfgrx3 */



/* srio_serdes_cfgtx3 */



/* srio_serdes_rsvd */



/* led_gem_passdone */


































/* led_plllock */






















/* led_chip_passdone */





/* tdiode */



/* margin */







/* secure_control */




/* efuse_secrom_chksum0 */



/* efuse_secrom_chksum1 */



/* obsclk_ctl */








/* vusr_cfgpll */



/* vusr_cfgrx0 */



/* vusr_cfgtx0 */



/* vusr_cfgrx1 */



/* vusr_cfgtx1 */



/* vusr_cfgrx2 */



/* vusr_cfgtx2 */



/* vusr_cfgrx3 */



/* vusr_cfgtx3 */



/* vusr_serdes_rsvd */



/* led_gpio_clr */



/* led_gpio */



/* efuse_rsvd0 */



/* efuse_rsvd1 */



/* efuse_rsvd2 */



/* efuse_rsvd3 */



/* chip_misc */








/* ddr3_config_reg_0 */



















/* ddr3_config_reg_1 */












/* ddr3_config_reg_2 */



/* ddr3_config_reg_3 */



/* ddr3_config_reg_4 */



/* ddr3_config_reg_5 */



/* ddr3_config_reg_6 */



/* ddr3_config_reg_7 */



/* ddr3_config_reg_8 */



/* ddr3_config_reg_9 */



/* ddr3_config_reg_10 */



/* ddr3_config_reg_11 */























/* ddr3_config_reg_12 */












/* ddr3_config_reg_13 */





/* ddr3_config_reg_14 */



/* ddr3_config_reg_15 */



/* ddr3_config_reg_16 */



/* ddr3_config_reg_17 */



/* ddr3_config_reg_18 */



/* ddr3_config_reg_19 */



/* ddr3_config_reg_20 */



/* ddr3_config_reg_21 */



/* ddr3_config_reg_22 */



/* ddr3_config_reg_23 */





/* ddr3_config_reg_24 */



/* end_point */




/** @defgroup CSL_BOOTCFG_API Boot Configuration
 *
 * @section Introduction
 *
 * @subsection 
 *  None
 *
 * @subsection References
 *  None
 */

/**
@defgroup CSL_BOOTCFG_SYMBOL  BOOT Configuration Symbols Defined
@ingroup  CSL_BOOTCFG_API
*/

/**
@defgroup CSL_BOOTCFG_FUNCTION  BOOT Configuration Functions
@ingroup  CSL_BOOTCFG_API
*/

/**
@addtogroup CSL_BOOTCFG_SYMBOL
@{
*/

/**
 *  Handle to access BOOTCFG registers.
 */

/**
@}
*/




/**
 *   @file  csl_bootcfgAux.h
 *
 *   @brief   
 *      This is the Boot Configuration Auxilary Header File which exposes 
 *      the various CSL Functional Layer API's to configure the BOOTCFG Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/




/** @addtogroup CSL_BOOTCFG_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_BootCfgGetRevisionInfo
 *
 *   @b Description
 *   @n The function is used to get the revision information for the boot 
 *      configuration module.
 *
 *   @b Arguments
     @verbatim
        info    Revision information populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_REVISION_REG
 *
 *   @b Example
 *   @verbatim
        Uint32  info;

        // Get the boot configuration revision information.
        CSL_BootCfgGetRevisionInfo (&info);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetRevisionInfo (Uint32* info)
{
    *info = ((CSL_BootcfgRegs*)(0x02620000))->REVISION_REG;
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetDeviceId
 *
 *   @b Description
 *   @n The function is used to get the device identifier.
 *
 *   @b Arguments
     @verbatim
        id    Device Identifier populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_DEVICE_ID_REG0
 *
 *   @b Example
 *   @verbatim
        Uint32  id;

        // Get the device identifier.
        CSL_BootCfgGetDeviceId (&id);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetDeviceId (Uint32* id)
{
    *id = ((CSL_BootcfgRegs*)(0x02620000))->DEVICE_ID_REG0;
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsLittleEndian
 *
 *   @b Description
 *   @n The function checks if the device is running in little endian mode or not?
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Device is in Little Endian Mode
 *   @n FALSE - Device is in Big Endian Mode
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_BOOT_REG0_BIG_ENDIAN
 *
 *   @b Example
 *   @verbatim

        // Check if device is in little endian mode or not?
        if (CSL_BootCfgIsLittleEndian () == TRUE)
        {
            // Little Endian
        }
        else
        {
            // Big Endian
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsLittleEndian (void)
{
    if ((((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) & (0x00000001u)) >> (0x00000000u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetBootMode
 *
 *   @b Description
 *   @n The function returns the boot mode which is latched at POR or RESETFULL.
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Boot mode 
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_BOOT_REG0_BOOT_MODE
 *
 *   @b Example
 *   @verbatim

        Uint16 bootMode;

        // Get the boot mode.
        bootMode = CSL_BootCfgGetBootMode();

     @endverbatim
 * =============================================================================
 */
static inline Uint16 CSL_BootCfgGetBootMode (void)
{
    return (((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) & (0x00003FFEu)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetBootMode
 *
 *   @b Description
 *   @n The function sets the boot mode 
 *
 *   @b Arguments
     @verbatim
        bootMode    - Boot Mode to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None 
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_BOOT_REG0_BOOT_MODE
 *
 *   @b Example
 *   @verbatim

        // Set the boot mode.
        CSL_BootCfgSetBootMode(0x10);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetBootMode (Uint16 bootMode)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) & ~(0x00003FFEu)) | (((bootMode) << (0x00000001u)) & (0x00003FFEu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetPCIEMode
 *
 *   @b Description
 *   @n The function returns the PCIE mode which is latched at POR or RESETFULL.
 *      The PCIE can operate in three modes, End-point mode, Legacy End-point mode 
 *      or Root complex mode.
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n 0x0 - PCIE in End-point mode
 *   @n 0x1 - PCIE in Legacy End-point mode
 *   @n 0x2 - PCIE in Root complex mode
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_BOOT_REG0_PCIESS_MODE
 *
 *   @b Example
 *   @verbatim

        Uint8 pcieMode;

        // Get the PCIE-SS mode.
        pcieMode = CSL_BootCfgGetPCIEMode();

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_BootCfgGetPCIEMode (void)
{
    return (((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) & (0x0000C000u)) >> (0x0000000Eu));
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsPCIEEnabled
 *
 *   @b Description
 *   @n The function checks if the PCIE mode is enabled or not?
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - PCIE is enabled
 *   @n FALSE - PCIE is disabled
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_BOOT_REG0_PCIESSEN
 *
 *   @b Example
 *   @verbatim

        // Is the PCIE-SS Enabled or not?
        if (CSL_BootCfgIsPCIEEnabled() == TRUE)
        {
            // PCIESS is enabled
        }
        else
        {
            // PCIESS is disabled
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsPCIEEnabled (void)
{
    return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) & (0x00010000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetPARefClockSelect
 *
 *   @b Description
 *   @n The function returns Packet accelerator subsystem (PASS) Clock select.
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n 0x0 - SYSCLK/ALTCORECLK is used as input to PA_SS PLL.
 *   @n 0x1 - PA_SS_CLK is used as input to PA_SS PLL.
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_BOOT_REG0_PA_REFCLK_SEL
 *
 *   @b Example
 *   @verbatim

        Uint8 passRefClkSelect;

        // Get the PA SS Reference clock select.
        passRefClkSelect = CSL_BootCfgGetPARefClockSelect();

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_BootCfgGetPARefClockSelect (void)
{
    return (((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) & (0x00020000u)) >> (0x00000011u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgUnlockKicker
 *
 *   @b Description
 *   @n The function is used to unlock the kicker mechanism which will allow the 
 *      Boot configuration MMR registers to be come writeable. 
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_KICK_REG0=0x83e70b13, BOOTCFG_KICK_REG1=0x95a4f1e0 
 *
 *   @b Example
 *   @verbatim

        // Unlock the kicker to ensure Boot configuration MMR is writeable
        CSL_BootCfgUnlockKicker();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgUnlockKicker (void)
{
    ((CSL_BootcfgRegs*)(0x02620000))->KICK_REG0 = 0x83e70b13;
    ((CSL_BootcfgRegs*)(0x02620000))->KICK_REG1 = 0x95a4f1e0;

    return;
}

/** ============================================================================
 *   @n@b CSL_BootCfgLockKicker
 *
 *   @b Description
 *   @n The function is used to lock the kicker mechanism which will ensure
 *      that all subequent writes to the Boot configuration MMR are now blocked
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_KICK_REG0=0x1, BOOTCFG_KICK_REG1=0x1 
 *
 *   @b Example
 *   @verbatim

        // Unlock the kicker to ensure Boot configuration MMR is writeable
        CSL_BootCfgUnlockKicker();
        ...
        // Lock the kicker mechanism
        CSL_BootCfgLockKicker();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgLockKicker (void)
{
    ((CSL_BootcfgRegs*)(0x02620000))->KICK_REG0 = 0x1;
    ((CSL_BootcfgRegs*)(0x02620000))->KICK_REG1 = 0x1;

    return;
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetDSPBootAddress
 *
 *   @b Description
 *   @n The function is used to get the initial fetch address of each GEM core
 *
 *   @b Arguments
     @verbatim
        coreIdx -   Index of the core for which the fecth address is required
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_BOOTADDR_GEM0_REG_BOOTADDR_GEM0
 *
 *   @b Example
 *   @verbatim
        Uint32  bootAddress;

        // Get the Boot configuration DSP Boot Address for Core 1
        bootAddress = CSL_BootCfgGetDSPBootAddress(1);

     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_BootCfgGetDSPBootAddress (Uint8 coreIdx)
{
    return (((((CSL_BootcfgRegs*)(0x02620000))->BOOTADDR_GEM_REG[coreIdx]) & (0xFFFFFC00u)) >> (0x0000000Au));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetDSPBootAddress
 *
 *   @b Description
 *   @n The function is used to set the initial fetch address of each GEM core
 *      This can be done only for non-secure devices.
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Index of the core for which the fetch address is configured
        bootAddress - Boot Address to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_BOOTADDR_GEM0_REG_BOOTADDR_GEM0
 *
 *   @b Example
 *   @verbatim
        Uint32  bootAddress;

        // Set the Boot configuration DSP Boot Address for Core 1
        CSL_BootCfgSetDSPBootAddress(1, 0x20B00000);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetDSPBootAddress (Uint8 coreIdx, Uint32 bootAddress)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->BOOTADDR_GEM_REG[coreIdx]) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOTADDR_GEM_REG[coreIdx]) & ~(0xFFFFFC00u)) | (((bootAddress) << (0x0000000Au)) & (0xFFFFFC00u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetMacIdentifier
 *
 *   @b Description
 *   @n The function is used to get the MAC address for this device derived from
 *      the EFUSE.
 *
 *   @b Arguments
     @verbatim
        macId1  -   Contents of the MAC ID1 register
        macId2  -   Contents of the MAC ID2 register
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_EMAC_ID1,BOOTCFG_EMAC_ID2
 *
 *   @b Example
 *   @verbatim
        Uint32  macId1;
        Uint32  macId2;

        // Get the MAC Identifier
        CSL_BootCfgGetMacIdentifier(&macId1, &macId2);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetMacIdentifier (Uint32* macId1, Uint32* macId2)
{
    *macId1 = ((CSL_BootcfgRegs*)(0x02620000))->EMAC_ID1;
    *macId2 = ((CSL_BootcfgRegs*)(0x02620000))->EMAC_ID2;
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsBootComplete
 *
 *   @b Description
 *   @n The function is used to check if the booting is complete for a specific
 *      core or not?
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core index which is to be checked
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_BOOT_COMPLETE_GEM0_COMPLETE;BOOTCFG_BOOT_COMPLETE_GEM1_COMPLETE;
 *   @n  ...;BOOTCFG_BOOT_COMPLETE_GEM7_COMPLETE
 *
 *   @b Example
 *   @verbatim

        // Check if the booting is complete or not for core 2?
        if (CSL_BootCfgIsBootComplete(2) == TRUE)
        {
            // Booting is done
        }
        else
        {
            // Booting is not done.        
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsBootComplete (Uint8 coreIdx)
{
    if (coreIdx == 0)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & (0x00000001u)) >> (0x00000000u));
    else if (coreIdx == 1)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & (0x00000002u)) >> (0x00000001u));
    else if (coreIdx == 2)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & (0x00000004u)) >> (0x00000002u));
    else if (coreIdx == 3)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & (0x00000008u)) >> (0x00000003u));
    else if (coreIdx == 4)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & (0x00000010u)) >> (0x00000004u));
    else if (coreIdx == 5)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & (0x00000020u)) >> (0x00000005u));
    else if (coreIdx == 6)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & (0x00000040u)) >> (0x00000006u));
    else
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & (0x00000080u)) >> (0x00000007u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetBootComplete
 *
 *   @b Description
 *   @n The function is used to set the boot complete. This can be done only once
 *      by the software.
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core index which for which boot complete is to be set
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_BOOT_COMPLETE_GEM0_COMPLETE;BOOTCFG_BOOT_COMPLETE_GEM1_COMPLETE;
 *   @n  ...;BOOTCFG_BOOT_COMPLETE_GEM7_COMPLETE
 *
 *   @b Example
 *   @verbatim

        // Booting is done for core 0
        CSL_BootCfgSetBootComplete (0);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetBootComplete (Uint8 coreIdx)
{
    if (coreIdx == 0)
        ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
    if (coreIdx == 1)
        ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));
    if (coreIdx == 2)
        ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & ~(0x00000004u)) | (((1) << (0x00000002u)) & (0x00000004u)));
    if (coreIdx == 3)
        ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & ~(0x00000008u)) | (((1) << (0x00000003u)) & (0x00000008u)));
    if (coreIdx == 4)
        ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & ~(0x00000010u)) | (((1) << (0x00000004u)) & (0x00000010u)));
    if (coreIdx == 5)
        ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & ~(0x00000020u)) | (((1) << (0x00000005u)) & (0x00000020u)));
    if (coreIdx == 6)
        ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & ~(0x00000040u)) | (((1) << (0x00000006u)) & (0x00000040u)));
    if (coreIdx == 7)
        ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_COMPLETE) & ~(0x00000080u)) | (((1) << (0x00000007u)) & (0x00000080u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetBootProgress
 *
 *   @b Description
 *   @n The function is used to get the boot progress. 
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Boot progress contents.
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_BOOT_PROGRESS
 *
 *   @b Example
 *   @verbatim
        Uint32  bootProgress;

        // Get the boot progress
        bootProgress = CSL_BootCfgGetBootProgress ();

     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_BootCfgGetBootProgress (void)
{
    return ((CSL_BootcfgRegs*)(0x02620000))->BOOT_PROGRESS;
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetBootProgress
 *
 *   @b Description
 *   @n The function is used to set the boot progress. 
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Boot progress contents.
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_BOOT_PROGRESS
 *
 *   @b Example
 *   @verbatim

        // Set the boot progress
        CSL_BootCfgSetBootProgress (0xDEAD);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetBootProgress (Uint32 bootProgress)
{
    ((CSL_BootcfgRegs*)(0x02620000))->BOOT_PROGRESS = bootProgress;
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsCoreLocalReset
 *
 *   @b Description
 *   @n The function is used to check if the core is locally reset or not?
 *
 *   @b Arguments
     @verbatim
        coreIdx - Core Index for which the reset status is needed
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Core is locally reset.
 *   @n FALSE - Core is not locally reset.
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_RESET_STAT_LRST_STAT0;BOOTCFG_RESET_STAT_LRST_STAT1;
 *   @n  ...;BOOTCFG_RESET_STAT_LRST_STAT7
 *
 *   @b Example
 *   @verbatim

        // Is Core 0 locally reset?
        if (CSL_BootCfgIsCoreLocalReset (0) == TRUE)
        {
            // Core 0 is locally reset.
        }
        else
        {
            // Core 0 is not locally reset.
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsCoreLocalReset (Uint8 coreIdx)
{
    if (coreIdx == 0)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x00000001u)) >> (0x00000000u));
    else if (coreIdx == 1)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x00000002u)) >> (0x00000001u));
    else if (coreIdx == 2)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x00000004u)) >> (0x00000002u));
    else if (coreIdx == 3)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x00000008u)) >> (0x00000003u));
    else if (coreIdx == 4)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x00000010u)) >> (0x00000004u));
    else if (coreIdx == 5)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x00000020u)) >> (0x00000005u));
    else if (coreIdx == 6)
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x00000040u)) >> (0x00000006u));
    else
        return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x00000080u)) >> (0x00000007u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgClearLocalReset
 *
 *   @b Description
 *   @n The function is used to clear the local reset state of the specified core
 *
 *   @b Arguments
     @verbatim
        coreIdx - Core Index for which the local reset state is to be cleared
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_RESET_STAT_CLR_LRST_STAT_0_CLR;BOOTCFG_RESET_STAT_CLR_LRST_STAT_1_CLR;
 *   @n  BOOTCFG_RESET_STAT_CLR_LRST_STAT_2_CLR;BOOTCFG_RESET_STAT_CLR_LRST_STAT_7_CLR
 *
 *   @b  Affects
 *   @n  BOOTCFG_RESET_STAT_LRST_STAT0=0;BOOTCFG_RESET_STAT_LRST_STAT1=0;
 *   @n  BOOTCFG_RESET_STAT_LRST_STAT2=0;BOOTCFG_RESET_STAT_LRST_STAT7=0
 *
 *   @b Example
 *   @verbatim

        // Is Core 0 locally reset?
        if (CSL_BootCfgIsCoreLocalReset (0) == TRUE)
        {
            // Core 0 is locally reset.
            ...
            // Clear Core 0 local reset.
            CSL_BootCfgClearLocalReset (0);
        }
        else
        {
            // Core 0 is not locally reset.
        }

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgClearLocalReset (Uint8 coreIdx)
{
    if (coreIdx == 0)
        ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
    if (coreIdx == 1)
        ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));
    if (coreIdx == 2)
        ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) & ~(0x00000004u)) | (((1) << (0x00000002u)) & (0x00000004u)));
    if (coreIdx == 3)
        ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) & ~(0x00000008u)) | (((1) << (0x00000003u)) & (0x00000008u)));
    if (coreIdx == 4)
        ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) & ~(0x00000010u)) | (((1) << (0x00000004u)) & (0x00000010u)));
    if (coreIdx == 5)
        ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) & ~(0x00000020u)) | (((1) << (0x00000005u)) & (0x00000020u)));
    if (coreIdx == 6)
        ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) & ~(0x00000040u)) | (((1) << (0x00000006u)) & (0x00000040u)));
    if (coreIdx == 7)
        ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT_CLR) & ~(0x00000080u)) | (((1) << (0x00000007u)) & (0x00000080u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsGlobalReset
 *
 *   @b Description
 *   @n The function is used to check if the device is globally reset or not?
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Device is global reset.
 *   @n FALSE - Device is not globally reset.
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_RESET_STAT_GRST_STAT
 *
 *   @b Example
 *   @verbatim

        // Is device globally reset?
        if (CSL_BootCfgIsGlobalReset () == TRUE)
        {
            // Device is global reset
        }
        else
        {
            // Device is NOT global reset
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsGlobalReset (void)
{
    return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & (0x80000000u)) >> (0x0000001Fu));
}

/** ============================================================================
 *   @n@b CSL_BootCfgClearGlobalReset
 *
 *   @b Description
 *   @n The function is used to clear the global reset state of the specified core
 *
 *   @b Arguments
     @verbatim
        coreIdx - Core Index for which the global reset state is to be cleared
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_RESET_STAT_GRST_STAT
 *
 *   @b Example
 *   @verbatim

        // Is device globally reset?
        if (CSL_BootCfgIsGlobalReset () == TRUE)
        {
            // Device is global reset
            ...
            // Clear the global reset flag
            CSL_BootCfgClearGlobalReset();
        }
        else
        {
            // Device is NOT global reset
        }

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgClearGlobalReset (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) = ((((CSL_BootcfgRegs*)(0x02620000))->RESET_STAT) & ~(0x80000000u)) | ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetNMILocalResetStatus
 *
 *   @b Description
 *   @n The function is used to get the NMI & Local reset status for a specific
 *      core.
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index for which the status is required
        nmiStatus   - NMI Status populated by this API
        localStatus - Local Reset Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Reads
 *   @n  BOOTCFG_LRSTNMISTAT_NMI_STAT0,BOOTCFG_LRSTNMISTAT_LRESET_STAT0;
 *   @n  BOOTCFG_LRSTNMISTAT_NMI_STAT1,BOOTCFG_LRSTNMISTAT_LRESET_STAT1;
 *   @n  ...;
 *   @n  BOOTCFG_LRSTNMISTAT_NMI_STAT3,BOOTCFG_LRSTNMISTAT_LRESET_STAT7;
 *
 *   @b Example
 *   @verbatim

        Uint8   nmiStatus;
        Uint8   localStatus;

        // Get the NMI and Local Reset Status for core 1
        CSL_BootCfgGetNMILocalResetStatus (1, &nmiStatus, &localStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetNMILocalResetStatus (Uint8 coreIdx, Uint8* nmiStatus, Uint8* localStatus)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->LRSTNMISTAT;

    if (coreIdx == 0)
    {
        *nmiStatus   = (((value) & (0x00000100u)) >> (0x00000008u));
        *localStatus = (((value) & (0x00000001u)) >> (0x00000000u));
    }
    if (coreIdx == 1)
    {
        *nmiStatus   = (((value) & (0x00000200u)) >> (0x00000009u));
        *localStatus = (((value) & (0x00000002u)) >> (0x00000001u));
    } 
    if (coreIdx == 2)
    {
        *nmiStatus   = (((value) & (0x00000400u)) >> (0x0000000Au));
        *localStatus = (((value) & (0x00000004u)) >> (0x00000002u));
    }
    if (coreIdx == 3)
    {
        *nmiStatus   = (((value) & (0x00000800u)) >> (0x0000000Bu));
        *localStatus = (((value) & (0x00000008u)) >> (0x00000003u));
    }
    if (coreIdx == 4)
    {
        *nmiStatus   = (((value) & (0x00001000u)) >> (0x0000000Cu));
        *localStatus = (((value) & (0x00000010u)) >> (0x00000004u));
    }
    if (coreIdx == 5)
    {
        *nmiStatus   = (((value) & (0x00002000u)) >> (0x0000000Du));
        *localStatus = (((value) & (0x00000020u)) >> (0x00000005u));
    }
    if (coreIdx == 6)
    {
        *nmiStatus   = (((value) & (0x00004000u)) >> (0x0000000Eu));
        *localStatus = (((value) & (0x00000040u)) >> (0x00000006u));
    }
    if (coreIdx == 7)
    {
        *nmiStatus   = (((value) & (0x00008000u)) >> (0x0000000Fu));
        *localStatus = (((value) & (0x00000080u)) >> (0x00000007u));
    }
}

/** ============================================================================
 *   @n@b CSL_BootCfgClearNMILocalResetStatus
 *
 *   @b Description
 *   @n The function is used to clear the NMI & Local reset status for a specific
 *      core.
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index for which the status is required
        nmiStatus   - NMI Status to be cleared
        localStatus - Local Reset Status to be cleared
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_LRSTNMISTAT_NMI_STAT0,BOOTCFG_LRSTNMISTAT_LRESET_STAT0;
 *   @n  BOOTCFG_LRSTNMISTAT_NMI_STAT1,BOOTCFG_LRSTNMISTAT_LRESET_STAT1;
 *   @n  ...;
 *   @n  BOOTCFG_LRSTNMISTAT_NMI_STAT3,BOOTCFG_LRSTNMISTAT_LRESET_STAT7;
 *
 *   @b Example
 *   @verbatim

        Uint8   nmiStatus;
        Uint8   localStatus;

        // Get the NMI and Local Reset Status for core 1
        CSL_BootCfgGetNMILocalResetStatus (1, &nmiStatus, &localStatus);
        ...
        // Clear the status
        CSL_BootCfgClearNMILocalResetStatus (1, nmiStatus, localStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgClearNMILocalResetStatus (Uint8 coreIdx, Uint8 nmiStatus, Uint8 localStatus)
{
    Uint32 value = 0;

    if (coreIdx == 0)
    {
        ((value) = ((value) & ~(0x00000100u)) | (((nmiStatus) << (0x00000008u)) & (0x00000100u)));
        ((value) = ((value) & ~(0x00000001u)) | (((localStatus) << (0x00000000u)) & (0x00000001u)));
    }
    if (coreIdx == 1)
    {
        ((value) = ((value) & ~(0x00000200u)) | (((nmiStatus) << (0x00000009u)) & (0x00000200u)));
        ((value) = ((value) & ~(0x00000002u)) | (((localStatus) << (0x00000001u)) & (0x00000002u)));
    } 
    if (coreIdx == 2)
    {
        ((value) = ((value) & ~(0x00000400u)) | (((nmiStatus) << (0x0000000Au)) & (0x00000400u)));
        ((value) = ((value) & ~(0x00000004u)) | (((localStatus) << (0x00000002u)) & (0x00000004u)));
    }
    if (coreIdx == 3)
    {
        ((value) = ((value) & ~(0x00000800u)) | (((nmiStatus) << (0x0000000Bu)) & (0x00000800u)));
        ((value) = ((value) & ~(0x00000008u)) | (((localStatus) << (0x00000003u)) & (0x00000008u)));
    }
    if (coreIdx == 4)
    {
        ((value) = ((value) & ~(0x00001000u)) | (((nmiStatus) << (0x0000000Cu)) & (0x00001000u)));
        ((value) = ((value) & ~(0x00000010u)) | (((localStatus) << (0x00000004u)) & (0x00000010u)));
    }
    if (coreIdx == 5)
    {
        ((value) = ((value) & ~(0x00002000u)) | (((nmiStatus) << (0x0000000Du)) & (0x00002000u)));
        ((value) = ((value) & ~(0x00000020u)) | (((localStatus) << (0x00000005u)) & (0x00000020u)));
    }
    if (coreIdx == 6)
    {
        ((value) = ((value) & ~(0x00004000u)) | (((nmiStatus) << (0x0000000Eu)) & (0x00004000u)));
        ((value) = ((value) & ~(0x00000040u)) | (((localStatus) << (0x00000006u)) & (0x00000040u)));
    }
    if (coreIdx == 7)
    {
        ((value) = ((value) & ~(0x00008000u)) | (((nmiStatus) << (0x0000000Fu)) & (0x00008000u)));
        ((value) = ((value) & ~(0x00000080u)) | (((localStatus) << (0x00000007u)) & (0x00000080u)));
    }

    /* Write to the register to clear the NMI Status. */
    ((CSL_BootcfgRegs*)(0x02620000))->LRSTNMISTAT_CLR = value;
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsSysClockEnabled
 *
 *   @b Description
 *   @n The function checks if the system clock is enabled or not?
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Clock output enabled
 *   @n FALSE - No Clock Output
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_DEVCFG_SYSCLKOUTEN
 *
 *   @b Example
 *   @verbatim

        // Is System clock is enabled or not?
        if (CSL_BootCfgIsSysClockEnabled () == TRUE)
        {
            // Clock output is Enabled
        }
        else
        {
            // No Clock Output
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsSysClockEnabled (void)
{
    return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->DEVCFG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgEnableSysClock
 *
 *   @b Description
 *   @n The function is used to enable the sys clock 
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_DEVCFG_SYSCLKOUTEN=1
 *
 *   @b Example
 *   @verbatim

        CSL_BootCfgEnableSysClock();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgEnableSysClock (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->DEVCFG) = ((((CSL_BootcfgRegs*)(0x02620000))->DEVCFG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgDisableSysClock
 *
 *   @b Description
 *   @n The function is used to disable the sys clock 
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_DEVCFG_SYSCLKOUTEN=0
 *
 *   @b Example
 *   @verbatim

        CSL_BootCfgDisableSysClock();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgDisableSysClock (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->DEVCFG) = ((((CSL_BootcfgRegs*)(0x02620000))->DEVCFG) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetPowerStatus
 *
 *   @b Description
 *   @n The function gets the Power status
 *
 *   @b Arguments
     @verbatim
        standbyStatus       - Indicates whether in Standby mode or not
        hibernationStatus   - Indicates whether in Hibernation mode or not
        hibernationMode     - Indicates whether in Hibernation mode1 or mode2
        generalPurpose      - General Purpose value in the register
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_PWR_STAT_STANDBY,BOOTCFG_PWR_STAT_HIBERNATION,
 *   @n BOOTCFG_PWR_STAT_HIBERNATION_MODE,BOOTCFG_PWR_STAT_PWR_STAT_GENERAL
 *
 *   @b Example
 *   @verbatim

        Uint8  standby;
        Uint8  hibernation;
        Uint8  hibernationMode;
        Uint32 generalPurpose;

        // Get the power status.
        CSL_BootCfgGetPowerStatus(&standby, &hibernation, &hibernationMode, &generalPurpose);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetPowerStatus 
(
    Uint8*  standby, 
    Uint8*  hibernation, 
    Uint8*  hibernationMode,
    Uint32* generalPurpose
)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->PWR_STAT;

    *standby        = (((value) & (0x00000001u)) >> (0x00000000u));
    *hibernation    = (((value) & (0x00000002u)) >> (0x00000001u));
    *hibernationMode= (((value) & (0x00000004u)) >> (0x00000002u));
    *generalPurpose = (((value) & (0xFFFFFFF8u)) >> (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetPowerStatus
 *
 *   @b Description
 *   @n The function sets the Power status
 *
 *   @b Arguments
     @verbatim
        standbyStatus       - Status of the standby to be configured
        hibernationStatus   - Hibernation Status to be configured
        hibernationMode     - Hibernation mode to be configured
        generalPurpose      - General Purpose value to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_PWR_STAT_STANDBY,BOOTCFG_PWR_STAT_HIBERNATION,
 *   @n BOOTCFG_PWR_STAT_HIBERNATION_MODE,BOOTCFG_PWR_STAT_PWR_STAT_GENERAL
 *
 *   @b Example
 *   @verbatim

        Uint8  standby;
        Uint8  hibernation;
        Uint8  hibernationMode;
        Uint32 generalPurpose;

        // Get the power status.
        CSL_BootCfgGetPowerStatus(&standby, &hibernation, &hibernationMode, &generalPurpose);
        ...
        // Set the power status to be in standby mode
        CSL_BootCfgSetPowerStatus (1, hibernation, hibernationMode, generalPurpose);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetPowerStatus 
(
    Uint8  standby, 
    Uint8  hibernation, 
    Uint8  hibernationMode,
    Uint32 generalPurpose
)
{
    ((CSL_BootcfgRegs*)(0x02620000))->PWR_STAT = (((standby) << (0x00000000u)) & (0x00000001u))            |
                         (((hibernation) << (0x00000001u)) & (0x00000002u))        |
                         (((hibernationMode) << (0x00000002u)) & (0x00000004u))    |
                         (((generalPurpose) << (0x00000003u)) & (0xFFFFFFF8u)); 
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSRIOSERDESStatus
 *
 *   @b Description
 *   @n The function gets the SRIO SERDES Status.
 *
 *   @b Arguments
     @verbatim
        srioSERDESStatus    - Status populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_STS_SRIO_STS_SRIO
 *
 *   @b Example
 *   @verbatim

        Uint32 srioSERDESStatus;

        // Get the SRIO SERDES status.
        CSL_BootCfgGetSRIOSERDESStatus(&srioSERDESStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSRIOSERDESStatus 
(
    Uint32*  srioSERDESStatus 
)
{
    *srioSERDESStatus = (((((CSL_BootcfgRegs*)(0x02620000))->STS_SRIO) & (0x1FFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSGMIISERDESStatus
 *
 *   @b Description
 *   @n The function gets the SGMII SERDES Status.
 *
 *   @b Arguments
     @verbatim
        sgmiiSERDESStatus    - Status populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_STS_SGMII_STS_SGMII
 *
 *   @b Example
 *   @verbatim

        Uint32 sgmiiSERDESStatus;

        // Get the SGMII SERDES status.
        CSL_BootCfgGetSGMIISERDESStatus(&sgmiiSERDESStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSGMIISERDESStatus 
(
    Uint32*  sgmiiSERDESStatus
)
{
    *sgmiiSERDESStatus = (((((CSL_BootcfgRegs*)(0x02620000))->STS_SGMII) & (0x00001FFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetPCIESERDESStatus
 *
 *   @b Description
 *   @n The function gets the PCIE SERDES Status.
 *
 *   @b Arguments
     @verbatim
        pcieSERDESStatus    - Status populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_STS_PCIE_STS_PCIE
 *
 *   @b Example
 *   @verbatim

        Uint32 pcieSERDESStatus;

        // Get the PCIE SERDES status.
        CSL_BootCfgGetPCIESERDESStatus(&pcieSERDESStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetPCIESERDESStatus 
(
    Uint32*  pcieSERDESStatus 
)
{
    *pcieSERDESStatus = (((((CSL_BootcfgRegs*)(0x02620000))->STS_PCIE) & (0x00001FFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetVUSRSERDESStatus
 *
 *   @b Description
 *   @n The function gets the VUSR SERDES Status.
 *
 *   @b Arguments
     @verbatim
        vusrSERDESStatus    - Status populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_STS_VUSR_STS_VUSR
 *
 *   @b Example
 *   @verbatim

        Uint32 vusrSERDESStatus;

        // Get the VUSR SERDES status.
        CSL_BootCfgGetVUSRSERDESStatus(&vusrSERDESStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetVUSRSERDESStatus 
(
    Uint32*  vusrSERDESStatus 
)
{
    *vusrSERDESStatus = (((((CSL_BootcfgRegs*)(0x02620000))->STS_VUSR) & (0x1FFFFFFFu)) >> (0x00000000u));
}


/** ============================================================================
 *   @n@b CSL_BootCfgGenerateNMIEvent
 *
 *   @b Description
 *   @n The function is used to generate a NMI event to a specific core.
 *
 *   @b Arguments
     @verbatim
        coreNum    - Core Number on which the NMI event is to be generated.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_NMIGR_0_NMIGR_0_REG;BOOTCFG_NMIGR_1_NMIGR_1_REG;
 *   @n BOOTCFG_NMIGR_2_NMIGR_2_REG;BOOTCFG_NMIGR_3_NMIGR_3_REG
 *
 *   @b Example
 *   @verbatim

        // Generate NMI Event on Core 0
        CSL_BootCfgGenerateNMIEvent(0);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGenerateNMIEvent 
(
    Uint8  coreNum
)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->NMIGR[coreNum]) = ((((CSL_BootcfgRegs*)(0x02620000))->NMIGR[coreNum]) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGenerateInterDSPInterrupt
 *
 *   @b Description
 *   @n The function is used to generate an inter-DSP interrupt.
 *
 *   @b Arguments
     @verbatim
        coreNum  - Core Number to which the interrupt is directed.
        sourceId - Source Id which identifies the entity generating the interrupt
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_IPCGR0_IPCGR0_SRC, BOOTCFG_IPCGR0_IPCGR0_REG=1;
 *   @n BOOTCFG_IPCGR1_IPCGR1_SRC, BOOTCFG_IPCGR1_IPCGR1_REG=1;
 *   @n BOOTCFG_IPCGR2_IPCGR2_SRC, BOOTCFG_IPCGR2_IPCGR2_REG=1;
 *   @n BOOTCFG_IPCGR3_IPCGR3_SRC, BOOTCFG_IPCGR3_IPCGR3_REG=1;
 *
 *   @b Example
 *   @verbatim

        // Generate Inter-DSP Interrupt to Core 1 with the Source Id as 4
        CSL_BootCfgGenerateInterDSPInterrupt(1, 4);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGenerateInterDSPInterrupt 
(
    Uint8   coreNum,
    Uint32  sourceId 
)
{
    ((CSL_BootcfgRegs*)(0x02620000))->IPCGR[coreNum] = (((sourceId) << (0x00000004u)) & (0xFFFFFFF0u)) | 
                               (((1) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGenerateExternalHostInterrupt
 *
 *   @b Description
 *   @n The function is used to generate an external host interrupt.
 *
 *   @b Arguments
     @verbatim
        sourceId - Source Id which identifies the entity generating the interrupt
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_IPCGRH_IPCGRH_SRC, BOOTCFG_IPCGRH_IPCGRH_REG=1;
 *
 *   @b Example
 *   @verbatim

        // Generate External Host Interrupt with the Source Id as 2
        CSL_BootCfgGenerateExternalHostInterrupt(2);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGenerateExternalHostInterrupt 
(
    Uint32  sourceId 
)
{
    ((CSL_BootcfgRegs*)(0x02620000))->IPCGRH = (((sourceId) << (0x00000004u)) & (0xFFFFFFF0u)) |
                       (((1) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetInterDSPInterruptStatus
 *
 *   @b Description
 *   @n The function is used to get the status of the Inter-DSP Interrupt 
 *      register. 
 *
 *   @b Arguments
     @verbatim
        coreNum   - Core Number for which the interrupt status is read.
        intStatus - Interrupt Status(Source ID) populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_IPCAR0_IPCGR0_SRC_CLR; BOOTCFG_IPCAR1_IPCGR1_SRC_CLR;
 *   @n BOOTCFG_IPCAR2_IPCGR2_SRC_CLR; BOOTCFG_IPCAR3_IPCGR3_SRC_CLR
 *
 *   @b Example
 *   @verbatim

        Uint32  srcId;

        // Get the Inter-DSP Interrupt Status for Core 2
        CSL_BootCfgGetInterDSPInterruptStatus(2, &srcId);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetInterDSPInterruptStatus 
(
    Uint8   coreNum,
    Uint32* intStatus 
)
{
    *intStatus = (((((CSL_BootcfgRegs*)(0x02620000))->IPCAR[coreNum]) & (0xFFFFFFF0u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgClearInterDSPInterruptStatus
 *
 *   @b Description
 *   @n The function is used to clear the status of the Inter-DSP Interrupt 
 *      register. 
 *
 *   @b Arguments
     @verbatim
        coreNum   - Core Number for which the interrupt status is read.
        intStatus - Interrupt Status(Source ID) to be cleared.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_IPCAR0_IPCGR0_SRC_CLR; BOOTCFG_IPCAR1_IPCGR1_SRC_CLR;
 *   @n BOOTCFG_IPCAR2_IPCGR2_SRC_CLR; BOOTCFG_IPCAR3_IPCGR3_SRC_CLR
 *
 *   @b Example
 *   @verbatim

        Uint32  srcId;

        // Get the Inter-DSP Interrupt Status for Core 2
        CSL_BootCfgGetInterDSPInterruptStatus(2, &srcId);
        ...
        // Clear the interrupts.
        CSL_BootCfgClearInterDSPInterruptStatus(2, srcId);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgClearInterDSPInterruptStatus 
(
    Uint8   coreNum,
    Uint32  intStatus 
)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->IPCAR[coreNum]) = ((((CSL_BootcfgRegs*)(0x02620000))->IPCAR[coreNum]) & ~(0xFFFFFFF0u)) | (((intStatus) << (0x00000004u)) & (0xFFFFFFF0u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetExternalHostInterruptStatus
 *
 *   @b Description
 *   @n The function is used to get the status of the External Host Interrupt 
 *      register. 
 *
 *   @b Arguments
     @verbatim
        intStatus - Interrupt Status(Source ID) populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_IPCARH_IPCGRH_SRC_CLR
 *
 *   @b Example
 *   @verbatim

        Uint32  srcId;

        // Get the External Host Interrupt Status
        CSL_BootCfgGetExternalHostInterruptStatus(&srcId);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetExternalHostInterruptStatus 
(
    Uint32* intStatus 
)
{
    *intStatus = (((((CSL_BootcfgRegs*)(0x02620000))->IPCARH) & (0xFFFFFFF0u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgClearExternalHostInterruptStatus
 *
 *   @b Description
 *   @n The function is used to clear the status of the External Host Interrupt 
 *      register. 
 *
 *   @b Arguments
     @verbatim
        intStatus - Interrupt Status(Source ID) to be cleared
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_IPCARH_IPCGRH_SRC_CLR
 *
 *   @b Example
 *   @verbatim

        Uint32  srcId;

        // Get the External Host Interrupt Status
        CSL_BootCfgGetExternalHostInterruptStatus(&srcId);
        ...
        // Clear the Interrupt Status
        CSL_BootCfgClearExternalHostInterruptStatus(srcId);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgClearExternalHostInterruptStatus 
(
    Uint32 intStatus 
)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->IPCARH) = ((((CSL_BootcfgRegs*)(0x02620000))->IPCARH) & ~(0xFFFFFFF0u)) | (((intStatus) << (0x00000004u)) & (0xFFFFFFF0u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetTimerInputSelection
 *
 *   @b Description
 *   @n The function gets the timer input selection
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Timer Input Selection
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_TINPSEL_TINPSEL
 *
 *   @b Example
 *   @verbatim

        Uint16 timerInput;

        // Get the timer input selection 
        timerInput = CSL_BootCfgGetTimerInputSelection();

     @endverbatim
 * =============================================================================
 */
static inline Uint16 CSL_BootCfgGetTimerInputSelection (void)
{
    return (((((CSL_BootcfgRegs*)(0x02620000))->TINPSEL) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetTimerInputSelection
 *
 *   @b Description
 *   @n The function sets the timer input selection
 *
 *   @b Arguments
     @verbatim
        timerInput  - Timer Input selection to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Timer Input Selection
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_TINPSEL_TINPSEL
 *
 *   @b Example
 *   @verbatim

        // Set the timer input selection 
        CSL_BootCfgSetTimerInputSelection(0x1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetTimerInputSelection (Uint16 timerInput)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->TINPSEL) = ((((CSL_BootcfgRegs*)(0x02620000))->TINPSEL) & ~(0xFFFFFFFFu)) | (((timerInput) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetTimerOutputSelection
 *
 *   @b Description
 *   @n The function gets the timer output selection
 *
 *   @b Arguments
     @verbatim
        timerOutputSel0 -   Timer output selection 0
        timerOutputSel1 -   Timer output selection 1
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_TOUTSEL_TOUTSEL0,BOOTCFG_TOUTSEL_TOUTSEL1
 *
 *   @b Example
 *   @verbatim

        Uint8 timerOutputSel0;
        Uint8 timerOutputSel1;

        // Get the timer output selections
        CSL_BootCfgGetTimerOutputSelection(&timerOutputSel0, &timerOutputSel1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetTimerOutputSelection (Uint8* timerOutputSel0, Uint8* timerOutputSel1)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->TOUTSEL;

    *timerOutputSel0 = (((value) & (0x0000001Fu)) >> (0x00000000u));
    *timerOutputSel1 = (((value) & (0x000003E0u)) >> (0x00000005u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetTimerOutputSelection
 *
 *   @b Description
 *   @n The function sets the timer output selection
 *
 *   @b Arguments
     @verbatim
        timerOutputSel0 -   Timer output selection 0
        timerOutputSel1 -   Timer output selection 1
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_TOUTSEL_TOUTSEL0,BOOTCFG_TOUTSEL_TOUTSEL1
 *
 *   @b Example
 *   @verbatim

        // Set the timer output selections
        CSL_BootCfgGetTimerOutputSelection(0x0, 0x1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetTimerOutputSelection (Uint8 timerOutputSel0, Uint8 timerOutputSel1)
{
    ((CSL_BootcfgRegs*)(0x02620000))->TOUTSEL = (((timerOutputSel0) << (0x00000000u)) & (0x0000001Fu)) |
                        (((timerOutputSel1) << (0x00000005u)) & (0x000003E0u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetResetMuxLockStatus
 *
 *   @b Description
 *   @n The function gets the reset mux block lock status
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index
        lockStatus  - Status of the register fields lock 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_RSTMUX0_RSTMUX_LOCK0
 *
 *   @b Example
 *   @verbatim

        Uint8   lockStatus;

        // Get the lock status for core 0
        CSL_BootCfgGetResetMuxLockStatus (0, &lockStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetResetMuxLockStatus (Uint8 coreIdx, Uint8* lockStatus)
{
    *lockStatus = (((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetResetMuxLockStatus
 *
 *   @b Description
 *   @n The function sets the reset mux block lock status
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index
        lockStatus  - Status of the register fields lock 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_RSTMUX0_RSTMUX_LOCK0
 *
 *   @b Example
 *   @verbatim

        // Lock registers for Core 0
        CSL_BootCfgSetResetMuxLockStatus (0, 1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetResetMuxLockStatus (Uint8 coreIdx, Uint8 lockStatus)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) = ((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) & ~(0x00000001u)) | (((lockStatus) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetResetMuxOutputMode
 *
 *   @b Description
 *   @n The function gets the reset mux block output mode
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index
        outputMode  - Output Mode populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_RSTMUX0_RSTMUX_OMODE0
 *
 *   @b Example
 *   @verbatim

        Uint8   outputMode;

        // Get the output mode for core 0
        CSL_BootCfgGetResetMuxOutputMode (0, &outputMode);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetResetMuxOutputMode (Uint8 coreIdx, Uint8* outputMode)
{
    *outputMode = (((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) & (0x0000000Eu)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetResetMuxOutputMode
 *
 *   @b Description
 *   @n The function sets the reset mux block output mode
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index
        outputMode  - Output Mode to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_RSTMUX0_RSTMUX_OMODE0
 *
 *   @b Example
 *   @verbatim

        // Set the output mode for core 0 to ensure that the WD Timer generates a local reset
        CSL_BootCfgSetResetMuxOutputMode (0, 2);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetResetMuxOutputMode (Uint8 coreIdx, Uint8 outputMode)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) = ((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) & ~(0x0000000Eu)) | (((outputMode) << (0x00000001u)) & (0x0000000Eu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetResetMuxDelay
 *
 *   @b Description
 *   @n The function gets the reset mux delay between NMI & IReset
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index
        delay       - Delay populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_RSTMUX0_RSTMUX_DELAY0
 *
 *   @b Example
 *   @verbatim

        Uint8   delay;

        // Get the delay for core 0
        CSL_BootCfgGetResetMuxOutputMode (0, &delay);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetResetMuxDelay (Uint8 coreIdx, Uint8* delay)
{
    *delay = (((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) & (0x000000E0u)) >> (0x00000005u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetResetMuxDelay
 *
 *   @b Description
 *   @n The function sets the reset mux delay between NMI & IReset
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index
        delay       - Delay to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_RSTMUX0_RSTMUX_DELAY0
 *
 *   @b Example
 *   @verbatim

        // Set the delay for core 0 to be 2048 CPU/6 cycles delay between NMI & lreset
        CSL_BootCfgSetResetMuxDelay (0, 0x3);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetResetMuxDelay (Uint8 coreIdx, Uint8 delay)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) = ((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) & ~(0x000000E0u)) | (((delay) << (0x00000005u)) & (0x000000E0u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsResetMuxEventDetected
 *
 *   @b Description
 *   @n The function checks if an event is detected by the Result Mux block 
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Event has been detected
 *   @n FALSE - Event has not been detected
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_RSTMUX0_RSTMUX_EVSTAT0
 *
 *   @b Example
 *   @verbatim

        // Check if there is an event detected or not for core 1
        if (CSL_BootCfgIsResetMuxEventDetected (1) == TRUE)
        {
            // Reset Event has been detected
        }
        else
        {
            // Reset Event has NOT been detected
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsResetMuxEventDetected (Uint8 coreIdx)
{
    return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) & (0x00000010u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgClearResetMuxEvent
 *
 *   @b Description
 *   @n The function is to used clear the detected event in the reset mux block
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Core Index
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_RSTMUX0_RSTMUX_EVSTAT_CLR0
 *
 *   @b Example
 *   @verbatim

        // Check if there is an event detected or not for core 1
        if (CSL_BootCfgIsResetMuxEventDetected (1) == TRUE)
        {
            // Reset Event has been detected
            ...
            // Clear the reset event
            CSL_BootCfgClearResetMuxEvent(1);
        }
        else
        {
            // Reset Event has NOT been detected
        }

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgClearResetMuxEvent (Uint8 coreIdx)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) = ((((CSL_BootcfgRegs*)(0x02620000))->RSTMUX[coreIdx]) & ~(0x00000200u)) | (((1) << (0x00000009u)) & (0x00000200u)));
}




/** ============================================================================
 *   @n@b CSL_BootCfgGetCOREPLLConfiguration
 *
 *   @b Description
 *   @n The function is to used get the CORE PLL configuration.
 *
 *   @b Arguments
     @verbatim
        corePLLConfig0    - CORE PLL Configuration0.
        corePLLConfig1    - CORE PLL Configuration1.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_CORE_PLL_CTL0, BOOTCFG_CORE_PLL_CTL1
 *
 *   @b Example
 *   @verbatim

        Uint32  corePLLConfig0;
        Uint32  corePLLConfig1;

        // Get the CORE PLL Configuration
        CSL_BootCfgGetCOREPLLConfiguration (&corePLLConfig0, &corePLLConfig1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetCOREPLLConfiguration (Uint32* corePLLConfig0, Uint32* corePLLConfig1)
{
    *corePLLConfig0 = ((CSL_BootcfgRegs*)(0x02620000))->CORE_PLL_CTL0;
    *corePLLConfig1 = ((CSL_BootcfgRegs*)(0x02620000))->CORE_PLL_CTL1;
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetCOREPLLConfiguration
 *
 *   @b Description
 *   @n The function is to used set the CORE PLL configuration.
 *
 *   @b Arguments
     @verbatim
        corePLLConfig0    - CORE PLL Configuration0.
        corePLLConfig1    - CORE PLL Configuration1.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_CORE_PLL_CTL0, BOOTCFG_CORE_PLL_CTL1
 *
 *   @b Example
 *   @verbatim

        Uint32  corePLLConfig0;
        Uint32  corePLLConfig1;

        // Get the CORE PLL Configuration
        CSL_BootCfgGetCOREPLLConfiguration (&corePLLConfig0, &corePLLConfig1);
        ...
        // Set the CORE PLL Configuration
        CSL_BootCfgSetCOREPLLConfiguration (corePLLConfig0, corePLLConfig1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetCOREPLLConfiguration (Uint32 corePLLConfig0, Uint32 corePLLConfig1)
{
    ((CSL_BootcfgRegs*)(0x02620000))->CORE_PLL_CTL0 = corePLLConfig0;
    ((CSL_BootcfgRegs*)(0x02620000))->CORE_PLL_CTL1 = corePLLConfig1;
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetDDR3PLLConfiguration
 *
 *   @b Description
 *   @n The function is to used get the DDR3 PLL configuration.
 *
 *   @b Arguments
     @verbatim
        ddr3PLLConfig0    - DDR3 PLL Configuration0.
        ddr3PLLConfig1    - DDR3 PLL Configuration1.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_DDR3_PLL_CTL0, BOOTCFG_DDR3_PLL_CTL1
 *
 *   @b Example
 *   @verbatim

        Uint32  ddr3PLLConfig0;
        Uint32  ddr3PLLConfig1;

        // Get the DDR3 PLL Configuration
        CSL_BootCfgGetDDR3PLLConfiguration (&ddr3PLLConfig0, &ddr3PLLConfig1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetDDR3PLLConfiguration (Uint32* ddr3PLLConfig0, Uint32* ddr3PLLConfig1)
{
    *ddr3PLLConfig0 = ((CSL_BootcfgRegs*)(0x02620000))->DDR3_PLL_CTL0;
    *ddr3PLLConfig1 = ((CSL_BootcfgRegs*)(0x02620000))->DDR3_PLL_CTL1;
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetDDR3PLLConfiguration
 *
 *   @b Description
 *   @n The function is to used set the DDR3 PLL configuration.
 *
 *   @b Arguments
     @verbatim
        ddr3PLLConfig0    - DDR3 PLL Configuration0.
        ddr3PLLConfig1    - DDR3 PLL Configuration1.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_DDR3_PLL_CTL0, BOOTCFG_DDR3_PLL_CTL1
 *
 *   @b Example
 *   @verbatim

        Uint32  ddr3PLLConfig0;
        Uint32  ddr3PLLConfig1;

        // Get the DDR3 PLL Configuration
        CSL_BootCfgGetDDR3PLLConfiguration (&ddr3PLLConfig0, &ddr3PLLConfig1);
        ...
        // Set the DDR3 PLL Configuration
        CSL_BootCfgSetDDR3PLLConfiguration (ddr3PLLConfig0, ddr3PLLConfig1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetDDR3PLLConfiguration (Uint32 ddr3PLLConfig0, Uint32 ddr3PLLConfig1)
{
    ((CSL_BootcfgRegs*)(0x02620000))->DDR3_PLL_CTL0 = ddr3PLLConfig0;
    ((CSL_BootcfgRegs*)(0x02620000))->DDR3_PLL_CTL1 = ddr3PLLConfig1;
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetPAPLLConfiguration
 *
 *   @b Description
 *   @n The function is to used get the PA PLL configuration.
 *
 *   @b Arguments
     @verbatim
        paPLLConfig0    - PA PLL Configuration0.
        paPLLConfig1    - PA PLL Configuration1.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_PA_PLL_CTL0, BOOTCFG_PA_PLL_CTL1
 *
 *   @b Example
 *   @verbatim

        Uint32  paPLLConfig0;
        Uint32  paPLLConfig1;

        // Get the PA PLL Configuration
        CSL_BootCfgGetPAPLLConfiguration (&paPLLConfig0, &paPLLConfig1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetPAPLLConfiguration (Uint32* paPLLConfig0, Uint32* paPLLConfig1)
{
    *paPLLConfig0 = ((CSL_BootcfgRegs*)(0x02620000))->PA_PLL_CTL0;
    *paPLLConfig1 = ((CSL_BootcfgRegs*)(0x02620000))->PA_PLL_CTL1;
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetPAPLLConfiguration
 *
 *   @b Description
 *   @n The function is to used set the PA PLL configuration.
 *
 *   @b Arguments
     @verbatim
        paPLLConfig0    - PA PLL Configuration0.
        paPLLConfig1    - PA PLL Configuration1.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_PA_PLL_CTL0, BOOTCFG_PA_PLL_CTL1
 *
 *   @b Example
 *   @verbatim

        Uint32  paPLLConfig0;
        Uint32  paPLLConfig1;

        // Get the PA PLL Configuration
        CSL_BootCfgGetPAPLLConfiguration (&paPLLConfig0, &paPLLConfig1);
        ...
        // Set the PA PLL Configuration
        CSL_BootCfgSetPAPLLConfiguration (paPLLConfig0, paPLLConfig1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetPAPLLConfiguration (Uint32 paPLLConfig0, Uint32 paPLLConfig1)
{
    ((CSL_BootcfgRegs*)(0x02620000))->PA_PLL_CTL0 = paPLLConfig0;
    ((CSL_BootcfgRegs*)(0x02620000))->PA_PLL_CTL1 = paPLLConfig1;
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSGMIIConfigPLL
 *
 *   @b Description
 *   @n The function is to used get the SGMII configuration PLL.
 *
 *   @b Arguments
     @verbatim
        configPLL   - SGMII PLL Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SGMII_CFGPLL_SGMII_CFGPLL
 *
 *   @b Example
 *   @verbatim

        Uint16  configPLL;

        // Get the SGMII Configuration PLL
        CSL_BootCfgGetSGMIIConfigPLL (&configPLL);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSGMIIConfigPLL (Uint16* configPLL)
{
    *configPLL = (((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGPLL) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetSGMIIConfigPLL
 *
 *   @b Description
 *   @n The function is to used set the SGMII configuration PLL.
 *
 *   @b Arguments
     @verbatim
        configPLL   - SGMII PLL Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SGMII_CFGPLL_SGMII_CFGPLL
 *
 *   @b Example
 *   @verbatim

        Uint16  configPLL;

        // Get the SGMII Configuration PLL
        CSL_BootCfgGetSGMIIConfigPLL (&configPLL);

        // Enable the PLL and configure it.
        configPLL = configPLL | 0x1;
        CSL_BootCfgSetSGMIIConfigPLL (configPLL);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetSGMIIConfigPLL (Uint16 configPLL)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGPLL) = ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGPLL) & ~(0x0000FFFFu)) | (((configPLL) << (0x00000000u)) & (0x0000FFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSGMIIRxConfig
 *
 *   @b Description
 *   @n The function is to used get the SGMII receive configuration.
 *
 *   @b Arguments
     @verbatim
        index      - Index of the SGMII Receive Configuration (0 or 1)
        rxConfig   - SGMII Receive configuration.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SGMII_CFGRX0_SGMII_RXCFG0;BOOTCFG_SGMII_CFGRX1_SGMII_RXCFG1
 *
 *   @b Example
 *   @verbatim

        Uint32  rxConfig;

        // Get the SGMII Receive Configuration
        CSL_BootCfgGetSGMIIRxConfig (0, &rxConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSGMIIRxConfig (Uint8 index, Uint32* rxConfig)
{
    if (index == 0)
        *rxConfig = (((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGRX0) & (0xFFFFFFFFu)) >> (0x00000000u));
    else
        *rxConfig = (((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGRX1) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetSGMIIRxConfig
 *
 *   @b Description
 *   @n The function is to used set the SGMII receive configuration.
 *
 *   @b Arguments
     @verbatim
        index      - Index of the SGMII Receive Configuration (0 or 1)
        rxConfig   - SGMII Receive configuration.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SGMII_CFGRX0_SGMII_RXCFG0;BOOTCFG_SGMII_CFGRX1_SGMII_RXCFG1
 *
 *   @b Example
 *   @verbatim

        Uint32  rxConfig;

        // Get the SGMII Receive Configuration
        CSL_BootCfgGetSGMIIRxConfig (0, &rxConfig);
        ...
        // Enable the SGMII Receive
        rxConfig = rxConfig | 0x1;

        // Set the SGMII Receive configuration.
        CSL_BootCfgSetSGMIIRxConfig (0, rxConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetSGMIIRxConfig (Uint8 index, Uint32 rxConfig)
{
    if (index == 0)
        ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGRX0) = ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGRX0) & ~(0xFFFFFFFFu)) | (((rxConfig) << (0x00000000u)) & (0xFFFFFFFFu)));
    else
        ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGRX1) = ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGRX1) & ~(0xFFFFFFFFu)) | (((rxConfig) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSGMIITxConfig
 *
 *   @b Description
 *   @n The function is to used get the SGMII transmit configuration.
 *
 *   @b Arguments
     @verbatim
        index      - Index of the SGMII Transmit Configuration (0 or 1)
        txConfig   - SGMII Transmit configuration.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SGMII_CFGTX0_SGMII_TXCFG0;BOOTCFG_SGMII_CFGTX1_SGMII_TXCFG1
 *
 *   @b Example
 *   @verbatim

        Uint32  txConfig;

        // Get the SGMII Transmit Configuration
        CSL_BootCfgGetSGMIITxConfig (1, &txConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSGMIITxConfig (Uint8 index, Uint32* txConfig)
{
    if (index == 0)
        *txConfig = (((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGTX0) & (0xFFFFFFFFu)) >> (0x00000000u));
    else
        *txConfig = (((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGTX1) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetSGMIITxConfig
 *
 *   @b Description
 *   @n The function is to used set the SGMII transmit configuration.
 *
 *   @b Arguments
     @verbatim
        index      - Index of the SGMII Transmit Configuration (0 or 1)
        txConfig   - SGMII Transmit configuration.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SGMII_CFGTX0_SGMII_TXCFG0;BOOTCFG_SGMII_CFGTX1_SGMII_TXCFG1
 *
 *   @b Example
 *   @verbatim

        Uint32  txConfig;

        // Get the SGMII Transmit Configuration
        CSL_BootCfgGetSGMIITxConfig (1, &txConfig);

        // Enable the SGMII Transmit 
        txConfig = txConfig | 0x1;
        CSL_BootCfgSetSGMIITxConfig (1, txConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetSGMIITxConfig (Uint8 index, Uint32 txConfig)
{
    if (index == 0)
        ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGTX0) = ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGTX0) & ~(0xFFFFFFFFu)) | (((txConfig) << (0x00000000u)) & (0xFFFFFFFFu)));
    else
        ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGTX1) = ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_CFGTX1) & ~(0xFFFFFFFFu)) | (((txConfig) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSGMIIReserved
 *
 *   @b Description
 *   @n The function is to used get the SGMII reserved information
 *
 *   @b Arguments
     @verbatim
        rsvdInfo   - SGMII Reserved Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SGMII_RSVD_SGMII_RSVD
 *
 *   @b Example
 *   @verbatim

        Uint32  rsvdInfo;

        // Get the SGMII Reserved information
        CSL_BootCfgGetSGMIIReserved (&rsvdInfo);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSGMIIReserved (Uint32* rsvdInfo)
{
    *rsvdInfo = (((((CSL_BootcfgRegs*)(0x02620000))->SGMII_RSVD) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetSGMIIReserved
 *
 *   @b Description
 *   @n The function is to used set the SGMII reserved information
 *
 *   @b Arguments
     @verbatim
        rsvdInfo   - SGMII Reserved Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SGMII_RSVD_SGMII_RSVD
 *
 *   @b Example
 *   @verbatim

        Uint32  rsvdInfo;

        // Get the SGMII Reserved information
        CSL_BootCfgGetSGMIIReserved (&rsvdInfo);
        ...
        // Set the SGMII Reserved information
        CSL_BootCfgSetSGMIIReserved (rsvdInfo);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetSGMIIReserved (Uint32 rsvdInfo)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_RSVD) = ((((CSL_BootcfgRegs*)(0x02620000))->SGMII_RSVD) & ~(0xFFFFFFFFu)) | (((rsvdInfo) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetPCIEConfigPLL
 *
 *   @b Description
 *   @n The function is to used get the PCIE configuration PLL
 *
 *   @b Arguments
     @verbatim
        config   - PCIE Configuration PLL
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_PCIE_CFGPLL_PCIE_CFGPLL
 *
 *   @b Example
 *   @verbatim

        Uint16 config;

        // Get the PCIE Configuration PLL
        CSL_BootCfgGetPCIEConfigPLL (&config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetPCIEConfigPLL (Uint16* config)
{
    *config = (((((CSL_BootcfgRegs*)(0x02620000))->PCIE_CFGPLL) & (0x0000FFFFu)) >> (0x00000000u));
}
/** ============================================================================
 *   @n@b CSL_BootCfgSetPCIEMode
 *
 *   @b Description
 *   @n The function sets the PCIE mode which is latched at POR or RESETFULL.
 *      The PCIE can operate in three modes, End-point mode, Legacy End-point mode 
 *      or Root complex mode.
 *
 *   @b Arguments
     @verbatim
        PCIe Mode - can have one of the following values:
 *   @n 0x0 - PCIE in End-point mode
 *   @n 0x1 - PCIE in Legacy End-point mode
 *   @n 0x2 - PCIE in Root complex mode
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b  Writes
 *   @n  BOOTCFG_BOOT_REG0_PCIESS_MODE
 *
 *   @b Example
 *   @verbatim

        Uint8 pcieMode;

        // Set the PCIE-SS mode.
        CSL_BootCfgSetPCIEMode(pcieMode);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetPCIEMode (Uint8 pcieMode)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) = ((((CSL_BootcfgRegs*)(0x02620000))->BOOT_REG0) & ~(0x0000C000u)) | (((pcieMode) << (0x0000000Eu)) & (0x0000C000u)));
}


/** ============================================================================
 *   @n@b CSL_BootCfgGetPCIEPLLLock
 *
 *   @b Description
 *   @n The function is to used get the PCIE PLL Lock status
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n lock - Lock status
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_STS_PCIE_STS_LOCK
 *
 *   @b Example
 *   @verbatim

        Uint16 lock;

        // Get the PCIE PLL lock status
        CSL_BootCfgGetPCIEPLLLock(&lock);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetPCIEPLLLock (Uint16* lock)
{
    *lock = (((((CSL_BootcfgRegs*)(0x02620000))->STS_PCIE) & (0x00000001u)) >> (0x00000000u));
}


/** ============================================================================
 *   @n@b CSL_BootCfgSetPCIEConfigPLL
 *
 *   @b Description
 *   @n The function is to used set the PCIE configuration PLL
 *
 *   @b Arguments
     @verbatim
        config   - PCIE Configuration PLL
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_PCIE_CFGPLL_PCIE_CFGPLL
 *
 *   @b Example
 *   @verbatim

        Uint16 config;

        // Get the PCIE Configuration PLL
        CSL_BootCfgGetPCIEConfigPLL (&config);

        // Enable the PLL
        config = config | 0x1;
        CSL_BootCfgSetPCIEConfigPLL (config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetPCIEConfigPLL (Uint16 config)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->PCIE_CFGPLL) = ((((CSL_BootcfgRegs*)(0x02620000))->PCIE_CFGPLL) & ~(0x0000FFFFu)) | (((config) << (0x00000000u)) & (0x0000FFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSRIOSERDESConfigPLL
 *
 *   @b Description
 *   @n The function is to used get the SRIO SERDES configuration PLL
 *
 *   @b Arguments
     @verbatim
        config   - SRIO SERDES Configuration PLL
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SRIO_SERDES_CFGPLL_SRIO_SERDES_CFGPLL
 *
 *   @b Example
 *   @verbatim

        Uint16 config;

        // Get the SRIO SERDES Configuration PLL
        CSL_BootCfgGetSRIOSERDESConfigPLL (&config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSRIOSERDESConfigPLL (Uint16* config)
{
    *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGPLL) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetSRIOSERDESConfigPLL
 *
 *   @b Description
 *   @n The function is to used set the SRIO SERDES configuration PLL
 *
 *   @b Arguments
     @verbatim
        config   - SRIO SERDES Configuration PLL
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SRIO_SERDES_CFGPLL_SRIO_SERDES_CFGPLL
 *
 *   @b Example
 *   @verbatim

        Uint16 config;

        // Get the SRIO SERDES Configuration PLL
        CSL_BootCfgGetSRIOSERDESConfigPLL (&config);

        // Enable the SRIO SERDES PLL Configuration.
        config = config | 0x1;
        CSL_BootCfgSetSRIOSERDESConfigPLL (config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetSRIOSERDESConfigPLL (Uint16 config)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGPLL) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGPLL) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetPCIEReserved
 *
 *   @b Description
 *   @n The function is to used get the PCIE reserved information
 *
 *   @b Arguments
     @verbatim
        rsvdInfo   - PCIE Reserved Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_PCIE_SERDES_RSVD_PCIE_SERDES_RSVD
 *
 *   @b Example
 *   @verbatim

        Uint32  rsvdInfo;

        // Get the PCIE Reserved information
        CSL_BootCfgGetPCIEReserved (&rsvdInfo);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetPCIEReserved (Uint8* rsvdInfo)
{
    *rsvdInfo = (((((CSL_BootcfgRegs*)(0x02620000))->PCIE_SERDES_RSVD) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetPCIEReserved
 *
 *   @b Description
 *   @n The function is to used set the PCIE reserved information
 *
 *   @b Arguments
     @verbatim
        rsvdInfo   - PCIE Reserved Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_PCIE_SERDES_RSVD_PCIE_SERDES_RSVD
 *
 *   @b Example
 *   @verbatim

        Uint32  rsvdInfo;

        // Get the PCIE Reserved information
        CSL_BootCfgGetPCIEReserved (&rsvdInfo);
        ...
        // Set the PCIE Reserved information.
        CSL_BootCfgSetPCIEReserved (rsvdInfo);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetPCIEReserved (Uint8 rsvdInfo)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->PCIE_SERDES_RSVD) = ((((CSL_BootcfgRegs*)(0x02620000))->PCIE_SERDES_RSVD) & ~(0xFFFFFFFFu)) | (((rsvdInfo) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSRIOSERDESRxConfig
 *
 *   @b Description
 *   @n The function is to used get the SRIO SERDES receive configuration
 *
 *   @b Arguments
     @verbatim
        index    - Index of the SRIO SERDES to be configured (0-3)
        config   - SRIO SERDES Receive Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SRIO_SERDES_CFGRX0_SRIO_SERDES_CFGRX0;
 *   @n BOOTCFG_SRIO_SERDES_CFGRX1_SRIO_SERDES_CFGRX1;
 *   @n BOOTCFG_SRIO_SERDES_CFGRX2_SRIO_SERDES_CFGRX2;
 *   @n BOOTCFG_SRIO_SERDES_CFGRX3_SRIO_SERDES_CFGRX3
 *
 *   @b Example
 *   @verbatim

        Uint32 config;

        // Get the SRIO SERDES Receive Configuration
        CSL_BootCfgGetSRIOSERDESRxConfig (0, &config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSRIOSERDESRxConfig (Uint8 index, Uint32* config)
{
    if (index == 0)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX0) & (0xFFFFFFFFu)) >> (0x00000000u));
    else if (index == 1)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX1) & (0xFFFFFFFFu)) >> (0x00000000u));
    else if (index == 2)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX2) & (0xFFFFFFFFu)) >> (0x00000000u));
    else
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX3) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetSRIOSERDESRxConfig
 *
 *   @b Description
 *   @n The function is to used set the SRIO SERDES receive configuration
 *
 *   @b Arguments
     @verbatim
        index    - Index of the SRIO SERDES to be configured (0-3)
        config   - SRIO SERDES Receive Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SRIO_SERDES_CFGRX0_SRIO_SERDES_CFGRX0;
 *   @n BOOTCFG_SRIO_SERDES_CFGRX1_SRIO_SERDES_CFGRX1;
 *   @n BOOTCFG_SRIO_SERDES_CFGRX2_SRIO_SERDES_CFGRX2;
 *   @n BOOTCFG_SRIO_SERDES_CFGRX3_SRIO_SERDES_CFGRX3
 *
 *   @b Example
 *   @verbatim

        Uint32 config;

        // Get the SRIO SERDES Receive Configuration
        CSL_BootCfgGetSRIOSERDESRxConfig (1, &config);

        // Enable the SRIO SERDES Configuration
        config = config | 0x1;
        CSL_BootCfgSetSRIOSERDESRxConfig (1, config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetSRIOSERDESRxConfig (Uint8 index, Uint32 config)
{
    if (index == 0)
        ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX0) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX0) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else if (index == 1)
        ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX1) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX1) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else if (index == 2)
        ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX2) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX2) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else
        ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX3) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGRX3) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSRIOSERDESTxConfig
 *
 *   @b Description
 *   @n The function is to used get the SRIO SERDES transmit configuration
 *
 *   @b Arguments
     @verbatim
        index    - Index of the SRIO SERDES to be configured (0-3)
        config   - SRIO SERDES Transmit Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SRIO_SERDES_CFGTX0_SRIO_SERDES_CFGTX0;
 *   @n BOOTCFG_SRIO_SERDES_CFGTX1_SRIO_SERDES_CFGTX1;
 *   @n BOOTCFG_SRIO_SERDES_CFGTX2_SRIO_SERDES_CFGTX2;
 *   @n BOOTCFG_SRIO_SERDES_CFGTX3_SRIO_SERDES_CFGTX3
 *
 *   @b Example
 *   @verbatim

        Uint32 config;

        // Get the SRIO SERDES Transmit Configuration
        CSL_BootCfgGetSRIOSERDESTxConfig (0, &config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSRIOSERDESTxConfig (Uint8 index, Uint32* config)
{
    if (index == 0)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX0) & (0xFFFFFFFFu)) >> (0x00000000u));
    else if (index == 1)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX1) & (0xFFFFFFFFu)) >> (0x00000000u));
    else if (index == 2)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX2) & (0xFFFFFFFFu)) >> (0x00000000u));
    else
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX3) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetSRIOSERDESTxConfig
 *
 *   @b Description
 *   @n The function is to used set the SRIO SERDES transmit configuration
 *
 *   @b Arguments
     @verbatim
        index    - Index of the SRIO SERDES to be configured (0-3)
        config   - SRIO SERDES Transmit Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SRIO_SERDES_CFGTX0_SRIO_SERDES_CFGTX0;
 *   @n BOOTCFG_SRIO_SERDES_CFGTX1_SRIO_SERDES_CFGTX1;
 *   @n BOOTCFG_SRIO_SERDES_CFGTX2_SRIO_SERDES_CFGTX2;
 *   @n BOOTCFG_SRIO_SERDES_CFGTX3_SRIO_SERDES_CFGTX3
 *
 *   @b Example
 *   @verbatim

        Uint32 config;

        // Set the SRIO SERDES Transmit Configuration
        CSL_BootCfgSetSRIOSERDESTxConfig (0, &config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetSRIOSERDESTxConfig (Uint8 index, Uint32 config)
{
    if (index == 0)
        ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX0) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX0) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else if (index == 1)
        ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX1) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX1) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else if (index == 2)
        ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX2) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX2) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else
        ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX3) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_CFGTX3) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetSRIOSERDESReserved
 *
 *   @b Description
 *   @n The function is to used get the SRIO SERDES reserved information. All the 
 *   reserved bits of cfgrxi[] and cfgtxi[] port of the SerDes interface 
 *   are mapped to the chip-level SERDES_RSVD registers. Only one 
 *   SERDES_RSVD register is allocated per peripheral irrespective of the number 
 *   of lanes. In case of peripheral with multiplelanes, the SERDES_RSVD register 
 *   will be broadcast to all lanes.
 *
 *   @b Arguments
     @verbatim
        rsvdInfo   - SRIO SERDES Reserved information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SRIO_SERDES_RSVD_SRIO_SERDES_RSVD
 *
 *   @b Example
 *   @verbatim

        Uint32 rsvdInfo;

        // Get the SRIO SERDES Reserved Information.
        CSL_BootCfgGetSRIOSERDESReserved (&rsvdInfo);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetSRIOSERDESReserved (Uint32* rsvdInfo)
{
    *rsvdInfo = (((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_RSVD) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetSRIOSERDESReserved
 *
 *   @b Description
 *   @n The function is to used set the SRIO SERDES reserved information.
 *
 *   @b Arguments
     @verbatim
        rsvdInfo   - SRIO SERDES Reserved information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SRIO_SERDES_RSVD_SRIO_SERDES_RSVD
 *
 *   @b Example
 *   @verbatim

        Uint32 rsvdInfo;

        // Get the SRIO SERDES Reserved Information.
        CSL_BootCfgGetSRIOSERDESReserved (&rsvdInfo);
        ...
        // Set the SRIO SERDES Reserved Information.
        CSL_BootCfgSetSRIOSERDESReserved(rsvdInfo);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetSRIOSERDESReserved (Uint32 rsvdInfo)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_RSVD) = ((((CSL_BootcfgRegs*)(0x02620000))->SRIO_SERDES_RSVD) & ~(0xFFFFFFFFu)) | (((rsvdInfo) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetLEDPassDoneStatus
 *
 *   @b Description
 *   @n The function is used to get the LED pass done status for a specific core
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Index of the core for which the status is required.
        pass        - Pass Status Flag
        done        - Done Status Flag
        idle        - Idle Status Flag
        waitLoop    - Function Wait Loop Flag
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_LED_GEM_PASSDONE_P0,BOOTCFG_LED_GEM_PASSDONE_D0,
 *   @n BOOTCFG_LED_GEM_PASSDONE_I0,BOOTCFG_LED_GEM_PASSDONE_L0;
 *   @n BOOTCFG_LED_GEM_PASSDONE_P1,BOOTCFG_LED_GEM_PASSDONE_D1,
 *   @n BOOTCFG_LED_GEM_PASSDONE_I1,BOOTCFG_LED_GEM_PASSDONE_L1;
 *   @n ...;
 *   @n BOOTCFG_LED_GEM_PASSDONE_P3,BOOTCFG_LED_GEM_PASSDONE_D7,
 *   @n BOOTCFG_LED_GEM_PASSDONE_I3,BOOTCFG_LED_GEM_PASSDONE_L7;
 *
 *   @b Example
 *   @verbatim

        Uint8  pass, 
        Uint8  done, 
        Uint8  idle, 
        Uint8  waitLoop

        // Get the LED Pass Done Status for Core 1
        CSL_BootCfgGetLEDPassDoneStatus (1, &pass, &done, &idle, &waitLoop);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetLEDPassDoneStatus 
(
    Uint8   coreIdx, 
    Uint8*  pass, 
    Uint8*  done, 
    Uint8*  idle, 
    Uint8*  waitLoop
)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE; 

    if (coreIdx == 0)
    {
        *pass     = (((value) & (0x00000001u)) >> (0x00000000u));
        *done     = (((value) & (0x00000002u)) >> (0x00000001u));
        *idle     = (((value) & (0x00000004u)) >> (0x00000002u));
        *waitLoop = (((value) & (0x00000008u)) >> (0x00000003u));
    }else if (coreIdx == 1)
    {
        *pass     = (((value) & (0x00000010u)) >> (0x00000004u));
        *done     = (((value) & (0x00000020u)) >> (0x00000005u));
        *idle     = (((value) & (0x00000040u)) >> (0x00000006u));
        *waitLoop = (((value) & (0x00000080u)) >> (0x00000007u));
    }else if (coreIdx == 2)
    {
        *pass     = (((value) & (0x00000100u)) >> (0x00000008u));
        *done     = (((value) & (0x00000200u)) >> (0x00000009u));
        *idle     = (((value) & (0x00000400u)) >> (0x0000000Au));
        *waitLoop = (((value) & (0x00000800u)) >> (0x0000000Bu));
    }else if (coreIdx == 3)
    {
        *pass     = (((value) & (0x00001000u)) >> (0x0000000Cu));
        *done     = (((value) & (0x00002000u)) >> (0x0000000Du));
        *idle     = (((value) & (0x00004000u)) >> (0x0000000Eu));
        *waitLoop = (((value) & (0x00008000u)) >> (0x0000000Fu));
    }else if (coreIdx == 4)
    {
        *pass     = (((value) & (0x00010000u)) >> (0x00000010u));
        *done     = (((value) & (0x00020000u)) >> (0x00000011u));
        *idle     = (((value) & (0x00040000u)) >> (0x00000012u));
        *waitLoop = (((value) & (0x00080000u)) >> (0x00000013u));
    }else if (coreIdx == 5)
    {
        *pass     = (((value) & (0x00100000u)) >> (0x00000014u));
        *done     = (((value) & (0x00200000u)) >> (0x00000015u));
        *idle     = (((value) & (0x00400000u)) >> (0x00000016u));
        *waitLoop = (((value) & (0x00800000u)) >> (0x00000017u));
    }else if (coreIdx == 6)
    {
        *pass     = (((value) & (0x01000000u)) >> (0x00000018u));
        *done     = (((value) & (0x02000000u)) >> (0x00000019u));
        *idle     = (((value) & (0x04000000u)) >> (0x0000001Au));
        *waitLoop = (((value) & (0x08000000u)) >> (0x0000001Bu));
    }else
    {
        *pass     = (((value) & (0x10000000u)) >> (0x0000001Cu));
        *done     = (((value) & (0x20000000u)) >> (0x0000001Du));
        *idle     = (((value) & (0x40000000u)) >> (0x0000001Eu));
        *waitLoop = (((value) & (0x80000000u)) >> (0x0000001Fu));
    }
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetLEDPassDoneStatus
 *
 *   @b Description
 *   @n The function is used to set the LED pass done status for a specific core
 *
 *   @b Arguments
     @verbatim
        coreIdx     - Index of the core for which the status is required.
        pass        - Pass Status Flag
        done        - Done Status Flag
        idle        - Idle Status Flag
        waitLoop    - Function Wait Loop Flag
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_LED_GEM_PASSDONE_P0,BOOTCFG_LED_GEM_PASSDONE_D0,
 *   @n BOOTCFG_LED_GEM_PASSDONE_I0,BOOTCFG_LED_GEM_PASSDONE_L0;
 *   @n BOOTCFG_LED_GEM_PASSDONE_P1,BOOTCFG_LED_GEM_PASSDONE_D1,
 *   @n BOOTCFG_LED_GEM_PASSDONE_I1,BOOTCFG_LED_GEM_PASSDONE_L1;
 *   @n ...;
 *   @n BOOTCFG_LED_GEM_PASSDONE_P3,BOOTCFG_LED_GEM_PASSDONE_D7,
 *   @n BOOTCFG_LED_GEM_PASSDONE_I3,BOOTCFG_LED_GEM_PASSDONE_L7;
 *
 *   @b Example
 *   @verbatim

        Uint8  pass, 
        Uint8  done, 
        Uint8  idle, 
        Uint8  waitLoop

        // Get the LED Pass Done Status for Core 0
        CSL_BootCfgGetLEDPassDoneStatus (0, &pass, &done, &idle, &waitLoop);
        ...
        // Set the PASS Flag for core 0
        CSL_BootCfgSetLEDPassDoneStatus(0, 1, done, idle, waitLoop);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetLEDPassDoneStatus 
(
    Uint8  coreIdx, 
    Uint8  pass, 
    Uint8  done, 
    Uint8  idle, 
    Uint8  waitLoop
)
{
    if (coreIdx == 0)
    {
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000001u)) | (((pass) << (0x00000000u)) & (0x00000001u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000002u)) | (((done) << (0x00000001u)) & (0x00000002u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000004u)) | (((idle) << (0x00000002u)) & (0x00000004u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000008u)) | (((waitLoop) << (0x00000003u)) & (0x00000008u)));
    }else if (coreIdx == 1)
    {
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000010u)) | (((pass) << (0x00000004u)) & (0x00000010u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000020u)) | (((done) << (0x00000005u)) & (0x00000020u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000040u)) | (((idle) << (0x00000006u)) & (0x00000040u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000080u)) | (((waitLoop) << (0x00000007u)) & (0x00000080u)));
    }else if (coreIdx == 2)
    {
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000100u)) | (((pass) << (0x00000008u)) & (0x00000100u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000200u)) | (((done) << (0x00000009u)) & (0x00000200u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000400u)) | (((idle) << (0x0000000Au)) & (0x00000400u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00000800u)) | (((waitLoop) << (0x0000000Bu)) & (0x00000800u)));
    }else if (coreIdx == 3)
    {
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00001000u)) | (((pass) << (0x0000000Cu)) & (0x00001000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00002000u)) | (((done) << (0x0000000Du)) & (0x00002000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00004000u)) | (((idle) << (0x0000000Eu)) & (0x00004000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00008000u)) | (((waitLoop) << (0x0000000Fu)) & (0x00008000u)));
    }else if (coreIdx == 4)
    {
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00010000u)) | (((pass) << (0x00000010u)) & (0x00010000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00020000u)) | (((done) << (0x00000011u)) & (0x00020000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00040000u)) | (((idle) << (0x00000012u)) & (0x00040000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00080000u)) | (((waitLoop) << (0x00000013u)) & (0x00080000u)));
    }else if (coreIdx == 5)
    {
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00100000u)) | (((pass) << (0x00000014u)) & (0x00100000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00200000u)) | (((done) << (0x00000015u)) & (0x00200000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00400000u)) | (((idle) << (0x00000016u)) & (0x00400000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x00800000u)) | (((waitLoop) << (0x00000017u)) & (0x00800000u)));
    }else if (coreIdx == 6)
    {
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x01000000u)) | (((pass) << (0x00000018u)) & (0x01000000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x02000000u)) | (((done) << (0x00000019u)) & (0x02000000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x04000000u)) | (((idle) << (0x0000001Au)) & (0x04000000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x08000000u)) | (((waitLoop) << (0x0000001Bu)) & (0x08000000u)));
    }else
    {
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x10000000u)) | (((pass) << (0x0000001Cu)) & (0x10000000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x20000000u)) | (((done) << (0x0000001Du)) & (0x20000000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x40000000u)) | (((idle) << (0x0000001Eu)) & (0x40000000u)));
        ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_GEM_PASSDONE) & ~(0x80000000u)) | (((waitLoop) << (0x0000001Fu)) & (0x80000000u)));
    }
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsLEDPLLLocked
 *
 *   @b Description
 *   @n The function is to used check if the LED PLL is locked or not?
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - LED PLL Locked
 *   @n FALSE - LED PLL is not Locked
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_LED_PLLLOCK_PLLLOCK
 *
 *   @b Example
 *   @verbatim

        // Is the LED PLL Locked or not?
        if (CSL_BootCfgIsLEDPLLLocked () == TRUE)
        {
            // LED PLL is locked
        }
        else
        {
            // LED PLL is not locked.
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsLEDPLLLocked (void)
{
    return (Bool)(((((CSL_BootcfgRegs*)(0x02620000))->LED_PLLLOCK) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgLockLEDPLL
 *
 *   @b Description
 *   @n The function is to used lock the LED PLL
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_LED_PLLLOCK_STICKY_EN_LOCK=1
 *
 *   @b Example
 *   @verbatim

        // Lock the LED PLL 
        CSL_BootCfgLockLEDPLL();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgLockLEDPLL (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->LED_PLLLOCK) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_PLLLOCK) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgUnlockLEDPLL
 *
 *   @b Description
 *   @n The function is to used unlock the LED PLL
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_LED_PLLLOCK_STICKY_EN_LOCK=0
 *
 *   @b Example
 *   @verbatim

        // Lock the LED PLL 
        CSL_BootCfgLockLEDPLL();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgUnlockLEDPLL (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->LED_PLLLOCK) = ((((CSL_BootcfgRegs*)(0x02620000))->LED_PLLLOCK) & ~(0x00000002u)) | (((0) << (0x00000001u)) & (0x00000002u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetLEDChipPassDoneStatus
 *
 *   @b Description
 *   @n The function is to used to get the LED Chip Pass Done Status
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_LED_CHIP_PASSDONE_CHIP_PASS,BOOTCFG_LED_CHIP_PASSDONE_CHIP_DONE
 *
 *   @b Example
 *   @verbatim

        Uint8   pass;
        Uint8   done;

        // Get the LED Chip Pass Done 
        CSL_BootCfgGetLEDChipPassDoneStatus(&pass, &done);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetLEDChipPassDoneStatus (Uint8* pass, Uint8* done)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->LED_CHIP_PASSDONE;

    *pass = (((value) & (0x00000001u)) >> (0x00000000u));
    *done = (((value) & (0x00000002u)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetLEDChipPassDoneStatus
 *
 *   @b Description
 *   @n The function is to used to set the LED Chip Pass Done Status
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_LED_CHIP_PASSDONE_CHIP_PASS,BOOTCFG_LED_CHIP_PASSDONE_CHIP_DONE
 *
 *   @b Example
 *   @verbatim

        // Set the LED Chip Pass Done flags 
        CSL_BootCfgSetLEDChipPassDoneStatus(1, 1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetLEDChipPassDoneStatus (Uint8 pass, Uint8 done)
{
    ((CSL_BootcfgRegs*)(0x02620000))->LED_CHIP_PASSDONE = (((pass) << (0x00000000u)) & (0x00000001u)) | 
                                  (((done) << (0x00000001u)) & (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetDeviceSecureControl
 *
 *   @b Description
 *   @n The function is to used to get the device secure control
 *
 *   @b Arguments
     @verbatim
        vusrSecEnStatus     - VUSR Secure Enable Status
        pbistSecEnStatus    - PBIST Secure Enable Status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_SECURE_CONTROL_VUSR_SEC_EN,BOOTCFG_SECURE_CONTROL_PBIST_SECURE_EN
 *
 *   @b Example
 *   @verbatim

        Uint8   vusrSecEnStatus;
        Uint8   pbistSecEnStatus;

        // Get the Secure Control
        CSL_BootCfgGetDeviceSecureControl(&vusrSecEnStatus, &pbistSecEnStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetDeviceSecureControl (Uint8* vusrSecEnStatus, Uint8* pbistSecEnStatus)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->SECURE_CONTROL;

    *vusrSecEnStatus = (((value) & (0x00000002u)) >> (0x00000001u));
    *pbistSecEnStatus= (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetDeviceSecureControl
 *
 *   @b Description
 *   @n The function is to used to set the device secure control. This API can
 *      only be called from a secure master
 *
 *   @b Arguments
     @verbatim
        vusrSecEnStatus     - VUSR Secure Enable Status
        pbistSecEnStatus    - PBIST Secure Enable Status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_SECURE_CONTROL_VUSR_SEC_EN,BOOTCFG_SECURE_CONTROL_PBIST_SECURE_EN
 *
 *   @b Example
 *   @verbatim

        Uint8   vusrSecEnStatus;
        Uint8   pbistSecEnStatus;

        // Get the Secure Control
        CSL_BootCfgGetDeviceSecureControl(&vusrSecEnStatus, &pbistSecEnStatus);

        // Set the secure control.
        CSL_BootCfgSetDeviceSecureControl(1, pbistSecEnStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetDeviceSecureControl (Uint8 vusrSecEnStatus, Uint8 pbistSecEnStatus)
{
    ((CSL_BootcfgRegs*)(0x02620000))->SECURE_CONTROL = (((vusrSecEnStatus) << (0x00000001u)) & (0x00000002u))     |
                               (((pbistSecEnStatus) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetROMChecksum
 *
 *   @b Description
 *   @n The function is to used to get the ROM checksum
 *
 *   @b Arguments
     @verbatim
        romLSBChecksum     - LSB of 64-bit ROM Checksum
        romMSBChecksum     - MSB of 64-bit ROM Checksum
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_EFUSE_SECROM_CHKSUM0,BOOTCFG_EFUSE_SECROM_CHKSUM1
 *
 *   @b Example
 *   @verbatim

        Uint32   romLSBChecksum;
        Uint32   romMSBChecksum;

        // Get the ROM Checksum
        CSL_BootCfgGetROMChecksum(&romLSBChecksum, &romMSBChecksum);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetROMChecksum (Uint32* romLSBChecksum, Uint32* romMSBChecksum)
{
    *romLSBChecksum = ((CSL_BootcfgRegs*)(0x02620000))->EFUSE_SECROM_CHKSUM0;
    *romMSBChecksum = ((CSL_BootcfgRegs*)(0x02620000))->EFUSE_SECROM_CHKSUM1;
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetCorePLLObservationClockControl
 *
 *   @b Description
 *   @n The function is to used to get the core PLL observation clock control
 *
 *   @b Arguments
     @verbatim
        selection - Controls which clock is output
        enable    - Status of the Core PLL IO Clock buffer.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_OBSCLK_CTL_CORE_PLL_OBSCLK_SEL,BOOTCFG_OBSCLK_CTL_CORE_PLL_OBSCLK_EN
 *
 *   @b Example
 *   @verbatim

        Uint8   selection;
        Uint8   enable;

        // Get the Core PLL Observation Clock Control 
        CSL_BootCfgGetCorePLLObservationClockControl(&selection, &enable);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetCorePLLObservationClockControl 
(
    Uint8* selection, 
    Uint8* enable
)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL;

    *selection = (((value) & (0x00000001u)) >> (0x00000000u));
    *enable    = (((value) & (0x00000002u)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetCorePLLObservationClockControl
 *
 *   @b Description
 *   @n The function is to used to set the core PLL observation clock control
 *
 *   @b Arguments
     @verbatim
        selection - Controls which clock is output
        enable    - Status of the Core PLL IO Clock buffer.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_OBSCLK_CTL_CORE_PLL_OBSCLK_SEL,BOOTCFG_OBSCLK_CTL_CORE_PLL_OBSCLK_EN
 *
 *   @b Example
 *   @verbatim

        Uint8   selection;
        Uint8   enable;

        // Get the Core PLL Observation Clock Control 
        CSL_BootCfgGetCorePLLObservationClockControl(&selection, &enable);
        
        // IO Clock buffer is enabled.
        CSL_BootCfgSetCorePLLObservationClockControl(selection, 1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetCorePLLObservationClockControl 
(
    Uint8 selection, 
    Uint8 enable
)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) = ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & ~(0x00000001u)) | (((selection) << (0x00000000u)) & (0x00000001u)));
    ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) = ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & ~(0x00000002u)) | (((enable) << (0x00000001u)) & (0x00000002u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetDDR3PLLObservationClockControl
 *
 *   @b Description
 *   @n The function is to used to get the DDR3 PLL observation clock control
 *
 *   @b Arguments
     @verbatim
        selection - Controls which clock is output
        enable    - Status of the DDR3 PLL IO Clock buffer.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_OBSCLK_CTL_DDR3_PLL_OBSCLK_SEL,BOOTCFG_OBSCLK_CTL_DDR3_PLL_OBSCLK_EN
 *
 *   @b Example
 *   @verbatim

        Uint8   selection;
        Uint8   enable;

        // Get the DDR3 PLL Observation Clock Control 
        CSL_BootCfgGetDDR3PLLObservationClockControl(&selection, &enable);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetDDR3PLLObservationClockControl 
(
    Uint8* selection, 
    Uint8* enable
)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL;

    *selection = (((value) & (0x00000004u)) >> (0x00000002u));
    *enable    = (((value) & (0x00000008u)) >> (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetDDR3PLLObservationClockControl
 *
 *   @b Description
 *   @n The function is to used to set the DDR3 PLL observation clock control
 *
 *   @b Arguments
     @verbatim
        selection - Controls which clock is output
        enable    - Status of the DDR3 PLL IO Clock buffer.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_OBSCLK_CTL_DDR3_PLL_OBSCLK_SEL,BOOTCFG_OBSCLK_CTL_DDR3_PLL_OBSCLK_EN
 *
 *   @b Example
 *   @verbatim

        Uint8   selection;
        Uint8   enable;

        // Get the DDR3 PLL Observation Clock Control 
        CSL_BootCfgGetDDR3PLLObservationClockControl(&selection, &enable);

        // DDR3 IO Clock Buffer is disabled.
        CSL_BootCfgSetDDR3PLLObservationClockControl(selection, 0);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetDDR3PLLObservationClockControl 
(
    Uint8 selection, 
    Uint8 enable
)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) = ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & ~(0x00000004u)) | (((selection) << (0x00000002u)) & (0x00000004u)));
    ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) = ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & ~(0x00000008u)) | (((enable) << (0x00000003u)) & (0x00000008u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetPAPLLObservationClockControl
 *
 *   @b Description
 *   @n The function is to used to get the PA PLL observation clock control
 *
 *   @b Arguments
     @verbatim
        selection - Controls which clock is output
        enable    - Status of the PA PLL IO Clock buffer.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_OBSCLK_CTL_PA_PLL_OBSCLK_SEL,BOOTCFG_OBSCLK_CTL_PA_PLL_OBSCLK_EN
 *
 *   @b Example
 *   @verbatim

        Uint8   selection;
        Uint8   enable;

        // Get the PA PLL Observation Clock Control 
        CSL_BootCfgGetPAPLLObservationClockControl(&selection, &enable);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetPAPLLObservationClockControl 
(
    Uint8* selection, 
    Uint8* enable
)
{
    Uint32 value = ((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL;

    *selection = (((value) & (0x00000010u)) >> (0x00000004u));
    *enable    = (((value) & (0x00000020u)) >> (0x00000005u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetPAPLLObservationClockControl
 *
 *   @b Description
 *   @n The function is to used to set the PA PLL observation clock control
 *
 *   @b Arguments
     @verbatim
        selection - Controls which clock is output
        enable    - Status of the PA PLL IO Clock buffer.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_OBSCLK_CTL_PA_PLL_OBSCLK_SEL,BOOTCFG_OBSCLK_CTL_PA_PLL_OBSCLK_EN
 *
 *   @b Example
 *   @verbatim

        Uint8   selection;
        Uint8   enable;

        // Get the PA PLL Observation Clock Control 
        CSL_BootCfgGetPAPLLObservationClockControl(&selection, &enable);

        // PA IO Clock Buffer is disabled.
        CSL_BootCfgSetPAPLLObservationClockControl(selection, 0);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetPAPLLObservationClockControl 
(
    Uint8 selection, 
    Uint8 enable
)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) = ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & ~(0x00000010u)) | (((selection) << (0x00000004u)) & (0x00000010u)));
    ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) = ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & ~(0x00000020u)) | (((enable) << (0x00000005u)) & (0x00000020u)));
}


/** ============================================================================
 *   @n@b CSL_BootCfgIsPSCEMIF4FResetEnabled
 *
 *   @b Description
 *   @n The function is to used to get the status of PSC EMIF4F Reset Enable bit
 *      in the Observation Clock Control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_OBSCLK_CTL_PSC_EMIF4F_RST_EN
 *
 *   @b Example
 *   @verbatim

        // Get the PSC EMIF4F Reset enable bit status
        if (CSL_BootCfgIsPSCEMIF4FResetEnabled() == TRUE)
        {
            // EMIF4F/DDR3 can be reset separately from rest of the chip.
        }
        else
        {
            // EMIF4F Reset disabled.
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsPSCEMIF4FResetEnabled (void)
{
    return (((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & (0x00000040u)) >> (0x00000006u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgEnablePSCEMIF4FReset
 *
 *   @b Description
 *   @n The function enables the PSC EMIF4F Reset Enable bit
 *      in the Observation Clock Control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_OBSCLK_CTL_PSC_EMIF4F_RST_EN=1
 *
 *   @b Example
 *   @verbatim

        // Enable PSC EMIF4 Reset Enable bit
        CSL_BootCfgEnablePSCEMIF4FReset();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgEnablePSCEMIF4FReset (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) = ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & ~(0x00000040u)) | (((1) << (0x00000006u)) & (0x00000040u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgDisablePSCEMIF4FReset
 *
 *   @b Description
 *   @n The function disables the PSC EMIF4F Reset Enable bit
 *      in the Observation Clock Control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_OBSCLK_CTL_PSC_EMIF4F_RST_EN=0
 *
 *   @b Example
 *   @verbatim

        // Disable PSC EMIF4 Reset Enable bit
        CSL_BootCfgEnablePSCEMIF4FReset();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgDisablePSCEMIF4FReset (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) = ((((CSL_BootcfgRegs*)(0x02620000))->OBSCLK_CTL) & ~(0x00000040u)) | (((0) << (0x00000006u)) & (0x00000040u)));
}


/** ============================================================================
 *   @n@b CSL_BootCfgGetVUSRConfigPLL
 *
 *   @b Description
 *   @n The function is to used to get the VUSR Configuration PLL 
 *
 *   @b Arguments
     @verbatim
        config   - VUSR Configuration PLL
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_VUSR_CFGPLL_VUSR_CFGPLL
 *
 *   @b Example
 *   @verbatim

        Uint16   config;

        // Get the VUSR Configuration PLL
        CSL_BootCfgGetVUSRConfigPLL(&config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetVUSRConfigPLL (Uint16* config)
{
    *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGPLL) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetVUSRConfigPLL
 *
 *   @b Description
 *   @n The function is to used to set the VUSR Configuration PLL 
 *
 *   @b Arguments
     @verbatim
        config   - VUSR Configuration PLL
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_VUSR_CFGPLL_VUSR_CFGPLL
 *
 *   @b Example
 *   @verbatim

        Uint16   config;

        // Get the VUSR Configuration PLL
        CSL_BootCfgGetVUSRConfigPLL(&config);
        ...
        // Enable the PLL
        config = config | 0x1;
        CSL_BootCfgSetVUSRConfigPLL (config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetVUSRConfigPLL (Uint16 config)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGPLL) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGPLL) & ~(0x0000FFFFu)) | (((config) << (0x00000000u)) & (0x0000FFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetVUSRRxConfig
 *
 *   @b Description
 *   @n The function is to used to get the VUSR Receive Configuration
 *
 *   @b Arguments
     @verbatim
        index    - Index of the VUSR Receive Configuration (0 - 3)
        config   - VUSR Receive Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_VUSR_CFGRX0_VUSR_CFGRX0;BOOTCFG_VUSR_CFGRX1_VUSR_CFGRX1;
 *   @n BOOTCFG_VUSR_CFGRX2_VUSR_CFGRX2;BOOTCFG_VUSR_CFGRX1_VUSR_CFGRX3
 *
 *   @b Example
 *   @verbatim

        Uint32   rxConfig;

        // Get the VUSR 0 Receive Configuration PLL
        CSL_BootCfgGetVUSRRxConfig(0, &rxConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetVUSRRxConfig (Uint8 index, Uint32* config)
{
    if (index == 0)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX0) & (0xFFFFFFFFu)) >> (0x00000000u));
    else if (index == 1)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX1) & (0xFFFFFFFFu)) >> (0x00000000u));
    else if (index == 2)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX2) & (0xFFFFFFFFu)) >> (0x00000000u));
    else 
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX3) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetVUSRRxConfig
 *
 *   @b Description
 *   @n The function is to used to set the VUSR Receive Configuration
 *
 *   @b Arguments
     @verbatim
        index    - Index of the VUSR Receive Configuration (0 - 3)
        config   - VUSR Receive Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_VUSR_CFGRX0_VUSR_CFGRX0;BOOTCFG_VUSR_CFGRX1_VUSR_CFGRX1;
 *   @n BOOTCFG_VUSR_CFGRX2_VUSR_CFGRX2;BOOTCFG_VUSR_CFGRX1_VUSR_CFGRX3
 *
 *   @b Example
 *   @verbatim

        Uint32   rxConfig;

        // Get the VUSR 0 Receive Configuration PLL
        CSL_BootCfgGetVUSRRxConfig(0, &rxConfig);
        ...
        // Enable the Receive
        rxConfig = rxConfig | 0x1;
        CSL_BootCfgSetVUSRRxConfig (0, rxConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetVUSRRxConfig (Uint8 index, Uint32 config)
{
    if (index == 0)
        ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX0) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX0) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else if (index == 1)
        ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX1) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX1) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else if (index == 2)
        ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX2) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX2) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else 
        ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX3) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGRX3) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetVUSRTxConfig
 *
 *   @b Description
 *   @n The function is to used to get the VUSR Transmit Configuration
 *
 *   @b Arguments
     @verbatim
        index    - Index of the VUSR Transmit Configuration (0 - 3)
        config   - VUSR Transmit Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_VUSR_CFGTX0_VUSR_CFGTX0;BOOTCFG_VUSR_CFGTX1_VUSR_CFGTX1;
 *   @n BOOTCFG_VUSR_CFGTX2_VUSR_CFGTX2;BOOTCFG_VUSR_CFGTX3_VUSR_CFGTX3
 *
 *   @b Example
 *   @verbatim

        Uint32   txConfig;

        // Get the VUSR 0 Transmit Configuration PLL
        CSL_BootCfgGetVUSRTxConfig(0, &txConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetVUSRTxConfig (Uint8 index, Uint32* config)
{
    if (index == 0)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX0) & (0xFFFFFFFFu)) >> (0x00000000u));
    else if (index == 1)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX1) & (0xFFFFFFFFu)) >> (0x00000000u));
    else if (index == 2)
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX2) & (0xFFFFFFFFu)) >> (0x00000000u));
    else 
        *config = (((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX3) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetVUSRTxConfig
 *
 *   @b Description
 *   @n The function is to used to set the VUSR Transmit Configuration
 *
 *   @b Arguments
     @verbatim
        index    - Index of the VUSR Transmit Configuration (0 - 3)
        config   - VUSR Transmit Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_VUSR_CFGTX0_VUSR_CFGTX0;BOOTCFG_VUSR_CFGTX1_VUSR_CFGTX1;
 *   @n BOOTCFG_VUSR_CFGTX2_VUSR_CFGTX2;BOOTCFG_VUSR_CFGTX3_VUSR_CFGTX3
 *
 *   @b Example
 *   @verbatim

        Uint32   txConfig;

        // Get the VUSR 0 Transmit Configuration PLL
        CSL_BootCfgGetVUSRTxConfig(0, &txConfig);

        // Enable the Transmit 
        txConfig = txConfig | 0x1;
        CSL_BootCfgSetVUSRTxConfig(0, txConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetVUSRTxConfig (Uint8 index, Uint32 config)
{
    if (index == 0)
        ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX0) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX0) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else if (index == 1)
        ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX1) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX1) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else if (index == 2)
        ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX2) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX2) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
    else 
        ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX3) = ((((CSL_BootcfgRegs*)(0x02620000))->VUSR_CFGTX3) & ~(0xFFFFFFFFu)) | (((config) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetVUSRReserved
 *
 *   @b Description
 *   @n The function is to used to get the VUSR Reserved information
 *
 *   @b Arguments
     @verbatim
        rsvdInfo   - VUSR Reserved Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_VUSR_SERDES_RSVD
 *
 *   @b Example
 *   @verbatim

        Uint32   rsvdInfo;

        // Get the VUSR Reserved Information
        CSL_BootCfgGetVUSRReserved(&rsvdInfo);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetVUSRReserved (Uint32* rsvdInfo)
{
    *rsvdInfo = ((CSL_BootcfgRegs*)(0x02620000))->VUSR_SERDES_RSVD;
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetVUSRReserved
 *
 *   @b Description
 *   @n The function is to used to set the VUSR Reserved information
 *
 *   @b Arguments
     @verbatim
        rsvdInfo   - VUSR Reserved Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_VUSR_SERDES_RSVD
 *
 *   @b Example
 *   @verbatim

        Uint32   rsvdInfo;

        // Get the VUSR Reserved Information
        CSL_BootCfgGetVUSRReserved(&rsvdInfo);
        ...
        // Set the VUSR reserved informatio
        CSL_BootCfgSetVUSRReserved(rsvdInfo);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetVUSRReserved (Uint32 rsvdInfo)
{
    ((CSL_BootcfgRegs*)(0x02620000))->VUSR_SERDES_RSVD = rsvdInfo;
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetQMPriority
 *
 *   @b Description
 *   @n The function is to used to get QM Master port transactions priority.
 *
 *   @b Arguments
     @verbatim
        qmprio  -   QM Master port transaction priority read.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_QM_PRIOR
 *
 *   @b Example
 *   @verbatim

        Uint8   qmprio;

        // Get the QM Priority from Chip Misc Control register
        CSL_BootCfgGetQMPriority(&qmprio);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetQMPriority 
(
    Uint8* qmprio
)
{
    *qmprio = (((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetQMPriority
 *
 *   @b Description
 *   @n The function is to used to set up QM Master port transactions priority.
 *
 *   @b Arguments
     @verbatim
        qmprio  -   QM Master port transaction priority to configure.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_QM_PRIOR
 *
 *   @b Example
 *   @verbatim

        Uint8   qmprio = 1;

        // Set the QM Priority in Chip Misc Control register
        CSL_BootCfgSetQMPriority(qmprio);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetQMPriority(Uint8 qmprio)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) = ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & ~(0x00000007u)) | (((qmprio) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetGEML2ReadLatency
 *
 *   @b Description
 *   @n The function is to used to get GEM L2's memory read latency.
 *
 *   @b Arguments
     @verbatim
        latency  -   GEM L2 memory read latency
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_GEM_L2RDLAT
 *
 *   @b Example
 *   @verbatim

        Uint8   latency;

        // Get the GEM L2 Read latency from Chip Misc Control register
        CSL_BootCfgGetGEML2ReadLatency(&latency);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetGEML2ReadLatency 
(
    Uint8* latency
)
{
    *latency = (((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & (0x00000078u)) >> (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetGEML2ReadLatency
 *
 *   @b Description
 *   @n The function is to used to set up GEM L2 memory read latency.
 *
 *   @b Arguments
     @verbatim
        latency  -   GEM L2 memory read latency to configure.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_GEM_L2RDLAT
 *
 *   @b Example
 *   @verbatim

        Uint8   latency = 1;

        // Set the GEM L2 Read latency in Chip Misc Control register
        CSL_BootCfgSetGEML2ReadLatency(latency);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetGEML2ReadLatency 
(
    Uint8   latency
)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) = ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & ~(0x00000078u)) | (((latency) << (0x00000003u)) & (0x00000078u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetGEML2AccessLatency
 *
 *   @b Description
 *   @n The function is to used to get GEM L2's memory access latency.
 *
 *   @b Arguments
     @verbatim
        latency  -   GEM L2 memory access latency
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_GEM_L2ACS_LAT
 *
 *   @b Example
 *   @verbatim

        Uint8   latency;

        // Get the GEM L2 Access latency from Chip Misc Control register
        CSL_BootCfgGetGEML2AccessLatency(&latency);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetGEML2AccessLatency 
(
    Uint8* latency
)
{
    *latency = (((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & (0x00000780u)) >> (0x00000007u));
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetGEML2AccessLatency
 *
 *   @b Description
 *   @n The function is to used to set up GEM L2 memory access latency.
 *
 *   @b Arguments
     @verbatim
        latency  -   GEM L2 memory access latency to configure.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_GEM_L2ACS_LAT
 *
 *   @b Example
 *   @verbatim

        Uint8   latency = 1;

        // Set the GEM L2 Access latency in Chip Misc Control register
        CSL_BootCfgSetGEML2AccessLatency(latency);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetGEML2AccessLatency 
(
    Uint8   latency
)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) = ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & ~(0x00000780u)) | (((latency) << (0x00000007u)) & (0x00000780u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsDDR3PSCLockEnabled
 *
 *   @b Description
 *   @n The function is to used to get the DDR3 PSC Lock status from the 
 *      Chip Miscellaneous Control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_GEM_EMIF4F_PSC_LOCK_N
 *
 *   @b Example
 *   @verbatim

        // Get the DDR3 PSC lock status from Chip Misc Control register
        if (CSL_BootCfgIsDDR3PSCLockEnabled() == TRUE)
        {
            // DDR3 PSC lock enabled.
        }
        else
        {
            // DDR3 PSC lock disabled.
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsDDR3PSCLockEnabled (void)
{
    return (((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & (0x00000800u)) >> (0x0000000Bu));
}

/** ============================================================================
 *   @n@b CSL_BootCfgEnableDDR3PSCLock
 *
 *   @b Description
 *   @n The function enables the DDR3 PSC Lock, thus enabling DDR3 EMIF to be 
 *      reset independently of the rest of the chip.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_GEM_EMIF4F_PSC_LOCK_N=1
 *
 *   @b Example
 *   @verbatim

        // Lock DDR3 PSC from reset with chip
        CSL_BootCfgEnableDDR3PSCLock();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgEnableDDR3PSCLock (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) = ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & ~(0x00000800u)) | (((1) << (0x0000000Bu)) & (0x00000800u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgDisableDDR3PSCLock
 *
 *   @b Description
 *   @n The function disables the DDR3 PSC Lock.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_GEM_EMIF4F_PSC_LOCK_N=0
 *
 *   @b Example
 *   @verbatim

        // Unlock DDR3 PSC.
        CSL_BootCfgDisableDDR3PSCLock();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgDisableDDR3PSCLock (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) = ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & ~(0x00000800u)) | (((0) << (0x0000000Bu)) & (0x00000800u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgIsMSMCParityResetBlocked
 *
 *   @b Description
 *   @n The function is to used to get the MSMC parity RAM reset block status 
 *      from the Chip Miscellaneous Control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_MSMC_BLOCK_PARITY_RST
 *
 *   @b Example
 *   @verbatim

        // Get the MSMC parity block status from Chip Misc Control register
        if (CSL_BootCfgIsMSMCParityResetBlocked() == TRUE)
        {
            // MSMC parity RAM reset is blocked.
        }
        else
        {
            // MSMC parity RAM reset is un-blocked.
        }

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_BootCfgIsMSMCParityResetBlocked (void)
{
    return (((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & (0x00001000u)) >> (0x0000000Cu));
}

/** ============================================================================
 *   @n@b CSL_BootCfgBlockMSMCParityReset
 *
 *   @b Description
 *   @n The function enables the MSMC Parity RAM block bit, thus preventing the
 *      MSMC parity RAM from being reset.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_MSMC_BLOCK_PARITY_RST=1
 *
 *   @b Example
 *   @verbatim

        // Block MSMC parity RAM from reset
        CSL_BootCfgBlockMSMCParityReset();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgBlockMSMCParityReset (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) = ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & ~(0x00001000u)) | (((1) << (0x0000000Cu)) & (0x00001000u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgUnblockMSMCParityReset
 *
 *   @b Description
 *   @n The function disables the MSMC Parity RAM block bit, thus enabling the
 *      MSMC parity RAM reset control.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_CHIP_MISC_CHIP_MISC_MSMC_BLOCK_PARITY_RST=0
 *
 *   @b Example
 *   @verbatim

        // Un-Block MSMC parity RAM from reset
        CSL_BootCfgUnblockMSMCParityReset();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgUnblockMSMCParityReset (void)
{
    ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) = ((((CSL_BootcfgRegs*)(0x02620000))->CHIP_MISC) & ~(0x00001000u)) | (((0) << (0x0000000Cu)) & (0x00001000u)));
}

/** ============================================================================
 *   @n@b CSL_BootCfgGetDDRConfig
 *
 *   @b Description
 *   @n The function is to used to get the DDR3 Configuration.
 *
 *   @b Arguments
     @verbatim
        regNum  - DDR Configuration Register to be read.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n BOOTCFG_DDR3_CONFIG_REG_0;BOOTCFG_DDR3_CONFIG_REG_1;BOOTCFG_DDR3_CONFIG_REG_2;
 *   @n BOOTCFG_DDR3_CONFIG_REG_3;BOOTCFG_DDR3_CONFIG_REG_4;BOOTCFG_DDR3_CONFIG_REG_5;
 *   @n BOOTCFG_DDR3_CONFIG_REG_6;BOOTCFG_DDR3_CONFIG_REG_7;BOOTCFG_DDR3_CONFIG_REG_8;
 *   @n BOOTCFG_DDR3_CONFIG_REG_9;BOOTCFG_DDR3_CONFIG_REG_10;BOOTCFG_DDR3_CONFIG_REG_11;
 *   @n BOOTCFG_DDR3_CONFIG_REG_12;BOOTCFG_DDR3_CONFIG_REG_13;BOOTCFG_DDR3_CONFIG_REG_14;
 *   @n BOOTCFG_DDR3_CONFIG_REG_15;BOOTCFG_DDR3_CONFIG_REG_16;BOOTCFG_DDR3_CONFIG_REG_17;
 *   @n BOOTCFG_DDR3_CONFIG_REG_18;BOOTCFG_DDR3_CONFIG_REG_19;BOOTCFG_DDR3_CONFIG_REG_20;
 *   @n BOOTCFG_DDR3_CONFIG_REG_21;BOOTCFG_DDR3_CONFIG_REG_22;BOOTCFG_DDR3_CONFIG_REG_23;
 *   @n BOOTCFG_DDR3_CONFIG_REG_24;BOOTCFG_DDR3_CONFIG_REG_25
 *
 *   @b Example
 *   @verbatim

        Uint32   ddr3Config;

        // Get the DDR3 Register 1 Configuration.
        CSL_BootCfgGetDDRConfig(1, &ddr3Config);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgGetDDRConfig 
(
    Uint8   regNum,
    Uint32* ddr3Config
)
{
    *ddr3Config = ((CSL_BootcfgRegs*)(0x02620000))->DDR3_CONFIG_REG[regNum];
}

/** ============================================================================
 *   @n@b CSL_BootCfgSetDDRConfig
 *
 *   @b Description
 *   @n The function is to used to set the DDR3 Configuration.
 *
 *   @b Arguments
     @verbatim
        regNum  - DDR Configuration Register to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n BOOTCFG_DDR3_CONFIG_REG_0;BOOTCFG_DDR3_CONFIG_REG_1;BOOTCFG_DDR3_CONFIG_REG_2;
 *   @n BOOTCFG_DDR3_CONFIG_REG_3;BOOTCFG_DDR3_CONFIG_REG_4;BOOTCFG_DDR3_CONFIG_REG_5;
 *   @n BOOTCFG_DDR3_CONFIG_REG_6;BOOTCFG_DDR3_CONFIG_REG_7;BOOTCFG_DDR3_CONFIG_REG_8;
 *   @n BOOTCFG_DDR3_CONFIG_REG_9;BOOTCFG_DDR3_CONFIG_REG_10;BOOTCFG_DDR3_CONFIG_REG_11;
 *   @n BOOTCFG_DDR3_CONFIG_REG_12;BOOTCFG_DDR3_CONFIG_REG_13;BOOTCFG_DDR3_CONFIG_REG_14;
 *   @n BOOTCFG_DDR3_CONFIG_REG_15;BOOTCFG_DDR3_CONFIG_REG_16;BOOTCFG_DDR3_CONFIG_REG_17;
 *   @n BOOTCFG_DDR3_CONFIG_REG_18;BOOTCFG_DDR3_CONFIG_REG_19;BOOTCFG_DDR3_CONFIG_REG_20;
 *   @n BOOTCFG_DDR3_CONFIG_REG_21;BOOTCFG_DDR3_CONFIG_REG_22;BOOTCFG_DDR3_CONFIG_REG_23;
 *   @n BOOTCFG_DDR3_CONFIG_REG_24;BOOTCFG_DDR3_CONFIG_REG_25
 *
 *   @b Example
 *   @verbatim

        // Set the DDR3 Register 2 Configuration.
        CSL_BootCfgSetDDRConfig(2, 0x123565);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_BootCfgSetDDRConfig 
(
    Uint8   regNum,
    Uint32  ddr3Config
)
{
    ((CSL_BootcfgRegs*)(0x02620000))->DDR3_CONFIG_REG[regNum] = ddr3Config;
}

/**
@}
*/




/* ============================================================================
 * Copyright (c) Texas Instruments Incorporated 2008, 2009
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** 
 * @file csl_ipcAux.h
 *
 * @brief 
 *  API Auxilary header file for IPC CSL. It gives the definitions of the 
 *  query & control functions.
 * 
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 *  @n   Use of this software is controlled by the terms and conditions found 
 *  @n   in the license agreement under which this software has been supplied.
 *  ===========================================================================
 *  \par 
 */



/*  ============================================================================
 *   Copyright (c) Texas Instruments Incorporated 2008, 2009
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** 
 *   @file  csl_ipc.h
 *
 *   @brief  
 *      IPC CSL Implementation on DSP side
 * 
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 *  @n   Use of this software is controlled by the terms and conditions found 
 *  @n   in the license agreement under which this software has been supplied.
 *  ===========================================================================
 *  \par
 */

/** @defgroup CSL_IPC_API IPC
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * Each of the GEM cores can communicate with one another in a variety of ways.
 * Inter-Processor interrupts (IPC) is one of the ways used for core synchronization,
 * allowing for direct notification from one GEM core to another.
 * Three different IPC mechanisms are defined:
 * 		a)	Inter-DSP Interrupts.
 * 		b)	Host CPU Interrupts (interrupts to external host).
 * 		c)	Non Maskable Interrupts (NMI) to GEMs. 
 *
 * @subsection References
 *   -# Inter-Processor Communications (IPC) Architecture 
 *
 * @subsection Assumptions
 *    The abbreviations IPC, ipc and Ipc have been used throughout this
 *    document to refer to Inter-Processor Communications (IPC) Architecture
 */


/* =============================================================================
 *  Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2006, 2007, 2008, 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/** ============================================================================
 *   @file  cslr_ipc.h
 *
 *   @desc  This file contains the Register Desciptions for IPC module.
 *  ============================================================================
 */

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 NMIGR[8];
    volatile Uint8 	RSVD0[32];
    volatile Uint32 IPCGR[8];
    volatile Uint8 	RSVD1[28];
    volatile Uint32 IPCGRH;
    volatile Uint32 IPCAR[8];
    volatile Uint8 	RSVD2[28];
    volatile Uint32 IPCARH;
} CSL_IPCRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* NMIGR */


/* IPCGR */

































/* IPCGRH */
































/* IPCAR */































/* IPCARH */































/**
@defgroup CSL_IPC_SYMBOL  IPC Symbols Defined
@ingroup CSL_IPC_API
*/
/**
@defgroup CSL_IPC_DATASTRUCT  IPC Data Structures
@ingroup CSL_IPC_API
*/
/**
@defgroup CSL_IPC_FUNCTION  IPC Functions
@ingroup CSL_IPC_API
*/

/**
@addtogroup CSL_IPC_SYMBOL
@{
*/

/**
@}
*/


/** @addtogroup CSL_IPC_DATASTRUCT
 @{ */

/**
 *  Handle to access IPC registers accessible through config bus.
 */

/* @} */

/** @addtogroup CSL_IPC_FUNCTION
 @{ */

/* @} */




/** @addtogroup CSL_IPC_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_IPC_genNMIEvent
 *
 *   @b Description
 *   @n This function sets the NMIG bit of the NMI Generation Register (NMIGRx) 
 * 		to create an NMI pulse to the GEM corresponding to the index
 * 		specified here. 
 *
 *   @b Arguments
     @verbatim
        index       GEM number for which the NMI event is to be raised.
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	None
 *
 *   <b> Pre Condition </b>
 *   @n None. 
 *
 *   <b> Post Condition </b>
 *	 @n	NMIG bit in the corresponding NMIGRx register configured.
 *
 *   @b Writes
 * 	 @n	IPC_NMIGR_NMIG=1 
 *
 *   @b Example
 *   @verbatim
        Example 1: Raise an NMI interrupt to Gem 2
        Uint32 index = 2;

        CSL_IPC_genNMIEvent (index);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_IPC_genNMIEvent (
	Uint32 index
)
{
	((((CSL_IPCRegs *) ((0x02620000) + 0x200))->NMIGR[index]) = ((((CSL_IPCRegs *) ((0x02620000) + 0x200))->NMIGR[index]) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

	return;
}

 
/** ============================================================================
 *   @n@b CSL_IPC_genGEMInterrupt
 *
 *   @b Description
 *   @n This function sets the IPCG bit of the IPC Generation Register (IPCGRx) 
 * 		to create an inter-DSP pulse to the	GEM corresponding to the index
 * 		specified here. This API also configures the source ID for this 
 * 		interrupt by setting the SRCSx bit of the IPCGRx register based on
 * 		the source ID specified.
 *
 *   @b Arguments
     @verbatim
        index       GEM number for which the interrupt is to be raised.
        srcId       Indicates which of the 0-27 SRCSx bits needs to be set 
                    in the IPCGRx registers corresponding to the index specified. 
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	None
 *
 *   <b> Pre Condition </b>
 *   @n None 
 *
 *   <b> Post Condition </b>
 *	 @n	IPCG and SRCSx/SRCCx bits in the corresponding IPCGRx/IPCARx register 
 * 		configured.
 *
 *   @b Writes
 * 	 @n	IPC_IPCGR_IPCG=1, 
 * 	 	IPC_IPCGR_SRCS0=1;
 * 		IPC_IPCGR_SRCS1=1;
 * 		IPC_IPCGR_SRCS2=1;
 * 		IPC_IPCGR_SRCS3=1;
 * 		IPC_IPCGR_SRCS4=1;
 * 		IPC_IPCGR_SRCS5=1;
 * 		IPC_IPCGR_SRCS6=1;
 * 		IPC_IPCGR_SRCS7=1;
 * 		IPC_IPCGR_SRCS8=1;
 * 		IPC_IPCGR_SRCS9=1;
 * 		IPC_IPCGR_SRCS10=1;
 * 		IPC_IPCGR_SRCS11=1;
 * 		IPC_IPCGR_SRCS12=1;
 * 		IPC_IPCGR_SRCS13=1;
 * 		IPC_IPCGR_SRCS14=1;
 * 		IPC_IPCGR_SRCS15=1;
 * 		IPC_IPCGR_SRCS16=1;
 * 		IPC_IPCGR_SRCS17=1;
 * 		IPC_IPCGR_SRCS18=1;
 * 		IPC_IPCGR_SRCS19=1;
 * 		IPC_IPCGR_SRCS20=1;
 * 		IPC_IPCGR_SRCS21=1;
 * 		IPC_IPCGR_SRCS22=1;
 * 		IPC_IPCGR_SRCS23=1;
 * 		IPC_IPCGR_SRCS24=1;
 * 		IPC_IPCGR_SRCS25=1;
 * 		IPC_IPCGR_SRCS26=1;
 * 		IPC_IPCGR_SRCS27=1;
 *
 *   @b Affects
 *   @n IPC_IPCAR_SRCC0=1;
 * 		IPC_IPCAR_SRCC1=1;
 * 		IPC_IPCAR_SRCC2=1;
 * 		IPC_IPCAR_SRCC3=1;
 * 		IPC_IPCAR_SRCC4=1;
 * 		IPC_IPCAR_SRCC5=1;
 * 		IPC_IPCAR_SRCC6=1;
 * 		IPC_IPCAR_SRCC7=1;
 * 		IPC_IPCAR_SRCC8=1;
 * 		IPC_IPCAR_SRCC9=1;
 * 		IPC_IPCAR_SRCC10=1;
 * 		IPC_IPCAR_SRCC11=1;
 * 		IPC_IPCAR_SRCC12=1;
 * 		IPC_IPCAR_SRCC13=1;
 * 		IPC_IPCAR_SRCC14=1;
 * 		IPC_IPCAR_SRCC15=1;
 * 		IPC_IPCAR_SRCC16=1;
 * 		IPC_IPCAR_SRCC17=1;
 * 		IPC_IPCAR_SRCC18=1;
 * 		IPC_IPCAR_SRCC19=1;
 * 		IPC_IPCAR_SRCC20=1;
 * 		IPC_IPCAR_SRCC21=1;
 * 		IPC_IPCAR_SRCC22=1;
 * 		IPC_IPCAR_SRCC23=1;
 * 		IPC_IPCAR_SRCC24=1;
 * 		IPC_IPCAR_SRCC25=1;
 * 		IPC_IPCAR_SRCC26=1;
 * 		IPC_IPCAR_SRCC27=1
 * 
 *   @b Example
 *   @verbatim
        Example 1: An application running on GEM 2 is trying to raise
        an interrupt to Gem 1. The source Id for Gem 2 say is 2. 
        Uint32 	index = 1;
        Uint32	srcId = 2;

        CSL_IPC_genGEMInterrupt (index, srcId);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_IPC_genGEMInterrupt (
	Uint32				index,
	Uint32				srcId
)
{
    ((CSL_IPCRegs *) ((0x02620000) + 0x200))->IPCGR[index]  =   (((1) << (0x00000000u)) & (0x00000001u)) | 
                            (((1) & ((1 << (((0x00000004u) + srcId) - ((0x00000004u) + srcId) + 1)) - 1)) << ((0x00000004u) + srcId));
	
	return;
}


/** ============================================================================
 *   @n@b CSL_IPC_isGEMInterruptSourceSet
 *
 *   @b Description
 *   @n This function checks if the SRCSx bit of the IPCGRx register is set. 
 * 		It returns 1 if the SRCSx bit corresponding to the srcId is set in the 
 * 		IPCGRx register	corresponding to the index specified. Otherwise it returns
 * 		0. 
 *
 *   @b Arguments
     @verbatim
        index       GEM number for which the IPCGRx register needs to be checked.
        srcId       Indicates which of the 0-27 SRCSx bits needs to be read 
                    in the IPCGRx registers corresponding to the index specified. 
	 @endverbatim
 *
 *   <b> Return Value </b>
 *   @n 1   -   Indicates that the corresponding SRCSx bit is set and the 
 *              srcId specified is in fact the source for the IPC Gem interrupt. \n
 *      0   -   Indicates that corresponding SRCSx bit not set and the 
 *              srcId specified is not the IPC source.
 *
 *   <b> Pre Condition </b>
 *   @n None 
 *
 *   <b> Post Condition </b>
 *	 @n	None
 *
 *   @b Reads
 *   @n IPC_IPCGR_SRCS0;
 *      IPC_IPCGR_SRCS1;
 *      IPC_IPCGR_SRCS2;
 *      IPC_IPCGR_SRCS3;
 *      IPC_IPCGR_SRCS4;
 *      IPC_IPCGR_SRCS5;
 *      IPC_IPCGR_SRCS6;
 *      IPC_IPCGR_SRCS7;
 *      IPC_IPCGR_SRCS8;
 *      IPC_IPCGR_SRCS9;
 *      IPC_IPCGR_SRCS10;
 *      IPC_IPCGR_SRCS11;
 *      IPC_IPCGR_SRCS12;
 *      IPC_IPCGR_SRCS13;
 *      IPC_IPCGR_SRCS14;
 *      IPC_IPCGR_SRCS15;
 *      IPC_IPCGR_SRCS16;
 *      IPC_IPCGR_SRCS17;
 *      IPC_IPCGR_SRCS18;
 *      IPC_IPCGR_SRCS19;
 *      IPC_IPCGR_SRCS20;
 *      IPC_IPCGR_SRCS21;
 *      IPC_IPCGR_SRCS22;
 *      IPC_IPCGR_SRCS23;
 *      IPC_IPCGR_SRCS24;
 *      IPC_IPCGR_SRCS25;
 *      IPC_IPCGR_SRCS26;
 *      IPC_IPCGR_SRCS27
 * 
 *   @b Example
 *   @verbatim
        Example 1: An application running on Gem 1 received an interrupt and
        wants to check if the interrupt was from the core it was waiting on, 
        i.e., the Gem 2.
   
        Uint32 	index = 1;
        Uint32	srcId = 2;
        Uint32	retVal;

        retVal = CSL_IPC_isGEMInterruptSourceSet (index, srcId);
        
        if (retVal == 0)
        {
        	...		// Maybe cotinue waiting for the IPC/message
       	}
       	else
       	{
       		...		// Do the needful processing.
       	}
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_IPC_isGEMInterruptSourceSet (
	Uint32				index,
	Uint32				srcId
)
{
	return (((((CSL_IPCRegs *) ((0x02620000) + 0x200))->IPCGR[index]) >> ((0x00000004u) + srcId)) & ((1 << (((0x00000004u) + srcId) - ((0x00000004u) + srcId) + 1)) - 1));

}

/** ============================================================================
 *   @n@b CSL_IPC_isGEMInterruptAckSet
 *
 *   @b Description
 *   @n This function checks if the SRCCx bit of the IPCARx register is set. 
 *      It returns 1 if the SRCCx bit corresponding to the srcId is set in the 
 *      IPCARx register corresponding to the index specified. Otherwise it returns
 *      0. 
 *
 *   @b Arguments
     @verbatim
        index       GEM number for which the IPCARx register needs to be checked.
        srcId       Indicates which of the 0-27 SRCCx bits needs to be read 
                    in the IPCARx registers corresponding to the index specified. 
     @endverbatim
 *
 *   <b> Return Value </b>
 *  @n  1   -       Indicates that the corresponding SRCCx bit is set and the 
 *                  srcId specified is in fact the source for the IPC Gem interrupt. \n
 *      0   -       Indicates that corresponding SRCCx bit not set and the 
 *                  srcId specified is not the IPC source.
 *
 *   <b> Pre Condition </b>
 *   @n None 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n IPC_IPCAR_SRCC0;
 *      IPC_IPCAR_SRCC1;
 *      IPC_IPCAR_SRCC2;
 *      IPC_IPCAR_SRCC3;
 *      IPC_IPCAR_SRCC4;
 *      IPC_IPCAR_SRCC5;
 *      IPC_IPCAR_SRCC6;
 *      IPC_IPCAR_SRCC7;
 *      IPC_IPCAR_SRCC8;
 *      IPC_IPCAR_SRCC9;
 *      IPC_IPCAR_SRCC10;
 *      IPC_IPCAR_SRCC11;
 *      IPC_IPCAR_SRCC12;
 *      IPC_IPCAR_SRCC13;
 *      IPC_IPCAR_SRCC14;
 *      IPC_IPCAR_SRCC15;
 *      IPC_IPCAR_SRCC16;
 *      IPC_IPCAR_SRCC17;
 *      IPC_IPCAR_SRCC18;
 *      IPC_IPCAR_SRCC19;
 *      IPC_IPCAR_SRCC20;
 *      IPC_IPCAR_SRCC21;
 *      IPC_IPCAR_SRCC22;
 *      IPC_IPCAR_SRCC23;
 *      IPC_IPCAR_SRCC24;
 *      IPC_IPCAR_SRCC25;
 *      IPC_IPCAR_SRCC26;
 *      IPC_IPCAR_SRCC27
 * 
 *   @b Example
 *   @verbatim
        Uint32  index = 1;
        Uint32  srcId = 2;
        Uint32  retVal;

        retVal = CSL_IPC_isGEMInterruptAckSet (index, srcId);
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_IPC_isGEMInterruptAckSet (
    Uint32              index,
    Uint32              srcId
)
{
    return (((((CSL_IPCRegs *) ((0x02620000) + 0x200))->IPCAR[index]) >> ((0x00000004u) + srcId)) & ((1 << (((0x00000004u) + srcId) - ((0x00000004u) + srcId) + 1)) - 1));

}

/** ============================================================================
 *   @n@b CSL_IPC_clearGEMInterruptSource
 *
 *   @b Description
 *   @n This function clears the interrupt source IDs by setting the SRCCx bit of 
 * 		the IPC	Acknowledgment Register (IPCARx) and SRCSx bit of IPC Generation 
 * 		Register (IPCGRx) corresponding to the GEM index and Source ID specified.  
 *
 *   @b Arguments
     @verbatim
        index       GEM number for which the interrupt surce is to be cleared.
        srcId       Indicates which of the 0-27 SRCSx/SRCCx bits needs to be cleared
                    in the IPCGRx/IPCARx registers corresponding to the index specified. 
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	None
 *
 *   <b> Pre Condition </b>
 *   @n None 
 *
 *   <b> Post Condition </b>
 *	 @n	SRCSx/SRCCx bits in the corresponding IPCGRx/IPCARx register are cleared.
 *
 *   @b Writes
 *   @n IPC_IPCAR_SRCC0=0;
 *      IPC_IPCAR_SRCC1=0;
 *      IPC_IPCAR_SRCC2=0;
 *      IPC_IPCAR_SRCC3=0;
 *      IPC_IPCAR_SRCC4=0;
 *      IPC_IPCAR_SRCC5=0;
 *      IPC_IPCAR_SRCC6=0;
 *      IPC_IPCAR_SRCC7=0;
 *      IPC_IPCAR_SRCC8=0;
 *      IPC_IPCAR_SRCC9=0;
 *      IPC_IPCAR_SRCC10=0;
 *      IPC_IPCAR_SRCC11=0;
 *      IPC_IPCAR_SRCC12=0;
 *      IPC_IPCAR_SRCC13=0;
 *      IPC_IPCAR_SRCC14=0;
 *      IPC_IPCAR_SRCC15=0;
 *      IPC_IPCAR_SRCC16=0;
 *      IPC_IPCAR_SRCC17=0;
 *      IPC_IPCAR_SRCC18=0;
 *      IPC_IPCAR_SRCC19=0;
 *      IPC_IPCAR_SRCC20=0;
 *      IPC_IPCAR_SRCC21=0;
 *      IPC_IPCAR_SRCC22=0;
 *      IPC_IPCAR_SRCC23=0;
 *      IPC_IPCAR_SRCC24=0;
 *      IPC_IPCAR_SRCC25=0;
 *      IPC_IPCAR_SRCC26=0;
 *      IPC_IPCAR_SRCC27=0
 *
 *   @b Affects
 *   @n IPC_IPCGR_SRCS0=0,
 *      IPC_IPCGR_SRCS1=0;
 *      IPC_IPCGR_SRCS2=0;
 *      IPC_IPCGR_SRCS3=0;
 *      IPC_IPCGR_SRCS4=0;
 *      IPC_IPCGR_SRCS5=0;
 *      IPC_IPCGR_SRCS6=0;
 *      IPC_IPCGR_SRCS7=0;
 *      IPC_IPCGR_SRCS8=0;
 *      IPC_IPCGR_SRCS9=0;
 *      IPC_IPCGR_SRCS10=0;
 *      IPC_IPCGR_SRCS11=0;
 *      IPC_IPCGR_SRCS12=0;
 *      IPC_IPCGR_SRCS13=0;
 *      IPC_IPCGR_SRCS14=0;
 *      IPC_IPCGR_SRCS15=0;
 *      IPC_IPCGR_SRCS16=0;
 *      IPC_IPCGR_SRCS17=0;
 *      IPC_IPCGR_SRCS18=0;
 *      IPC_IPCGR_SRCS19=0;
 *      IPC_IPCGR_SRCS20=0;
 *      IPC_IPCGR_SRCS21=0;
 *      IPC_IPCGR_SRCS22=0;
 *      IPC_IPCGR_SRCS23=0;
 *      IPC_IPCGR_SRCS24=0;
 *      IPC_IPCGR_SRCS25=0;
 *      IPC_IPCGR_SRCS26=0;
 *      IPC_IPCGR_SRCS27=0
 * 
 *   @b Example
 *   @verbatim
        Example 1: Clear the interrupt for Gem 1 raised by Gem 2. 
        Uint32 	index = 1;
        Uint32	srcId = 2;

        CSL_IPC_clearGEMInterruptSource (index, srcId);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_IPC_clearGEMInterruptSource (
	Uint32				index,
	Uint32				srcId
)
{
    ((CSL_IPCRegs *) ((0x02620000) + 0x200))->IPCAR[index]  =   (((1) & ((1 << (((0x00000004u) + srcId) - ((0x00000004u) + srcId) + 1)) - 1)) << ((0x00000004u) + srcId));
	
	return;
}


/** ============================================================================
 *   @n@b CSL_IPC_genHostInterrupt
 *
 *   @b Description
 *   @n This function sets the IPCG bit of the Host IPC Generation Register (IPCGRH) 
 * 		to create an interrupt pulse on the device pin. This API also configures the 
 * 		source ID for this interrupt by setting the SRCSx bit of the IPCGRHx 
 * 		register based on the source ID specified.
 *
 *   @b Arguments
     @verbatim
        srcId       Indicates which of the 0-27 SRCSx bits needs to be set 
                    in the IPCGRH register. 
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	None
 *
 *   <b> Pre Condition </b>
 *   @n None 
 *
 *   <b> Post Condition </b>
 *	 @n	IPCG and SRCSx/SRCCx bits in the IPCGRH/IPCARH register configured.
 *
 *   @b Writes
 * 	 @n	IPC_IPCGRH_IPCG=1, 
 * 	 	IPC_IPCGRH_SRCS0=1;
 * 		IPC_IPCGRH_SRCS1=1;
 * 		IPC_IPCGRH_SRCS2=1;
 * 		IPC_IPCGRH_SRCS3=1;
 * 		IPC_IPCGRH_SRCS4=1;
 * 		IPC_IPCGRH_SRCS5=1;
 * 		IPC_IPCGRH_SRCS6=1;
 * 		IPC_IPCGRH_SRCS7=1;
 * 		IPC_IPCGRH_SRCS8=1;
 * 		IPC_IPCGRH_SRCS9=1;
 * 		IPC_IPCGRH_SRCS10=1;
 * 		IPC_IPCGRH_SRCS11=1;
 * 		IPC_IPCGRH_SRCS12=1;
 * 		IPC_IPCGRH_SRCS13=1;
 * 		IPC_IPCGRH_SRCS14=1;
 * 		IPC_IPCGRH_SRCS15=1;
 * 		IPC_IPCGRH_SRCS16=1;
 * 		IPC_IPCGRH_SRCS17=1;
 * 		IPC_IPCGRH_SRCS18=1;
 * 		IPC_IPCGRH_SRCS19=1;
 * 		IPC_IPCGRH_SRCS20=1;
 * 		IPC_IPCGRH_SRCS21=1;
 * 		IPC_IPCGRH_SRCS22=1;
 * 		IPC_IPCGRH_SRCS23=1;
 * 		IPC_IPCGRH_SRCS24=1;
 * 		IPC_IPCGRH_SRCS25=1;
 * 		IPC_IPCGRH_SRCS26=1;
 * 		IPC_IPCGRH_SRCS27=1
 *
 *   @b Affects
 * 	 	IPC_IPCARH_SRCC0=1;
 * 		IPC_IPCARH_SRCC1=1;
 * 		IPC_IPCARH_SRCC2=1;
 * 		IPC_IPCARH_SRCC3=1;
 * 		IPC_IPCARH_SRCC4=1;
 * 		IPC_IPCARH_SRCC5=1;
 * 		IPC_IPCARH_SRCC6=1;
 * 		IPC_IPCARH_SRCC7=1;
 * 		IPC_IPCARH_SRCC8=1;
 * 		IPC_IPCARH_SRCC9=1;
 * 		IPC_IPCARH_SRCC10=1;
 * 		IPC_IPCARH_SRCC11=1;
 * 		IPC_IPCARH_SRCC12=1;
 * 		IPC_IPCARH_SRCC13=1;
 * 		IPC_IPCARH_SRCC14=1;
 * 		IPC_IPCARH_SRCC15=1;
 * 		IPC_IPCARH_SRCC16=1;
 * 		IPC_IPCARH_SRCC17=1;
 * 		IPC_IPCARH_SRCC18=1;
 * 		IPC_IPCARH_SRCC19=1;
 * 		IPC_IPCARH_SRCC20=1;
 * 		IPC_IPCARH_SRCC21=1;
 * 		IPC_IPCARH_SRCC22=1;
 * 		IPC_IPCARH_SRCC23=1;
 * 		IPC_IPCARH_SRCC24=1;
 * 		IPC_IPCARH_SRCC25=1;
 * 		IPC_IPCARH_SRCC26=1;
 * 		IPC_IPCARH_SRCC27=1
 * 
 *   @b Example
 *   @verbatim
        Example 1: An application running on GEM 2 is trying to raise
        a host interrupt. 
        Uint32	srcId = 2;

        CSL_IPC_genHostInterrupt (srcId);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_IPC_genHostInterrupt (
	Uint32				srcId
)
{
    ((CSL_IPCRegs *) ((0x02620000) + 0x200))->IPCGRH    =   (((1) << (0x00000000u)) & (0x00000001u)) |
                        (((1) & ((1 << (((0x00000004u) + srcId) - ((0x00000004u) + srcId) + 1)) - 1)) << ((0x00000004u) + srcId));
	
	return;
}


/** ============================================================================
 *   @n@b CSL_IPC_isHostInterruptSourceSet
 *
 *   @b Description
 *   @n This function checks if the SRCSx bit of the IPCGRH register is set. 
 * 		It returns 1 if the SRCSx bit corresponding to the srcId is set in the 
 * 		IPCGRH register. Otherwise it returns 0. 
 *
 *   @b Arguments
     @verbatim
        srcId       Indicates which of the 0-27 SRCSx bits needs to be read 
                    in the IPCGRH register. 
	 @endverbatim
 *
 *   <b> Return Value </b>
 *   @n 1   -       Indicates that the corresponding SRCSx bit is set and the 
 *                  srcId specified is in fact the source for the IPC Host interrupt. \n
 *      0   -       Indicates that corresponding SRCSx bit not set and the 
 *                  srcId specified is not the IPC source.
 *
 *   <b> Pre Condition </b>
 *   @n None 
 *
 *   <b> Post Condition </b>
 *	 @n	None
 *
 *   @b Reads
 * 	 @n	IPC_IPCGRH_SRCS0;
 * 		IPC_IPCGRH_SRCS1;
 * 		IPC_IPCGRH_SRCS2;
 * 		IPC_IPCGRH_SRCS3;
 * 		IPC_IPCGRH_SRCS4;
 * 		IPC_IPCGRH_SRCS5;
 * 		IPC_IPCGRH_SRCS6;
 * 		IPC_IPCGRH_SRCS7;
 * 		IPC_IPCGRH_SRCS8;
 * 		IPC_IPCGRH_SRCS9;
 * 		IPC_IPCGRH_SRCS10;
 * 		IPC_IPCGRH_SRCS11;
 * 		IPC_IPCGRH_SRCS12;
 * 		IPC_IPCGRH_SRCS13;
 * 		IPC_IPCGRH_SRCS14;
 * 		IPC_IPCGRH_SRCS15;
 * 		IPC_IPCGRH_SRCS16;
 * 		IPC_IPCGRH_SRCS17;
 * 		IPC_IPCGRH_SRCS18;
 * 		IPC_IPCGRH_SRCS19;
 * 		IPC_IPCGRH_SRCS20;
 * 		IPC_IPCGRH_SRCS21;
 * 		IPC_IPCGRH_SRCS22;
 * 		IPC_IPCGRH_SRCS23;
 * 		IPC_IPCGRH_SRCS24;
 * 		IPC_IPCGRH_SRCS25;
 * 		IPC_IPCGRH_SRCS26;
 * 		IPC_IPCGRH_SRCS27
 * 
 *   @b Example
 *   @verbatim
        Example 1: Check if the host interrupt's source was set correctly
        to 2, i.e., the Gem 2 the source of the host interrupt.
 
        Uint32	srcId = 2;
        Uint32	retVal;

        retVal = CSL_IPC_isHostInterruptSourceSet (srcId);
        
        if (retVal == 0)
        {
            ...		// Do something.
        }
        else
        {
            ...		// Do the needful processing.
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_IPC_isHostInterruptSourceSet (
	Uint32				srcId
)
{
	return (((((CSL_IPCRegs *) ((0x02620000) + 0x200))->IPCGRH) >> ((0x00000004u) + srcId)) & ((1 << (((0x00000004u) + srcId) - ((0x00000004u) + srcId) + 1)) - 1));

}


/** ============================================================================
 *   @n@b CSL_IPC_isHostInterruptAckSet
 *
 *   @b Description
 *   @n This function checks if the SRCCx bit of the IPCARH register is set. 
 *      It returns 1 if the SRCCx bit corresponding to the srcId is set in the 
 *      IPCARH register. Otherwise it returns 0. 
 *
 *   @b Arguments
     @verbatim
        srcId       Indicates which of the 0-27 SRCCx bits needs to be read 
                    in the IPCARH register. 
     @endverbatim
 *
 *   <b> Return Value </b>
 *  @n  1   -       Indicates that the corresponding SRCCx bit is set and the 
 *                  srcId specified is in fact the source for the IPC Host interrupt. \n
 *      0   -       Indicates that corresponding SRCCx bit not set and the 
 *                  srcId specified is not the IPC source.
 *
 *   <b> Pre Condition </b>
 *   @n None 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n IPC_IPCARH_SRCC0;
 *      IPC_IPCARH_SRCC1;
 *      IPC_IPCARH_SRCC2;
 *      IPC_IPCARH_SRCC3;
 *      IPC_IPCARH_SRCC4;
 *      IPC_IPCARH_SRCC5;
 *      IPC_IPCARH_SRCC6;
 *      IPC_IPCARH_SRCC7;
 *      IPC_IPCARH_SRCC8;
 *      IPC_IPCARH_SRCC9;
 *      IPC_IPCARH_SRCC10;
 *      IPC_IPCARH_SRCC11;
 *      IPC_IPCARH_SRCC12;
 *      IPC_IPCARH_SRCC13;
 *      IPC_IPCARH_SRCC14;
 *      IPC_IPCARH_SRCC15;
 *      IPC_IPCARH_SRCC16;
 *      IPC_IPCARH_SRCC17;
 *      IPC_IPCARH_SRCC18;
 *      IPC_IPCARH_SRCC19;
 *      IPC_IPCARH_SRCC20;
 *      IPC_IPCARH_SRCC21;
 *      IPC_IPCARH_SRCC22;
 *      IPC_IPCARH_SRCC23;
 *      IPC_IPCARH_SRCC24;
 *      IPC_IPCARH_SRCC25;
 *      IPC_IPCARH_SRCC26;
 *      IPC_IPCARH_SRCC27
 * 
 *   @b Example
 *   @verbatim
        Uint32  srcId = 2;
        Uint32  retVal;

        retVal = CSL_IPC_isHostInterruptAckSet (srcId);
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_IPC_isHostInterruptAckSet (
    Uint32              srcId
)
{
    return (((((CSL_IPCRegs *) ((0x02620000) + 0x200))->IPCARH) >> ((0x00000004u) + srcId)) & ((1 << (((0x00000004u) + srcId) - ((0x00000004u) + srcId) + 1)) - 1));

}


/** ============================================================================
 *   @n@b CSL_IPC_clearHostInterruptSource
 *
 *   @b Description
 *   @n This function clears the interrupt source IDs by setting the SRCCx bit 
 * 		of the Host IPC Acknowledgment Register (IPCARH) and SRCSx bit of Host 
 * 		IPC Generation Register (IPCGRH) corresponding to the Source ID specified.  
 *
 *   @b Arguments
     @verbatim
        srcId       Indicates which of the 0-27 SRCSx/SRCCx bits needs to be cleared
                    in the IPCGRH/IPCARH registers. 
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	None
 *
 *   <b> Pre Condition </b>
 *   @n None 
 *
 *   <b> Post Condition </b>
 *	 @n	SRCSx/SRCCx bits in the corresponding IPCGRH/IPCARH register are cleared.
 *
 *   @b Writes
 *   @n IPC_IPCARH_SRCC0=0;
 * 		IPC_IPCARH_SRCC1=0;
 * 		IPC_IPCARH_SRCC2=0;
 * 		IPC_IPCARH_SRCC3=0;
 * 		IPC_IPCARH_SRCC4=0;
 * 		IPC_IPCARH_SRCC5=0;
 * 		IPC_IPCARH_SRCC6=0;
 * 		IPC_IPCARH_SRCC7=0;
 * 		IPC_IPCARH_SRCC8=0;
 * 		IPC_IPCARH_SRCC9=0;
 * 		IPC_IPCARH_SRCC10=0;
 * 		IPC_IPCARH_SRCC11=0;
 * 		IPC_IPCARH_SRCC12=0;
 * 		IPC_IPCARH_SRCC13=0;
 * 		IPC_IPCARH_SRCC14=0;
 * 		IPC_IPCARH_SRCC15=0;
 * 		IPC_IPCARH_SRCC16=0;
 * 		IPC_IPCARH_SRCC17=0;
 * 		IPC_IPCARH_SRCC18=0;
 * 		IPC_IPCARH_SRCC19=0;
 * 		IPC_IPCARH_SRCC20=0;
 * 		IPC_IPCARH_SRCC21=0;
 * 		IPC_IPCARH_SRCC22=0;
 * 		IPC_IPCARH_SRCC23=0;
 * 		IPC_IPCARH_SRCC24=0;
 * 		IPC_IPCARH_SRCC25=0;
 * 		IPC_IPCARH_SRCC26=0;
 * 		IPC_IPCARH_SRCC27=0
 *
 *   @b Affects
 * 	 @n	IPC_IPCGRH_SRCS0=0;
 * 		IPC_IPCGRH_SRCS1=0;
 * 		IPC_IPCGRH_SRCS2=0;
 * 		IPC_IPCGRH_SRCS3=0;
 * 		IPC_IPCGRH_SRCS4=0;
 * 		IPC_IPCGRH_SRCS5=0;
 * 		IPC_IPCGRH_SRCS6=0;
 * 		IPC_IPCGRH_SRCS7=0;
 * 		IPC_IPCGRH_SRCS8=0;
 * 		IPC_IPCGRH_SRCS9=0;
 * 		IPC_IPCGRH_SRCS10=0;
 * 		IPC_IPCGRH_SRCS11=0;
 * 		IPC_IPCGRH_SRCS12=0;
 * 		IPC_IPCGRH_SRCS13=0;
 * 		IPC_IPCGRH_SRCS14=0;
 * 		IPC_IPCGRH_SRCS15=0;
 * 		IPC_IPCGRH_SRCS16=0;
 * 		IPC_IPCGRH_SRCS17=0;
 * 		IPC_IPCGRH_SRCS18=0;
 * 		IPC_IPCGRH_SRCS19=0;
 * 		IPC_IPCGRH_SRCS20=0;
 * 		IPC_IPCGRH_SRCS21=0;
 * 		IPC_IPCGRH_SRCS22=0;
 * 		IPC_IPCGRH_SRCS23=0;
 * 		IPC_IPCGRH_SRCS24=0;
 * 		IPC_IPCGRH_SRCS25=0;
 * 		IPC_IPCGRH_SRCS26=0;
 * 		IPC_IPCGRH_SRCS27=0;
 * 
 *   @b Example
 *   @verbatim
        Example 1: Clear the host interrupt raised by Gem 2. 
        Uint32	srcId = 2;

        CSL_IPC_clearHostInterruptSource (srcId);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_IPC_clearHostInterruptSource (
	Uint32				srcId
)
{
    ((CSL_IPCRegs *) ((0x02620000) + 0x200))->IPCARH    =   (((1) & ((1 << (((0x00000004u) + srcId) - ((0x00000004u) + srcId) + 1)) - 1)) << ((0x00000004u) + srcId));
	
	return;
}


/* @} */

//#include <cslr_intgen.h> // couldn't find equivalent file
//#include <csl_chip.h>
/*  ============================================================================
 *   Copyright (c) Texas Instruments Incorporated 2008, 2009
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/** 
 *   @file  csl_chip.h
 *
 *   @brief  
 *      API header file for CHIP module CSL
 * 
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 *  @n   Use of this software is controlled by the terms and conditions found 
 *  @n   in the license agreement under which this software has been supplied.
 *  ===========================================================================
 *  \par
 */
 
/** @defgroup CSL_CHIP_API CHIP 
 *
 *  @section Introduction 
 *  
 * @subsection xxx Overview
 *  This module deals with all System On Chip (SOC) configurations. It consists
 *  of Configuration Registers specific for the chip. Following are the Registers
 *  associated with the CHIP module:   \n 
 *
 *      (1) Addressing Mode Register - This register specifies the addressing 
 *          mode for the registers which can perform linear or circular addressing, 
 *          also contain sizes for circular addressing  \n
 *          
 *      (2) Control Status Register - This register contains the control and status
 *          bits. This register is used to control the mode of cache. This is also 
 *          used to enable or disable all the interrupts except reset and 
 *          non maskable interrupt. \n
 *
 *      (3) Interrupt Flag Register - This register contains the status of 
 *          INT4-INT15 and NMI interrupt. Each corresponding bit in the IFR is set 
 *          to 1 when that interrupt occurs; otherwise, the bits are cleared to 0. \n
 *
 *      (4) Interrupt Set Register - This register allows user to manually set the
 *          maskable interrupts (INT4-INT15) in the interrupt flag register (IFR).
 *          Writing a 1 to any of the bits in ISR causes the corresponding interrupt 
 *          flag to be set in IFR. \n
 *
 *      (5) Interrupt Clear Register - This register allows user to manually clear
 *          the maskable interrupts (INT15-INT4) in the interrupt flag register 
 *          (IFR). Writing a 1 to any of the bits in ICR causes the corresponding 
 *          interrupt flag to be cleared in IFR. \n
 *
 *      (6) Interrupt Enable Register - This register enables and disables individual
 *          interrupts and this not accessible in User mode. \n
 *
 *      (7) Interrupt Service Table Pointer Register - This register is used to
 *          locate the interrupt service routine (ISR). \n
 *
 *      (8) Interrupt Return Pointer Register - This register contains the return
 *          pointer that directs the CPU to the proper location to continue program
 *          execution after processing a maskable interrupt. \n
 *
 *      (9) Nonmaskable Interrupt (NMI) Return Pointer Register - This register
 *          contains the return pointer that directs the CPU to the proper location 
 *          to continue program execution after processing of a non-maskable 
 *          interrupt (NMI). \n
 *
 *      (10)Exception Return Pointer Register - This register contains the return
 *          pointer that directs the CPU to the proper location to continue program
 *          execution after processing of a exception. \n
 *
 *      (11)Time Stamp Counter Registers - The CPU contains a free running 64-bit
 *          counter that advances each CPU clock after counting is enabled. The counter
 *          is accessed using two 32-bit read-only control registers, Time Stamp Counter
 *          Registers - Low (TSCL) and Time Stamp Counter Registers - High (TSCH). The
 *          counter is enabled by writing to TSCL. The value written is ignored. Once
 *          enabled, counting cannot be disabled under program control. Counting is
 *          disabled in the following cases:
 *                  a.  After exiting the reset state.
 *                  b.  When the CPU is fully powered down. \n
 *
 *      (12)Analysis Return Pointer \n
 *
 *      (13)SPLOOP Inner Loop Count Register - The SPLOOP or SPLOOPD instructions
 *          use the SPLOOP inner loop count register (ILC), as the count of the number
 *          of iterations left to perform. The ILC content is decremented at each stage
 *          boundary until the ILC content reaches 0. \n
 *
 *      (14)SPLOOP Reload Inner Loop Count Register - Predicated SPLOOP or 
 *          SPLOOPD instructions used in conjunction with a SPMASKR or SPKERNELR 
 *          instruction use the SPLOOP reload inner loop count register (RILC), as 
 *          the iteration count value to be written to the SPLOOP inner loop count 
 *          register (ILC) in the cycle before the reload operation begins. \n
 *
 *      (15)Restricted Entry Point Address Register - This register is used by the
 *          SWENR instruction as the target of the change of control when an SWENR
 *          instruction is issued. The contents of REP should be preinitialized by the
 *          processor in Supervisor mode before any SWENR instruction is issued.  \n
 *
 *      (16)E1 Phase Program Counter - This register contains the 32-bit address of the 
 *          fetch packet in the E1 pipeline phase. \n
 *
 *      (17)DSP Core Number Register - This register provides an identifier to shared 
 *          resources in the system which identifies which CPU is accessing those
 *          resources. The contents of this register are set to a specific value at reset. \n
 *
 *      (18)Saturation Status Register - This register provides saturation flags for
 *          each functional unit, making it possible for the program to distinguish
 *          between saturations caused by different instructions in the same execute 
 *          packet. \n
 *
 *      (19)GMPY Polynomial.A Side Register - The GMPY instruction uses the 32-bit
 *          polynomial in the GMPY polynomial-A side register (GPLYA), when the
 *          instruction is executed on the M1 unit. \n
 *
 *      (20)GMPY Polynomial.B Side Register - The GMPY instruction uses the 32-bit
 *          polynomial in the GMPY polynomial-B side register (GPLYB), when the 
 *          instruction is executed on the M2 unit. \n
 *
 *      (21)Galois Field Polynomial Generator Function Register - This register
 *          controls the field size and the Galois field polynomial generator of the
 *          Galois field multiply hardware. \n
 *
 *      (22)Debug Interrupt Enable Register - This register is used to designate 
 *          which interrupts and exceptions are treated as high priority interrupts
 *          when operating in real-time emulation mode. \n
 *
 *      (23)Task State Register - This register contains all of the status bits that
 *          determine or indicate the current execution environment. TSR is saved in the
 *          event of an interrupt or exception to the ITSR or NTSR, respectively. \n
 *
 *      (24)Interrupt Task State Register - This register is used to store the
 *          contents of the task state register (TSR) in the event of an interrupt. \n
 *
 *      (25)NMI/Exception Task State Register - This register is used to store
 *          the contents of the task state register (TSR) and the conditions under 
 *          which an exception occurred in the event of a nonmaskable interrupt (NMI) or 
 *          an exception. \n
 *
 *      (26)Exception Flag Register - This register contains bits that indicate
 *          which exceptions have been detected. Clearing the EFR bits is done by
 *          writing a 1 to the corresponding bit position in the exception clear
 *          register (ECR). \n
 *
 *      (27)Exception Clear Register - This register is used to clear individual
 *          bits in the exception flag register (EFR). Writing a 1 to any bit in ECR
 *          clears the corresponding bit in EFR. \n
 *
 *      (28)Internal Exception Report Register - This register contains flags that
 *          indicate the cause of the internal exception. \n
 */
 


/* ============================================================================
 * Copyright (c) Texas Instruments Incorporated 2009               
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** ============================================================================ 
 * @file cslr_chip.h
 *
 * @brief   CSL Register Overlay definition file for C667x Chip level
 *          Registers.
 * ============================================================================
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* AMR */



/*----B7MODE Tokens----*/


/*----B6MODE Tokens----*/


/*----B5MODE Tokens----*/


/*----B4MODE Tokens----*/


/*----A7MODE Tokens----*/


/*----A6MODE Tokens----*/


/*----A5MODE Tokens----*/


/*----A4MODE Tokens----*/


/* CSR */





/*----SAT Tokens----*/


/*----EN Tokens----*/





/*----GIE Tokens----*/


/* IFR */


/*----IF15 Tokens----*/














/* ISR */


/*----IS15 Tokens----*/


/*----IS14 Tokens----*/


/*----IS13 Tokens----*/


/*----IS12 Tokens----*/


/*----IS11 Tokens----*/


/*----IS10 Tokens----*/


/*----IS9 Tokens----*/


/*----IS8 Tokens----*/


/*----IS7 Tokens----*/


/*----IS6 Tokens----*/


/*----IS5 Tokens----*/


/*----IS4 Tokens----*/


/* ICR */


/*----IC15 Tokens----*/


/*----IC14 Tokens----*/


/*----IC13 Tokens----*/


/*----IC12 Tokens----*/


/*----IC11 Tokens----*/


/*----IC10 Tokens----*/


/*----IC9 Tokens----*/


/*----IC8 Tokens----*/


/*----IC7 Tokens----*/


/*----IC6 Tokens----*/


/*----IC5 Tokens----*/


/*----IC4 Tokens----*/


/* IER */


/*----IE15 Tokens----*/


/*----IE14 Tokens----*/


/*----IE13 Tokens----*/


/*----IE12 Tokens----*/


/*----IE11 Tokens----*/


/*----IE10 Tokens----*/


/*----IE09 Tokens----*/


/*----IE08 Tokens----*/


/*----IE07 Tokens----*/


/*----IE06 Tokens----*/


/*----IE05 Tokens----*/


/*----IE04 Tokens----*/


/*----NMI Tokens----*/



/* ISTP */




/* IRP */



/* NRP */



/* ERP */



/* TSCL */



/* TSCH */



/* ARP */



/* ILC */



/* RILC */



/* PCE1 */



/* DNUM */



/* SSR */









/* GPLYA */



/* GPLYB */



/* GFPGFR */




/* DIER */



















/* TSR */


/*----IB Tokens----*/


/*----SPLX Tokens----*/


/*----EXC Tokens----*/


/*----INT Tokens----*/


/*----CXM Tokens----*/


/*----XEN Tokens----*/


/*----GEE Tokens----*/



/*----GIE Tokens----*/


/* ITSR */


/*----IB Tokens----*/


/*----SPLX Tokens----*/


/*----EXC Tokens----*/


/*----INT Tokens----*/


/*----CXM Tokens----*/


/*----XEN Tokens----*/


/*----GEE Tokens----*/



/*----GIE Tokens----*/


/* NTSR */


/*----IB Tokens----*/


/*----SPLX Tokens----*/


/*----EXC Tokens----*/


/*----INT Tokens----*/


/*----CXM Tokens----*/


/*----XEN Tokens----*/


/*----GEE Tokens----*/



/*----GIE Tokens----*/


/* EFR */






/* ECR */


/*----NXC Tokens----*/


/*----EXC Tokens----*/


/*----IXC Tokens----*/


/*----OXC Tokens----*/


/* IERR */










/* REP */





/*****************************************************************************/
/*  C6X.H v7.3.4                                                             */
/*                                                                           */
/* Copyright (c) 1996-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/

/*****************************************************************************/
/*  VECT.H v7.3.4                                                            */
/*                                                                           */
/* Copyright (c) 1996-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/




typedef float float32_t;







struct __simd128_int32_t { int32_t _v[4]; } __attribute__((aligned(16))) __attribute__((vector_type)); typedef struct __simd128_int32_t int32x4_t;

typedef int32x4_t __x128_t;



/*****************************************************************************/
/*                                                                           */
/* NOTICE TO THOSE WHO USE INTRINSICS AND PACKED DATA                        */
/*                                                                           */
/* This note contains information on a new __float2_t type.                  */
/* It also contains recommendations on the use of the "double" type.         */
/*                                                                           */
/* In order to better support packed data compiler optimizations in the      */
/* future, the use of the type "double" for packed data is now discouraged   */
/* and its support may be discontinued in the future.                        */
/*                                                                           */
/* There are several recommendations and changes as a result.  Note that     */
/* these changes do NOT break compatibility with older code (source files    */
/* or object files).                                                         */
/*                                                                           */
/* (1) long long should be used for 64-bit packed integer data.  The double  */
/*     type should be used only for double-precision floating point values.  */
/*                                                                           */
/* (2) There is a new type, __float2_t, that holds two floats and should     */
/*     be used instead of double for holding two floats.  For now, this new  */
/*     type is typedef'ed to double in c6x.h, but could be changed in the    */
/*     future to a structure or vector type to allow better optimization of  */
/*     packed data floats.  We recommend the use of __float2_t for any       */
/*     float x2 data instead of double.                                      */
/*                                                                           */
/* (3) There are new __float2_t manipulation intrinsics (see below) that     */
/*     should be used to create and manipulate objects of type __float2_t.   */
/*                                                                           */
/* (4) C66 intrinsics that deal with packed float data are now declared      */
/*     using __float2_t instead of double.  (Those intrinsics are declared   */
/*     in this file, c6x.h.)                                                 */
/*                                                                           */
/* (5) When using any intrinsic that involves __float2_t, c6x.h must be      */
/*     included.                                                             */
/*                                                                           */
/* (6) Certain intrinsics that used double to store fixed-point packed       */
/*     data have been deprecated.  They will still be supported in the       */
/*     near future, but their descriptions will be removed from the          */
/*     compiler user's guide (spru187).  Deprecated: _mpy2, _mpyhi, _mpyli,  */
/*     _mpysu4, _mpyu4, and _smpy2.  Use the long long versions instead.     */
/*                                                                           */
/* Please see                                                                */
/* http://processors.wiki.ti.com/index.php/C6000_Intrinsics_and_Type_Double  */
/* and the C6000 Compiler User's Guide (v7.2), spru187, for more             */
/* information.                                                              */
/*                                                                           */
/*****************************************************************************/
/* If not using host intrinsics, define __float2_t items. */
  typedef double   __float2_t;
  /*-------------------------------------------------------------------------*/
  /* __float2_t manipulation intrinsics                                      */
  /*                                                                         */
  /* Since __float2_t is just a typedef to double at this time, we simply    */
  /* use #defines to "create" the __float2_t manipulation intrinsics.  The   */
  /* __float2_t intrinsics are listed in this comment for convenience.       */
  /*                                                                         */
  /* __float2_t _lltof2(long long)   Reinterpret long long as __float2_t     */
  /* long long  _dtoll(__float2_t)   Reinterpret __float2_t as long long     */
  /* __float2_t _ftod(float, float)  Create a __float2_t from 2 floats       */
  /* float      _hif(__float2_t)     Return the hi 32 bits of a __float2_t   */
  /* float      _lof(__float2_t)     Return the lo 32 bits of a __float2_t   */
  /* __int40_t  _dtol(__float2_t)    Reinterpret __float2_t as 40-bit type   */
  /* __float2_t _ltod(__int40_t)     Reinterpret 40-bit type as __float2_t   */
  /*                                                                         */
  /* __float2_t & _amem8_f2(void *)         |                                */
  /* __float2_t & _amem8_f2_const(void *)   | Allows (un)aligned loads and   */
  /* __float2_t & _mem8_f2(void *)          | stores of 8 bytes to and from  */
  /* __float2_t & _mem8_f2_const(void *)    | memory.                        */
  /*                                                                         */
  /* __float2_t _fdmv(float, float)  Move two floats with one instruction    */
  /* __float2_t _hif2_128(__x128_t)  Return hi 64 bits of __x128_t           */
  /* __float2_t _lof2_128(__x128_t)  Return hi 64 bits of __x128_t           */
  /* __x128_t   _f2to128(__float2_t, __float2_t)  Compose __x128_t           */
  /* __float2_t _fdmvd(float, float) Delayed move of two floats              */
  /*-------------------------------------------------------------------------*/


  /* _mem8_f2 and _mem8_f2_const for C6400 and compatible */

  /* _fdmv_f2 for C6400+ and compatible */

  /* __float2_t manipulation intrinsics for __x128_t and C6600 */


unsigned  _extu	   (unsigned, unsigned, unsigned);
int       _ext	   (int,      unsigned, unsigned);
unsigned  _set	   (unsigned, unsigned, unsigned);
unsigned  _clr	   (unsigned, unsigned, unsigned);
unsigned  _extur   (unsigned, int);
int       _extr	   (int,      int);
unsigned  _setr	   (unsigned, int);
unsigned  _clrr	   (unsigned, int);
int       _sadd	   (int,      int);
int	  _ssub	   (int,      int);
int       _sshl	   (int,      unsigned);
int	  _add2	   (int,      int);
int	  _sub2	   (int,      int);
unsigned  _subc	   (unsigned, unsigned);
unsigned  _lmbd	   (unsigned, unsigned);
int       _abs	   (int);
__int40_t _labs	   (__int40_t);
unsigned  _norm	   (int);
int	  _smpy	   (int,      int);
int	  _smpyhl  (int,      int);
int	  _smpylh  (int,      int);
int	  _smpyh   (int,      int);
int	  _mpy	   (int,      int);
int	  _mpyus   (unsigned, int);
int	  _mpysu   (int,      unsigned);
unsigned  _mpyu	   (unsigned, unsigned);
int	  _mpyhl   (int,      int);
int	  _mpyhuls (unsigned, int);
int	  _mpyhslu (int,      unsigned);
unsigned  _mpyhlu  (unsigned, unsigned);
int	  _mpylh   (int,      int);
int	  _mpyluhs (unsigned, int);
int	  _mpylshu (int,      unsigned);
unsigned  _mpylhu  (unsigned, unsigned);
int	  _mpyh	   (int,      int);
int	  _mpyhus  (unsigned, int);
int	  _mpyhsu  (int,      unsigned);
unsigned  _mpyhu   (unsigned, unsigned);

__int40_t _lsadd   (int, __int40_t);
__int40_t _lssub   (int, __int40_t);
int       _sat	   (__int40_t);
unsigned  _lnorm   (__int40_t);

double    _fabs    (double);
float     _fabsf   (float);
long long _mpyidll (int,      int);
int    	  _spint   (float);
int    	  _dpint   (double);
float  	  _rcpsp   (float);
double 	  _rcpdp   (double);
float  	  _rsqrsp  (float);
double 	  _rsqrdp  (double);

/*double    _mpyid   (int,      int);  Deprecated.  Use _mpyidll instead. */

unsigned  _hi(double);      /* Return the hi 32 bits of a double as an int    */
float     _hif(double);     /* Return the hi 32 bits of a double as a float   */
unsigned  _hill(long long); /* Return the hi 32 bits of a long long as an int */
unsigned  _lo(double);      /* Return the lo 32 bits of a double as an int    */
float     _lof(double);     /* Return the lo 32 bits of a double as a float   */
unsigned  _loll(long long); /* Return the lo 32 bits of a long long as an int */
  
double 	  _itod(unsigned, unsigned);  /* Create a double from 2 ints    */
double 	  _ftod(float,    float);     /* Create a double from 2 floats  */
long long _itoll(unsigned, unsigned); /* Create a long long from 2 ints */
float  	  _itof(unsigned);            /* Reinterpret int as float.      */
unsigned  _ftoi(float);               /* Reinterpret float as int.      */

__int40_t _dtol(double);              /* Reinterpret double as 40-bit type    */
double    _ltod(__int40_t);           /* Reinterpret 40-bit type as double    */
long long _dtoll(double);             /* Reinterpret double as long long      */
double    _lltod(long long);          /* Reinterpret long long as double      */

int       _add4      (int,      int);
int       _avg2      (int,      int);
unsigned  _avgu4     (unsigned, unsigned);
int       _cmpeq2    (int,      int);
int       _cmpeq4    (int,      int);
int       _cmpgt2    (int,      int);
unsigned  _cmpgtu4   (unsigned, unsigned);
int       _dotp2     (int,      int);
int       _dotpn2    (int,      int);
int       _dotpnrsu2 (int,      unsigned);
int       _dotprsu2  (int,      unsigned);
int       _dotpsu4   (int,      unsigned);
unsigned  _dotpu4    (unsigned, unsigned);
int       _gmpy4     (int,      int);
__int40_t _ldotp2    (int,      int);
int       _max2      (int,      int);
unsigned  _maxu4     (unsigned, unsigned);
int       _min2      (int,      int);
unsigned  _minu4     (unsigned, unsigned);
long long _mpy2ll    (int,      int);
long long _mpyhill   (int,      int);
int       _mpyhir    (int,      int);
long long _mpylill   (int,      int);
int       _mpylir    (int,      int);
long long _mpysu4ll  (int,      unsigned);
long long _mpyu4ll   (unsigned, unsigned);
unsigned  _pack2     (unsigned, unsigned);
unsigned  _packh2    (unsigned, unsigned);
unsigned  _packh4    (unsigned, unsigned);
unsigned  _packhl2   (unsigned, unsigned);
unsigned  _packl4    (unsigned, unsigned);
unsigned  _packlh2   (unsigned, unsigned);
unsigned  _rotl      (unsigned, unsigned);
int       _sadd2     (int,      int);
unsigned  _saddu4    (unsigned, unsigned);
int       _saddus2   (unsigned, int);
unsigned  _shlmb     (unsigned, unsigned);
int       _shr2      (int,      unsigned);
unsigned  _shrmb     (unsigned, unsigned);
unsigned  _shru2     (unsigned, unsigned);
long long _smpy2ll   (int,      int);
int       _spack2    (int,      int);
unsigned  _spacku4   (int,      int);
int       _sshvl     (int,      int);
int       _sshvr     (int,      int);
int       _sub4      (int,      int);
int       _subabs4   (int,      int);
     
int       _abs2      (int);
unsigned  _bitc4     (unsigned);
unsigned  _bitr      (unsigned);
unsigned  _deal      (unsigned);
int       _mvd       (int);
unsigned  _shfl      (unsigned);
unsigned  _swap4     (unsigned);
unsigned  _unpkhu4   (unsigned);
unsigned  _unpklu4   (unsigned);
unsigned  _xpnd2     (unsigned);
unsigned  _xpnd4     (unsigned);

/*double  _mpy2      (int,      int);  Deprecated: use _mpy2ll instead */
/*double  _mpyhi     (int,      int);  Deprecated: use _mpyhill instead */
/*double  _mpysu4    (int,      unsigned);  Deprecated: use _mpysu4ll instead */
/*double  _mpyu4     (unsigned, unsigned);  Deprecated: use _mpyu4ll instead */
/*double  _smpy2     (int,      int);  Deprecated: use _smpy2ll instead */


long long _addsub    (int,       int);
long long _addsub2   (unsigned,  unsigned);
long long _cmpy      (unsigned,  unsigned);
unsigned  _cmpyr     (unsigned,  unsigned);
unsigned  _cmpyr1    (unsigned,  unsigned);
long long _ddotph2   (long long, unsigned);
unsigned  _ddotph2r  (long long, unsigned);
long long _ddotpl2   (long long, unsigned);
unsigned  _ddotpl2r  (long long, unsigned);
long long _ddotp4    (unsigned,  unsigned);
long long _dpack2    (unsigned,  unsigned);
long long _dpackx2   (unsigned,  unsigned);
long long _dmv       (unsigned,  unsigned);
double    _fdmv      (float,     float);
unsigned  _gmpy      (unsigned,  unsigned);
long long _mpy32ll   (int,       int);
int       _mpy32     (int,       int);
long long _mpy32su   (int,       unsigned);
long long _mpy32us   (unsigned,  int);
long long _mpy32u    (unsigned,  unsigned);
long long _mpy2ir    (unsigned,  int);
unsigned  _rpack2    (unsigned,  unsigned);
long long _saddsub   (int,       int);
long long _saddsub2  (unsigned,  unsigned);
long long _shfl3     (unsigned,  unsigned);
int       _smpy32    (int,       int);
int       _ssub2     (int,       int);
unsigned  _xormpy    (unsigned,  unsigned);

long long  _dcmpyr1    (long long, long long);
long long  _dccmpyr1   (long long, long long);
long long  _cmpy32r1   (long long, long long);
long long  _ccmpy32r1  (long long, long long);
long long  _mpyu2      (unsigned,  unsigned);
int        _dotp4h     (long long, long long);
long long  _dotp4hll   (long long, long long);
int        _dotpsu4h   (long long, long long);
long long  _dotpsu4hll (long long, long long);
long long  _dadd       (long long, long long);
long long  _dadd_c     (int,       long long);
long long  _dsadd      (long long, long long);
long long  _dadd2      (long long, long long);
long long  _dsadd2     (long long, long long);
long long  _dsub       (long long, long long);
long long  _dssub      (long long, long long);
long long  _dssub2     (long long, long long);
long long  _dapys2     (long long, long long);
long long  _dshr       (long long, unsigned);
long long  _dshru      (long long, unsigned);
long long  _dshl       (long long, unsigned);
long long  _dshr2      (long long, unsigned);
long long  _dshru2     (long long, unsigned);
unsigned   _shl2       (unsigned , unsigned);
long long  _dshl2      (long long, unsigned);
long long  _dxpnd4     (unsigned);
long long  _dxpnd2     (unsigned);
int        _crot90     (int);
long long  _dcrot90    (long long);
int        _crot270    (int);
long long  _dcrot270   (long long);
long long  _dmax2      (long long, long long);
long long  _dmin2      (long long, long long);
long long  _dmaxu4     (long long, long long);
long long  _dminu4     (long long, long long);
unsigned   _dcmpgt2    (long long, long long);
unsigned   _dcmpeq2    (long long, long long);
unsigned   _dcmpgtu4   (long long, long long);
unsigned   _dcmpeq4    (long long, long long);
long long  _davg2      (long long, long long);
long long  _davgu4     (long long, long long);
long long  _davgnr2    (long long, long long);
long long  _davgnru4   (long long, long long);
long long  _unpkbu4    (unsigned);
long long  _unpkh2     (unsigned);
long long  _unpkhu2    (unsigned);
long long  _dpackl2    (long long, long long);
long long  _dpackh2    (long long, long long);
long long  _dpackhl2   (long long, long long);
long long  _dpacklh4   (unsigned,  unsigned);
long long  _dpackl4    (long long, long long);
long long  _dpackh4    (long long, long long);
long long  _dspacku4   (long long, long long);
void       _mfence     ();
__float2_t _dmpysp     (__float2_t, __float2_t);
__float2_t _daddsp     (__float2_t, __float2_t);
__float2_t _dsubsp     (__float2_t, __float2_t);
__float2_t _dinthsp    (unsigned);
__float2_t _dinthspu   (unsigned);
__float2_t _dintsp     (long long);
__float2_t _dintspu    (long long);
unsigned   _dspinth    (__float2_t);
long long  _dspint     (__float2_t);

int        _land       (int, int);
int        _landn      (int, int);
int        _lor        (int, int);

long long  _dmvd       (int,       int);
double     _fdmvd      (float,     float);

double     _complex_mpysp           (double, double); /* CMPYSP then DADDSP */
double     _complex_conjugate_mpysp (double, double); /* CMPYSP then DSUBSP */

long long  _xorll_c    (int, long long);

__x128_t   __attribute__((builtin)) _dcmpy      (long long, long long);
__x128_t   __attribute__((builtin)) _dccmpy     (long long, long long);
long long  __attribute__((builtin)) _cmatmpyr1  (long long, __x128_t);
long long  __attribute__((builtin)) _ccmatmpyr1 (long long, __x128_t);
__x128_t   __attribute__((builtin)) _cmatmpy    (long long, __x128_t);
__x128_t   __attribute__((builtin)) _ccmatmpy   (long long, __x128_t);
__x128_t   __attribute__((builtin)) _qsmpy32r1  (__x128_t,  __x128_t);
__x128_t   __attribute__((builtin)) _qmpy32     (__x128_t,  __x128_t);
__x128_t   __attribute__((builtin)) _dsmpy2     (long long, long long);
__x128_t   __attribute__((builtin)) _dmpy2      (long long, long long);
__x128_t   __attribute__((builtin)) _dmpyu2     (long long, long long);
__x128_t   __attribute__((builtin)) _dmpysu4    (long long, long long);
__x128_t   __attribute__((builtin)) _dmpyu4     (long long, long long);
__x128_t   __attribute__((builtin)) _cmpysp     (__float2_t, __float2_t);
__x128_t   __attribute__((builtin)) _qmpysp     (__x128_t,  __x128_t);
long long  __attribute__((builtin)) _ddotp4h    (__x128_t,  __x128_t);
long long  __attribute__((builtin)) _ddotpsu4h  (__x128_t,  __x128_t);

__x128_t   __attribute__((builtin)) _ito128  (unsigned,  unsigned, unsigned, unsigned);
__x128_t   __attribute__((builtin)) _fto128  (float,     float,    float,    float);
__x128_t   __attribute__((builtin)) _llto128 (long long, long long);
__x128_t   __attribute__((builtin)) _dto128  (double,    double);

long long  __attribute__((builtin)) _hi128   (__x128_t);
double     __attribute__((builtin)) _hid128  (__x128_t);
long long  __attribute__((builtin)) _lo128   (__x128_t);
double     __attribute__((builtin)) _lod128  (__x128_t);

unsigned  __attribute__((builtin)) _get32_128  (__x128_t, __attribute__((constrange((0), (3)))) unsigned);
float     __attribute__((builtin)) _get32f_128 (__x128_t, __attribute__((constrange((0), (3)))) unsigned);

__x128_t  __attribute__((builtin)) _dup32_128 (unsigned);


extern __cregister volatile unsigned int AMR;
extern __cregister volatile unsigned int CSR;
extern __cregister volatile unsigned int IFR;
extern __cregister volatile unsigned int ISR;
extern __cregister volatile unsigned int ICR;
extern __cregister volatile unsigned int IER;
extern __cregister volatile unsigned int ISTP;
extern __cregister volatile unsigned int IRP;
extern __cregister volatile unsigned int NRP;

extern __cregister volatile unsigned int GFPGFR;
extern __cregister volatile unsigned int DIER;

extern __cregister volatile unsigned int FADCR;
extern __cregister volatile unsigned int FAUCR;
extern __cregister volatile unsigned int FMCR;

extern __cregister volatile unsigned int DESR;
extern __cregister volatile unsigned int DETR;

extern __cregister volatile unsigned int REP;
extern __cregister volatile unsigned int TSCL;
extern __cregister volatile unsigned int TSCH;
extern __cregister volatile unsigned int ARP;
extern __cregister volatile unsigned int ILC;
extern __cregister volatile unsigned int RILC;
extern __cregister volatile unsigned int PCE1;
extern __cregister volatile unsigned int DNUM;
extern __cregister volatile unsigned int SSR;
extern __cregister volatile unsigned int GPLYA;
extern __cregister volatile unsigned int GPLYB;
extern __cregister volatile unsigned int TSR;
extern __cregister volatile unsigned int ITSR;
extern __cregister volatile unsigned int NTSR;
extern __cregister volatile unsigned int ECR;
extern __cregister volatile unsigned int EFR;
extern __cregister volatile unsigned int IERR;

extern __cregister volatile unsigned int DMSG;
extern __cregister volatile unsigned int CMSG;
extern __cregister volatile unsigned int DT_DMA_ADDR;
extern __cregister volatile unsigned int DT_DMA_DATA;
extern __cregister volatile unsigned int DT_DMA_CNTL;
extern __cregister volatile unsigned int TCU_CNTL;
extern __cregister volatile unsigned int RTDX_REC_CNTL;
extern __cregister volatile unsigned int RTDX_XMT_CNTL;
extern __cregister volatile unsigned int RTDX_CFG;
extern __cregister volatile unsigned int RTDX_RDATA;
extern __cregister volatile unsigned int RTDX_WDATA;
extern __cregister volatile unsigned int RTDX_RADDR;
extern __cregister volatile unsigned int RTDX_WADDR;
extern __cregister volatile unsigned int MFREG0;
extern __cregister volatile unsigned int DBG_STAT;
extern __cregister volatile unsigned int BRK_EN;
extern __cregister volatile unsigned int HWBP0_CNT;
extern __cregister volatile unsigned int HWBP0;
extern __cregister volatile unsigned int HWBP1;
extern __cregister volatile unsigned int HWBP2;
extern __cregister volatile unsigned int HWBP3;
extern __cregister volatile unsigned int OVERLAY;
extern __cregister volatile unsigned int PC_PROF;
extern __cregister volatile unsigned int ATSR;
extern __cregister volatile unsigned int TRR;
extern __cregister volatile unsigned int TCRR;


/*****************************************************************************/
/* DATA_IS_ALIGNED_2, DATA_IS_ALIGNED_4, DATA_IS_ALIGNED_8 -                 */
/*     Tell the compiler that data is already aligned to a 2-byte, 4-byte    */
/*     or 8-byte boundary.  Note: this macro does not change the             */
/*     alignment of data.  Use DATA_ALIGN to change alignment.               */
/*****************************************************************************/


/*****************************************************************************/
/* SAVE_AMR -                                                                */
/*     Define a local 'volatile unsigned int' variable in your interrupt     */
/*     routine.                                                              */
/*     When invoking this macro, pass that local variable to save the AMR.   */
/*                                                                           */
/*     If you interrupted an assembly coded routine that may be using        */
/*     circular addressing, and you interrupt into a C coded interrupt       */
/*     service routine, you need to set the AMR to 0 for the C code and save */
/*     off the AMR register, so that it will have the correct value upon     */
/*     leaving the C interrupt service routine and returning to the assembly */
/*     code.                                                                 */
/*                                                                           */
/*     Add this routine immediately after your local variable definitions    */
/*     and before the start of your C interrupt code.                        */
/*****************************************************************************/

/*****************************************************************************/
/* RESTORE_AMR -                                                             */
/*    When invoking this macro, pass the same local variable that was passed */
/*    to the SAVE_AMR macro.  This macro will restore the AMR to the value   */
/*    it had when interrupted out of the hand assembly routine.              */
/*                                                                           */
/*    Add this macro immediately before exiting the C interrupt service      */
/*    routine.                                                               */ 
/*****************************************************************************/

/*****************************************************************************/
/* SAVE_SAT -                                                                */
/*     Define a local 'volatile unsigned int' variable in your interrupt     */
/*     routine.                                                              */
/*     When invoking this macro, pass that local variable to save the SAT    */
/*     bit.                                                                  */
/*                                                                           */
/*     If you interrupted a routine that was performing saturated arithmetic */
/*     and the interrupt service routine is also performing saturated        */
/*     arithmetic, then you must save and restore the SAT bit in your        */
/*     interrupt service routine.                                            */
/*                                                                           */
/*     Add this routine immediately after your local variable definitions    */
/*     and before the start of your C interrupt code.                        */
/*****************************************************************************/

/*****************************************************************************/
/* RESTORE_SAT -                                                             */
/*    When invoking this macro, pass the same local variable that was passed */
/*    to the SAVE_SAT macro.  This macro will restore the SAT bit to the     */
/*    value it had when your application was interrupted.                    */
/*                                                                           */
/*    Add this macro immediately before exiting the C interrupt service      */
/*    routine.                                                               */ 
/*****************************************************************************/


/**
@defgroup CSL_CHIP_ENUM  CHIP Enumerated Data Types
@ingroup CSL_CHIP_API
*/

/**
@defgroup CSL_CHIP_FUNCTION  CHIP Functions
@ingroup CSL_CHIP_API
*/

/* CHIP global macro declarations */

/* CHIP global typedef declarations */

/** @addtogroup CSL_CHIP_ENUM
 @{ */
/** Enum for the CHIP registers */
typedef enum  {
    /** Addressing Mode Register */
    CSL_CHIP_AMR = 0,
    /** Control Status Register */
    CSL_CHIP_CSR = 1,
    /** Interrupt Flag Register */
    CSL_CHIP_IFR = 2,
    /** Interrupt Set Register */
    CSL_CHIP_ISR = 2,
    /** Interrupt Clear Register */
    CSL_CHIP_ICR = 3,
    /** Interrupt Enable Register */
    CSL_CHIP_IER = 4,
    /** Interrupt Service Table Pointer Register */
    CSL_CHIP_ISTP= 5,
    /** Interrupt Return Pointer Register */
    CSL_CHIP_IRP= 6,
    /** Nonmaskable Interrupt (NMI) Return Pointer Register */
    CSL_CHIP_NRP= 7,
    /** Exception Return Pointer Register */
    CSL_CHIP_ERP= 7,
    /** Time Stamp Counter Register - Low */
    CSL_CHIP_TSCL= 10,
    /** Time Stamp Counter Registers - High */
    CSL_CHIP_TSCH= 11,
    /** Analysis Return Pointer */
    CSL_CHIP_ARP= 12,    
    /** SPLOOP Inner Loop Count Register */
    CSL_CHIP_ILC= 13,
    /** SPLOOP Reload Inner Loop Count Register */
    CSL_CHIP_RILC= 14,
    /** Restricted Entry Point Address Register */
    CSL_CHIP_REP= 15,
    /** E1 Phase Program Counter */
    CSL_CHIP_PCE1= 16,
    /** DSP Core Number Register */
    CSL_CHIP_DNUM= 17,
    /** Saturation Status Register */
    CSL_CHIP_SSR= 21,
    /** GMPY Polynomial.A Side Register */
    CSL_CHIP_GPLYA= 22,
    /** GMPY Polynomial.B Side Register */
    CSL_CHIP_GPLYB= 23,
    /** Galois Field Polynomial Generator Function Register */
    CSL_CHIP_GFPGFR= 24,
    /** Debug interrupt enable register */
    CSL_CHIP_DIER=25,
    /** Task State Register */
    CSL_CHIP_TSR= 26,
    /** Interrupt Task State Register */
    CSL_CHIP_ITSR= 27,
    /** NMI/Exception Task State Register */
    CSL_CHIP_NTSR= 28,
    /** Exception Flag Register */
    CSL_CHIP_EFR= 29,
    /** Exception Clear Register */
    CSL_CHIP_ECR= 29,
    /** Internal Exception Report Register */
    CSL_CHIP_IERR= 31
} CSL_ChipReg;

/**
@}
*/

/* CHIP global function declarations   */

extern Uint32  CSL_chipWriteReg (
    CSL_ChipReg    reg,
    CSL_Reg32      val
);

extern Uint32  CSL_chipReadReg(
    CSL_ChipReg    reg
);


//#include <cslr_dev.h> // couldn't find equivalent file



typedef struct ITaskQ
{
	FIFO	oQ;
	Signal	oWrite;
	Signal	*pRead;
	Mutex	oLock;

}ITaskQ;


void ITaskQ_Init (ITaskQ *pThis, String pSigName, String pSemName, UINT16 nNumQNodes);
void *ITaskQ_Read( ITaskQ *pThis );
void *ITaskQ_ReadNoBlock( ITaskQ *pThis );
void ITaskQ_Write(ITaskQ *pThis, void *pVal);


typedef enum LINKS
{
 	LINK_C1_COMMAND_C0 = 0,
	LINK_C2_COMMAND_C0,
	LINK_C3_COMMAND_C0,
	LINK_C4_COMMAND_C0,
	LINK_C5_COMMAND_C0,
	LINK_C6_COMMAND_C0,
	LINK_C7_COMMAND_C0,

	LINK_C1_BURSTINFO_C0, // BurstInfo Request from C1 to DDC RX
	LINK_C2_BURSTINFO_C0, // BurstInfo Request from C2 to DDC RX
	LINK_C3_BURSTINFO_C0,  // and so on..
	LINK_C4_BURSTINFO_C0,
	LINK_C5_BURSTINFO_C0,
	LINK_C6_BURSTINFO_C0,
	LINK_C7_BURSTINFO_C0,

	LINK_C1_L1RECEIVER_C0, // Burst From DDC RX to C1 : L2 Pak C1 to IPU
	LINK_C2_L1RECEIVER_C0, // Burst From DDC RX to C2 : L2 Pak C2 to IPU
	LINK_C3_L1RECEIVER_C0, // and so on...
	LINK_C4_L1RECEIVER_C0,
	LINK_C5_L1RECEIVER_C0,
	LINK_C6_L1RECEIVER_C0,
	LINK_C7_L1RECEIVER_C0,


	//LINK_C1_L1TRANSMITTER_C0, // L2 Packet from IPU to C1 : Burst from C1 to FPGa
//	LINK_C2_L1TRANSMITTER_C0, // L2 Packet from IPU to C2 : Burst from C2 to FPGa
//	LINK_C3_L1TRANSMITTER_C0,// L2 Packet from IPU to C3 : Burst from C3 to FPGa
//	LINK_C4_L1TRANSMITTER_C0,// L2 Packet from IPU to C4 : Burst from C4 to FPGa
//	LINK_C5_L1TRANSMITTER_C0,// L2 Packet from IPU to C5 : Burst from C5 to FPGa
//	LINK_C6_L1TRANSMITTER_C0,// L2 Packet from IPU to C6 : Burst from C6 to FPGa
//	LINK_C7_L1TRANSMITTER_C0,// L2 Packet from IPU to C7 : Burst from C7 to FPGa

	MAX_LINKS
} LINKS;

typedef struct TransferJob
{
	UINT32 		 lLastSentPakNum;

	// If the transfer need to be splitted in to two due to the rollover concern.
	// If true,  uses the following members.
	BOOL 		 bIsRollOverBreak;
	UINT32		 nSymbolSet1;
	UINT32		 nSymbolSet2;
	DDC_RxData	 *pStartAddr;
	DDC_RxData	 *pEndAddr;
	UINT64		 JobCompPakNum;

	struct BurstInfo    oBurstInfo;
	UINT8				nExpectedSeqNum;
	UINT8				nTargetSeq;
	struct BurstInfo    *pNewBurstInfo;
	UINT32				lEndPakNum; // For a given job where the memory starts.
//	BOOL				bNewRequest;
}TransferJob;


/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/** ===========================================================================
 *  @file       Ipc.h
 *
 *  @brief      Ipc Manager.
 *
 *  This module is primarily used to configure IPC, synchronize processors, and
 *  initialize the IPC runtime.  The memory for SharedRegion zero must be valid 
 *  before Ipc_start() can be called.  Ipc_start() must be called before any
 *  other IPC APIs are used.
 *
 *  The Ipc header should be included in an application as follows:
 *  @code
 *  #include <ti/ipc/Ipc.h>
 *  @endcode
 *
 *  ============================================================================
 */



/* =============================================================================
 *  All success and failure codes for the module
 * =============================================================================
 */

/*!
 *  @def    Ipc_S_BUSY
 *  @brief  The resource is still in use
 */

/*!
 *  @def    Ipc_S_ALREADYSETUP
 *  @brief  The module has been already setup
 */

/*!
 *  @def    Ipc_S_SUCCESS
 *  @brief  Operation is successful.
 */

/*!
 *  @def    Ipc_E_FAIL
 *  @brief  Generic failure.
 */

/*!
 *  @def    Ipc_E_INVALIDARG
 *  @brief  Argument passed to function is invalid.
 */

/*!
 *  @def    Ipc_E_MEMORY
 *  @brief  Operation resulted in memory failure.
 */

/*!
 *  @def    Ipc_E_ALREADYEXISTS
 *  @brief  The specified entity already exists.
 */

/*!
 *  @def    Ipc_E_NOTFOUND
 *  @brief  Unable to find the specified entity.
 */

/*!
 *  @def    Ipc_E_TIMEOUT
 *  @brief  Operation timed out.
 */

/*!
 *  @def    Ipc_E_INVALIDSTATE
 *  @brief  Module is not initialized or in an invalid state.
 */

/*!
 *  @def    Ipc_E_OSFAILURE
 *  @brief  A failure occurred in an OS-specific call
 */

/*!
 *  @def    Ipc_E_RESOURCE
 *  @brief  Specified resource is not available
 */

/*!
 *  @def    Ipc_E_RESTART
 *  @brief  Operation was interrupted. Please restart the operation
 */

/*!
 *  @def    Ipc_E_NOTREADY
 *  @brief  Operation was not ready.
 */


/* =============================================================================
 *  Ipc Module-wide Functions
 * =============================================================================
 */

/*!
 *  @brief      Attach to remote processor
 *
 *  This function uses shared memory to synchronize self with the remote
 *  processor.  Both processors must call this function to attach to each
 *  other.  Ipc_start() must be called before calling Ipc_attach().
 *  A processor must attach to the owner of SharedRegion zero before
 *  it can successfully attach to another processor.  Attempting to
 *  attach to another processor first returns #Ipc_E_FAIL.
 *
 *  This function opens the default GateMP and SharedRegion zero heap.
 *  The Notify, NameServerRemoteNotify, and MessageQ transport
 *  instances are created for communicating with the specified remote
 *  processor in SharedRegion zero heap.  The user's Ipc attach function
 *  is called.
 *
 *  For BIOS, this function should be called within a 'while' loop
 *  within a Task.  A Task_sleep() or Task_yield() should be called
 *  within the loop to allow other threads in the system to execute. 
 *  This function needs to be called in a loop because the remote
 *  processor may not be in a ready state.
 *
 *  Note:  For BIOS, if the config parameter Ipc.procSync is set to
 *  Ipc.ProcSync_ALL, there is no need to call this function as it is
 *  internally called by Ipc_start().
 *
 *  @code
 *  while (Ipc_attach(remoteProcId) < 0) {
 *      Task_sleep(1);
 *  }
 *  @endcode
 *
 *  @param      remoteProcId  remote processor's MultiProc id
 *
 *  @return     Status
 *              - #Ipc_S_SUCCESS: attach was successful
 *              - #Ipc_S_ALREADYSETUP: already attached
 *              - #Ipc_E_MEMORY: operation failed due to a memory error
 *              - #Ipc_E_FAIL: General failure
 *              - #Ipc_E_NOTREADY: remote processor not ready
 *
 *  @sa         Ipc_detach Ipc_isAttached
 */
Int Ipc_attach(UInt16 remoteProcId);

/*!
 *  @brief      Detach from the remote processor
 *
 *  A processor must detach from all other processors before it can
 *  successfully detach from the owner of SharedRegion zero.  Attempting to
 *  detach from the owner of SharedRegion zero first returns #Ipc_E_FAIL.
 *
 *  If a processor successfully attached to a remote processor 'N' times,
 *  it must call Ipc_detach 'N' times to be completely detached.  
 *  Ipc_detach returns #Ipc_S_BUSY for the first 'N - 1' times its called.  
 *  Ipc_detach returns #Ipc_S_SUCCESS, if successful, on the 'N' time its 
 *  called.  If called on a remote processor that is detached, #Ipc_S_SUCCESS
 *  is returned.
 *
 *  This function should be called within a loop to make sure the processor
 *  successfully detached from the remote processor.
 *  If called from the processor with the bigger procId, this function closes
 *  the instances created for communicating with the specified remote processor.  
 *  If called from the processor with the smaller procId, this function returns
 *  Ipc_E_NOTREADY while the processor with the bigger procId has not finished
 *  detaching.  Once the processor with the bigger procId is finished detaching,
 *  this function deletes the instances created for communicating with the
 *  specified remote processor.  
 *
 *  For BIOS, this function should be called within a 'while' loop in a Task
 *  because the slave may have to wait for the master to detach.  Furthermore,
 *  a Task_sleep() or Task_yield() should be called within the same 'while'
 *  loop to allow other threads in the system to execute.
 *
 *  @code
 *  while (TRUE) {
 *      status = Ipc_detach(remoteProcId);
 *      if (status == Ipc_E_NOTREADY) {
 *          Task_sleep(1);
 *      }
 *      else if (status < 0) {
 *          System_printf("Ipc_detach failed \n");
 *          break;
 *      }
 *      else {
 *          break;
 *      }
 *  }
 *  @endcode
 *
 *  @param      remoteProcId  remote processor's MultiProc id
 *
 *  @return     Status
 *              - #Ipc_S_SUCCESS: operation was successful
 *              - #Ipc_S_BUSY: attach count != 0
 *              - #Ipc_E_FAIL: operation failed
 *              - #Ipc_E_NOTREADY: processor not ready to detach
 *
 *  @sa         Ipc_attach Ipc_isAttached
 */
Int Ipc_detach(UInt16 remoteProcId);

/*!
 *  @brief      Query whether attached to a remote processor
 *
 *  Returns TRUE if attached to a remote processor and FALSE otherwise.  If 
 *  remoteProcId == MultiProc_self(), FALSE is always returned. 
 *
 *  @param      remoteProcId  remote processor's MultiProc id
 *
 *  @return     TRUE if attached, FALSE if not attached
 *
 *  @sa         Ipc_attach Ipc_detach
 */
Bool Ipc_isAttached(UInt16 remoteProcId);

/*!
 *  @brief      Reads the config entry from the config area.
 *
 *  For more information about this API, refer to the documentation for 
 *  #Ipc_writeConfig
 *
 *  @param      remoteProcId  remote processor's MultiProc id
 *  @param      tag           tag to identify a config entry
 *  @param      cfg           address where the entry will be copied
 *  @param      size          size of config entry
 *
 *  @return     Status
 *              - #Ipc_S_SUCCESS: operation was successful
 *              - #Ipc_E_FAIL: operation failed
 *
 *  @sa         Ipc_writeConfig
 */
Int Ipc_readConfig(UInt16 remoteProcId, UInt32 tag, Ptr cfg, SizeT size);

/*!
 *  @brief      Reserves memory, creates default GateMP and HeapMemMP
 *
 *  This function needs to be called before Ipc_attach().  It should
 *  only be called once, unless the return value is #Ipc_E_NOTREADY.
 *  This indicates that either the SharedRegion zero is not valid or
 *  has not been setup yet so Ipc_start may be called again. Once
 *  sucessfully started, subsequent calls returns #Ipc_S_ALREADYSETUP.
 *
 *  Ipc reserves some shared memory in SharedRegion zero for synchronization.
 *  GateMP reserves some shared memory for managing the gates and for the
 *  default GateMP.  The same amount of memory must be reserved by each
 *  processor, but only the owner of SharedRegion zero clears the reserved 
 *  memory and creates the default GateMP. The default heap for each
 *  SharedRegion is created by the owner of each SharedRegion.
 *
 *  Note:  For BIOS, if the config parameter Ipc.procSync is set to
 *  Ipc.ProcSync_ALL, this function calls Ipc_attach() internally.
 *
 *  @return     Status
 *              - #Ipc_S_SUCCESS: operation was successful
 *              - #Ipc_S_ALREADYSETUP: already successfully called
 *              - #Ipc_E_NOTREADY: shared memory is not ready
 *              - #Ipc_E_FAIL: operation failed
 */
Int Ipc_start(void);

/*!
 *  @brief      Resets the Ipc state
 *
 *  This function should be called only once and only after detaching
 *  from all processors.  Once called, Ipc is placed back to
 *  the same state as it was before Ipc_start() was called.
 *
 *  @return     Status
 *              - #Ipc_S_SUCCESS: operation was successful
 */
Int Ipc_stop(void);

/*!
 *  @brief      Writes the config entry to the config area.
 *
 *  The #Ipc_writeConfig and #Ipc_readConfig APIs are used to pass configuration
 *  information from one core to another.  This 'information' is passed via 
 *  a pointer to shared memory with a given size and is identified via a unique
 *  tag.  A typical use case of this API would be passing 
 *  configuration information from a Slave core to the Host at startup-time. 
 *  For example, if MessageQ is used, this information 
 *  might include the queue name, message heap sizes, etc.
 *
 *  The APIs will write into SharedRegion 0 (SR0) and will use the tag 
 *  to uniquely identify the structure (cfg) and size written into SR0 which 
 *  both sides must agree on.
 *
 *  @param      remoteProcId  remote processor's MultiProc id
 *  @param      tag           tag to identify a config entry
 *  @param      cfg           address where the entry will be copied
 *  @param      size          size of config entry
 *
 *  @return     Status
 *              - #Ipc_S_SUCCESS: if operation was successful
 *              - #Ipc_E_FAIL: if operation failed
 *
 *  @sa         Ipc_readConfig
 */
Int Ipc_writeConfig(UInt16 remoteProcId, UInt32 tag, Ptr cfg, SizeT size);



/*
 */

/*
 *  @(#) ti.ipc; 1, 0, 0, 0,1; 5-22-2012 16:16:05; /db/vtree/library/trees/ipc/ipc-h32/src/ xlibrary

 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */

/** ============================================================================
 *  @file       MessageQ.h
 *
 *  @brief      MessageQ Manager
 *
 *  The MessageQ module supports the structured sending and receiving of 
 *  variable length messages. This module can be used for homogeneous
 *  (DSP to DSP)  or heterogeneous (Arm to DSP) multi-processor messaging. 
 * 
 *  MessageQ provides more sophisticated messaging than other modules. It is
 *  typically used for complex situations such as multi-processor messaging. 
 * 
 *  The following are key features of the MessageQ module:
 *  - Writers and readers can be relocated to another processor with no
 *    runtime code changes.
 *  - Timeouts are allowed when receiving messages.
 *  - Readers can determine the writer and reply back.
 *  - Receiving a message is deterministic when the timeout is zero.
 *  - Messages can reside on any message queue.
 *  - Supports zero-copy transfers.
 *  - Can send and receive from any type of thread.
 *  - Notification mechanism is specified by application.
 *  - Allows QoS (quality of service) on message buffer pools. For example,
 *    using specific buffer pools for specific message queues.
 *
 *  Messages are sent and received by being placed on and removed from a
 *  message queue. A reader is a thread that gets (reads) messages from a
 *  message queue. A writer is a thread that puts (writes) a message to a
 *  message queue. Each message queue has one reader and can have many writers.
 *  A thread may read from or write to multiple message queues.
 *
 *  Conceptually, the reader thread owns a message queue. The reader thread
 *  creates a message queue. The writer threads open a created message queue
 *  to get access to them.
 *
 *  Message queues are identified by a system-wide unique name. Internally, 
 *  MessageQ uses the NameServer module for managing 
 *  these names. The names are used for opening a message queue.
 * 
 *  Messages must be allocated from the MessageQ module. Once a message is
 *  allocated, it can be sent to any message queue. Once a message is sent, the
 *  writer loses ownership of the message and should not attempt to modify the
 *  message. Once the reader receives the message, it owns the message. It
 *  may either free the message or re-use the message.
 *
 *  Messages in a message queue can be of variable length. The only
 *  requirement is that the first field in the definition of a message must be a
 *  #::MessageQ_MsgHeader structure. For example:
 *  @code
 *  typedef struct MyMsg {
 *      MessageQ_MsgHeader header;
 *      ...
 *  } MyMsg;
 *  @endcode
 *
 *  The MessageQ API uses the MessageQ_MsgHeader internally. Your application
 *  should not modify or directly access the fields in the MessageQ_MsgHeader.
 *
 *  All messages sent via the MessageQ module must be allocated from a 
 *  heap. The heap can also be used for other memory allocation not related to 
 *  MessageQ.
 *
 *  An application can use multiple heaps. The purpose of having multiple
 *  heaps is to allow an application to regulate its message usage. For
 *  example, an application can allocate critical messages from one heap of fast
 *  on-chip memory and non-critical messages from another heap of slower
 *  external memory.
 *
 *  The #MessageQ_registerHeap API is used to
 *  assign a MessageQ heapId to a heap. When allocating a message, the heapId
 *  is used, not the heap handle. This heapId is actually placed into the 
 *  message (part of the #::MessageQ_MsgHeader). Care must be taken when 
 *  assigning heapIds. Refer to the #MessageQ_registerHeap API description for 
 *  more details.
 *
 *  MessageQ also supports the usage of messages that are not allocated via the
 *  #MessageQ_alloc function. Please refer to the #MessageQ_staticMsgInit
 *  function description for more details.
 *
 *  MessageQ supports reads/writes of different thread models. This is
 *  accomplished by having the creator of the message queue specify a 
 *  synchronizer via the #MessageQ_Params::synchronizer
 *  configuration parameter. The synchronizer is signaled whenever the 
 *  #MessageQ_put is called. The synchronizer waits if #MessageQ_get is called
 *  and there are no messages.
 *
 *  Since ISyncs are binary, the reader must drain the message queue of all
 *  messages before waiting for another signal. For example, if the reader 
 *  was a SYSBIOS Swi, the synchronizer instance could be a SyncSwi. 
 *  If a #MessageQ_put was called, the Swi_post() would 
 *  be called. The Swi would run and it must call #MessageQ_get until no 
 *  messages are returned.
 *
 *  The MessageQ header should be included in an application as follows:
 *  @code
 *  #include <ti/ipc/MessageQ.h>
 *  @endcode
 *
 *  @version        0.00.01
 *  
 *  ============================================================================
 */
 

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/** ===========================================================================
 *  @file       MultiProc.h
 *
 *  @brief      Processor ID Manager
 *
 *  Many IPC modules require the ability to uniquely specify and identify
 *  processors in a multi-processor environment. The MultiProc module
 *  centeralizes processor id management into one module.  Since this 
 *  configuration is almost always universally required, most IPC applications 
 *  require supplying configuration of this module.
 *
 *  Each processor in the MultiProc module may be uniquely identified by
 *  either a name string or an integer ranging from 0 to NUMPROCESSORS - 1.
 *
 *  At runtime, the #MultiProc_getId call returns the MultiProc id for any
 *  processor given its name.
 *
 *  The MultiProc header should be included in an application as follows:
 *  @code
 *  #include <ti/ipc/MultiProc.h>
 *  @endcode
 */



/* =============================================================================
 *  All success and failure codes for the module
 * =============================================================================
 */

/*!
 *  @def    MultiProc_S_BUSY
 *  @brief  The resource is still in use
 */

/*!
 *  @def    MultiProc_S_ALREADYSETUP
 *  @brief  The module has been already setup
 */

/*!
 *  @def    MultiProc_S_SUCCESS
 *  @brief  Operation is successful.
 */

/*!
 *  @def    MultiProc_E_FAIL
 *  @brief  Generic failure.
 */

/*!
 *  @def    MultiProc_E_INVALIDARG
 *  @brief  Argument passed to function is invalid.
 */

/*!
 *  @def    MultiProc_E_MEMORY
 *  @brief  Operation resulted in memory failure.
 */

/*!
 *  @def    MultiProc_E_ALREADYEXISTS
 *  @brief  The specified entity already exists.
 */

/*!
 *  @def    MultiProc_E_NOTFOUND
 *  @brief  Unable to find the specified entity.
 */

/*!
 *  @def    MultiProc_E_TIMEOUT
 *  @brief  Operation timed out.
 */

/*!
 *  @def    MultiProc_E_INVALIDSTATE
 *  @brief  Module is not initialized.
 */

/*!
 *  @def    MultiProc_E_OSFAILURE
 *  @brief  A failure occurred in an OS-specific call
 */

/*!
 *  @def    MultiProc_E_RESOURCE
 *  @brief  Specified resource is not available
 */

/*!
 *  @def    MultiProc_E_RESTART
 *  @brief  Operation was interrupted. Please restart the operation
 */

/* =============================================================================
 *  Macros
 * =============================================================================
 */

/*!
 *  @def    MultiProc_INVALIDID
 *  @brief  Invalid processor id.
 */

/* =============================================================================
 *  MultiProc Module-wide Functions
 * =============================================================================
 */

 /*!
 *  @brief      Gets the base MultiProc id of the cluster
 *
 *  Retrieves the base MultiProc id for the cluster of processors.
 *
 *  @return     MultiProc id for base of cluster
 *
 *  @sa         MultiProc_getClusterId
 */
UInt16 MultiProc_getBaseIdOfCluster(void);

/*!
 *  @brief      Gets the MultiProc id
 *
 *  Retrieves the MultiProc id for the processor with corresponding MultiProc 
 *  name. #MultiProc_INVALIDID is returned if the name was not found.
 *
 *  @param      name  Name of the processor.
 *
 *  @return     MultiProc id
 *
 *  @sa         MultiProc_getName
 */
UInt16 MultiProc_getId(String name);

/*!
 *  @brief      Gets the name of a processor
 *
 *  @param      id  MultiProc id.
 *
 *  @return     Name of the processor
 * 
 *  The returned string should never be modified.
 *
 *  @sa         MultiProc_getId
 */
String MultiProc_getName(UInt16 id);

/*!
 *  @brief      Gets the number of processors
 *
 *  @return     Number of processors configured with MultiProc
 */
UInt16 MultiProc_getNumProcessors(void);

/*!
 *  @brief      Gets the number of processors in the cluster
 *
 *  @return     Number of processors in cluster
 */
UInt16 MultiProc_getNumProcsInCluster(void);

/*!
 *  @brief      Gets executing processor's MultiProc id
 *
 *  @return     Executing processor's id
 *
 *  @sa         MultiProc_getId
 */
UInt16 MultiProc_self(void);

/*!
 *  @brief      Sets executing processor's base id of the cluster
 *
 *  @param      baseId  The MultiProc base id of the cluster
 *
 *  @return     MultiProc status:
 *              - #MultiProc_S_SUCCESS: sucessfully set base id of cluster
 *              - #MultiProc_E_FAIL:    failed to set base id of cluster
 */
Int MultiProc_setBaseIdOfCluster(UInt16 baseId);

/*!
 *  @brief      Sets executing processor's MultiProc id
 *
 *  @param      id  MultiProc id
 *
 *  @return     MultiProc status:
 *              - #MultiProc_S_SUCCESS: MultiProc id successfully set
 *              - #MultiProc_E_FAIL:    MultiProc id cannot be set at this time
 */
Int MultiProc_setLocalId(UInt16 id);



/*
 */
/*
 *  @(#) ti.ipc; 1, 0, 0, 0,1; 5-22-2012 16:16:05; /db/vtree/library/trees/ipc/ipc-h32/src/ xlibrary

 */



/* =============================================================================
 *  All success and failure codes for the module
 * =============================================================================
 */

/*!
 *  @def    MessageQ_S_BUSY
 *  @brief  The resource is still in use  
 */

/*!
 *  @def    MessageQ_S_ALREADYSETUP
 *  @brief  The module has been already setup
 */

/*!
 *  @def    MessageQ_S_SUCCESS
 *  @brief  Operation is successful.
 */

/*!
 *  @def    MessageQ_E_FAIL
 *  @brief  Operation is not successful.
 */    

/*!
 *  @def    MessageQ_E_INVALIDARG
 *  @brief  There is an invalid argument.
 */   

/*!
 *  @def    MessageQ_E_MEMORY
 *  @brief  Operation resulted in memory failure.
 */

/*!
 *  @def    MessageQ_E_ALREADYEXISTS
 *  @brief  The specified entity already exists.
 */

/*!
 *  @def    MessageQ_E_NOTFOUND
 *  @brief  Unable to find the specified entity.
 */

/*!
 *  @def    MessageQ_E_TIMEOUT
 *  @brief  Operation timed out.
 */

/*!
 *  @def    MessageQ_E_INVALIDSTATE
 *  @brief  Module is not initialized.
 */

/*!
 *  @def    MessageQ_E_OSFAILURE
 *  @brief  A failure occurred in an OS-specific call
 */

/*!
 *  @def    MessageQ_E_RESOURCE
 *  @brief  Specified resource is not available  
 */

/*!
 *  @def    MessageQ_E_RESTART
 *  @brief  Operation was interrupted. Please restart the operation  
 */

/*!
 *  @def    MessageQ_E_INVALIDMSG
 *  @brief  An invalid message was encountered
 */

/*!
 *  @def    MessageQ_E_NOTOWNER
 *  @brief  Not the owner
 */ 

/*!
 *  @def    MessageQ_E_REMOTEACTIVE
 *  @brief  Operation resulted in error
 */

/*!
 *  @def    MessageQ_E_INVALIDHEAPID
 *  @brief  An invalid heap id was encountered
 */  

/*!
 *  @def    MessageQ_E_INVALIDPROCID
 *  @brief  An invalid MultiProc id was encountered
 */   

/*!
 *  @def    MessageQ_E_MAXREACHED
 *  @brief  The max has been reached.
 */

/*!
 *  @def    MessageQ_E_UNREGISTEREDHEAPID
 *  @brief  Attempting to use an unregistered heap id.
 */

/*!
 *  @def    MessageQ_E_CANNOTFREESTATICMSG
 *  @brief  Trying to free a statically initialized message
 */

/*!
 *  @def    MessageQ_E_UNBLOCKED
 *  @brief  MessageQ was unblocked
 */

/* =============================================================================
 *  Macros
 * =============================================================================
 */

/*!
 *  @brief      Used as the timeout value to specify wait forever
 */

/*!
 *  @brief      Invalid message id
 */

/*!
 *  @brief      Invalid message queue
 */

/*!
 *  @brief      Mask to extract priority setting
 */

/*!
 *  @brief      Extract the destination queue from a message.
 *  
 *  Can only be used on the same processor where the destination queue resides.
 *  This function should only be used by Message Queue Transport writers.
 *
 *  @param   msg    Message
 *
 *  @retval  Destination-Queue-ID    Destination message queue.
 */


/*!
 *  @brief   Retrieves the message ID of a message.
 *
 *  This function retrieves the message ID from the message. The 
 *  #MessageQ_setMsgId function is used to insert the message ID.
 * 
 *  The message id is part of the #MessageQ_MsgHeader header and is in every 
 *  MessageQ message. All message ids are initialized to #MessageQ_INVALIDMSGID 
 *  in the #MessageQ_alloc and #MessageQ_staticMsgInit calls.
 *
 *  @param   msg     Message
 *
 *  @retval  size    Message ID from the message
 */

/*!
 *  @brief   Returns the size of the specified message. This function is helpful
 *           when re-using a message.
 *
 *  @param   msg     Message
 *
 *  @retval  size    Size of the message
 */

/*!
 *  @brief   Gets the message priority of a message
 *
 *  @retval  priority Priority of the message
 */

/*!
 *  @brief      Returns the MultiProc processor id on which the queue resides
 *
 *  Message queues reside on the processor that created them. This function
 *  allows the caller to determined on which processor the queue resides.
 *
 *  @param[in]  queueId      Unique id that identifies the queue
 *
 *  @retval     procId       The MultiProc id on which the queue resides
 */
                
/*!
 *  @brief   Retrieves the embedded source message queue from a message.
 *           
 *  This function along with the #MessageQ_setReplyQueue} function can  be used 
 *  instead of the open function. The sender of a message can embed a messageQ 
 *  into the message with the #MessageQ_setReplyQueue function. The receiver of 
 *  the message can extract the message queue ID with this function.
 *
 *  This method is particularing useful in a client/server relationship where 
 *  the server does not want to know who the clients are. The clients can embed 
 *  their message queue into the message to the server and the server extracts 
 *  it and uses it to reply.
 *
 *  @param   msg         Message
 *
 *  @retval  Reply-Queue Reply Message Queue ID
 */

/*!
 *  @brief   Sets the message id in a message.
 *
 *  This function sets the message ID in the message. The #MessageQ_getMsgId 
 *  function is used to retrieve the message ID.  The message id is part of the 
 *  #MessageQ_MsgHeader header and is in every MessageQ message. All message ids
 *  are initialized to #MessageQ_INVALIDMSGID in the #MessageQ_alloc and
 *  #MessageQ_staticMsgInit calls.
 *
 *  @param   msg        Message
 *  @param   id         Message id
 */

/*!
 *  @brief   Sets the message priority of a message
 *
 *  @param   msg      Message
 *  @param   priority Priority of message to be set.
 */

/* =============================================================================
 *  Structures & Enums
 * =============================================================================
 */

/*!
 *  @brief  Type used with MessageQ_[open/set/get]ReplyQueue and 
 *          MessageQ_put
 */ 
typedef UInt32 MessageQ_QueueId;

/*!
 *  @brief  Local queue index
 */ 
typedef UInt16 MessageQ_QueueIndex;

/*!
 *  @brief  MessageQ_Handle type
 */
typedef struct MessageQ_Object *MessageQ_Handle; 

/*!
 *  @brief  Structure defining parameters for the MessageQ module.
 */
typedef struct {
    void *synchronizer;
    /*!< Synchronizer instance used to signal IO completion
     *
     *  The synchronizer is used in the #MessageQ_put and #MessageQ_get calls.
     *  The synchronizer signal is called as part of the #MessageQ_put call.  
     *  The synchronizer waits in the #MessageQ_get if there are no messages 
     *  present.
     */
    
} MessageQ_Params;

/*!
 *  @brief      Required first field in every message
 */ 
typedef struct {
    Bits32       reserved0;         /*!< reserved for List.elem->next       */
    Bits32       reserved1;         /*!< reserved for List.elem->prev       */
    Bits32       msgSize;           /*!< message size                       */
    Bits16       flags;             /*!< bitmask of different flags         */
    Bits16       msgId;             /*!< message id                         */
    Bits16       dstId;             /*!< destination queue id               */
    Bits16       dstProc;           /*!< destination processor id           */
    Bits16       replyId;           /*!< reply id                           */
    Bits16       replyProc;         /*!< reply processor                    */
    Bits16       srcProc;           /*!< source processor                   */
    Bits16       heapId;            /*!< heap id                            */
    Bits16       seqNum;            /*!< sequence number                    */
    Bits16       reserved;          /*!< reserved                           */
} MessageQ_MsgHeader;

/*!
 *  @brief  Typedef for ease of use
 */ 
typedef MessageQ_MsgHeader *MessageQ_Msg;  

/*!
 *  @brief      Message priority
 */ 
typedef enum {
    MessageQ_NORMALPRI      = 0,    /*!< Normal Priority                  */
    MessageQ_HIGHPRI        = 1,    /*!< High Priority                    */
    MessageQ_RESERVEDPRI    = 2,    /*!< Reserved Priorit                 */
    MessageQ_URGENTPRI      = 3     /*!< Urgent Priority                  */
} MessageQ_Priority;


/* =============================================================================
 *  MessageQ Module-wide Functions
 * =============================================================================
 */

/*! 
 *  @brief      Initialize MessageQ_Params 
 *
 *  @param[in]  params      Parameters required to create a MessageQ
 */
void MessageQ_Params_init(MessageQ_Params *params);

/*!
 *  @brief      Create a MessageQ instance
 *
 *  The name supplied here does not have to be in persistent memory.  The
 *  maximum length of the string supplied here, including the '\\0' terminator
 *  is '32' by default. 
 *
 *  There are no verifications to ensure that the name supplied in 
 *  MessageQ_create is unique across all processors. Caution must be exercised
 *  to ensure that each processor uses a unique name.
 *  
 *  @param[in]  name        Name of the queue
 *  @param[in]  params      Initialized MessageQ parameters
 *
 *  @return     MessageQ Handle
 */
MessageQ_Handle MessageQ_create(String name, const MessageQ_Params *params);

/*! 
 *  @brief      Delete a created MessageQ instance 
 *
 *  This function deletes a created message queue instance. If the
 *  message queue is non-empty, any messages remaining in the queue
 *  will not be freed and will be lost.
 *
 *  @param[in,out]  handlePtr   Pointer to handle to delete.
 *
 *  @return     MessageQ status:
 *              - #MessageQ_E_FAIL: delete failed
 *              - #MessageQ_S_SUCCESS: delete successful
 */
Int MessageQ_delete(MessageQ_Handle *handlePtr);

/*!
 *  @brief      Open a message queue
 *
 *  MessageQ_open is used to retrieve the queue id for a queue that has been 
 *  created either locally or remotely.  Note that the queueId is simply a 
 *  32 bit value that uniquely identifies a queue.  Therefore, it is also 
 *  possible to put a message on a queue whose queueId has been retrieved using 
 *  any other method.
 *
 *  @param[in]  name        Name of queue to open
 *  @param[out] queueId     QueueId that can be used in #MessageQ_put
 *
 *  @return     MessageQ status:
 *              - #MessageQ_E_NOTFOUND: open failed (name not found on any 
 *                processor)
 *              - #MessageQ_S_SUCCESS: open successful
 */
Int MessageQ_open(String name, MessageQ_QueueId *queueId);

/*!
 *  @brief      Close the opened handle
 *
 *  Only close a queueId that was returned from #MessageQ_open.
 *
 *  @param[in]  queueId     Pointer to queueId to close
 *
 *  @return     MessageQ status:
 *              - #MessageQ_E_FAIL: close failed
 *              - #MessageQ_S_SUCCESS: close successful
 */
Int MessageQ_close(MessageQ_QueueId *queueId);

/*!
 *  @brief      Allocates a message from the heap
 *
 *  This function allocates a message from the heap associated with the heapId.
 *  The first field of the message must be a #::MessageQ_MsgHeader structure. 
 *  For example:
 *      @code
 *      typedef struct MyMsg {
 *         MessageQ_MsgHeader header;
 *         ...
 *      } MyMsg;
 *      @endcode
 *
 *  @param[in]  heapId      heapId
 *  @param[in]  size        size of requested message (including the 
 *                          #::MessageQ_MsgHeader).
 *
 *  @return    Allocated message or NULL if no memory.
 */
MessageQ_Msg MessageQ_alloc(UInt16 heapId, UInt32 size);

/*!
 *  @brief      Frees a message back to the heap
 *
 *  Frees the message back to the heap that was used to allocate it.
 *
 *  @param[in]  msg         Message to free.
 *
 *  @return     MessageQ status:
 *              - #MessageQ_E_FAIL: failed to free message
 *              - #MessageQ_S_SUCCESS: successfully freed the message
 */
Int MessageQ_free(MessageQ_Msg msg);

/*!
 *  @brief      Register a heap with MessageQ
 *
 *  This function registers a heap with MessageQ. The user selects a unique
 *  heapId associated with this heap. When a message is allocated via the
 *  #MessageQ_alloc function, the heapId is specified. Internally, MessageQ
 *  uses the heapId to access the heap.
 *
 *  Care must be taken when assigning heapIds. Internally MessageQ stores
 *  the heapId into the message. When the message is freed
 *  (via #MessageQ_free), the heapId is used to determine which heap to use.
 *  On systems with shared memory the heapIds must match on corresponding
 *  processors. For example, assume there is a heap called myHeap which
 *  acts on shared memory and processors 0 and 1 both use this heap.
 *  When you register the heap with MessageQ, the same heapId must be used
 *  on both processor 0 and 1.
 *
 *  If a heap is already registered for the specified heapId, no action is
 *  taken and MessageQ_E_ALREADYEXISTS is returned.
 *
 *  @param[in]  heap        Heap to register
 *  @param[in]  heapId      heapId associated with the heap
 *
 *  @return     MessageQ status:
 *              - #MessageQ_S_SUCCESS: heap successfully registered
 *              - #MessageQ_E_ALREADYEXISTS: heap already exists with heapId
 */
Int MessageQ_registerHeap(Ptr heap, UInt16 heapId);

/*!
 *  @brief      Unregister a heap with MessageQ
 *
 *  This function unregisters the heap associated with the heapId.
 *  Care must be taken to ensure that there are no outstanding messages
 *  allocated from this heap. If there are outstanding messages, an attempt
 *  to free the message will result in non-deterministic results.
 *
 *  @param[in]  heapId      Heap to unregister
 *
 *  @return     MessageQ status:
 *              - #MessageQ_S_SUCCESS: heap successfully unregistered
 */
Int MessageQ_unregisterHeap(UInt16 heapId);

/*!
 *  @brief      Sets the message tracing flag on a given message
 *
 *  This function enables message tracing for a message.  Tracing is offered
 *  in the form of Log messages that are output during operations on the 
 *  message (i.e. MessageQ_free, MessageQ_put, etc).
 *
 *  @param      msg         Message
 *  @param      traceFlag   Message trace flag (TRUE = tracing enabled)
 */
void MessageQ_setMsgTrace(MessageQ_Msg msg, Bool traceFlag);

/*!
 *  @brief      Initializes a message not obtained from MessageQ_alloc
 *
 *  There are several fields in the #::MessageQ_MsgHeader that
 *  are initialized by the #MessageQ_alloc function. The staticMsgInit
 *  can be used to initialize these fields for messages that are
 *  not allocated from MessageQ.
 *
 *  There is one strict constraint with using messages not allocated
 *  from MessageQ. The message cannot be freed via #MessageQ_free function.
 *  This includes
 *      - The application calling MessageQ_free on the same processor
 *      - The application calling MessageQ_free on a different processor
 *      - The application cannot send the message to another processor
 *        where the transport might call MessageQ_free on the message.
 *        For example, copy based transport call MessageQ_free after sending
 *        the message.
 *  If a staticMsgInit'd msg is passed to MessageQ_free an assert will occur
 *
 *  @param      msg     Message to initialize
 *  @param[in]  size    Size of the message in MAUs
 */
void MessageQ_staticMsgInit(MessageQ_Msg msg, UInt32 size);

/* =============================================================================
 *  MessageQ Per-instance Functions
 * =============================================================================
 */

/*!
 *  @brief      Gets a message from the message queue
 *
 *  This function returns a status. It also returns a message in msg.
 *  If no message is available, it blocks on the synchronizer object
 *  until the synchronizer is signaled or a timeout occurs.
 *  The synchronizer is signaled, when Message_put is called on the MessageQ
 *  handle. If a timeout occurs, the msg is set to NULL and the status is
 *  #MessageQ_E_TIMEOUT. If a timeout of zero is specified, the function
 *  returns immediately and if no message is available, the msg
 *  is set to NULL and the status is #MessageQ_E_TIMEOUT. The
 *  #MessageQ_E_UNBLOCKED status is return, if MessageQ_unblock is called
 *  on the MessageQ handle. If a message is successfully retrieved, the msg
 *  is set to the message and a #MessageQ_S_SUCCESS status is returned.
 *
 *  @param[in]  handle      MessageQ handle
 *  @param[out] msg         Pointer to the message
 *  @param[in]  timeout     Maximum duration to wait for a message in
 *                          microseconds.
 *
 *  @return     MessageQ status:
 *              - #MessageQ_S_SUCCESS: Message successfully returned
 *              - #MessageQ_E_TIMEOUT: MessageQ_get timed out
 *              - #MessageQ_E_UNBLOCKED: MessageQ_get was unblocked
 *              - #MessageQ_E_FAIL:    A general failure has occurred
 *
 *  @sa         MessageQ_put MessageQ_unblock
 */
Int MessageQ_get(MessageQ_Handle handle, MessageQ_Msg *msg, UInt timeout);

/*!
 *  @brief      Place a message onto a message queue
 *
 *  This call places the message onto the specified message queue. The
 *  message queue could be local or remote. The MessageQ module manages
 *  the delivery.
 *
 *  In the case where the queue is remote, MessageQ does not guarantee that
 *  the message is actually delivered before the MessageQ_put() call returns
 *
 *  The queue id must have been returned from one of the following functions:
 *  - MessageQ_open
 *  - MessageQ_getReplyQueue
 *  - MessageQ_getDstQueue
 *
 *  After the message is placed onto the final destination, the queue's
 *  #MessageQ_Params::synchronizer signal function is called.
 *
 *  The application loses ownership of the message once put() is called.
 *
 *  @param[in]  queueId     Destination MessageQ
 *  @param[in]  msg         Message to be sent.
 *
 *  @return     Status of the call. 
 *              - #MessageQ_S_SUCCESS denotes success.
 *              - #MessageQ_E_FAIL denotes failure. The put was not successful. 
 *                 The caller still owns the message.
 */
Int MessageQ_put(MessageQ_QueueId queueId, MessageQ_Msg msg);

/*!
 *  @brief      Returns the number of messages in a message queue
 *
 *  This function returns the number of messages in a message queue.
 *
 *  @param[in]  handle      MessageQ handle
 *
 *  @return     Number of messages in the message queue.
 */
Int MessageQ_count(MessageQ_Handle handle);

/*!
 *  @brief      Returns the QueueId associated with the handle
 *
 *  Since the #MessageQ_put function takes a QueueId, the creator
 *  of a message queue cannot send a message to itself without
 *  retrieving the QueueId. This function extracts the QueueId
 *  from the object.
 *
 *  @param[in]  handle      MessageQ handle
 *
 *  @return     QueueId associated to the object
 */
UInt32 MessageQ_getQueueId(MessageQ_Handle handle);

/*!
 *  @brief      Embeds a source message queue into a message
 *
 *  This function along with the #MessageQ_getReplyQueue function
 *  can be used instead of the #MessageQ_open function. The sender
 *  of a message can embed a messageQ into the message with this
 *  function. The receiver of the message can extract the message queue
 *  id with the #MessageQ_getReplyQueue function.
 *
 *  This method is particularly useful in a client/server relationship
 *  where the server does not want to know who the clients are. The
 *  clients can embed their message queue into the message to the server
 *  and the server extracts it and uses it to reply.
 *
 *  @param      handle      MessageQ handle
 *  @param      msg         Message to embed queue into
 */
void MessageQ_setReplyQueue(MessageQ_Handle handle, MessageQ_Msg msg);

/*!
 *  @brief      Unblocks a MessageQ
 *
 *  Unblocks a reader thread that is blocked on a MessageQ_get.  The 
 *  MessageQ_get call will return with status #MessageQ_E_UNBLOCKED indicating
 *  that it returned due to a MessageQ_unblock rather than a timeout or a 
 *  received message.  This call should only be used during a shutdown sequence
 *  in order to ensure that there is no blocked reader on a queue before
 *  deleting the queue.  A queue may not be used after it has been unblocked.
 * 
 *  MessageQ_unblock works by raising a flag in the queue indicating that it
 *  is unblocked and then signaling the synchronizer that is configured with 
 *  the target queue.  If MessageQ_unblock is called upon a queue that has
 *  no blocked listeners, then any subsequent MessageQ_get will not block and 
 *  will immediately return MessageQ_E_UNBLOCKED regardless of whether there
 *  is a message on the queue.
 *
 *  Restrictions:
 *  -  A queue may not be used after it has been unblocked.
 *  -  MessageQ_unblock may only be called on a local queue.
 *  -  May only be used with a queue configured with a blocking synchronizer.
 *
 *  @param[in]  handle      MessageQ handle
 *
 *  @sa         MessageQ_get
 */
void MessageQ_unblock(MessageQ_Handle handle);


/*
 */

/*
 *  @(#) ti.ipc; 1, 0, 0, 0,1; 5-22-2012 16:16:05; /db/vtree/library/trees/ipc/ipc-h32/src/ xlibrary

 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/** ============================================================================
 *  @file       HeapBufMP.h
 *
 *  @brief      Multi-processor fixed-size buffer heap implementation
 *
 *  Heap implementation that manages fixed size buffers that can be used 
 *  in a multiprocessor system with shared memory.
 *
 *  The HeapBufMP manager provides functions to allocate and free storage from a
 *  heap of type HeapBufMP which inherits from IHeap. HeapBufMP manages a single
 *  fixed-size buffer, split into equally sized allocatable blocks.
 *
 *  The HeapBufMP manager is intended as a very fast memory
 *  manager which can only allocate blocks of a single size. It is ideal for
 *  managing a heap that is only used for allocating a single type of object,
 *  or for objects that have very similar sizes.
 *
 *  The HeapBufMP module uses a NameServer instance to
 *  store instance information when an instance is created.  The name supplied
 *  must be unique for all HeapBufMP instances.
 *
 *  The #HeapBufMP_create call initializes the shared memory as needed. Once an 
 *  instance is created, a #HeapBufMP_open can be performed. The 
 *  open is used to gain access to the same HeapBufMP instance. 
 *  Generally an instance is created on one processor and opened on the 
 *  other processor(s).
 *
 *  The open returns a HeapBufMP instance handle like the create, 
 *  however the open does not modify the shared memory.
 * 
 *  The HeapBufMP header should be included in an application as follows:
 *  @code
 *  #include <ti/ipc/HeapBufMP.h>
 *  @endcode
 *
 *  @version        0.00.01
 */




/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/** ============================================================================
 *  @file       GateMP.h
 *
 *  @brief      Multiple processor gate that provides local and remote context 
 *              protection.
 * 
 *  A GateMP instance can be used to enforce both local and remote context 
 *  context protection.  That is, entering a GateMP can prevent preemption by
 *  another thread running on the same processor and simultaneously prevent a
 *  remote processor from entering the same gate.  GateMP's are typically used
 *  to protect reads/writes to a shared resource, such as shared memory.
 * 
 *  Creating a GateMP requires supplying the following configuration
 *      - Instance name (see #GateMP_Params::name)
 *      - Region id (see #GateMP_Params::regionId)
 *  In addition, the following parameters should be configured as necessary:
 *      - The level of local protection (interrupt, thread, tasklet, process 
 *        or none) can be configured using the #GateMP_Params::localProtect  
 *        config parameter.
 *      - The type of remote system gate that can be used.  Most devices will
 *        typically have a single type of system gate so this configuration
 *        should typically be left alone.  See #GateMP_Params::remoteProtect for
 *        more information.

 *  Once created GateMP allows the gate to be opened on another processor
 *  using #GateMP_open and the name that was used in #GateMP_create.
 * 
 *  A GateMP can be entered and left using #GateMP_enter and #GateMP_leave 
 *  like any other gate that implements the IGateProvider interface. 
 * 
 *  GateMP has the following proxies - RemoteSystemProxy, RemoteCustom1Proxy
 *  and RemoteCustom2Proxy which are automatically plugged with device-specific
 *  delegates that implement multiple processor mutexes using a variety of 
 *  hardware mechanisms.
 *
 *  GateMP creates a default system gate whose handle may be obtained 
 *  using #GateMP_getDefaultRemote.  Most IPC modules typically use this gate
 *  by default if they require gates and no instance gate is configured by the
 *  user.
 *
 *  The GateMP header should be included in an application as follows:
 *  @code
 *  #include <ti/ipc/GateMP.h>
 *  @endcode
 *  
 *
 *  @version        0.00.01
 *  
 *  ============================================================================
 */



/* =============================================================================
 *  All success and failure codes for the module
 * =============================================================================
 */

/*!
 *  @def    GateMP_S_BUSY
 *  @brief  The resource is still in use  
 */

/*!
 *  @def    GateMP_S_ALREADYSETUP
 *  @brief  The module has been already setup  
 */

/*!
 *  @def    GateMP_S_SUCCESS
 *  @brief  Operation is successful.
 */

/*!
 *  @def    GateMP_E_FAIL
 *  @brief  Generic failure.
 */

/*!
 *  @def    GateMP_E_INVALIDARG
 *  @brief  Argument passed to function is invalid.
 */

/*!
 *  @def    GateMP_E_MEMORY
 *  @brief  Operation resulted in memory failure.
 */

/*!
 *  @def    GateMP_E_ALREADYEXISTS
 *  @brief  The specified entity already exists.
 */

/*!
 *  @def    GateMP_E_NOTFOUND
 *  @brief  Unable to find the specified entity.
 */

/*!
 *  @def    GateMP_E_TIMEOUT
 *  @brief  Operation timed out.
 */

/*!
 *  @def    GateMP_E_INVALIDSTATE
 *  @brief  Module is not initialized.
 */

/*!
 *  @def    GateMP_E_OSFAILURE
 *  @brief  A failure occurred in an OS-specific call  */

/*!
 *  @def    GateMP_E_RESOURCE
 *  @brief  Specified resource is not available  */

/*!
 *  @def    GateMP_E_RESTART
 *  @brief  Operation was interrupted. Please restart the operation  */

/* =============================================================================
 *  Structures & Enums
 * =============================================================================
 */

/*!
 *  @brief  A set of local context protection levels
 *
 *  Each member corresponds to a specific local processor gates used for 
 *  local protection. 
 *
 *  In Linux user mode, the following are the mapping for the constants
 *      - INTERRUPT -> [N/A]
 *      - TASKLET   -> [N/A]
 *      - THREAD    -> GateMutex
 *      - PROCESS   -> GateMutex
 *
 *  In Linux kernel mode, the following are the mapping for the constants
 *      - INTERRUPT -> [Interrupts disabled]
 *      - TASKLET   -> GateMutex
 *      - THREAD    -> GateMutex
 *      - PROCESS   -> GateMutex
 *
 *  For SYS/BIOS users, the following are the mappings for the constants
 *      - INTERRUPT -> GateAll: disables interrupts, Swis and Tasks
 *      - TASKLET   -> GateSwi: disables Swis and Tasks 
 *      - THREAD    -> GateMutexPri: based on Semaphores
 *      - PROCESS   -> GateMutexPri: based on Semaphores
 */
typedef enum GateMP_LocalProtect {
    GateMP_LocalProtect_NONE      = 0,
    /*!< Use no local protection */
    
    GateMP_LocalProtect_INTERRUPT = 1,
    /*!< Use the INTERRUPT local protection level */
    
    GateMP_LocalProtect_TASKLET   = 2,
    /*!< Use the TASKLET local protection level */
    
    GateMP_LocalProtect_THREAD    = 3,
    /*!< Use the THREAD local protection level */
    
    GateMP_LocalProtect_PROCESS   = 4
    /*!< Use the PROCESS local protection level */
    
} GateMP_LocalProtect;


/*!
 *  @brief  Type of remote Gate
 *  
 *  Each member corresponds to a specific type of remote gate. 
 *  Each enum value corresponds to the following remote protection levels:
 *      - NONE      -> No remote protection (the GateMP instance will 
 *                     exclusively offer local protection configured in 
 *                     #GateMP_Params::localProtect
 *      - SYSTEM    -> Use the SYSTEM remote protection level (default for 
 *                     remote protection
 *      - CUSTOM1   -> Use the CUSTOM1 remote protection level
 *      - CUSTOM2   -> Use the CUSTOM2 remote protection level
 */ 
typedef enum GateMP_RemoteProtect {        
    GateMP_RemoteProtect_NONE     = 0,
    /*!< No remote protection (the GateMP instance will exclusively
     *  offer local protection configured in #GateMP_Params::localProtect)  
     */
     
    GateMP_RemoteProtect_SYSTEM   = 1,
    /*!< Use the SYSTEM remote protection level (default remote protection) */

    GateMP_RemoteProtect_CUSTOM1  = 2,
    /*!< Use the CUSTOM1 remote protection level */
    
    GateMP_RemoteProtect_CUSTOM2  = 3
    /*!< Use the CUSTOM2 remote protection level */
    
} GateMP_RemoteProtect;

/*!
 *  @brief  GateMP_Handle type
 */
typedef struct GateMP_Object *GateMP_Handle;

/*!
 *  @brief  Structure defining parameters for the GateMP module.
 */
typedef struct GateMP_Params {
    String name;
    /*!< Name of this instance.
     *
     *  The name (if not NULL) must be unique among all GateMP instances
     *  in the entire system.  The name does not have to be in persistent
     *  memory.  The supplied string is copied into persistent memory.
     *  If no name is supplied, the instance cannot be opened calling
     *  #GateMP_open.  The max length of the name is defined by the
     *  maxNameLen of the NameServer instance.
     */
    
    UInt16 regionId;
    /*!< Shared region ID
     *
     *  The index corresponding to the shared region from which shared memory
     *  is allocated for the instance.  If not specified, the default of '0'
     *  is used, otherwise the specified SharedRegion is used.  The amount
     *  of shared memory allocated can be determined by calling
     *  #GateMP_sharedMemReq.
     */
    
    /*! @cond */
    Ptr sharedAddr;
    /*!< Physical address of the shared memory
     *
     *  This value can be left as 'null' unless it is required to place the
     *  instance at a specific location in shared memory.  If specified,
     *  it must be from a valid SharedRegion and the regionId is ignored.
     *  If sharedAddr is null, then shared memory for a new instance is
     *  allocated from the heap belonging to the region identified by
     *  #GateMP_Params::regionId.  The amount of shared memory allocated
     *  can be determined by calling #GateMP_sharedMemReq.
     */
    /*! @endcond */
    
    
    GateMP_LocalProtect localProtect;
    /*!< Local protection level
     *
     *   The default value is #GateMP_LocalProtect_THREAD
     */    

    GateMP_RemoteProtect remoteProtect;
    /*!< Remote protection level
     *
     *   The default value is #GateMP_RemoteProtect_SYSTEM
     */
} GateMP_Params;

/* =============================================================================
 *  GateMP Module-wide Functions
 * =============================================================================
 */

/*!
 *  @brief      Close an opened gate
 *
 *  @param[in,out]  handlePtr   Pointer to handle to opened GateMP instance
 *
 *  @return     GateMP status
 */
Int GateMP_close(GateMP_Handle *handlePtr);
 
/*!
 *  @brief      Create a GateMP instance
 *
 *  The params structure should be initialized using GateMP_Params_init.
 *
 *  @param[in]  params      GateMP parameters
 *
 *  @return     GateMP Handle
 */
GateMP_Handle GateMP_create(const GateMP_Params *params);

/*!
 *  @brief      Delete a created GateMP instance
 *
 *  @param[in,out]  handlePtr       Pointer to GateMP handle
 *
 *  @return     GateMP Status
 */
Int GateMP_delete(GateMP_Handle *handlePtr);

/*!
 *  @brief      Get the default remote gate     
 *
 *  @return     GateMP handle
 */
GateMP_Handle GateMP_getDefaultRemote(void);

/*!
 *  @brief      Get the local protection level configured in a GateMP instance
 *
 *  @return     GateMP_LocalProtect corresponding to local protection level
 */
GateMP_LocalProtect GateMP_getLocalProtect(GateMP_Handle handle);

/*!
 *  @brief      Get the remote protection level configured in a GateMP instance
 *
 *  @return     GateMP_RemoteProtect corresponding to remote protection level
 */
GateMP_RemoteProtect GateMP_getRemoteProtect(GateMP_Handle handle);

/*!
 *  @brief      Open a created GateMP by name
 *
 *  @param[in]  name        Name of the GateMP instance
 *  @param[out] handlePtr   Pointer to GateMP handle to be opened
 *
 *  @return     GateMP status:
 *              - #GateMP_E_NOTFOUND: open failed (name not found on any 
 *                processor)
 *              - #GateMP_E_FAIL: open failed (general failure occurred)
 *              - #GateMP_S_SUCCESS: open successful
 */
Int GateMP_open(String name, GateMP_Handle *handlePtr);

/*! @cond */
Int GateMP_openByAddr(Ptr sharedAddr, GateMP_Handle *handlePtr);

/*! @endcond */

/*!
 *  @brief      Initialize a GateMP parameters struct
 *
 *  @param[out] params      Pointer to GateMP parameters
 *
 */
void GateMP_Params_init(GateMP_Params *params);

/*! @cond */
/*!
 *  @brief      Amount of shared memory required for creation of each instance
 *
 *  @param[in]  params      Pointer to the parameters that will be used in
 *                          the create.
 *
 *  @return     Number of MAUs needed to create the instance.
 */
SizeT GateMP_sharedMemReq(const GateMP_Params *params);

/*! @endcond */

/* =============================================================================
 *  GateMP Per-instance Functions
 * =============================================================================
 */

/*!
 *  @brief      Enter the GateMP
 *
 *  @param[in]  handle      GateMP handle
 *
 *  @return     key that must be used to leave the gate
 */
IArg GateMP_enter(GateMP_Handle handle);

/*!
 *  @brief      Leave the GateMP
 *  
 *  @param[in]  handle      GateMP handle
 *  @param[in]  key         key returned from GateMP_enter
 */
void GateMP_leave(GateMP_Handle handle, IArg key);


/*
 */

/*
 *  @(#) ti.ipc; 1, 0, 0, 0,1; 5-22-2012 16:16:04; /db/vtree/library/trees/ipc/ipc-h32/src/ xlibrary

 */


/* =============================================================================
 *  All success and failure codes for the module
 * =============================================================================
 */

/*!
 *  @def    HeapBufMP_S_BUSY
 *  @brief  The resource is still in use  
 */

/*!
 *  @def    HeapBufMP_S_ALREADYSETUP
 *  @brief  The module has been already setup  
 */

/*!
 *  @def    HeapBufMP_S_SUCCESS
 *  @brief  Operation is successful.
 */

/*!
 *  @def    HeapBufMP_E_FAIL
 *  @brief  Generic failure.
 */

/*!
 *  @def    HeapBufMP_E_INVALIDARG
 *  @brief  Argument passed to function is invalid.
 */

/*!
 *  @def    HeapBufMP_E_MEMORY
 *  @brief  Operation resulted in memory failure.
 */

/*!
 *  @def    HeapBufMP_E_ALREADYEXISTS
 *  @brief  The specified entity already exists.
 */

/*!
 *  @def    HeapBufMP_E_NOTFOUND
 *  @brief  Unable to find the specified entity.
 */

/*!
 *  @def    HeapBufMP_E_TIMEOUT
 *  @brief  Operation timed out.
 */

/*!
 *  @def    HeapBufMP_E_INVALIDSTATE
 *  @brief  Module is not initialized.
 */

/*!
 *  @def    HeapBufMP_E_OSFAILURE
 *  @brief  A failure occurred in an OS-specific call  */

/*!
 *  @def    HeapBufMP_E_RESOURCE
 *  @brief  Specified resource is not available  */

/*!
 *  @def    HeapBufMP_E_RESTART
 *  @brief  Operation was interrupted. Please restart the operation  */

/* =============================================================================
 *  Structures & Enums
 * =============================================================================
 */

/*!
 *  @brief  HeapBufMP_Handle type
 */
typedef struct HeapBufMP_Object *HeapBufMP_Handle;

/*!
 *  @brief  Structure defining parameters for the HeapBufMP module.
 */
typedef struct HeapBufMP_Params {
    String name;
    /*!< Name of this instance.
     *
     *  The name (if not NULL) must be unique among all HeapBufMP
     *  instances in the entire system.  When creating a new
     *  heap, it is necessary to supply an instance name.
     *
     *  The name does not have to be persistent.  The supplied string is copied
     *  into persistent memory.
     */
    
    UInt16 regionId;
    /*!< Shared region ID
     *
     *  The index corresponding to the shared region from which shared memory
     *  will be allocated.
     */
    
    /*! @cond */
    Ptr sharedAddr;
    /*!< Physical address of the shared memory
     *
     *  This value can be left as 'null' unless it is required to place the
     *  heap at a specific location in shared memory.  If sharedAddr is null,
     *  then shared memory for a new instance will be allocated from the 
     *  heap belonging to the region identified by #HeapBufMP_Params::regionId.
     */
    /*! @endcond */
     
    SizeT blockSize;
    /*!< Size (in MAUs) of each block.
     *
     *  HeapBufMP will round the blockSize up to the nearest multiple of the
     *  alignment, so the actual blockSize may be larger. When creating a
     *  HeapBufMP dynamically, this needs to be taken into account to determine
     *  the proper buffer size to pass in.
     *
     *  Required parameter.
     *
     *  The default size of the blocks is 0 MAUs.
     */
    
    UInt numBlocks;
    /*!<Number of fixed-size blocks.
     *
     *  This is a required parameter for all new HeapBufMP instances.
     */
    
    SizeT align;
    /*!< Alignment (in MAUs) of each block.
     *
     *  The alignment must be a power of 2. If the value 0 is specified,
     *  the value will be changed to meet minimum structure alignment 
     *  requirements and the cache alignment size of the region in which the
     *  heap will be placed.  Therefore, the actual alignment may be larger.
     *
     *  The default alignment is 0.
     */
     
    Bool exact;
    /*!< Use exact matching
     *
     *  Setting this flag will allow allocation only if the requested size
     *  is equal to (rather than less than or equal to) the buffer's block
     *  size.
     */
     
    GateMP_Handle gate;
    /*!< GateMP used for critical region management of the shared memory 
     *
     *  Using the default value of NULL will result in use of the GateMP
     *  system gate for context protection.
     */
    
} HeapBufMP_Params;

/*!
 *  @brief  Stats structure for the HeapBufMP_getExtendedStats API.
 */
typedef struct HeapBufMP_ExtendedStats {
    UInt maxAllocatedBlocks;
    /*!< The maximum number of blocks allocated from this heap at any point in 
     *  time during the lifetime of this HeapBufMP instance.
     */
     
    UInt numAllocatedBlocks;
    /*!< The total number of blocks currently allocated in this HeapBufMP 
     *  instance.
     */
} HeapBufMP_ExtendedStats;

/* =============================================================================
 *  HeapBufMP Module-wide Functions
 * =============================================================================
 */

/*!
 *  @brief      Close a HeapBufMP instance
 *
 *  Closing an instance will free local memory consumed by the opened
 *  instance. All opened instances should be closed before the instance 
 *  is deleted.
 *
 *  @param      handlePtr   Pointer to handle returned from #HeapBufMP_open
 *
 *  @sa         HeapBufMP_open
 */
Int HeapBufMP_close(HeapBufMP_Handle *handlePtr);
 
/*!
 *  @brief      Create a HeapBufMP instance
 *
 *  @param      params      HeapBufMP parameters
 *
 *  @return     HeapBufMP Handle
 */
HeapBufMP_Handle HeapBufMP_create(const HeapBufMP_Params *params);

/*! 
 *  @brief      Delete a created HeapBufMP instance 
 *
 *  @param      handlePtr   Pointer to handle to delete.
 */
Int HeapBufMP_delete(HeapBufMP_Handle *handlePtr);

/*!
 *  @brief      Open a created HeapBufMP instance
 *
 *  Once an instance is created, an open can be performed. The 
 *  open is used to gain access to the same HeapBufMP instance. 
 *  Generally an instance is created on one processor and opened on the 
 *  other processor.
 *
 *  The open returns a HeapBufMP instance handle like the create, 
 *  however the open does not initialize the shared memory. The supplied
 *  name is used to identify the created instance.
 *
 *  Call #HeapBufMP_close when the opened instance is not longer needed.
 *
 *  @param      name        Name of created HeapBufMP instance
 *  @param      handlePtr   Pointer to HeapBufMP handle to be opened
 *
 *  @return     HeapBufMP status:
 *              - #HeapBufMP_S_SUCCESS: Heap successfully opened
 *              - #HeapBufMP_E_NOTFOUND: Heap is not yet ready to be opened.
 *              - #HeapBufMP_E_FAIL: A general failure has occurred
 * 
 *  @sa         HeapBufMP_close
 */
Int HeapBufMP_open(String name, HeapBufMP_Handle *handlePtr);

/*! @cond */
Int HeapBufMP_openByAddr(Ptr sharedAddr, HeapBufMP_Handle *handlePtr);

/*! @endcond */

/*!
 *  @brief      Initialize a HeapBufMP parameters struct
 *
 *  @param[out] params      Pointer to GateMP parameters
 *
 */
void HeapBufMP_Params_init(HeapBufMP_Params *params);

/*! @cond */
/*!
 *  @brief      Amount of shared memory required for creation of each instance
 *
 *  @param[in]  params      Pointer to the parameters that will be used in
 *                          the create.
 *
 *  @return     Number of MAUs needed to create the instance.
 */
SizeT HeapBufMP_sharedMemReq(const HeapBufMP_Params *params);

/*! @endcond */

/* =============================================================================
 *  HeapBufMP Per-instance Functions
 * =============================================================================
 */

/*!
 *  @brief      Allocate a block of memory of specified size and alignment
 *
 *  The actual block returned may be larger than requested to satisfy
 *  alignment requirements.
 *
 *  HeapBufMP_alloc will lock the heap using the HeapBufMP gate
 *  while it traverses the list of free blocks to find a large enough block
 *  for the request.
 *
 *  Guidelines for using large heaps and multiple alloc() calls.
 *      - If possible, allocate larger blocks first. Previous allocations
 *        of small memory blocks can reduce the size of the blocks
 *        available for larger memory allocations.
 *      - Realize that alloc() can fail even if the heap contains a
 *        sufficient absolute amount of unalloccated space. This is
 *        because the largest free memory block may be smaller than
 *        total amount of unallocated memory.
 *
 *  @param      handle    Handle to previously created/opened instance.
 *  @param      size      Size to be allocated (in MADUs)
 *  @param      align     Alignment for allocation (power of 2)
 *
 *  @sa         HeapBufMP_free
 */
void *HeapBufMP_alloc(HeapBufMP_Handle handle, SizeT size, SizeT align);

/*!
 *  @brief      Frees a block of memory.
 *
 *  free() places the memory block specified by addr and size back into the
 *  free pool of the heap specified. The newly freed block is combined with
 *  any adjacent free blocks. The space is then available for further
 *  allocation by alloc().
 *
 *  #HeapBufMP_free will lock the heap using the HeapBufMP gate if one is 
 *  specified or the system GateMP if not.
 *
 *  @param      handle    Handle to previously created/opened instance.
 *  @param      block     Block of memory to be freed.
 *  @param      size      Size to be freed (in MADUs)
 *
 *  @sa         HeapBufMP_alloc
 */
void HeapBufMP_free(HeapBufMP_Handle handle, Ptr block, SizeT size);

/*!
 *  @brief      Get extended memory statistics
 *
 *  This function retrieves the extended statistics for a HeapBufMP 
 *  instance.  It does not retrieve the standard Memory_Stats 
 *  information.  Refer to #HeapBufMP_ExtendedStats for more information
 *  regarding what information is returned.
 *
 *  @param      handle    Handle to previously created/opened instance.
 *  @param[out] stats     ExtendedStats structure
 *
 *  @sa
 */
void HeapBufMP_getExtendedStats(HeapBufMP_Handle handle,
                                HeapBufMP_ExtendedStats *stats);

/*!
 *  @brief      Get memory statistics
 *
 *  @param[in]  handle    Handle to previously created/opened instance.
 *  @param[out] stats     Memory statistics structure
 *
 *  @sa
 */
void HeapBufMP_getStats(HeapBufMP_Handle handle, Ptr stats);
    

/*
 */

/*
 *  @(#) ti.ipc; 1, 0, 0, 0,1; 5-22-2012 16:16:05; /db/vtree/library/trees/ipc/ipc-h32/src/ xlibrary

 */



/*
===============================================================================
//  Copyright(C):
//
//  FILENAME: <Timer.h> (Platfform.pjt)
//
//  Subsystem: Low Level Driver Library.
//
//  Purpose of file:
//  
//      To enable the users to have a APIs that will initialize Timers, gets 
//  Time Lapsed in us, ms and secs, 
//
//  Dependencies, Limitations, and Design Notes:
//
//=============================================================================
// Version   Date     Modification_History                               Author
//=============================================================================
//  
// 								   	
//
===============================================================================
*/

/*****************************************************************************/
/* STDIO.H v7.3.4                                                            */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/



/**
 *   @file  csl_tmr.h
 *
 *   @brief   
 *      This is the main header file for the TIMER Module which defines
 *      all the data structures and exported API.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2002, 2003, 2004, 2005, 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** @defgroup CSL_TIMER_API TIMER
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 * The timer can be configured as a general-purpose 64-bit timer, dual general-purpose 32-bit
 * timers, or a watchdog timer. When configured as a dual 32-bit timers, each half can operate in
 * conjunction (chain mode) or independently (unchained mode) of each other. The timer can be
 * configured in one of three modes using the timer mode (TIMMODE) bits in the timer global control
 * register (TGCR): a 64-bit general-purpose (GP) timer, dual 32-bit timers (Timer Low and Timer
 * High), or a watchdog timer. When configured as dual 32-bit timers, each half can operate
 * dependently (chain mode) or independently (unchained mode) of each other. At reset, the timer is
 * configured as a 64-bit GP timer. The watchdog timer function can be enabled if desired, via the
 * TIMMODE bits in timer global control register (TGCR) and WDEN bit in the watchdog timer
 * control register WDTCR). Once the timer is configured as a watchdog timer, it cannot be reconfigured
 * as a regular timer until a device reset occurs. The timer has one input pin (TINPL) and
 * one output pin (TOUTL). The timer control register (TCR) controls the function of the input and
 * output pin.
 * The timers can be used to: time events, count events, generate pulses, interrupt the CPU, and
 * send synchronization events to the EDMA.
 *
 *  @subsection References
 *    -# Timer User's Guide SPRU818.pdf (December 2005)
 */



/*  ===========================================================================
 *  Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2006, 2008
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** ============================================================================
 *   @file  cslr_tmr.h
 *
 *   @path  $(CSLPATH)\inc
 *
 *   @desc  This file contains the Register Desciptions for TIMER
 *
 */


/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint8 RSVD0[4];
    volatile Uint32 EMUMGT_CLKSPD;
    volatile Uint8 RSVD1[8];
    volatile Uint32 CNTLO;
    volatile Uint32 CNTHI;
    volatile Uint32 PRDLO;
    volatile Uint32 PRDHI;
    volatile Uint32 TCR;
    volatile Uint32 TGCR;
    volatile Uint32 WDTCR;
} CSL_TmrRegs;


/*************************************************************************** Overlay structure typedef definition
\**************************************************************************/
typedef volatile CSL_TmrRegs             *CSL_TmrRegsOvly;


/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* EMUMGT_CLKSPD */


/*----CLKDIV Tokens----*/




/* CNTLO */



/* CNTHI */



/* PRDLO */



/* PRDHI */



/* TCR */





/* Timer in stop mode */









/* Timer in stop mode */








/* TGCR */





/* Strat the timer */

/* the timer in reset mode */


/* Strat the timer */

/* the timer in reset mode */


/* WDTCR */


/*----WDKEY Tokens----*/



/*----WDEN Tokens----*/




/**
@defgroup CSL_TIMER_SYMBOL  TIMER Symbols Defined
@ingroup CSL_TIMER_API
*/
/**
@defgroup CSL_TIMER_DATASTRUCT  TIMER Data Structures
@ingroup CSL_TIMER_API
*/
/**
@defgroup CSL_TIMER_FUNCTION  TIMER Functions
@ingroup CSL_TIMER_API
*/
/**
@defgroup CSL_TIMER_ENUM TIMER Enumerated Data Types
@ingroup CSL_TIMER_API
*/

/**
@addtogroup CSL_TIMER_ENUM
@{
*/

/**
 * General purpose global type def declarations
 */

/**
 *  @brief This enum describes the commands used to control the GP timer through
 *  CSL_tmrHwControl()
 */
typedef enum {
    /**
     * @brief   Loads the GP Timer Period Register Low
     * @param   Uint32 *
     */
    CSL_TMR_CMD_LOAD_PRDLO = 0,

    /**
     * @brief   Loads the GP Timer Period Register High
     * @param   Uint32 *
     */
    CSL_TMR_CMD_LOAD_PRDHI = 1,

    /**
     * @brief   Loads the GP Timer Pre-scalar value for CNTHI
     * @param   Uint8 *
     */
    CSL_TMR_CMD_LOAD_PSCHI = 2,

    /**
     * @brief   Enable the GP timer Low
     * @param   CSL_TmrEnamode
     */
    CSL_TMR_CMD_START_TIMLO = 3,

    /**
     * @brief   Enable the GP timer High
     * @param   CSL_TmrEnamode
     */
    CSL_TMR_CMD_START_TIMHI = 4,

    /**
     * @brief   Stop the GP timer Low
     * @param   None
     */
    CSL_TMR_CMD_STOP_TIMLO = 5,

    /**
     * @brief   Stop the GP timer High
     * @param   None
     */
    CSL_TMR_CMD_STOP_TIMHI = 6,

    /**
     * @brief   Reset the GP timer Low
     * @param   None
     */
    CSL_TMR_CMD_RESET_TIMLO = 7,

    /**
     * @brief   Reset the GP timer High
     * @param   None
     */
    CSL_TMR_CMD_RESET_TIMHI = 8,

    /**
     * @brief   Start the timer in GPtimer64 OR Chained mode
     * @param   None
     */
    CSL_TMR_CMD_START64 = 9,

    /**
     * @brief   Stop the timer of GPtimer64 OR Chained
     * @param   CSL_TmrEnamode
     */
    CSL_TMR_CMD_STOP64 = 10,

    /**
     * @brief   Reset the timer of GPtimer64 OR Chained
     * @param   None
     */
    CSL_TMR_CMD_RESET64 = 11,

    /**
     * @brief	Enable the timer in watchdog mode
     * @param	CSL_TmrEnamode
     */
    CSL_TMR_CMD_START_WDT = 12,

    /**
     * @brief	Loads the watchdog key
     * @param	Uint16
     */
    CSL_TMR_CMD_LOAD_WDKEY = 13
} CSL_TmrHwControlCmd;

/**
 *  @brief This enum describes the commands used to get status of various parameters of the
 *  GP timer. These values are used in CSL_tmrGetHwStatus()
 */
typedef enum {
    /**
     * @brief   Gets the current value of the GP timer CNTLO register
     * @param   Uint32 *
     */
    CSL_TMR_QUERY_COUNT_LO = 0,

    /**
     * @brief   Gets the current value of the GP timer CNTHI register
     * @param   Uint32 *
     */
    CSL_TMR_QUERY_COUNT_HI = 1,
    /**
     * @brief   This query command returns the status
     *          about whether the CNTLO is running or stopped
     *
     * @param   CSL_TmrTstat
     */
    CSL_TMR_QUERY_TSTAT_LO = 2,

    /**
     * @brief   This query command returns the status
     *          about whether the CNTHI is running or stopped
     *
     * @param   CSL_TmrTstat
     */
    CSL_TMR_QUERY_TSTAT_HI = 3,

    /**
     * @brief	This query command returns the status about whether the timer
     *		is in watchdog mode or not
     * @param	CSL_WdflagBitStatus
     */
    CSL_TMR_QUERY_WDFLAG_STATUS = 4
} CSL_TmrHwStatusQuery;

/**
 *  @brief This enum describes whether the Timer Clock input is gated or not gated.
 */
typedef enum {
    /** timer input not gated */
    CSL_TMR_CLOCK_INP_NOGATE = 0,

    /** timer input gated */
    CSL_TMR_CLOCK_INP_GATE = 1
} CSL_TmrIpGate;

/**
 *  @brief This enum describes the Timer Clock source selection.
 */
typedef enum {
    /** timer clock INTERNAL source selection */
    CSL_TMR_CLKSRC_INTERNAL = 0,

    /** timer clock Timer input pin source selection */
    CSL_TMR_CLKSRC_TMRINP = 1
} CSL_TmrClksrc;

/**
 *  @brief This enum describes the enabling/disabling of Timer.
 */
typedef enum {
    /** The timer is disabled and maintains current value */
    CSL_TMR_ENAMODE_DISABLE = 0,

    /**  The timer is enabled one time */
    CSL_TMR_ENAMODE_ENABLE = 1,

    /**  The timer is enabled continuously */
    CSL_TMR_ENAMODE_CONT = 2
} CSL_TmrEnamode;

/**
 *  @brief This enum describes the Timer Clock cycles (1/2/3/4).
 */
typedef enum {
    /** One timer clock cycle */
    CSL_TMR_PWID_ONECLK = 0,

    /** Two timer clock cycle */
    CSL_TMR_PWID_TWOCLKS = 1,

    /** Three timer clock cycle */
    CSL_TMR_PWID_THREECLKS = 2,

    /** Four timer clock cycle */
    CSL_TMR_PWID_FOURCLKS = 3
} CSL_TmrPulseWidth;

/**
 *  @brief This enum describes the mode of Timer Clock (Pulse/Clock).
 */
typedef enum {
    /** Pulse mode */
    CSL_TMR_CP_PULSE = 0,

    /** Clock mode */
    CSL_TMR_CP_CLOCK = 1
} CSL_TmrClockPulse;

/**
 *  @brief This enum describes the Timer input inverter control
 */
typedef enum {
    /** Un inverted timer input drives timer */
    CSL_TMR_INVINP_UNINVERTED = 0,

    /** Inverted timer input drives timer */
    CSL_TMR_INVINP_INVERTED = 1
} CSL_TmrInvInp;

/**
 *  @brief This enum describes the Timer output inverter control
 */
typedef enum {
    /** Un inverted timer output */
    CSL_TMR_INVOUTP_UNINVERTED = 0,

    /** Inverted timer output */
    CSL_TMR_INVOUTP_INVERTED = 1
} CSL_TmrInvOutp;

/**
 *  @brief This enum describes the mode of Timer (GPT/WDT/Chained/Unchained).
 */
typedef enum {
    /** The timer is in 64-bit GP timer mode */
    CSL_TMR_TIMMODE_GPT = 0,

    /** The timer is in dual 32-bit timer, unchained mode */
    CSL_TMR_TIMMODE_DUAL_UNCHAINED = 1,

    /** The timer is in 64-bit Watchdog timer mode */
    CSL_TMR_TIMMODE_WDT = 2,

    /** The timer is in dual 32-bit timer, chained mode */
    CSL_TMR_TIMMODE_DUAL_CHAINED = 3
} CSL_TmrMode;

/**
 *  @brief This enum describes the reset condition of Timer (ON/OFF).
 */
typedef enum {
    /** timer TIMxx is in reset */
    CSL_TMR_TIMxxRS_RESET_ON = 0,

    /** timer CNTHI is not in reset. CNTHI can be used as a 32-bit timer */
    CSL_TMR_TIMxxRS_RESET_OFF = 1
} CSL_TmrState;

/**  @brief This enum describes the status of Timer.
 */
typedef enum {
    /** Timer status drives High */
    CSL_TMR_TSTAT_HIGH = 1,

    /** Timer status drives Low */
    CSL_TMR_TSTAT_LOW = 0
} CSL_TmrTstat;

/** @brief This enumeration describes the flag bit status of the timer in watchdog mode
 */
typedef enum {
	/** No watchdog timeout occurred */
	CSL_TMR_WDFLAG_NOTIMEOUT = 0,

	/** Watchdog timeout occurred */
	CSL_TMR_WDFLAG_TIMEOUT = 1
} CSL_TmrWdflagBitStatus;

/**
@}
*/

/** @addtogroup CSL_TIMER_DATASTRUCT
 @{ */

/**
 * @brief Hardware setup structure.
 */
typedef struct {
    /** 32 bit load value to be loaded to Timer Period Register low */
    Uint32 tmrTimerPeriodLo;

    /** 32 bit load value to be loaded to Timer Period Register High */
    Uint32 tmrTimerPeriodHi;

    /** 32 bit load value to be loaded to Timer Counter Register Low */
    Uint32 tmrTimerCounterLo;

    /** 32 bit load value to be loaded to Timer Counter Register High */
    Uint32 tmrTimerCounterHi;

    /** TIEN determines if the timer clock is gated by the timer input.
     *  Applicable only when CLKSRC=0
     */
    CSL_TmrIpGate tmrIpGateHi;

    /** CLKSRC determines the selected clock source for the timer */
    CSL_TmrClksrc tmrClksrcHi;

    /** Pulse width. used in pulse mode (C/P_=0) by the timer */
    CSL_TmrPulseWidth tmrPulseWidthHi;

    /** Clock/Pulse mode for timerHigh output */
    CSL_TmrClockPulse tmrClockPulseHi;

    /** Timer input inverter control. Only affects operation
     *  if CLKSRC=1, Timer Input pin
     */
    CSL_TmrInvInp tmrInvInpHi;

    /** Timer output inverter control */
    CSL_TmrInvOutp tmrInvOutpHi;

    /** TIEN determines if the timer clock is gated by the timer input.
     *  Applicable only when CLKSRC=0
     */
    CSL_TmrIpGate tmrIpGateLo;

    /** CLKSRC determines the selected clock source for the timer */
    CSL_TmrClksrc tmrClksrcLo;

    /** Pulse width. used in pulse mode (C/P_=0) by the timer */
    CSL_TmrPulseWidth tmrPulseWidthLo;

    /** Clock/Pulse mode for timerLow output */
    CSL_TmrClockPulse tmrClockPulseLo;

    /** Timer input inverter control. Only affects operation
     *  if CLKSRC=1, Timer Input pin
     */
    CSL_TmrInvInp tmrInvInpLo;

    /** Timer output inverter control */
    CSL_TmrInvOutp tmrInvOutpLo;

    /** CNTHI pre-scalar counter specifies the count for CNTHI */
    Uint8 tmrPreScalarCounterHi;

    /** Configures the GP timer in GP mode or in
     *  general purpose timer mode or Dual 32 bit timer mode
     */
    CSL_TmrMode tmrTimerMode;
} CSL_TmrHwSetup;

/**
 *  @brief Config-structure Used to configure the GP timer using CSL_tmrHwSetupRaw()
 */
typedef struct {
    /** Timer Counter Register Low */
    Uint32 CNTLO;
    /** Timer Counter Register High */
    Uint32 CNTHI;
    /** Timer Period Register Low */
    Uint32 PRDLO;
    /** Timer Period Register High */
    Uint32 PRDHI;
    /** Timer Control Register */
    Uint32 TCR;
    /** Timer Global Control Register */
    Uint32 TGCR;
    /** Watchdog Timer Control Register */
    Uint32 WDTCR;
} CSL_TmrConfig;

/**
 * @brief Module specific context information. Present implementation of GP
 *        timer CSL doesn't have any context information.
 */
typedef struct {
    /** Context information of GP timer CSL.
     *  The below declaration is just a place-holder for future implementation.
     */
    Uint16 contextInfo;
} CSL_TmrContext;

/** @brief Module specific parameters. Present implementation of GP timer CSL
 *         doesn't have any module specific parameters.
 */
typedef struct {
    /** Bit mask to be used for module specific parameters. The below
     *  declaration is just a place-holder for future implementation.
     */
    CSL_BitMask16 flags;
} CSL_TmrParam;

/** @brief This structure contains the base-address information for the
 *         peripheral instance
 */
typedef struct {
    /** Base-address of the configuration registers of the peripheral
     */
    CSL_TmrRegsOvly regs;
} CSL_TmrBaseAddress;

/**
 * @brief  Watchdog timer object structure.
 */
typedef struct {
    /** Pointer to the register overlay structure of the GP timer */
    CSL_TmrRegsOvly regs;

    /** Instance of GP timer being referred by this object  */
    CSL_InstNum tmrNum;
} CSL_TmrObj;


/**
 * @brief This data type is used to return the handle to the CSL of the GP timer
 */
typedef CSL_TmrObj *CSL_TmrHandle;

/**
@}
*/

/**
@addtogroup CSL_TIMER_SYMBOL
@{
*/

/** @brief Default hardware setup parameters */

/** @brief Default values for config structure */

/**
@}
*/

/** @addtogroup CSL_TIMER_FUNCTION
 @{ */

/*******************************************************************************
 * Timer global function declarations
 ******************************************************************************/

extern CSL_Status CSL_tmrInit (
    CSL_TmrContext *pContext
);

extern CSL_TmrHandle CSL_tmrOpen (
    CSL_TmrObj   *tmrObj,
    CSL_InstNum  tmrNum,
    CSL_TmrParam *pTmrParam,
    CSL_Status   *status
);

extern CSL_Status CSL_tmrGetBaseAddress (
    CSL_InstNum        tmrNum,
    CSL_TmrParam       *pTmrParam,
    CSL_TmrBaseAddress *pBaseAddress
);

extern CSL_Status CSL_tmrClose (
    CSL_TmrHandle hTmr
);

extern CSL_Status CSL_tmrHwSetup (
    CSL_TmrHandle  hTmr,
    CSL_TmrHwSetup *hwSetup
);

extern CSL_Status CSL_tmrHwControl(
    CSL_TmrHandle       hTmr,
    CSL_TmrHwControlCmd cmd,
    void                *cmdArg
);

extern CSL_Status CSL_tmrGetHwStatus (
    CSL_TmrHandle        hTmr,
    CSL_TmrHwStatusQuery query,
    void                 *response
);

extern CSL_Status CSL_tmrHwSetupRaw (
    CSL_TmrHandle hTmr,
    CSL_TmrConfig *config
);

extern CSL_Status CSL_tmrGetHwSetup (
    CSL_TmrHandle  hTmr,
    CSL_TmrHwSetup *hwSetup
);

/**
@}
*/



//#include <ti/csl/src/intc/csl_intc.h>
//#include <ti/csl/src/intc/csl_intcAux.h>
/**
 *   @file  csl_tmrAux.h
 *
 *   @brief   
 *      This is the TIMER Auxilary Header File which exposes the various
 *      CSL Functional Layer API's to configure the TIMER Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2002, 2003, 2004, 2005, 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/




/** @addtogroup CSL_TIMER_FUNCTION
 @{ */
        
/** ============================================================================
 *   @n@b CSL_tmrGetTimHiCount
 *
 *   @b Description
 *   @n This function gets the value of the CNTHI counter
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Pointer to the object that holds reference to the
                     instance of TIMER requested after the call
         countHi     Output parameter to get the CNTHI value
     @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n The argument countHi is populated with the contents of the CNTHI register
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Reads
 *   @n  TMR_CNTHI_CNT
 *
 *   @b  Example
 *   @verbatim
        CSL_TmrHandle   hTmr;
        Unit32*         countHi;
        ...
        CSL_tmrGetTimHiCount(hTmr, &countHi);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_tmrGetTimHiCount (CSL_TmrHandle hTmr,Uint32 *countHi)
{
    *countHi = (((hTmr->regs->CNTHI) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ===========================================================================
 *   @n@b CSL_tmrGetTimLoCount
 *
 *   @b Description
 *   @n This function gets the value of the CNTLO counter
 *
 *   @b Arguments
 *   @verbatim
         hTmr       Pointer to the object that holds reference to the
                    instance of TIMER requested after the call
         countLo    Output parameter to get the CNTLO value
     @endverbatim
 *
 *   <b> Return Value </b>  
 *      None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n The argument countLo is populated with the contents of the CNTLO register
 *
 *   @b Reads
 *   @n TMR_CNTLO_CNT
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        Unit32        *countLo;
        ...
        CSL_tmrGetTimLoCount(hTmr, &countLo);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_tmrGetTimLoCount (CSL_TmrHandle hTmr,Uint32* countLo)
{
    *countLo = (((hTmr->regs->CNTLO) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ===========================================================================
 *   @n@b CSL_tmrGetTstatLoStatus
 *
 *   @b Description
 *   @n This function gets the status of the TINTLO
 *
 *   @b Arguments
 *   @verbatim
         hTmr   Pointer to the object that holds reference to the
                instance of TIMER requested after the call
     @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n CSL_TmrTstatLo - TINTLO status value
 *   @li CSL_TMR_TSTAT_LO_LOW  - Data low
 *   @li CSL_TMR_TSTAT_LO_HIGH - Data High
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n TMR_TCR_TSTAT_LO
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle  hTmr;
        CSL_TmrTstatLo statusLo;
        ...
        statusLo = CSL_tmrGetTstatLoStatus(hTmr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_TmrTstat CSL_tmrGetTstatLoStatus (CSL_TmrHandle hTmr)
{        
    return (CSL_TmrTstat)(((hTmr->regs->TCR) & (0x00000001u)) >> (0x00000000u));
}

/** ===========================================================================
 *   @n@b CSL_tmrGetTstatHiStatus
 *
 *   @b Description
 *   @n This function gets the status of the TINTHI
 *
 *   @b Arguments
 *   @verbatim
         hTmr   Pointer to the object that holds reference to the
                instance of TIMER requested after the call
     @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n CSL_TmrTstatHi - TINTHI status value
 *   @li CSL_TMR_TSTATHI_LOW  - Data low
 *   @li CSL_TMR_TSTATHI_HIGH - Data High
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n TMR_TCR_TSTAT_HI
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle  hTmr;
        CSL_TmrTstatHi statusHi;
        ...
        statusHi = CSL_tmrGetTstatHiStatus(hTmr);
        ...
     @endverbatim
 * ============================================================================
 */
static inline CSL_TmrTstat CSL_tmrGetTstatHiStatus (CSL_TmrHandle hTmr)
{
    return (CSL_TmrTstat)(((hTmr->regs->TCR) & (0x00010000u)) >> (0x00000010u));
}

/** ===========================================================================
 *   @n@b CSL_tmrGetWdflagStatus
 *
 *   @b Description
 *   @n This function gets the status of the WDFLAG
 *
 *   @b Arguments
 *   @verbatim
         hTmr   Pointer to the object that holds reference to the
                instance of TIMER requested after the call
     @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n CSL_TmrFlagBitStatus - WDFLAG status value
 *   @li  CSL_TMR_WDFLAG_NOTIMEOUT  - no watchdog timeout occurred
 *   @li  CSL_TMR_WDFLAG_TIMEOUT    - watchdog timeout occurred
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called and the
 *       Timer should be set in WATCHDOG mode
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n TMR_WDTCR_WDFLAG
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle          hTmr;
        CSL_TmrWdflagBitStatus status;
        ...
        status = CSL_tmrGetWdflagStatus(hTmr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_TmrWdflagBitStatus CSL_tmrGetWdflagStatus (CSL_TmrHandle hTmr)
{
    return (CSL_TmrWdflagBitStatus)(((hTmr->regs->WDTCR) & (0x00008000u)) >> (0x0000000Fu));
}

/** ============================================================================
 *   @n@b CSL_TmrLoadPrdLo
 *
 *   @b Description
 *      Loads the General purpose timer LOW period register.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Gptimer instance
         loadVal     Value to be loaded to the Gptimer period register Low
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n Period register is loaded with the given value.
 *
 *   @b Writes
 *   @n TMR_PRDLO_PRDLO
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        Uint32       loadVal;

        loadVal = 10;
        CSL_TmrLoadPrdLo(hWdt, &loadVal);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrLoadPrdLo (CSL_TmrHandle hTmr,Uint32* loadVal)
{
    ((hTmr->regs->PRDLO) = ((hTmr->regs->PRDLO) & ~(0xFFFFFFFFu)) | (((*loadVal) << (0x00000000u)) & (0xFFFFFFFFu))); 
}

/** ============================================================================
 *   @n@b CSL_TmrLoadPrdHi
 *
 *   @b Description
 *      Loads the General purpose timer HIGH period register 
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the GPtimer instance
         loadVal     Value to be loaded to the Gptimer period register High
     @endverbatim
 *
 *   <b> Return Value </b>
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  Period register is loaded with the given value.
 *
 *   @b Writes
 *   @n TMR_PRDHI_PRDHI
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle   hTmr;
        Uint32          loadVal;
        ...
        loadVal = 10;
        CSL_TmrLoadPrdHi(hWdt, &loadVal);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrLoadPrdHi (CSL_TmrHandle hTmr,Uint32* loadVal)
{
    ((hTmr->regs->PRDHI) = ((hTmr->regs->PRDHI) & ~(0xFFFFFFFFu)) | (((*loadVal) << (0x00000000u)) & (0xFFFFFFFFu))); 
}

/** ============================================================================
 *   @n@b CSL_TmrLoadPrescalarHi
 *
 *   @b Description
 *      Configures the prescalar values for the HIGH Timer.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Timer Instance
         loadVal     Value to be loaded to the PRESCALAR bits in the TGCR register
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  Gptimer pre scalar register is loaded with the given value.
 *
 *   @b Writes
 *   @n TMR_TGCR_PSCHI
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        Uint8         *loadVal;
        ...
        CSL_TmrLoadPrescalarHi(hWdt, &loadVal);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrLoadPrescalarHi (CSL_TmrHandle hTmr, Uint8* loadVal)
{
    ((hTmr->regs->TGCR) = ((hTmr->regs->TGCR) & ~(0x00000F00u)) | (((*loadVal) << (0x00000008u)) & (0x00000F00u)));
}

/** ============================================================================
 *   @n@b CSL_TmrStartHi
 *
 *   @b Description
 *      The functions starts the HIGH timer.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Timer instance
         countMode   Specifies the timer counting mode (OFF/CONTINIOUS/SINGLE Shot)
     @endverbatim
 *
 *   <b> Return Value </b>
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The HIGH timer is brought out of reset and is activated in the 
 *       provided counting mode.
 *
 *   @b Writes
 *   @n TMR_TGCR_TIMHIRS=1,TMR_TCR_ENAMODE_HI
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle  hTmr;
        ...
        CSL_TmrStartHi(hTmr, CSL_TMR_ENAMODE_ENABLE);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrStartHi (CSL_TmrHandle hTmr, CSL_TmrEnamode countMode)
{
    /* Bring the HIGH Timer out of reset. */
    (((hTmr->regs->TGCR)) = (((hTmr->regs->TGCR)) & ~(0x00000002u)) | ((((0x00000001u)) << (0x00000001u)) & (0x00000002u)));

    /* Configure the HIGH TIMER with the appropriate counting mode. */
    ((hTmr->regs->TCR) = ((hTmr->regs->TCR) & ~(0x00C00000u)) | (((countMode) << (0x00000016u)) & (0x00C00000u)));
    return;
}

/** ============================================================================
 *   @n@b CSL_TmrStartLo
 *
 *   @b Description
 *      The function starts the LOW Timer.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Gptimer instance
         countMode   Specifies the timer counting mode (OFF/CONTINIOUS/SINGLE Shot)
     @endverbatim
 *
 *   <b> Return Value </b>
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The LOW timer is brought out of reset and is activated in the 
 *       provided counting mode.
 *
 *   @b Writes
 *   @n TMR_TGCR_TIMLORS=1,TMR_TCR_ENAMODE_LO
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle  hTmr;
        ...
        CSL_TmrStartLo(hTmr, CSL_TMR_ENAMODE_ENABLE);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrStartLo (CSL_TmrHandle hTmr, CSL_TmrEnamode countMode)
{
    /* Bring the LOW Timer out of reset. */
    (((hTmr->regs->TGCR)) = (((hTmr->regs->TGCR)) & ~(0x00000001u)) | ((((0x00000001u)) << (0x00000000u)) & (0x00000001u)));

    /* Configure the LOW TIMER with the appropriate counting mode. */
    ((hTmr->regs->TCR) = ((hTmr->regs->TCR) & ~(0x000000C0u)) | (((countMode) << (0x00000006u)) & (0x000000C0u)));
}

/** ===========================================================================
 *   @n@b CSL_TmrStart64
 *
 *   @b Description
 *      The function starts the 64bit Timer by bringing both the LOW and HIGH
 *      timer out of reset.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Gptimer instance
         countMode   Specifies the timer counting mode (OFF/CONTINIOUS/SINGLE Shot)
     @endverbatim
 *
 *   <b> Return Value </b>
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n   Set the GP OR chained timer counting mode and
 *		  timer Low and High reset register.
 *
 *   @b Writes
 *   @n TMR_TGCR_TIMLORS=1,TMR_TGCR_TIMHIRS=1,
 *   @n TMR_TCR_ENAMODE_LO,TMR_TCR_ENAMODE_HI
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle  hTmr;
        ...
        CSL_TmrStart64(hTmr, CSL_TMR_ENAMODE_ENABLE);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrStart64 (CSL_TmrHandle  hTmr, CSL_TmrEnamode countMode)
{
    Uint32 tmpReg;

    /* Bring the LOW and HIGH Timer outs of reset. */
    tmpReg = hTmr->regs->TGCR;
    (((tmpReg)) = (((tmpReg)) & ~(0x00000001u)) | ((((0x00000001u)) << (0x00000000u)) & (0x00000001u)));
    (((tmpReg)) = (((tmpReg)) & ~(0x00000002u)) | ((((0x00000001u)) << (0x00000001u)) & (0x00000002u)));
    hTmr->regs->TGCR = tmpReg; 

    /* Configure the counting mode for both the LOW and HIGH Timers. */
    tmpReg = hTmr->regs->TCR;
    ((tmpReg) = ((tmpReg) & ~(0x000000C0u)) | (((countMode) << (0x00000006u)) & (0x000000C0u)));
    ((tmpReg) = ((tmpReg) & ~(0x00C00000u)) | (((countMode) << (0x00000016u)) & (0x00C00000u)));
    hTmr->regs->TCR = tmpReg;
}

/** ===========================================================================
 *   @n@b CSL_TmrStopLo
 *
 *   @b Description
 *      The function stops the LOW Timer
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Timer instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  Low Timer is disabled.
 *
 *   @b Writes
 *   @n TMR_TCR_ENAMODE_LO=0
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        ...
        CSL_TmrStopLo(hTmr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrStopLo (CSL_TmrHandle hTmr)
{
    (((hTmr->regs->TCR)) = (((hTmr->regs->TCR)) & ~(0x000000C0u)) | ((((0x00000000u)) << (0x00000006u)) & (0x000000C0u)));
}

/** ===========================================================================
 *   @n@b CSL_TmrStopHi
 *
 *   @b Description
 *      The function stops the HIGH Timer
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Timer instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  High Timer is disabled.
 *
 *   @b Writes
 *   @n TMR_TCR_ENAMODE_HI=0
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        ...
        CSL_TmrStopHi(hTmr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrStopHi (CSL_TmrHandle hTmr)
{
    (((hTmr->regs->TCR)) = (((hTmr->regs->TCR)) & ~(0x00C00000u)) | ((((0x00000000u)) << (0x00000016u)) & (0x00C00000u)));
}

/** ===========================================================================
 *   @n@b CSL_TmrStop64
 *
 *   @b Description
 *      The function stops the 64bit timer.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Timer instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The 64bit timer is stopped 
 *
 *   @b Writes
 *   @n TMR_TCR_ENAMODE_LO=0,TMR_TCR_ENAMODE_HI=0
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        ...
        CSL_TmrStop64(hWdt);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrStop64 (CSL_TmrHandle hTmr)
{
    Uint32 tmpReg;

    /* Disable the LOW and HIGH Timers. */
    tmpReg = hTmr->regs->TCR;
    (((tmpReg)) = (((tmpReg)) & ~(0x000000C0u)) | ((((0x00000000u)) << (0x00000006u)) & (0x000000C0u)));
    (((tmpReg)) = (((tmpReg)) & ~(0x00C00000u)) | ((((0x00000000u)) << (0x00000016u)) & (0x00C00000u)));
    hTmr->regs->TCR = tmpReg;
}

/** ===========================================================================
 *   @n@b CSL_TmrResetHi
 *
 *   @b Description
 *      The HIGH timer is moved to RESET state.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the HIGH timer instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n High timer is reset. 
 *
 *   @b Writes
 *   @n TMR_TGCR_TIMHIRS=0
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        ...
        CSL_TmrResetHi(hTmr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrResetHi (CSL_TmrHandle hTmr)
{
    (((hTmr->regs->TGCR)) = (((hTmr->regs->TGCR)) & ~(0x00000002u)) | ((((0x00000000u)) << (0x00000001u)) & (0x00000002u)));
}

/** ===========================================================================
 *   @n@b CSL_TmrResetLo
 *
 *   @b Description
 *      The LOW timer is moved to RESET state.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Gptimer instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n Low Timer is Reset 
 *
 *   @b Writes
 *   @n TMR_TGCR_TIMLORS=0
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        ...
        CSL_TmrResetLo(hWdt);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrResetLo (CSL_TmrHandle hTmr)
{
    (((hTmr->regs->TGCR)) = (((hTmr->regs->TGCR)) & ~(0x00000001u)) | ((((0x00000000u)) << (0x00000000u)) & (0x00000001u)));
}

/** ===========================================================================
 *   @n@b CSL_TmrReset64
 *
 *   @b Description
 *      The function resets the 64bit timer.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Timer instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  64bit Timer is reset.
 *
 *   @b Writes
 *   @n TMR_TGCR_TIMLORS=0,TMR_TGCR_TIMHIRS=0
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hTmr;
        ...
        CSL_TmrReset64(hTmr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrReset64 (CSL_TmrHandle hTmr)
{
    Uint32 tmpReg = hTmr->regs->TGCR;

    /* Move both the Low and High Timers into reset. */
    (((tmpReg)) = (((tmpReg)) & ~(0x00000001u)) | ((((0x00000000u)) << (0x00000000u)) & (0x00000001u)));
    (((tmpReg)) = (((tmpReg)) & ~(0x00000002u)) | ((((0x00000000u)) << (0x00000001u)) & (0x00000002u)));
    hTmr->regs->TGCR = tmpReg;
}

/** ===========================================================================
 *   @n@b CSL_TmrStartWdt
 *
 *   @b Description
 *      The function starts the timer in Watch Dog Mode.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Timer instance
         countMode   Specifies the timer counting mode (OFF/CONTINIOUS/SINGLE Shot)
     @endverbatim
 *
 *   <b> Return Value </b>
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  Timer has been started in WATCH Dog Mode.
 *
 *   @b Writes
 *   @n TMR_TGCR_TIMLORS=1,TMR_TGCR_TIMHIRS=1,TMR_WDTCR_WDEN=1,TMR_TCR_ENAMODE_LO,TMR_TCR_ENAMODE_HI;
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle  hWdt;
        ...
        CSL_TmrStartWdt(hWdt, CSL_TMR_ENAMODE_CONT);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrStartWdt (CSL_TmrHandle  hTmr,CSL_TmrEnamode countMode)
{
    Uint32 tmpReg = hTmr->regs->TGCR;

    /* Bring the LOW and HIGH Timers out of reset. */
    (((tmpReg)) = (((tmpReg)) & ~(0x00000001u)) | ((((0x00000001u)) << (0x00000000u)) & (0x00000001u)));
    (((tmpReg)) = (((tmpReg)) & ~(0x00000002u)) | ((((0x00000001u)) << (0x00000001u)) & (0x00000002u)));
    hTmr->regs->TGCR = tmpReg;

    /* Enable the Watch Dog Timer */
    (((hTmr->regs->WDTCR)) = (((hTmr->regs->WDTCR)) & ~(0x00004000u)) | ((((0x00000001u)) << (0x0000000Eu)) & (0x00004000u)));

    /* Enable the LOW and HIGH Timers to operate */
    tmpReg = hTmr->regs->TCR;
    ((tmpReg) = ((tmpReg) & ~(0x000000C0u)) | (((countMode) << (0x00000006u)) & (0x000000C0u)));
    ((tmpReg) = ((tmpReg) & ~(0x00C00000u)) | (((countMode) << (0x00000016u)) & (0x00C00000u)));
    hTmr->regs->TCR = tmpReg;
}

/** ===========================================================================
 *   @n@b CSL_TmrLoadtWdkey
 *
 *   @b Description
 *      The function loads the watch dog timer with the appropriate key.
 *
 *   @b Arguments
 *   @verbatim
         hTmr        Handle to the Gptimer instance
         cmd         Specifies the WATCHDOG Key. This can only be either of 
                     the following:-
                        - CSL_TMR_WDTCR_WDKEY_CMD1
                        - CSL_TMR_WDTCR_WDKEY_CMD2
     @endverbatim
 *
 *   <b> Return Value </b>
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n   Loads the  WDKEY in WDTCR register.
 *
 *   @b Writes
 *   @n TMR_WDTCR_WDKEY
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hWdt;
        ...
        CSL_TmrLoadWdkey(hWdt, CSL_TMR_WDTCR_WDKEY_CMD1);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrLoadWdkey (CSL_TmrHandle hTmr, Uint16 cmd)
{
    ((hTmr->regs->WDTCR) = ((hTmr->regs->WDTCR) & ~(0xFFFF0000u)) | (((cmd) << (0x00000010u)) & (0xFFFF0000u)));
}

/** ===========================================================================
 *   @n@b CSL_TmrDisableWdt
 *
 *   @b Description
 *      The function disables the Watch Dog Timer.
 *
 *   @b Arguments
 *   @verbatim
        hTmr         Handle to the Timer instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *       None
 *
 *   <b> Pre Condition </b>
 *   @n  Both @a CSL_tmrInit() and @a CSL_tmrOpen() must be called.
 *
 *   <b> Post Condition </b>
 *   @n   The Watch Dog timer is disabled.
 *
 *   @b Writes
 *   @n TMR_WDTCR_WDEN=0
 *
 *   @b Example
 *   @verbatim
        CSL_TmrHandle hWdt;
        ...
        CSL_TmrDisableWdt(hWdt);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_TmrDisableWdt (CSL_TmrHandle hTmr)
{
    (((hTmr->regs->WDTCR)) = (((hTmr->regs->WDTCR)) & ~(0x00004000u)) | ((((0x00000000u)) << (0x0000000Eu)) & (0x00004000u)));
}

/**
@}
*/



extern CSL_Status CSL_tmrInit  ( CSL_TmrContext *  pContext   );

/*===============================================================================
//  Copyright(C):
//
//  FILENAME: <Intr.h> (Platfform.pjt)
//
//  Subsystem: Low Level Driver Library.
//
//  Purpose of file:
//  	To create haseless library to initialize, enable and
//		disable the Interrupt,
//  
//
//  Dependencies, Limitations, and Design Notes:
//  
//
//=============================================================================
// Version   Date     Modification_History                               Author
//=============================================================================
//  
// 								   	
//
===============================================================================
*/


//#include <ti/csl/src/intc/csl_intc.h>
//#include <ti/csl/src/intc/csl_intcAux.h>
//#include <ti/csl/csl_cic.h>//in CCS5 this include file is not present, that's why removed by remesh
/**
 *   @file  csl_cpIntc.h
 *
 *   @brief   
 *      This is the main header file for the CPINTC Module which defines
 *      all the data structures and exported API.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** @defgroup CSL_CPINTC_API CPINTC
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *  The CPINTC is the interrupt controller which handles the system interrupts
 *  for the host, processes & prioritizes them and then is responsible for 
 *  delivering these to the host.
 *
 * @subsection References
 *   -# CPINTC Architecture Specification.
 *
 * @subsection Assumptions
 *    The abbreviations CPINTC, cpintc have been used throughout this
 *    document to refer to Interrupt Controller.
 */
 


/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified Registers CH_MAP_REG0-CH_MAP_REG255 to an array of bytes of CHMAP[1024]
 *      b) Modified Registers HINT_MAP_REG0-HINT_MAP_REG63 to an array of HINTMAP[64]
 *      c) Modified Registers RAW_STATUS_REG0-RAW_STATUS_REG31 to an array of RAW_STATUS_REG[32]
 *      d) Modified Registers ENA_STATUS_REG0-ENA_STATUS_REG32 to an array of ENA_STATUS_REG[32]
 *      e) Modified Registers ENABLE_REG0-ENABLE_REG31 to an array of ENABLE_REG[32]
 *      f) Modified Registers ENABLE_CLR_REG0-ENABLE_CLR_REG31 to an array of ENABLE_CLR_REG[32]
 *      g) Modified Registers PRI_HINT_REG0-PRI_HINT_REG255 to an array of PRI_HINT_REG[256]
 *      h) Modified Registers POLARITY_REG0-POLARITY_REG31 to an array of POLARITY_REG[32]
 *      i) Modified Registers TYPE_REG0-TYPE_REG31 to an array of TYPE_REG[32]
 *      j) Modified Registers DBG_SELECT_REG0-DBG_SELECT_REG63 to an array of DBG_SELECT_REG[64]
 *      k) Modified Registers SECURE_ENABLE_REG0-SECURE_ENABLE_REG31 to an array of SECURE_ENABLE_REG[32]
 *      l) Modified Registers SECURE_ENABLE_CLR_REG0-SECURE_ENABLE_CLR_REG31 to an array of SECURE_ENABLE_CLR_REG[32]
 *      m) Modified Registers NEST_LEVEL_REG0-NEST_LEVEL_REG255 to an array of NEST_LEVEL_REG[256]
 *      n) Modified Registers ENABLE_HINT_REG0-ENABLE_HINT_REG7 to an array of ENABLE_HINT_REG[8]
 *      o) Modified Registers VECTOR_ADDRESS_REG_0-VECTOR_ADDRESS_REG_1023 to an array of VECTOR_ADDRESS_REG[1024]
 *      p) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 REVISION_REG;
    volatile Uint32 CONTROL_REG;
    volatile Uint8 RSVD0[4];
    volatile Uint32 HOST_CONTROL_REG;
    volatile Uint32 GLOBAL_ENABLE_HINT_REG;
    volatile Uint8 RSVD1[8];
    volatile Uint32 GLB_NEST_LEVEL_REG;
    volatile Uint32 STATUS_SET_INDEX_REG;
    volatile Uint32 STATUS_CLR_INDEX_REG;
    volatile Uint32 ENABLE_SET_INDEX_REG;
    volatile Uint32 ENABLE_CLR_INDEX_REG;
    volatile Uint8 RSVD2[4];
    volatile Uint32 HINT_ENABLE_SET_INDEX_REG;
    volatile Uint32 HINT_ENABLE_CLR_INDEX_REG;
    volatile Uint8 RSVD3[28];
    volatile Uint32 VECTOR_NULL_REG;
    volatile Uint8 RSVD4[36];
    volatile Uint32 GLB_PRI_INTR_REG;
    volatile Uint32 GLB_VECTOR_ADDR_REG;
    volatile Uint8 RSVD5[8];
    volatile Uint32 GLOBAL_SECURE_ENABLE_REG;
    volatile Uint32 SECURE_PRI_INTR_REG;
    volatile Uint8 RSVD6[360];
    volatile Uint32 RAW_STATUS_REG[32];
    volatile Uint32 ENA_STATUS_REG[32];
    volatile Uint32 ENABLE_REG[32];
    volatile Uint32 ENABLE_CLR_REG[32];
    volatile Uint8  CH_MAP[1024];
    volatile Uint32 HINT_MAP[64];
    volatile Uint32 PRI_HINT_REG[256];
    volatile Uint32 POLARITY_REG[32];
    volatile Uint32 TYPE_REG[32];
    volatile Uint8 RSVD7[256];
    volatile Uint32 DBG_SELECT_REG[64];
    volatile Uint32 SECURE_ENABLE_REG[32];
    volatile Uint32 SECURE_ENABLE_CLR_REG[32];
    volatile Uint32 NEST_LEVEL_REG[256];
    volatile Uint32 ENABLE_HINT_REG[8];
    volatile Uint8 RSVD8[2784];
    volatile Uint32 VECTOR_ADDRESS_REG[1024];
} CSL_CPINTCRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* revision_reg */








/* control_reg */





/* host_control_reg */



/* global_enable_hint_reg */



/* glb_nest_level_reg */



/* status_set_index_reg */



/* status_clr_index_reg */



/* enable_set_index_reg */



/* enable_clr_index_reg */



/* hint_enable_set_index_reg */



/* hint_enable_clr_index_reg */



/* vector_null_reg */



/* glb_pri_intr_reg */




/* glb_vector_addr_reg */



/* global_secure_enable_reg */




/* secure_pri_intr_reg */




/* raw_status_reg0 */


































/* raw_status_reg1 */


































/* raw_status_reg2 */


































/* raw_status_reg3 */


































/* raw_status_reg4 */


































/* raw_status_reg5 */


































/* raw_status_reg6 */


































/* raw_status_reg7 */


































/* raw_status_reg8 */


































/* raw_status_reg9 */


































/* raw_status_reg10 */


































/* raw_status_reg11 */


































/* raw_status_reg12 */


































/* raw_status_reg13 */


































/* raw_status_reg14 */


































/* raw_status_reg15 */


































/* raw_status_reg16 */


































/* raw_status_reg17 */


































/* raw_status_reg18 */


































/* raw_status_reg19 */


































/* raw_status_reg20 */


































/* raw_status_reg21 */


































/* raw_status_reg22 */


































/* raw_status_reg23 */


































/* raw_status_reg24 */


































/* raw_status_reg25 */


































/* raw_status_reg26 */


































/* raw_status_reg27 */


































/* raw_status_reg28 */


































/* raw_status_reg29 */


































/* raw_status_reg30 */


































/* raw_status_reg31 */


































/* ena_status_reg0 */


































/* ena_status_reg1 */


































/* ena_status_reg2 */


































/* ena_status_reg3 */


































/* ena_status_reg4 */


































/* ena_status_reg5 */


































/* ena_status_reg6 */


































/* ena_status_reg7 */


































/* ena_status_reg8 */


































/* ena_status_reg9 */


































/* ena_status_reg10 */


































/* ena_status_reg11 */


































/* ena_status_reg12 */


































/* ena_status_reg13 */


































/* ena_status_reg14 */


































/* ena_status_reg15 */


































/* ena_status_reg16 */


































/* ena_status_reg17 */


































/* ena_status_reg18 */


































/* ena_status_reg19 */


































/* ena_status_reg20 */


































/* ena_status_reg21 */


































/* ena_status_reg22 */


































/* ena_status_reg23 */


































/* ena_status_reg24 */


































/* ena_status_reg25 */


































/* ena_status_reg26 */


































/* ena_status_reg27 */


































/* ena_status_reg28 */


































/* ena_status_reg29 */


































/* ena_status_reg30 */


































/* ena_status_reg31 */


































/* enable_reg0 */


































/* enable_reg1 */


































/* enable_reg2 */


































/* enable_reg3 */


































/* enable_reg4 */


































/* enable_reg5 */


































/* enable_reg6 */


































/* enable_reg7 */


































/* enable_reg8 */


































/* enable_reg9 */


































/* enable_reg10 */


































/* enable_reg11 */


































/* enable_reg12 */


































/* enable_reg13 */


































/* enable_reg14 */


































/* enable_reg15 */


































/* enable_reg16 */


































/* enable_reg17 */


































/* enable_reg18 */


































/* enable_reg19 */


































/* enable_reg20 */


































/* enable_reg21 */


































/* enable_reg22 */


































/* enable_reg23 */


































/* enable_reg24 */


































/* enable_reg25 */


































/* enable_reg26 */


































/* enable_reg27 */


































/* enable_reg28 */


































/* enable_reg29 */


































/* enable_reg30 */


































/* enable_reg31 */


































/* enable_clr_reg0 */


































/* enable_clr_reg1 */


































/* enable_clr_reg2 */


































/* enable_clr_reg3 */


































/* enable_clr_reg4 */


































/* enable_clr_reg5 */


































/* enable_clr_reg6 */


































/* enable_clr_reg7 */


































/* enable_clr_reg8 */


































/* enable_clr_reg9 */


































/* enable_clr_reg10 */


































/* enable_clr_reg11 */


































/* enable_clr_reg12 */


































/* enable_clr_reg13 */


































/* enable_clr_reg14 */


































/* enable_clr_reg15 */


































/* enable_clr_reg16 */


































/* enable_clr_reg17 */


































/* enable_clr_reg18 */


































/* enable_clr_reg19 */


































/* enable_clr_reg20 */


































/* enable_clr_reg21 */


































/* enable_clr_reg22 */


































/* enable_clr_reg23 */


































/* enable_clr_reg24 */


































/* enable_clr_reg25 */


































/* enable_clr_reg26 */


































/* enable_clr_reg27 */


































/* enable_clr_reg28 */


































/* enable_clr_reg29 */


































/* enable_clr_reg30 */


































/* enable_clr_reg31 */


































/* ch_map_reg0 */






/* ch_map_reg1 */






/* ch_map_reg2 */






/* ch_map_reg3 */






/* ch_map_reg4 */






/* ch_map_reg5 */






/* ch_map_reg6 */






/* ch_map_reg7 */






/* ch_map_reg8 */






/* ch_map_reg9 */






/* ch_map_reg10 */






/* ch_map_reg11 */






/* ch_map_reg12 */






/* ch_map_reg13 */






/* ch_map_reg14 */






/* ch_map_reg15 */






/* ch_map_reg16 */






/* ch_map_reg17 */






/* ch_map_reg18 */






/* ch_map_reg19 */






/* ch_map_reg20 */






/* ch_map_reg21 */






/* ch_map_reg22 */






/* ch_map_reg23 */






/* ch_map_reg24 */






/* ch_map_reg25 */






/* ch_map_reg26 */






/* ch_map_reg27 */






/* ch_map_reg28 */






/* ch_map_reg29 */






/* ch_map_reg30 */






/* ch_map_reg31 */






/* ch_map_reg32 */






/* ch_map_reg33 */






/* ch_map_reg34 */






/* ch_map_reg35 */






/* ch_map_reg36 */






/* ch_map_reg37 */






/* ch_map_reg38 */






/* ch_map_reg39 */






/* ch_map_reg40 */






/* ch_map_reg41 */






/* ch_map_reg42 */






/* ch_map_reg43 */






/* ch_map_reg44 */






/* ch_map_reg45 */






/* ch_map_reg46 */






/* ch_map_reg47 */






/* ch_map_reg48 */






/* ch_map_reg49 */






/* ch_map_reg50 */






/* ch_map_reg51 */






/* ch_map_reg52 */






/* ch_map_reg53 */






/* ch_map_reg54 */






/* ch_map_reg55 */






/* ch_map_reg56 */






/* ch_map_reg57 */






/* ch_map_reg58 */






/* ch_map_reg59 */






/* ch_map_reg60 */






/* ch_map_reg61 */






/* ch_map_reg62 */






/* ch_map_reg63 */






/* ch_map_reg64 */






/* ch_map_reg65 */






/* ch_map_reg66 */






/* ch_map_reg67 */






/* ch_map_reg68 */






/* ch_map_reg69 */






/* ch_map_reg70 */






/* ch_map_reg71 */






/* ch_map_reg72 */






/* ch_map_reg73 */






/* ch_map_reg74 */






/* ch_map_reg75 */






/* ch_map_reg76 */






/* ch_map_reg77 */






/* ch_map_reg78 */






/* ch_map_reg79 */






/* ch_map_reg80 */






/* ch_map_reg81 */






/* ch_map_reg82 */






/* ch_map_reg83 */






/* ch_map_reg84 */






/* ch_map_reg85 */






/* ch_map_reg86 */






/* ch_map_reg87 */






/* ch_map_reg88 */






/* ch_map_reg89 */






/* ch_map_reg90 */






/* ch_map_reg91 */






/* ch_map_reg92 */






/* ch_map_reg93 */






/* ch_map_reg94 */






/* ch_map_reg95 */






/* ch_map_reg96 */






/* ch_map_reg97 */






/* ch_map_reg98 */






/* ch_map_reg99 */






/* ch_map_reg100 */






/* ch_map_reg101 */






/* ch_map_reg102 */






/* ch_map_reg103 */






/* ch_map_reg104 */






/* ch_map_reg105 */






/* ch_map_reg106 */






/* ch_map_reg107 */






/* ch_map_reg108 */






/* ch_map_reg109 */






/* ch_map_reg110 */






/* ch_map_reg111 */






/* ch_map_reg112 */






/* ch_map_reg113 */






/* ch_map_reg114 */






/* ch_map_reg115 */






/* ch_map_reg116 */






/* ch_map_reg117 */






/* ch_map_reg118 */






/* ch_map_reg119 */






/* ch_map_reg120 */






/* ch_map_reg121 */






/* ch_map_reg122 */






/* ch_map_reg123 */






/* ch_map_reg124 */






/* ch_map_reg125 */






/* ch_map_reg126 */






/* ch_map_reg127 */






/* ch_map_reg128 */






/* ch_map_reg129 */






/* ch_map_reg130 */






/* ch_map_reg131 */






/* ch_map_reg132 */






/* ch_map_reg133 */






/* ch_map_reg134 */






/* ch_map_reg135 */






/* ch_map_reg136 */






/* ch_map_reg137 */






/* ch_map_reg138 */






/* ch_map_reg139 */






/* ch_map_reg140 */






/* ch_map_reg141 */






/* ch_map_reg142 */






/* ch_map_reg143 */






/* ch_map_reg144 */






/* ch_map_reg145 */






/* ch_map_reg146 */






/* ch_map_reg147 */






/* ch_map_reg148 */






/* ch_map_reg149 */






/* ch_map_reg150 */






/* ch_map_reg151 */






/* ch_map_reg152 */






/* ch_map_reg153 */






/* ch_map_reg154 */






/* ch_map_reg155 */






/* ch_map_reg156 */






/* ch_map_reg157 */






/* ch_map_reg158 */






/* ch_map_reg159 */






/* ch_map_reg160 */






/* ch_map_reg161 */






/* ch_map_reg162 */






/* ch_map_reg163 */






/* ch_map_reg164 */






/* ch_map_reg165 */






/* ch_map_reg166 */






/* ch_map_reg167 */






/* ch_map_reg168 */






/* ch_map_reg169 */






/* ch_map_reg170 */






/* ch_map_reg171 */






/* ch_map_reg172 */






/* ch_map_reg173 */






/* ch_map_reg174 */






/* ch_map_reg175 */






/* ch_map_reg176 */






/* ch_map_reg177 */






/* ch_map_reg178 */






/* ch_map_reg179 */






/* ch_map_reg180 */






/* ch_map_reg181 */






/* ch_map_reg182 */






/* ch_map_reg183 */






/* ch_map_reg184 */






/* ch_map_reg185 */






/* ch_map_reg186 */






/* ch_map_reg187 */






/* ch_map_reg188 */






/* ch_map_reg189 */






/* ch_map_reg190 */






/* ch_map_reg191 */






/* ch_map_reg192 */






/* ch_map_reg193 */






/* ch_map_reg194 */






/* ch_map_reg195 */






/* ch_map_reg196 */






/* ch_map_reg197 */






/* ch_map_reg198 */






/* ch_map_reg199 */






/* ch_map_reg200 */






/* ch_map_reg201 */






/* ch_map_reg202 */






/* ch_map_reg203 */






/* ch_map_reg204 */






/* ch_map_reg205 */






/* ch_map_reg206 */






/* ch_map_reg207 */






/* ch_map_reg208 */






/* ch_map_reg209 */






/* ch_map_reg210 */






/* ch_map_reg211 */






/* ch_map_reg212 */






/* ch_map_reg213 */






/* ch_map_reg214 */






/* ch_map_reg215 */






/* ch_map_reg216 */






/* ch_map_reg217 */






/* ch_map_reg218 */






/* ch_map_reg219 */






/* ch_map_reg220 */






/* ch_map_reg221 */






/* ch_map_reg222 */






/* ch_map_reg223 */






/* ch_map_reg224 */






/* ch_map_reg225 */






/* ch_map_reg226 */






/* ch_map_reg227 */






/* ch_map_reg228 */






/* ch_map_reg229 */






/* ch_map_reg230 */






/* ch_map_reg231 */






/* ch_map_reg232 */






/* ch_map_reg233 */






/* ch_map_reg234 */






/* ch_map_reg235 */






/* ch_map_reg236 */






/* ch_map_reg237 */






/* ch_map_reg238 */






/* ch_map_reg239 */






/* ch_map_reg240 */






/* ch_map_reg241 */






/* ch_map_reg242 */






/* ch_map_reg243 */






/* ch_map_reg244 */






/* ch_map_reg245 */






/* ch_map_reg246 */






/* ch_map_reg247 */






/* ch_map_reg248 */






/* ch_map_reg249 */






/* ch_map_reg250 */






/* ch_map_reg251 */






/* ch_map_reg252 */






/* ch_map_reg253 */






/* ch_map_reg254 */






/* ch_map_reg255 */






/* hint_map_reg0 */






/* hint_map_reg1 */






/* hint_map_reg2 */






/* hint_map_reg3 */






/* hint_map_reg4 */






/* hint_map_reg5 */






/* hint_map_reg6 */






/* hint_map_reg7 */






/* hint_map_reg8 */






/* hint_map_reg9 */






/* hint_map_reg10 */






/* hint_map_reg11 */






/* hint_map_reg12 */






/* hint_map_reg13 */






/* hint_map_reg14 */






/* hint_map_reg15 */






/* hint_map_reg16 */






/* hint_map_reg17 */






/* hint_map_reg18 */






/* hint_map_reg19 */






/* hint_map_reg20 */






/* hint_map_reg21 */






/* hint_map_reg22 */






/* hint_map_reg23 */






/* hint_map_reg24 */






/* hint_map_reg25 */






/* hint_map_reg26 */






/* hint_map_reg27 */






/* hint_map_reg28 */






/* hint_map_reg29 */






/* hint_map_reg30 */






/* hint_map_reg31 */






/* hint_map_reg32 */






/* hint_map_reg33 */






/* hint_map_reg34 */






/* hint_map_reg35 */






/* hint_map_reg36 */






/* hint_map_reg37 */






/* hint_map_reg38 */






/* hint_map_reg39 */






/* hint_map_reg40 */






/* hint_map_reg41 */






/* hint_map_reg42 */






/* hint_map_reg43 */






/* hint_map_reg44 */






/* hint_map_reg45 */






/* hint_map_reg46 */






/* hint_map_reg47 */






/* hint_map_reg48 */






/* hint_map_reg49 */






/* hint_map_reg50 */






/* hint_map_reg51 */






/* hint_map_reg52 */






/* hint_map_reg53 */






/* hint_map_reg54 */






/* hint_map_reg55 */






/* hint_map_reg56 */






/* hint_map_reg57 */






/* hint_map_reg58 */






/* hint_map_reg59 */






/* hint_map_reg60 */






/* hint_map_reg61 */






/* hint_map_reg62 */






/* hint_map_reg63 */






/* pri_hint_reg0 */




/* pri_hint_reg1 */




/* pri_hint_reg2 */




/* pri_hint_reg3 */




/* pri_hint_reg4 */




/* pri_hint_reg5 */




/* pri_hint_reg6 */




/* pri_hint_reg7 */




/* pri_hint_reg8 */




/* pri_hint_reg9 */




/* pri_hint_reg10 */




/* pri_hint_reg11 */




/* pri_hint_reg12 */




/* pri_hint_reg13 */




/* pri_hint_reg14 */




/* pri_hint_reg15 */




/* pri_hint_reg16 */




/* pri_hint_reg17 */




/* pri_hint_reg18 */




/* pri_hint_reg19 */




/* pri_hint_reg20 */




/* pri_hint_reg21 */




/* pri_hint_reg22 */




/* pri_hint_reg23 */




/* pri_hint_reg24 */




/* pri_hint_reg25 */




/* pri_hint_reg26 */




/* pri_hint_reg27 */




/* pri_hint_reg28 */




/* pri_hint_reg29 */




/* pri_hint_reg30 */




/* pri_hint_reg31 */




/* pri_hint_reg32 */




/* pri_hint_reg33 */




/* pri_hint_reg34 */




/* pri_hint_reg35 */




/* pri_hint_reg36 */




/* pri_hint_reg37 */




/* pri_hint_reg38 */




/* pri_hint_reg39 */




/* pri_hint_reg40 */




/* pri_hint_reg41 */




/* pri_hint_reg42 */




/* pri_hint_reg43 */




/* pri_hint_reg44 */




/* pri_hint_reg45 */




/* pri_hint_reg46 */




/* pri_hint_reg47 */




/* pri_hint_reg48 */




/* pri_hint_reg49 */




/* pri_hint_reg50 */




/* pri_hint_reg51 */




/* pri_hint_reg52 */




/* pri_hint_reg53 */




/* pri_hint_reg54 */




/* pri_hint_reg55 */




/* pri_hint_reg56 */




/* pri_hint_reg57 */




/* pri_hint_reg58 */




/* pri_hint_reg59 */




/* pri_hint_reg60 */




/* pri_hint_reg61 */




/* pri_hint_reg62 */




/* pri_hint_reg63 */




/* pri_hint_reg64 */




/* pri_hint_reg65 */




/* pri_hint_reg66 */




/* pri_hint_reg67 */




/* pri_hint_reg68 */




/* pri_hint_reg69 */




/* pri_hint_reg70 */




/* pri_hint_reg71 */




/* pri_hint_reg72 */




/* pri_hint_reg73 */




/* pri_hint_reg74 */




/* pri_hint_reg75 */




/* pri_hint_reg76 */




/* pri_hint_reg77 */




/* pri_hint_reg78 */




/* pri_hint_reg79 */




/* pri_hint_reg80 */




/* pri_hint_reg81 */




/* pri_hint_reg82 */




/* pri_hint_reg83 */




/* pri_hint_reg84 */




/* pri_hint_reg85 */




/* pri_hint_reg86 */




/* pri_hint_reg87 */




/* pri_hint_reg88 */




/* pri_hint_reg89 */




/* pri_hint_reg90 */




/* pri_hint_reg91 */




/* pri_hint_reg92 */




/* pri_hint_reg93 */




/* pri_hint_reg94 */




/* pri_hint_reg95 */




/* pri_hint_reg96 */




/* pri_hint_reg97 */




/* pri_hint_reg98 */




/* pri_hint_reg99 */




/* pri_hint_reg100 */




/* pri_hint_reg101 */




/* pri_hint_reg102 */




/* pri_hint_reg103 */




/* pri_hint_reg104 */




/* pri_hint_reg105 */




/* pri_hint_reg106 */




/* pri_hint_reg107 */




/* pri_hint_reg108 */




/* pri_hint_reg109 */




/* pri_hint_reg110 */




/* pri_hint_reg111 */




/* pri_hint_reg112 */




/* pri_hint_reg113 */




/* pri_hint_reg114 */




/* pri_hint_reg115 */




/* pri_hint_reg116 */




/* pri_hint_reg117 */




/* pri_hint_reg118 */




/* pri_hint_reg119 */




/* pri_hint_reg120 */




/* pri_hint_reg121 */




/* pri_hint_reg122 */




/* pri_hint_reg123 */




/* pri_hint_reg124 */




/* pri_hint_reg125 */




/* pri_hint_reg126 */




/* pri_hint_reg127 */




/* pri_hint_reg128 */




/* pri_hint_reg129 */




/* pri_hint_reg130 */




/* pri_hint_reg131 */




/* pri_hint_reg132 */




/* pri_hint_reg133 */




/* pri_hint_reg134 */




/* pri_hint_reg135 */




/* pri_hint_reg136 */




/* pri_hint_reg137 */




/* pri_hint_reg138 */




/* pri_hint_reg139 */




/* pri_hint_reg140 */




/* pri_hint_reg141 */




/* pri_hint_reg142 */




/* pri_hint_reg143 */




/* pri_hint_reg144 */




/* pri_hint_reg145 */




/* pri_hint_reg146 */




/* pri_hint_reg147 */




/* pri_hint_reg148 */




/* pri_hint_reg149 */




/* pri_hint_reg150 */




/* pri_hint_reg151 */




/* pri_hint_reg152 */




/* pri_hint_reg153 */




/* pri_hint_reg154 */




/* pri_hint_reg155 */




/* pri_hint_reg156 */




/* pri_hint_reg157 */




/* pri_hint_reg158 */




/* pri_hint_reg159 */




/* pri_hint_reg160 */




/* pri_hint_reg161 */




/* pri_hint_reg162 */




/* pri_hint_reg163 */




/* pri_hint_reg164 */




/* pri_hint_reg165 */




/* pri_hint_reg166 */




/* pri_hint_reg167 */




/* pri_hint_reg168 */




/* pri_hint_reg169 */




/* pri_hint_reg170 */




/* pri_hint_reg171 */




/* pri_hint_reg172 */




/* pri_hint_reg173 */




/* pri_hint_reg174 */




/* pri_hint_reg175 */




/* pri_hint_reg176 */




/* pri_hint_reg177 */




/* pri_hint_reg178 */




/* pri_hint_reg179 */




/* pri_hint_reg180 */




/* pri_hint_reg181 */




/* pri_hint_reg182 */




/* pri_hint_reg183 */




/* pri_hint_reg184 */




/* pri_hint_reg185 */




/* pri_hint_reg186 */




/* pri_hint_reg187 */




/* pri_hint_reg188 */




/* pri_hint_reg189 */




/* pri_hint_reg190 */




/* pri_hint_reg191 */




/* pri_hint_reg192 */




/* pri_hint_reg193 */




/* pri_hint_reg194 */




/* pri_hint_reg195 */




/* pri_hint_reg196 */




/* pri_hint_reg197 */




/* pri_hint_reg198 */




/* pri_hint_reg199 */




/* pri_hint_reg200 */




/* pri_hint_reg201 */




/* pri_hint_reg202 */




/* pri_hint_reg203 */




/* pri_hint_reg204 */




/* pri_hint_reg205 */




/* pri_hint_reg206 */




/* pri_hint_reg207 */




/* pri_hint_reg208 */




/* pri_hint_reg209 */




/* pri_hint_reg210 */




/* pri_hint_reg211 */




/* pri_hint_reg212 */




/* pri_hint_reg213 */




/* pri_hint_reg214 */




/* pri_hint_reg215 */




/* pri_hint_reg216 */




/* pri_hint_reg217 */




/* pri_hint_reg218 */




/* pri_hint_reg219 */




/* pri_hint_reg220 */




/* pri_hint_reg221 */




/* pri_hint_reg222 */




/* pri_hint_reg223 */




/* pri_hint_reg224 */




/* pri_hint_reg225 */




/* pri_hint_reg226 */




/* pri_hint_reg227 */




/* pri_hint_reg228 */




/* pri_hint_reg229 */




/* pri_hint_reg230 */




/* pri_hint_reg231 */




/* pri_hint_reg232 */




/* pri_hint_reg233 */




/* pri_hint_reg234 */




/* pri_hint_reg235 */




/* pri_hint_reg236 */




/* pri_hint_reg237 */




/* pri_hint_reg238 */




/* pri_hint_reg239 */




/* pri_hint_reg240 */




/* pri_hint_reg241 */




/* pri_hint_reg242 */




/* pri_hint_reg243 */




/* pri_hint_reg244 */




/* pri_hint_reg245 */




/* pri_hint_reg246 */




/* pri_hint_reg247 */




/* pri_hint_reg248 */




/* pri_hint_reg249 */




/* pri_hint_reg250 */




/* pri_hint_reg251 */




/* pri_hint_reg252 */




/* pri_hint_reg253 */




/* pri_hint_reg254 */




/* pri_hint_reg255 */




/* polarity_reg0 */


































/* polarity_reg1 */


































/* polarity_reg2 */


































/* polarity_reg3 */


































/* polarity_reg4 */


































/* polarity_reg5 */


































/* polarity_reg6 */


































/* polarity_reg7 */


































/* polarity_reg8 */


































/* polarity_reg9 */


































/* polarity_reg10 */


































/* polarity_reg11 */


































/* polarity_reg12 */


































/* polarity_reg13 */


































/* polarity_reg14 */


































/* polarity_reg15 */


































/* polarity_reg16 */


































/* polarity_reg17 */


































/* polarity_reg18 */


































/* polarity_reg19 */


































/* polarity_reg20 */


































/* polarity_reg21 */


































/* polarity_reg22 */


































/* polarity_reg23 */


































/* polarity_reg24 */


































/* polarity_reg25 */


































/* polarity_reg26 */


































/* polarity_reg27 */


































/* polarity_reg28 */


































/* polarity_reg29 */


































/* polarity_reg30 */


































/* polarity_reg31 */


































/* type_reg0 */


































/* type_reg1 */


































/* type_reg2 */


































/* type_reg3 */


































/* type_reg4 */


































/* type_reg5 */


































/* type_reg6 */


































/* type_reg7 */


































/* type_reg8 */


































/* type_reg9 */


































/* type_reg10 */


































/* type_reg11 */


































/* type_reg12 */


































/* type_reg13 */


































/* type_reg14 */


































/* type_reg15 */


































/* type_reg16 */


































/* type_reg17 */


































/* type_reg18 */


































/* type_reg19 */


































/* type_reg20 */


































/* type_reg21 */


































/* type_reg22 */


































/* type_reg23 */


































/* type_reg24 */


































/* type_reg25 */


































/* type_reg26 */


































/* type_reg27 */


































/* type_reg28 */


































/* type_reg29 */


































/* type_reg30 */


































/* type_reg31 */


































/* dbg_select_reg0 */




/* dbg_select_reg1 */




/* dbg_select_reg2 */




/* dbg_select_reg3 */




/* dbg_select_reg4 */




/* dbg_select_reg5 */




/* dbg_select_reg6 */




/* dbg_select_reg7 */




/* dbg_select_reg8 */




/* dbg_select_reg9 */




/* dbg_select_reg10 */




/* dbg_select_reg11 */




/* dbg_select_reg12 */




/* dbg_select_reg13 */




/* dbg_select_reg14 */




/* dbg_select_reg15 */




/* dbg_select_reg16 */




/* dbg_select_reg17 */




/* dbg_select_reg18 */




/* dbg_select_reg19 */




/* dbg_select_reg20 */




/* dbg_select_reg21 */




/* dbg_select_reg22 */




/* dbg_select_reg23 */




/* dbg_select_reg24 */




/* dbg_select_reg25 */




/* dbg_select_reg26 */




/* dbg_select_reg27 */




/* dbg_select_reg28 */




/* dbg_select_reg29 */




/* dbg_select_reg30 */




/* dbg_select_reg31 */




/* dbg_select_reg32 */




/* dbg_select_reg33 */




/* dbg_select_reg34 */




/* dbg_select_reg35 */




/* dbg_select_reg36 */




/* dbg_select_reg37 */




/* dbg_select_reg38 */




/* dbg_select_reg39 */




/* dbg_select_reg40 */




/* dbg_select_reg41 */




/* dbg_select_reg42 */




/* dbg_select_reg43 */




/* dbg_select_reg44 */




/* dbg_select_reg45 */




/* dbg_select_reg46 */




/* dbg_select_reg47 */




/* dbg_select_reg48 */




/* dbg_select_reg49 */




/* dbg_select_reg50 */




/* dbg_select_reg51 */




/* dbg_select_reg52 */




/* dbg_select_reg53 */




/* dbg_select_reg54 */




/* dbg_select_reg55 */




/* dbg_select_reg56 */




/* dbg_select_reg57 */




/* dbg_select_reg58 */




/* dbg_select_reg59 */




/* dbg_select_reg60 */




/* dbg_select_reg61 */




/* dbg_select_reg62 */




/* dbg_select_reg63 */




/* secure_enable_reg0 */


































/* secure_enable_reg1 */


































/* secure_enable_reg2 */


































/* secure_enable_reg3 */


































/* secure_enable_reg4 */


































/* secure_enable_reg5 */


































/* secure_enable_reg6 */


































/* secure_enable_reg7 */


































/* secure_enable_reg8 */


































/* secure_enable_reg9 */


































/* secure_enable_reg10 */


































/* secure_enable_reg11 */


































/* secure_enable_reg12 */


































/* secure_enable_reg13 */


































/* secure_enable_reg14 */


































/* secure_enable_reg15 */


































/* secure_enable_reg16 */


































/* secure_enable_reg17 */


































/* secure_enable_reg18 */


































/* secure_enable_reg19 */


































/* secure_enable_reg20 */


































/* secure_enable_reg21 */


































/* secure_enable_reg22 */


































/* secure_enable_reg23 */


































/* secure_enable_reg24 */


































/* secure_enable_reg25 */


































/* secure_enable_reg26 */


































/* secure_enable_reg27 */


































/* secure_enable_reg28 */


































/* secure_enable_reg29 */


































/* secure_enable_reg30 */


































/* secure_enable_reg31 */


































/* secure_enable_clr_reg0 */


































/* secure_enable_clr_reg1 */


































/* secure_enable_clr_reg2 */


































/* secure_enable_clr_reg3 */


































/* secure_enable_clr_reg4 */


































/* secure_enable_clr_reg5 */


































/* secure_enable_clr_reg6 */


































/* secure_enable_clr_reg7 */


































/* secure_enable_clr_reg8 */


































/* secure_enable_clr_reg9 */


































/* secure_enable_clr_reg10 */


































/* secure_enable_clr_reg11 */


































/* secure_enable_clr_reg12 */


































/* secure_enable_clr_reg13 */


































/* secure_enable_clr_reg14 */


































/* secure_enable_clr_reg15 */


































/* secure_enable_clr_reg16 */


































/* secure_enable_clr_reg17 */


































/* secure_enable_clr_reg18 */


































/* secure_enable_clr_reg19 */


































/* secure_enable_clr_reg20 */


































/* secure_enable_clr_reg21 */


































/* secure_enable_clr_reg22 */


































/* secure_enable_clr_reg23 */


































/* secure_enable_clr_reg24 */


































/* secure_enable_clr_reg25 */


































/* secure_enable_clr_reg26 */


































/* secure_enable_clr_reg27 */


































/* secure_enable_clr_reg28 */


































/* secure_enable_clr_reg29 */


































/* secure_enable_clr_reg30 */


































/* secure_enable_clr_reg31 */


































/* nest_level_reg0 */



/* nest_level_reg1 */



/* nest_level_reg2 */



/* nest_level_reg3 */



/* nest_level_reg4 */



/* nest_level_reg5 */



/* nest_level_reg6 */



/* nest_level_reg7 */



/* nest_level_reg8 */



/* nest_level_reg9 */



/* nest_level_reg10 */



/* nest_level_reg11 */



/* nest_level_reg12 */



/* nest_level_reg13 */



/* nest_level_reg14 */



/* nest_level_reg15 */



/* nest_level_reg16 */



/* nest_level_reg17 */



/* nest_level_reg18 */



/* nest_level_reg19 */



/* nest_level_reg20 */



/* nest_level_reg21 */



/* nest_level_reg22 */



/* nest_level_reg23 */



/* nest_level_reg24 */



/* nest_level_reg25 */



/* nest_level_reg26 */



/* nest_level_reg27 */



/* nest_level_reg28 */



/* nest_level_reg29 */



/* nest_level_reg30 */



/* nest_level_reg31 */



/* nest_level_reg32 */



/* nest_level_reg33 */



/* nest_level_reg34 */



/* nest_level_reg35 */



/* nest_level_reg36 */



/* nest_level_reg37 */



/* nest_level_reg38 */



/* nest_level_reg39 */



/* nest_level_reg40 */



/* nest_level_reg41 */



/* nest_level_reg42 */



/* nest_level_reg43 */



/* nest_level_reg44 */



/* nest_level_reg45 */



/* nest_level_reg46 */



/* nest_level_reg47 */



/* nest_level_reg48 */



/* nest_level_reg49 */



/* nest_level_reg50 */



/* nest_level_reg51 */



/* nest_level_reg52 */



/* nest_level_reg53 */



/* nest_level_reg54 */



/* nest_level_reg55 */



/* nest_level_reg56 */



/* nest_level_reg57 */



/* nest_level_reg58 */



/* nest_level_reg59 */



/* nest_level_reg60 */



/* nest_level_reg61 */



/* nest_level_reg62 */



/* nest_level_reg63 */



/* nest_level_reg64 */



/* nest_level_reg65 */



/* nest_level_reg66 */



/* nest_level_reg67 */



/* nest_level_reg68 */



/* nest_level_reg69 */



/* nest_level_reg70 */



/* nest_level_reg71 */



/* nest_level_reg72 */



/* nest_level_reg73 */



/* nest_level_reg74 */



/* nest_level_reg75 */



/* nest_level_reg76 */



/* nest_level_reg77 */



/* nest_level_reg78 */



/* nest_level_reg79 */



/* nest_level_reg80 */



/* nest_level_reg81 */



/* nest_level_reg82 */



/* nest_level_reg83 */



/* nest_level_reg84 */



/* nest_level_reg85 */



/* nest_level_reg86 */



/* nest_level_reg87 */



/* nest_level_reg88 */



/* nest_level_reg89 */



/* nest_level_reg90 */



/* nest_level_reg91 */



/* nest_level_reg92 */



/* nest_level_reg93 */



/* nest_level_reg94 */



/* nest_level_reg95 */



/* nest_level_reg96 */



/* nest_level_reg97 */



/* nest_level_reg98 */



/* nest_level_reg99 */



/* nest_level_reg100 */



/* nest_level_reg101 */



/* nest_level_reg102 */



/* nest_level_reg103 */



/* nest_level_reg104 */



/* nest_level_reg105 */



/* nest_level_reg106 */



/* nest_level_reg107 */



/* nest_level_reg108 */



/* nest_level_reg109 */



/* nest_level_reg110 */



/* nest_level_reg111 */



/* nest_level_reg112 */



/* nest_level_reg113 */



/* nest_level_reg114 */



/* nest_level_reg115 */



/* nest_level_reg116 */



/* nest_level_reg117 */



/* nest_level_reg118 */



/* nest_level_reg119 */



/* nest_level_reg120 */



/* nest_level_reg121 */



/* nest_level_reg122 */



/* nest_level_reg123 */



/* nest_level_reg124 */



/* nest_level_reg125 */



/* nest_level_reg126 */



/* nest_level_reg127 */



/* nest_level_reg128 */



/* nest_level_reg129 */



/* nest_level_reg130 */



/* nest_level_reg131 */



/* nest_level_reg132 */



/* nest_level_reg133 */



/* nest_level_reg134 */



/* nest_level_reg135 */



/* nest_level_reg136 */



/* nest_level_reg137 */



/* nest_level_reg138 */



/* nest_level_reg139 */



/* nest_level_reg140 */



/* nest_level_reg141 */



/* nest_level_reg142 */



/* nest_level_reg143 */



/* nest_level_reg144 */



/* nest_level_reg145 */



/* nest_level_reg146 */



/* nest_level_reg147 */



/* nest_level_reg148 */



/* nest_level_reg149 */



/* nest_level_reg150 */



/* nest_level_reg151 */



/* nest_level_reg152 */



/* nest_level_reg153 */



/* nest_level_reg154 */



/* nest_level_reg155 */



/* nest_level_reg156 */



/* nest_level_reg157 */



/* nest_level_reg158 */



/* nest_level_reg159 */



/* nest_level_reg160 */



/* nest_level_reg161 */



/* nest_level_reg162 */



/* nest_level_reg163 */



/* nest_level_reg164 */



/* nest_level_reg165 */



/* nest_level_reg166 */



/* nest_level_reg167 */



/* nest_level_reg168 */



/* nest_level_reg169 */



/* nest_level_reg170 */



/* nest_level_reg171 */



/* nest_level_reg172 */



/* nest_level_reg173 */



/* nest_level_reg174 */



/* nest_level_reg175 */



/* nest_level_reg176 */



/* nest_level_reg177 */



/* nest_level_reg178 */



/* nest_level_reg179 */



/* nest_level_reg180 */



/* nest_level_reg181 */



/* nest_level_reg182 */



/* nest_level_reg183 */



/* nest_level_reg184 */



/* nest_level_reg185 */



/* nest_level_reg186 */



/* nest_level_reg187 */



/* nest_level_reg188 */



/* nest_level_reg189 */



/* nest_level_reg190 */



/* nest_level_reg191 */



/* nest_level_reg192 */



/* nest_level_reg193 */



/* nest_level_reg194 */



/* nest_level_reg195 */



/* nest_level_reg196 */



/* nest_level_reg197 */



/* nest_level_reg198 */



/* nest_level_reg199 */



/* nest_level_reg200 */



/* nest_level_reg201 */



/* nest_level_reg202 */



/* nest_level_reg203 */



/* nest_level_reg204 */



/* nest_level_reg205 */



/* nest_level_reg206 */



/* nest_level_reg207 */



/* nest_level_reg208 */



/* nest_level_reg209 */



/* nest_level_reg210 */



/* nest_level_reg211 */



/* nest_level_reg212 */



/* nest_level_reg213 */



/* nest_level_reg214 */



/* nest_level_reg215 */



/* nest_level_reg216 */



/* nest_level_reg217 */



/* nest_level_reg218 */



/* nest_level_reg219 */



/* nest_level_reg220 */



/* nest_level_reg221 */



/* nest_level_reg222 */



/* nest_level_reg223 */



/* nest_level_reg224 */



/* nest_level_reg225 */



/* nest_level_reg226 */



/* nest_level_reg227 */



/* nest_level_reg228 */



/* nest_level_reg229 */



/* nest_level_reg230 */



/* nest_level_reg231 */



/* nest_level_reg232 */



/* nest_level_reg233 */



/* nest_level_reg234 */



/* nest_level_reg235 */



/* nest_level_reg236 */



/* nest_level_reg237 */



/* nest_level_reg238 */



/* nest_level_reg239 */



/* nest_level_reg240 */



/* nest_level_reg241 */



/* nest_level_reg242 */



/* nest_level_reg243 */



/* nest_level_reg244 */



/* nest_level_reg245 */



/* nest_level_reg246 */



/* nest_level_reg247 */



/* nest_level_reg248 */



/* nest_level_reg249 */



/* nest_level_reg250 */



/* nest_level_reg251 */



/* nest_level_reg252 */



/* nest_level_reg253 */



/* nest_level_reg254 */



/* nest_level_reg255 */



/* enable_hint_reg0 */


































/* enable_hint_reg1 */


































/* enable_hint_reg2 */


































/* enable_hint_reg3 */


































/* enable_hint_reg4 */


































/* enable_hint_reg5 */


































/* enable_hint_reg6 */


































/* enable_hint_reg7 */


































/* vector_address_reg_0 */



/* vector_address_reg_1 */



/* vector_address_reg_2 */



/* vector_address_reg_3 */



/* vector_address_reg_4 */



/* vector_address_reg_5 */



/* vector_address_reg_6 */



/* vector_address_reg_7 */



/* vector_address_reg_8 */



/* vector_address_reg_9 */



/* vector_address_reg_10 */



/* vector_address_reg_11 */



/* vector_address_reg_12 */



/* vector_address_reg_13 */



/* vector_address_reg_14 */



/* vector_address_reg_15 */



/* vector_address_reg_16 */



/* vector_address_reg_17 */



/* vector_address_reg_18 */



/* vector_address_reg_19 */



/* vector_address_reg_20 */



/* vector_address_reg_21 */



/* vector_address_reg_22 */



/* vector_address_reg_23 */



/* vector_address_reg_24 */



/* vector_address_reg_25 */



/* vector_address_reg_26 */



/* vector_address_reg_27 */



/* vector_address_reg_28 */



/* vector_address_reg_29 */



/* vector_address_reg_30 */



/* vector_address_reg_31 */



/* vector_address_reg_32 */



/* vector_address_reg_33 */



/* vector_address_reg_34 */



/* vector_address_reg_35 */



/* vector_address_reg_36 */



/* vector_address_reg_37 */



/* vector_address_reg_38 */



/* vector_address_reg_39 */



/* vector_address_reg_40 */



/* vector_address_reg_41 */



/* vector_address_reg_42 */



/* vector_address_reg_43 */



/* vector_address_reg_44 */



/* vector_address_reg_45 */



/* vector_address_reg_46 */



/* vector_address_reg_47 */



/* vector_address_reg_48 */



/* vector_address_reg_49 */



/* vector_address_reg_50 */



/* vector_address_reg_51 */



/* vector_address_reg_52 */



/* vector_address_reg_53 */



/* vector_address_reg_54 */



/* vector_address_reg_55 */



/* vector_address_reg_56 */



/* vector_address_reg_57 */



/* vector_address_reg_58 */



/* vector_address_reg_59 */



/* vector_address_reg_60 */



/* vector_address_reg_61 */



/* vector_address_reg_62 */



/* vector_address_reg_63 */



/* vector_address_reg_64 */



/* vector_address_reg_65 */



/* vector_address_reg_66 */



/* vector_address_reg_67 */



/* vector_address_reg_68 */



/* vector_address_reg_69 */



/* vector_address_reg_70 */



/* vector_address_reg_71 */



/* vector_address_reg_72 */



/* vector_address_reg_73 */



/* vector_address_reg_74 */



/* vector_address_reg_75 */



/* vector_address_reg_76 */



/* vector_address_reg_77 */



/* vector_address_reg_78 */



/* vector_address_reg_79 */



/* vector_address_reg_80 */



/* vector_address_reg_81 */



/* vector_address_reg_82 */



/* vector_address_reg_83 */



/* vector_address_reg_84 */



/* vector_address_reg_85 */



/* vector_address_reg_86 */



/* vector_address_reg_87 */



/* vector_address_reg_88 */



/* vector_address_reg_89 */



/* vector_address_reg_90 */



/* vector_address_reg_91 */



/* vector_address_reg_92 */



/* vector_address_reg_93 */



/* vector_address_reg_94 */



/* vector_address_reg_95 */



/* vector_address_reg_96 */



/* vector_address_reg_97 */



/* vector_address_reg_98 */



/* vector_address_reg_99 */



/* vector_address_reg_100 */



/* vector_address_reg_101 */



/* vector_address_reg_102 */



/* vector_address_reg_103 */



/* vector_address_reg_104 */



/* vector_address_reg_105 */



/* vector_address_reg_106 */



/* vector_address_reg_107 */



/* vector_address_reg_108 */



/* vector_address_reg_109 */



/* vector_address_reg_110 */



/* vector_address_reg_111 */



/* vector_address_reg_112 */



/* vector_address_reg_113 */



/* vector_address_reg_114 */



/* vector_address_reg_115 */



/* vector_address_reg_116 */



/* vector_address_reg_117 */



/* vector_address_reg_118 */



/* vector_address_reg_119 */



/* vector_address_reg_120 */



/* vector_address_reg_121 */



/* vector_address_reg_122 */



/* vector_address_reg_123 */



/* vector_address_reg_124 */



/* vector_address_reg_125 */



/* vector_address_reg_126 */



/* vector_address_reg_127 */



/* vector_address_reg_128 */



/* vector_address_reg_129 */



/* vector_address_reg_130 */



/* vector_address_reg_131 */



/* vector_address_reg_132 */



/* vector_address_reg_133 */



/* vector_address_reg_134 */



/* vector_address_reg_135 */



/* vector_address_reg_136 */



/* vector_address_reg_137 */



/* vector_address_reg_138 */



/* vector_address_reg_139 */



/* vector_address_reg_140 */



/* vector_address_reg_141 */



/* vector_address_reg_142 */



/* vector_address_reg_143 */



/* vector_address_reg_144 */



/* vector_address_reg_145 */



/* vector_address_reg_146 */



/* vector_address_reg_147 */



/* vector_address_reg_148 */



/* vector_address_reg_149 */



/* vector_address_reg_150 */



/* vector_address_reg_151 */



/* vector_address_reg_152 */



/* vector_address_reg_153 */



/* vector_address_reg_154 */



/* vector_address_reg_155 */



/* vector_address_reg_156 */



/* vector_address_reg_157 */



/* vector_address_reg_158 */



/* vector_address_reg_159 */



/* vector_address_reg_160 */



/* vector_address_reg_161 */



/* vector_address_reg_162 */



/* vector_address_reg_163 */



/* vector_address_reg_164 */



/* vector_address_reg_165 */



/* vector_address_reg_166 */



/* vector_address_reg_167 */



/* vector_address_reg_168 */



/* vector_address_reg_169 */



/* vector_address_reg_170 */



/* vector_address_reg_171 */



/* vector_address_reg_172 */



/* vector_address_reg_173 */



/* vector_address_reg_174 */



/* vector_address_reg_175 */



/* vector_address_reg_176 */



/* vector_address_reg_177 */



/* vector_address_reg_178 */



/* vector_address_reg_179 */



/* vector_address_reg_180 */



/* vector_address_reg_181 */



/* vector_address_reg_182 */



/* vector_address_reg_183 */



/* vector_address_reg_184 */



/* vector_address_reg_185 */



/* vector_address_reg_186 */



/* vector_address_reg_187 */



/* vector_address_reg_188 */



/* vector_address_reg_189 */



/* vector_address_reg_190 */



/* vector_address_reg_191 */



/* vector_address_reg_192 */



/* vector_address_reg_193 */



/* vector_address_reg_194 */



/* vector_address_reg_195 */



/* vector_address_reg_196 */



/* vector_address_reg_197 */



/* vector_address_reg_198 */



/* vector_address_reg_199 */



/* vector_address_reg_200 */



/* vector_address_reg_201 */



/* vector_address_reg_202 */



/* vector_address_reg_203 */



/* vector_address_reg_204 */



/* vector_address_reg_205 */



/* vector_address_reg_206 */



/* vector_address_reg_207 */



/* vector_address_reg_208 */



/* vector_address_reg_209 */



/* vector_address_reg_210 */



/* vector_address_reg_211 */



/* vector_address_reg_212 */



/* vector_address_reg_213 */



/* vector_address_reg_214 */



/* vector_address_reg_215 */



/* vector_address_reg_216 */



/* vector_address_reg_217 */



/* vector_address_reg_218 */



/* vector_address_reg_219 */



/* vector_address_reg_220 */



/* vector_address_reg_221 */



/* vector_address_reg_222 */



/* vector_address_reg_223 */



/* vector_address_reg_224 */



/* vector_address_reg_225 */



/* vector_address_reg_226 */



/* vector_address_reg_227 */



/* vector_address_reg_228 */



/* vector_address_reg_229 */



/* vector_address_reg_230 */



/* vector_address_reg_231 */



/* vector_address_reg_232 */



/* vector_address_reg_233 */



/* vector_address_reg_234 */



/* vector_address_reg_235 */



/* vector_address_reg_236 */



/* vector_address_reg_237 */



/* vector_address_reg_238 */



/* vector_address_reg_239 */



/* vector_address_reg_240 */



/* vector_address_reg_241 */



/* vector_address_reg_242 */



/* vector_address_reg_243 */



/* vector_address_reg_244 */



/* vector_address_reg_245 */



/* vector_address_reg_246 */



/* vector_address_reg_247 */



/* vector_address_reg_248 */



/* vector_address_reg_249 */



/* vector_address_reg_250 */



/* vector_address_reg_251 */



/* vector_address_reg_252 */



/* vector_address_reg_253 */



/* vector_address_reg_254 */



/* vector_address_reg_255 */



/* vector_address_reg_256 */



/* vector_address_reg_257 */



/* vector_address_reg_258 */



/* vector_address_reg_259 */



/* vector_address_reg_260 */



/* vector_address_reg_261 */



/* vector_address_reg_262 */



/* vector_address_reg_263 */



/* vector_address_reg_264 */



/* vector_address_reg_265 */



/* vector_address_reg_266 */



/* vector_address_reg_267 */



/* vector_address_reg_268 */



/* vector_address_reg_269 */



/* vector_address_reg_270 */



/* vector_address_reg_271 */



/* vector_address_reg_272 */



/* vector_address_reg_273 */



/* vector_address_reg_274 */



/* vector_address_reg_275 */



/* vector_address_reg_276 */



/* vector_address_reg_277 */



/* vector_address_reg_278 */



/* vector_address_reg_279 */



/* vector_address_reg_280 */



/* vector_address_reg_281 */



/* vector_address_reg_282 */



/* vector_address_reg_283 */



/* vector_address_reg_284 */



/* vector_address_reg_285 */



/* vector_address_reg_286 */



/* vector_address_reg_287 */



/* vector_address_reg_288 */



/* vector_address_reg_289 */



/* vector_address_reg_290 */



/* vector_address_reg_291 */



/* vector_address_reg_292 */



/* vector_address_reg_293 */



/* vector_address_reg_294 */



/* vector_address_reg_295 */



/* vector_address_reg_296 */



/* vector_address_reg_297 */



/* vector_address_reg_298 */



/* vector_address_reg_299 */



/* vector_address_reg_300 */



/* vector_address_reg_301 */



/* vector_address_reg_302 */



/* vector_address_reg_303 */



/* vector_address_reg_304 */



/* vector_address_reg_305 */



/* vector_address_reg_306 */



/* vector_address_reg_307 */



/* vector_address_reg_308 */



/* vector_address_reg_309 */



/* vector_address_reg_310 */



/* vector_address_reg_311 */



/* vector_address_reg_312 */



/* vector_address_reg_313 */



/* vector_address_reg_314 */



/* vector_address_reg_315 */



/* vector_address_reg_316 */



/* vector_address_reg_317 */



/* vector_address_reg_318 */



/* vector_address_reg_319 */



/* vector_address_reg_320 */



/* vector_address_reg_321 */



/* vector_address_reg_322 */



/* vector_address_reg_323 */



/* vector_address_reg_324 */



/* vector_address_reg_325 */



/* vector_address_reg_326 */



/* vector_address_reg_327 */



/* vector_address_reg_328 */



/* vector_address_reg_329 */



/* vector_address_reg_330 */



/* vector_address_reg_331 */



/* vector_address_reg_332 */



/* vector_address_reg_333 */



/* vector_address_reg_334 */



/* vector_address_reg_335 */



/* vector_address_reg_336 */



/* vector_address_reg_337 */



/* vector_address_reg_338 */



/* vector_address_reg_339 */



/* vector_address_reg_340 */



/* vector_address_reg_341 */



/* vector_address_reg_342 */



/* vector_address_reg_343 */



/* vector_address_reg_344 */



/* vector_address_reg_345 */



/* vector_address_reg_346 */



/* vector_address_reg_347 */



/* vector_address_reg_348 */



/* vector_address_reg_349 */



/* vector_address_reg_350 */



/* vector_address_reg_351 */



/* vector_address_reg_352 */



/* vector_address_reg_353 */



/* vector_address_reg_354 */



/* vector_address_reg_355 */



/* vector_address_reg_356 */



/* vector_address_reg_357 */



/* vector_address_reg_358 */



/* vector_address_reg_359 */



/* vector_address_reg_360 */



/* vector_address_reg_361 */



/* vector_address_reg_362 */



/* vector_address_reg_363 */



/* vector_address_reg_364 */



/* vector_address_reg_365 */



/* vector_address_reg_366 */



/* vector_address_reg_367 */



/* vector_address_reg_368 */



/* vector_address_reg_369 */



/* vector_address_reg_370 */



/* vector_address_reg_371 */



/* vector_address_reg_372 */



/* vector_address_reg_373 */



/* vector_address_reg_374 */



/* vector_address_reg_375 */



/* vector_address_reg_376 */



/* vector_address_reg_377 */



/* vector_address_reg_378 */



/* vector_address_reg_379 */



/* vector_address_reg_380 */



/* vector_address_reg_381 */



/* vector_address_reg_382 */



/* vector_address_reg_383 */



/* vector_address_reg_384 */



/* vector_address_reg_385 */



/* vector_address_reg_386 */



/* vector_address_reg_387 */



/* vector_address_reg_388 */



/* vector_address_reg_389 */



/* vector_address_reg_390 */



/* vector_address_reg_391 */



/* vector_address_reg_392 */



/* vector_address_reg_393 */



/* vector_address_reg_394 */



/* vector_address_reg_395 */



/* vector_address_reg_396 */



/* vector_address_reg_397 */



/* vector_address_reg_398 */



/* vector_address_reg_399 */



/* vector_address_reg_400 */



/* vector_address_reg_401 */



/* vector_address_reg_402 */



/* vector_address_reg_403 */



/* vector_address_reg_404 */



/* vector_address_reg_405 */



/* vector_address_reg_406 */



/* vector_address_reg_407 */



/* vector_address_reg_408 */



/* vector_address_reg_409 */



/* vector_address_reg_410 */



/* vector_address_reg_411 */



/* vector_address_reg_412 */



/* vector_address_reg_413 */



/* vector_address_reg_414 */



/* vector_address_reg_415 */



/* vector_address_reg_416 */



/* vector_address_reg_417 */



/* vector_address_reg_418 */



/* vector_address_reg_419 */



/* vector_address_reg_420 */



/* vector_address_reg_421 */



/* vector_address_reg_422 */



/* vector_address_reg_423 */



/* vector_address_reg_424 */



/* vector_address_reg_425 */



/* vector_address_reg_426 */



/* vector_address_reg_427 */



/* vector_address_reg_428 */



/* vector_address_reg_429 */



/* vector_address_reg_430 */



/* vector_address_reg_431 */



/* vector_address_reg_432 */



/* vector_address_reg_433 */



/* vector_address_reg_434 */



/* vector_address_reg_435 */



/* vector_address_reg_436 */



/* vector_address_reg_437 */



/* vector_address_reg_438 */



/* vector_address_reg_439 */



/* vector_address_reg_440 */



/* vector_address_reg_441 */



/* vector_address_reg_442 */



/* vector_address_reg_443 */



/* vector_address_reg_444 */



/* vector_address_reg_445 */



/* vector_address_reg_446 */



/* vector_address_reg_447 */



/* vector_address_reg_448 */



/* vector_address_reg_449 */



/* vector_address_reg_450 */



/* vector_address_reg_451 */



/* vector_address_reg_452 */



/* vector_address_reg_453 */



/* vector_address_reg_454 */



/* vector_address_reg_455 */



/* vector_address_reg_456 */



/* vector_address_reg_457 */



/* vector_address_reg_458 */



/* vector_address_reg_459 */



/* vector_address_reg_460 */



/* vector_address_reg_461 */



/* vector_address_reg_462 */



/* vector_address_reg_463 */



/* vector_address_reg_464 */



/* vector_address_reg_465 */



/* vector_address_reg_466 */



/* vector_address_reg_467 */



/* vector_address_reg_468 */



/* vector_address_reg_469 */



/* vector_address_reg_470 */



/* vector_address_reg_471 */



/* vector_address_reg_472 */



/* vector_address_reg_473 */



/* vector_address_reg_474 */



/* vector_address_reg_475 */



/* vector_address_reg_476 */



/* vector_address_reg_477 */



/* vector_address_reg_478 */



/* vector_address_reg_479 */



/* vector_address_reg_480 */



/* vector_address_reg_481 */



/* vector_address_reg_482 */



/* vector_address_reg_483 */



/* vector_address_reg_484 */



/* vector_address_reg_485 */



/* vector_address_reg_486 */



/* vector_address_reg_487 */



/* vector_address_reg_488 */



/* vector_address_reg_489 */



/* vector_address_reg_490 */



/* vector_address_reg_491 */



/* vector_address_reg_492 */



/* vector_address_reg_493 */



/* vector_address_reg_494 */



/* vector_address_reg_495 */



/* vector_address_reg_496 */



/* vector_address_reg_497 */



/* vector_address_reg_498 */



/* vector_address_reg_499 */



/* vector_address_reg_500 */



/* vector_address_reg_501 */



/* vector_address_reg_502 */



/* vector_address_reg_503 */



/* vector_address_reg_504 */



/* vector_address_reg_505 */



/* vector_address_reg_506 */



/* vector_address_reg_507 */



/* vector_address_reg_508 */



/* vector_address_reg_509 */



/* vector_address_reg_510 */



/* vector_address_reg_511 */



/* vector_address_reg_512 */



/* vector_address_reg_513 */



/* vector_address_reg_514 */



/* vector_address_reg_515 */



/* vector_address_reg_516 */



/* vector_address_reg_517 */



/* vector_address_reg_518 */



/* vector_address_reg_519 */



/* vector_address_reg_520 */



/* vector_address_reg_521 */



/* vector_address_reg_522 */



/* vector_address_reg_523 */



/* vector_address_reg_524 */



/* vector_address_reg_525 */



/* vector_address_reg_526 */



/* vector_address_reg_527 */



/* vector_address_reg_528 */



/* vector_address_reg_529 */



/* vector_address_reg_530 */



/* vector_address_reg_531 */



/* vector_address_reg_532 */



/* vector_address_reg_533 */



/* vector_address_reg_534 */



/* vector_address_reg_535 */



/* vector_address_reg_536 */



/* vector_address_reg_537 */



/* vector_address_reg_538 */



/* vector_address_reg_539 */



/* vector_address_reg_540 */



/* vector_address_reg_541 */



/* vector_address_reg_542 */



/* vector_address_reg_543 */



/* vector_address_reg_544 */



/* vector_address_reg_545 */



/* vector_address_reg_546 */



/* vector_address_reg_547 */



/* vector_address_reg_548 */



/* vector_address_reg_549 */



/* vector_address_reg_550 */



/* vector_address_reg_551 */



/* vector_address_reg_552 */



/* vector_address_reg_553 */



/* vector_address_reg_554 */



/* vector_address_reg_555 */



/* vector_address_reg_556 */



/* vector_address_reg_557 */



/* vector_address_reg_558 */



/* vector_address_reg_559 */



/* vector_address_reg_560 */



/* vector_address_reg_561 */



/* vector_address_reg_562 */



/* vector_address_reg_563 */



/* vector_address_reg_564 */



/* vector_address_reg_565 */



/* vector_address_reg_566 */



/* vector_address_reg_567 */



/* vector_address_reg_568 */



/* vector_address_reg_569 */



/* vector_address_reg_570 */



/* vector_address_reg_571 */



/* vector_address_reg_572 */



/* vector_address_reg_573 */



/* vector_address_reg_574 */



/* vector_address_reg_575 */



/* vector_address_reg_576 */



/* vector_address_reg_577 */



/* vector_address_reg_578 */



/* vector_address_reg_579 */



/* vector_address_reg_580 */



/* vector_address_reg_581 */



/* vector_address_reg_582 */



/* vector_address_reg_583 */



/* vector_address_reg_584 */



/* vector_address_reg_585 */



/* vector_address_reg_586 */



/* vector_address_reg_587 */



/* vector_address_reg_588 */



/* vector_address_reg_589 */



/* vector_address_reg_590 */



/* vector_address_reg_591 */



/* vector_address_reg_592 */



/* vector_address_reg_593 */



/* vector_address_reg_594 */



/* vector_address_reg_595 */



/* vector_address_reg_596 */



/* vector_address_reg_597 */



/* vector_address_reg_598 */



/* vector_address_reg_599 */



/* vector_address_reg_600 */



/* vector_address_reg_601 */



/* vector_address_reg_602 */



/* vector_address_reg_603 */



/* vector_address_reg_604 */



/* vector_address_reg_605 */



/* vector_address_reg_606 */



/* vector_address_reg_607 */



/* vector_address_reg_608 */



/* vector_address_reg_609 */



/* vector_address_reg_610 */



/* vector_address_reg_611 */



/* vector_address_reg_612 */



/* vector_address_reg_613 */



/* vector_address_reg_614 */



/* vector_address_reg_615 */



/* vector_address_reg_616 */



/* vector_address_reg_617 */



/* vector_address_reg_618 */



/* vector_address_reg_619 */



/* vector_address_reg_620 */



/* vector_address_reg_621 */



/* vector_address_reg_622 */



/* vector_address_reg_623 */



/* vector_address_reg_624 */



/* vector_address_reg_625 */



/* vector_address_reg_626 */



/* vector_address_reg_627 */



/* vector_address_reg_628 */



/* vector_address_reg_629 */



/* vector_address_reg_630 */



/* vector_address_reg_631 */



/* vector_address_reg_632 */



/* vector_address_reg_633 */



/* vector_address_reg_634 */



/* vector_address_reg_635 */



/* vector_address_reg_636 */



/* vector_address_reg_637 */



/* vector_address_reg_638 */



/* vector_address_reg_639 */



/* vector_address_reg_640 */



/* vector_address_reg_641 */



/* vector_address_reg_642 */



/* vector_address_reg_643 */



/* vector_address_reg_644 */



/* vector_address_reg_645 */



/* vector_address_reg_646 */



/* vector_address_reg_647 */



/* vector_address_reg_648 */



/* vector_address_reg_649 */



/* vector_address_reg_650 */



/* vector_address_reg_651 */



/* vector_address_reg_652 */



/* vector_address_reg_653 */



/* vector_address_reg_654 */



/* vector_address_reg_655 */



/* vector_address_reg_656 */



/* vector_address_reg_657 */



/* vector_address_reg_658 */



/* vector_address_reg_659 */



/* vector_address_reg_660 */



/* vector_address_reg_661 */



/* vector_address_reg_662 */



/* vector_address_reg_663 */



/* vector_address_reg_664 */



/* vector_address_reg_665 */



/* vector_address_reg_666 */



/* vector_address_reg_667 */



/* vector_address_reg_668 */



/* vector_address_reg_669 */



/* vector_address_reg_670 */



/* vector_address_reg_671 */



/* vector_address_reg_672 */



/* vector_address_reg_673 */



/* vector_address_reg_674 */



/* vector_address_reg_675 */



/* vector_address_reg_676 */



/* vector_address_reg_677 */



/* vector_address_reg_678 */



/* vector_address_reg_679 */



/* vector_address_reg_680 */



/* vector_address_reg_681 */



/* vector_address_reg_682 */



/* vector_address_reg_683 */



/* vector_address_reg_684 */



/* vector_address_reg_685 */



/* vector_address_reg_686 */



/* vector_address_reg_687 */



/* vector_address_reg_688 */



/* vector_address_reg_689 */



/* vector_address_reg_690 */



/* vector_address_reg_691 */



/* vector_address_reg_692 */



/* vector_address_reg_693 */



/* vector_address_reg_694 */



/* vector_address_reg_695 */



/* vector_address_reg_696 */



/* vector_address_reg_697 */



/* vector_address_reg_698 */



/* vector_address_reg_699 */



/* vector_address_reg_700 */



/* vector_address_reg_701 */



/* vector_address_reg_702 */



/* vector_address_reg_703 */



/* vector_address_reg_704 */



/* vector_address_reg_705 */



/* vector_address_reg_706 */



/* vector_address_reg_707 */



/* vector_address_reg_708 */



/* vector_address_reg_709 */



/* vector_address_reg_710 */



/* vector_address_reg_711 */



/* vector_address_reg_712 */



/* vector_address_reg_713 */



/* vector_address_reg_714 */



/* vector_address_reg_715 */



/* vector_address_reg_716 */



/* vector_address_reg_717 */



/* vector_address_reg_718 */



/* vector_address_reg_719 */



/* vector_address_reg_720 */



/* vector_address_reg_721 */



/* vector_address_reg_722 */



/* vector_address_reg_723 */



/* vector_address_reg_724 */



/* vector_address_reg_725 */



/* vector_address_reg_726 */



/* vector_address_reg_727 */



/* vector_address_reg_728 */



/* vector_address_reg_729 */



/* vector_address_reg_730 */



/* vector_address_reg_731 */



/* vector_address_reg_732 */



/* vector_address_reg_733 */



/* vector_address_reg_734 */



/* vector_address_reg_735 */



/* vector_address_reg_736 */



/* vector_address_reg_737 */



/* vector_address_reg_738 */



/* vector_address_reg_739 */



/* vector_address_reg_740 */



/* vector_address_reg_741 */



/* vector_address_reg_742 */



/* vector_address_reg_743 */



/* vector_address_reg_744 */



/* vector_address_reg_745 */



/* vector_address_reg_746 */



/* vector_address_reg_747 */



/* vector_address_reg_748 */



/* vector_address_reg_749 */



/* vector_address_reg_750 */



/* vector_address_reg_751 */



/* vector_address_reg_752 */



/* vector_address_reg_753 */



/* vector_address_reg_754 */



/* vector_address_reg_755 */



/* vector_address_reg_756 */



/* vector_address_reg_757 */



/* vector_address_reg_758 */



/* vector_address_reg_759 */



/* vector_address_reg_760 */



/* vector_address_reg_761 */



/* vector_address_reg_762 */



/* vector_address_reg_763 */



/* vector_address_reg_764 */



/* vector_address_reg_765 */



/* vector_address_reg_766 */



/* vector_address_reg_767 */



/* vector_address_reg_768 */



/* vector_address_reg_769 */



/* vector_address_reg_770 */



/* vector_address_reg_771 */



/* vector_address_reg_772 */



/* vector_address_reg_773 */



/* vector_address_reg_774 */



/* vector_address_reg_775 */



/* vector_address_reg_776 */



/* vector_address_reg_777 */



/* vector_address_reg_778 */



/* vector_address_reg_779 */



/* vector_address_reg_780 */



/* vector_address_reg_781 */



/* vector_address_reg_782 */



/* vector_address_reg_783 */



/* vector_address_reg_784 */



/* vector_address_reg_785 */



/* vector_address_reg_786 */



/* vector_address_reg_787 */



/* vector_address_reg_788 */



/* vector_address_reg_789 */



/* vector_address_reg_790 */



/* vector_address_reg_791 */



/* vector_address_reg_792 */



/* vector_address_reg_793 */



/* vector_address_reg_794 */



/* vector_address_reg_795 */



/* vector_address_reg_796 */



/* vector_address_reg_797 */



/* vector_address_reg_798 */



/* vector_address_reg_799 */



/* vector_address_reg_800 */



/* vector_address_reg_801 */



/* vector_address_reg_802 */



/* vector_address_reg_803 */



/* vector_address_reg_804 */



/* vector_address_reg_805 */



/* vector_address_reg_806 */



/* vector_address_reg_807 */



/* vector_address_reg_808 */



/* vector_address_reg_809 */



/* vector_address_reg_810 */



/* vector_address_reg_811 */



/* vector_address_reg_812 */



/* vector_address_reg_813 */



/* vector_address_reg_814 */



/* vector_address_reg_815 */



/* vector_address_reg_816 */



/* vector_address_reg_817 */



/* vector_address_reg_818 */



/* vector_address_reg_819 */



/* vector_address_reg_820 */



/* vector_address_reg_821 */



/* vector_address_reg_822 */



/* vector_address_reg_823 */



/* vector_address_reg_824 */



/* vector_address_reg_825 */



/* vector_address_reg_826 */



/* vector_address_reg_827 */



/* vector_address_reg_828 */



/* vector_address_reg_829 */



/* vector_address_reg_830 */



/* vector_address_reg_831 */



/* vector_address_reg_832 */



/* vector_address_reg_833 */



/* vector_address_reg_834 */



/* vector_address_reg_835 */



/* vector_address_reg_836 */



/* vector_address_reg_837 */



/* vector_address_reg_838 */



/* vector_address_reg_839 */



/* vector_address_reg_840 */



/* vector_address_reg_841 */



/* vector_address_reg_842 */



/* vector_address_reg_843 */



/* vector_address_reg_844 */



/* vector_address_reg_845 */



/* vector_address_reg_846 */



/* vector_address_reg_847 */



/* vector_address_reg_848 */



/* vector_address_reg_849 */



/* vector_address_reg_850 */



/* vector_address_reg_851 */



/* vector_address_reg_852 */



/* vector_address_reg_853 */



/* vector_address_reg_854 */



/* vector_address_reg_855 */



/* vector_address_reg_856 */



/* vector_address_reg_857 */



/* vector_address_reg_858 */



/* vector_address_reg_859 */



/* vector_address_reg_860 */



/* vector_address_reg_861 */



/* vector_address_reg_862 */



/* vector_address_reg_863 */



/* vector_address_reg_864 */



/* vector_address_reg_865 */



/* vector_address_reg_866 */



/* vector_address_reg_867 */



/* vector_address_reg_868 */



/* vector_address_reg_869 */



/* vector_address_reg_870 */



/* vector_address_reg_871 */



/* vector_address_reg_872 */



/* vector_address_reg_873 */



/* vector_address_reg_874 */



/* vector_address_reg_875 */



/* vector_address_reg_876 */



/* vector_address_reg_877 */



/* vector_address_reg_878 */



/* vector_address_reg_879 */



/* vector_address_reg_880 */



/* vector_address_reg_881 */



/* vector_address_reg_882 */



/* vector_address_reg_883 */



/* vector_address_reg_884 */



/* vector_address_reg_885 */



/* vector_address_reg_886 */



/* vector_address_reg_887 */



/* vector_address_reg_888 */



/* vector_address_reg_889 */



/* vector_address_reg_890 */



/* vector_address_reg_891 */



/* vector_address_reg_892 */



/* vector_address_reg_893 */



/* vector_address_reg_894 */



/* vector_address_reg_895 */



/* vector_address_reg_896 */



/* vector_address_reg_897 */



/* vector_address_reg_898 */



/* vector_address_reg_899 */



/* vector_address_reg_900 */



/* vector_address_reg_901 */



/* vector_address_reg_902 */



/* vector_address_reg_903 */



/* vector_address_reg_904 */



/* vector_address_reg_905 */



/* vector_address_reg_906 */



/* vector_address_reg_907 */



/* vector_address_reg_908 */



/* vector_address_reg_909 */



/* vector_address_reg_910 */



/* vector_address_reg_911 */



/* vector_address_reg_912 */



/* vector_address_reg_913 */



/* vector_address_reg_914 */



/* vector_address_reg_915 */



/* vector_address_reg_916 */



/* vector_address_reg_917 */



/* vector_address_reg_918 */



/* vector_address_reg_919 */



/* vector_address_reg_920 */



/* vector_address_reg_921 */



/* vector_address_reg_922 */



/* vector_address_reg_923 */



/* vector_address_reg_924 */



/* vector_address_reg_925 */



/* vector_address_reg_926 */



/* vector_address_reg_927 */



/* vector_address_reg_928 */



/* vector_address_reg_929 */



/* vector_address_reg_930 */



/* vector_address_reg_931 */



/* vector_address_reg_932 */



/* vector_address_reg_933 */



/* vector_address_reg_934 */



/* vector_address_reg_935 */



/* vector_address_reg_936 */



/* vector_address_reg_937 */



/* vector_address_reg_938 */



/* vector_address_reg_939 */



/* vector_address_reg_940 */



/* vector_address_reg_941 */



/* vector_address_reg_942 */



/* vector_address_reg_943 */



/* vector_address_reg_944 */



/* vector_address_reg_945 */



/* vector_address_reg_946 */



/* vector_address_reg_947 */



/* vector_address_reg_948 */



/* vector_address_reg_949 */



/* vector_address_reg_950 */



/* vector_address_reg_951 */



/* vector_address_reg_952 */



/* vector_address_reg_953 */



/* vector_address_reg_954 */



/* vector_address_reg_955 */



/* vector_address_reg_956 */



/* vector_address_reg_957 */



/* vector_address_reg_958 */



/* vector_address_reg_959 */



/* vector_address_reg_960 */



/* vector_address_reg_961 */



/* vector_address_reg_962 */



/* vector_address_reg_963 */



/* vector_address_reg_964 */



/* vector_address_reg_965 */



/* vector_address_reg_966 */



/* vector_address_reg_967 */



/* vector_address_reg_968 */



/* vector_address_reg_969 */



/* vector_address_reg_970 */



/* vector_address_reg_971 */



/* vector_address_reg_972 */



/* vector_address_reg_973 */



/* vector_address_reg_974 */



/* vector_address_reg_975 */



/* vector_address_reg_976 */



/* vector_address_reg_977 */



/* vector_address_reg_978 */



/* vector_address_reg_979 */



/* vector_address_reg_980 */



/* vector_address_reg_981 */



/* vector_address_reg_982 */



/* vector_address_reg_983 */



/* vector_address_reg_984 */



/* vector_address_reg_985 */



/* vector_address_reg_986 */



/* vector_address_reg_987 */



/* vector_address_reg_988 */



/* vector_address_reg_989 */



/* vector_address_reg_990 */



/* vector_address_reg_991 */



/* vector_address_reg_992 */



/* vector_address_reg_993 */



/* vector_address_reg_994 */



/* vector_address_reg_995 */



/* vector_address_reg_996 */



/* vector_address_reg_997 */



/* vector_address_reg_998 */



/* vector_address_reg_999 */



/* vector_address_reg_1000 */



/* vector_address_reg_1001 */



/* vector_address_reg_1002 */



/* vector_address_reg_1003 */



/* vector_address_reg_1004 */



/* vector_address_reg_1005 */



/* vector_address_reg_1006 */



/* vector_address_reg_1007 */



/* vector_address_reg_1008 */



/* vector_address_reg_1009 */



/* vector_address_reg_1010 */



/* vector_address_reg_1011 */



/* vector_address_reg_1012 */



/* vector_address_reg_1013 */



/* vector_address_reg_1014 */



/* vector_address_reg_1015 */



/* vector_address_reg_1016 */



/* vector_address_reg_1017 */



/* vector_address_reg_1018 */



/* vector_address_reg_1019 */



/* vector_address_reg_1020 */



/* vector_address_reg_1021 */



/* vector_address_reg_1022 */



/* vector_address_reg_1023 */





/**
@defgroup CSL_CPINTC_SYMBOL  CPINTC Symbols Defined
@ingroup CSL_CPINTC_API
*/
/**
@defgroup CSL_CPINTC_DATASTRUCT  CPINTC Data Structures
@ingroup CSL_CPINTC_API
*/
/**
@defgroup CSL_CPINTC_FUNCTION  CPINTC Functions
@ingroup CSL_CPINTC_API
*/

/** @addtogroup CSL_CPINTC_DATASTRUCT
 @{ */
 
/** @brief Register Overlay Memory map for the CPINTC0 Registers. */
typedef volatile CSL_CPINTCRegs*  CSL_CPINTC_RegsOvly;

/** @brief This is the handle to the CPINTC instance */
typedef Uint32   CSL_CPINTC_Handle;

/** @brief This defines the system interrupt */
typedef Uint32   CSL_CPINTCSystemInterrupt;

/** @brief This defines the host interrupt */
typedef Uint32   CSL_CPINTCHostInterrupt;

/** @brief This defines the channels */
typedef Uint32   CSL_CPINTCChannel;

/** @brief This defines the nesting level */
typedef Uint16   CSL_CPINTCNestingLevel;

/** @brief Enumeration defines the type of Nesting Modes which is supported by the CPINTC */
typedef enum CSL_CPINTCNestingMode
{
    CPINTC_NO_NESTING            = 0x0,
    CPINTC_AUTOMATIC_GLB_NESTING = 0x1,
    CPINTC_AUTOMATIC_IND_NESTING = 0x2,
    CPINTC_MANUAL_NESTING        = 0x3
}CSL_CPINTCNestingMode;

/**
@}
*/

/* Device specific API which opens the CPINTC instance and returns a handle used in all subsequent calls */
extern CSL_CPINTC_Handle CSL_CPINTC_open (Int32 instNum);



//#include <csl_cicAux.h> //in CCS5 this include file is not present, that's why removed by remesh
/**
 *   @file  csl_cpintcAux.h
 *
 *   @brief   
 *      This is the CPINTC Auxilary Header File which exposes the various
 *      CSL Functional Layer API's to configure the CPINTC Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
 



/** @addtogroup CSL_CPINTC_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_CPINTC_setNestingMode
 *
 *   @b Description
 *   @n This API configures the Interrupt Controller nesting mode.
 *      
 *   @b Arguments
 *   @verbatim
        hnd         This is the handle to the CPINTC instance.
        nestMode    Nesting Mode to be configured
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The interrupt controller is configured to use the specified nesting mode.
 *
 *   @b  Writes
 *   @n  CPINTC_CONTROL_REG_NEST_MODE
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCNestingMode nestMode;
        CSL_CPINTC_HANDLE     hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTC_setNestingMode (hnd, nestMode);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_setNestingMode
(
    CSL_CPINTC_Handle       hnd, 
    CSL_CPINTCNestingMode   nestMode
)
{
    /* Write the CONTROL_REG with the specified nesting mode. */        
    ((CSL_CPINTC_RegsOvly)hnd)->CONTROL_REG = (((nestMode) << (0x00000002u)) & (0x0000000Cu));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_getNestingMode
 *
 *   @b Description
 *   @n This API gets the current nesting mode which is configured in the
 *      interrupt controller.
 * 
 *   @b Arguments
 *   @verbatim
        hnd         This is the handle to the CPINTC instance.
     @endverbatim
 * 
 *      
 *   <b> Return Value </b> 
 *       CSL_CPINTCNestingMode - Current Nesting Mode.
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Reads
 *   @n  CPINTC_CONTROL_REG_NEST_MODE
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTC_HANDLE     hnd;
        CSL_CPINTCNestingMode nestMode;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        nestMode = CSL_CPINTC_getNestingMode();
     @endverbatim
 * ===========================================================================
 */
static inline CSL_CPINTCNestingMode CSL_CPINTC_getNestingMode (CSL_CPINTC_Handle hnd)
{
    return (CSL_CPINTCNestingMode)(((((CSL_CPINTC_RegsOvly)hnd)->CONTROL_REG) & (0x0000000Cu)) >> (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_setNestingLevel
 *
 *   @b Description
 *   @n This API overrides the Interrupt Controller global nesting level that
        is set by automatic nesting	mode
 *      
 *   @b Arguments
 *   @verbatim
        hnd         This is the handle to the CPINTC instance.
        nestLevel   Nesting Level to be configured
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The interrupt controller is configured to use the specified nesting level.
 *
 *   @b  Writes
 *   @n  CPINTC_GLB_NEST_LEVEL_REG_GLB_NEST_LEVEL
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCNestingLevel nestLevel;
        CSL_CPINTC_HANDLE      hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTC_setNestingLevel (hnd, nestLevel);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_setNestingLevel
(
    CSL_CPINTC_Handle       hnd, 
    CSL_CPINTCNestingLevel  nestLevel
)
{
	Uint32 writeVal;

	writeVal = nestLevel & 0x1ff;
	writeVal |= 0x80000000;		/* set bit 31 auto_override */
    /* Write the GLB_NEST_LEVEL_REG with the specified nesting mode. */        
    ((CSL_CPINTC_RegsOvly)hnd)->GLB_NEST_LEVEL_REG = writeVal;
}

/** ============================================================================
 *   @n@b CSL_CPINTC_getNestingLevel
 *
 *   @b Description
 *   @n This API gets the current nesting level which is configured in the
 *      interrupt controller.
 * 
 *   @b Arguments
 *   @verbatim
        hnd         This is the handle to the CPINTC instance.
     @endverbatim
 * 
 *      
 *   <b> Return Value </b> 
 *       CSL_CPINTCNestingLevel - Current Nesting Level.
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Reads
 *   @n  CPINTC_GLB_NEST_LEVEL_REG_GLB_NEST_LEVEL
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTC_HANDLE      hnd;
        CSL_CPINTCNestingLevel nestLevel;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        nestLevel = CSL_CPINTC_getNestingLevel();
     @endverbatim
 * ===========================================================================
 */
static inline CSL_CPINTCNestingLevel CSL_CPINTC_getNestingLevel (CSL_CPINTC_Handle hnd)
{
    return (CSL_CPINTCNestingLevel)(((((CSL_CPINTC_RegsOvly)hnd)->GLB_NEST_LEVEL_REG) & (0x000001FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_enableAllHostInterrupt
 *
 *   @b Description
 *   @n This API enables all the Host Interrupts in the system.
 * 
 *   @b Arguments
 *   @verbatim
        hnd         This is the handle to the CPINTC instance.
     @endverbatim
 *       
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  All host interrupts are enabled in the system. Individual Host
 *       interrupts are still enabled/disabled from their individual 
 *       registers
 *
 *   @b  Writes
 *   @n  CPINTC_GLOBAL_ENABLE_HINT_REG_ENABLE_HINT_ANY=1
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTC_HANDLE     hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTC_enableAllHostInterrupt (hnd);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_enableAllHostInterrupt (CSL_CPINTC_Handle hnd)
{
    /* Enable all host interrupts by writing 1 to the register. */
    ((CSL_CPINTC_RegsOvly)hnd)->GLOBAL_ENABLE_HINT_REG = 
            (((1) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_disableAllHostInterrupt
 *
 *   @b Description
 *   @n This API disables all the Host Interrupts in the system.
 * 
 *   @b Arguments
 *   @verbatim
        hnd         This is the handle to the CPINTC instance.
     @endverbatim
 *       
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  All host interrupts are disabled in the system. 
 *
 *   @b  Writes
 *   @n  CPINTC_GLOBAL_ENABLE_HINT_REG_ENABLE_HINT_ANY=0
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTC_HANDLE     hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTC_disableAllHostInterrupt (hnd);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_disableAllHostInterrupt (CSL_CPINTC_Handle hnd)
{
    /* Disable all host interrupts by writing 0 to the register. */
    ((CSL_CPINTC_RegsOvly)hnd)->GLOBAL_ENABLE_HINT_REG = 
            (((0) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_enableSysInterrupt
 *
 *   @b Description
 *   @n This API enables the system interrupt in the interrupt controller.
 *      
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        sysIntr    System Interrupt which is to be enabled.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The specific System Interrupt is enabled in the controller and
 *       can now generate host interrupts.
 *
 *   @b  Writes
 *   @n  CPINTC_ENABLE_SET_INDEX_REG_ENABLE_SET_INDEX
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCSystemInterrupt     sysIntr;
        CSL_CPINTC_HANDLE             hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTC_enableSysInterrupt (hnd, sysIntr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_enableSysInterrupt 
(
    CSL_CPINTC_Handle           hnd,
    CSL_CPINTCSystemInterrupt   sysIntr
)
{
    /* Write the sysIntr to the ENABLE_SET_INDEX_REG to enable the interrupt. */
    ((CSL_CPINTC_RegsOvly)hnd)->ENABLE_SET_INDEX_REG = 
            (((sysIntr) << (0x00000000u)) & (0x000003FFu));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_disableSysInterrupt
 *
 *   @b Description
 *   @n This API disables the system interrupt in the interrupt controller.
 *      
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        sysIntr    System Interrupt which is to be disabled.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The specific System Interrupt is disabled in the controller and
 *       cannot generate host interrupts.
 *
 *   @b  Writes
 *   @n  CPINTC_ENABLE_CLR_INDEX_REG_ENABLE_CLR_INDEX
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCSystemInterrupt     sysIntr;
        CSL_CPINTC_HANDLE             hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTC_disableSysInterrupt (hnd, sysIntr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_disableSysInterrupt 
(
    CSL_CPINTC_Handle           hnd,
    CSL_CPINTCSystemInterrupt   sysIntr
)
{
    /* Write the sysIntr to the ENABLE_CLR_INDEX_REG to disable the interrupt. */
    ((CSL_CPINTC_RegsOvly)hnd)->ENABLE_CLR_INDEX_REG = 
            (((sysIntr) << (0x00000000u)) & (0x000003FFu));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_clearSysInterrupt
 *
 *   @b Description
 *   @n This API clear the system interrupt in the interrupt controller.
 *      
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        sysIntr    System Interrupt which is to be cleared.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The specific system interrupt has been serviced and is cleared. 
 *
 *   @b  Writes
 *   @n  CPINTC_STATUS_CLR_INDEX_REG_STATUS_CLR_INDEX
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCSystemInterrupt     sysIntr;
        CSL_CPINTC_HANDLE             hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0       
        ...
        CSL_CPINTC_clearSysInterrupt (hnd, sysIntr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_clearSysInterrupt 
(
    CSL_CPINTC_Handle           hnd,
    CSL_CPINTCSystemInterrupt   sysIntr
)
{
    /* Write the sysIntr to the STATUS_CLR_INDEX_REG to clear the interrupt. */
    ((CSL_CPINTC_RegsOvly)hnd)->STATUS_CLR_INDEX_REG = 
            (((sysIntr) << (0x00000000u)) & (0x000003FFu));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_enableHostInterrupt
 *
 *   @b Description
 *   @n This API enables the host interrupt in the interrupt controller.
 *      
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        sysIntr    Host Interrupt which is to be enabled.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The specific Host Interrupt is enabled in the controller and
 *       can now generate host interrupts.
 *
 *   @b  Writes
 *   @n  CPINTC_HINT_ENABLE_SET_INDEX_REG_HINT_ENABLE_SET_INDEX
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCHostInterrupt     hostIntr;
        CSL_CPINTC_HANDLE           hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0       
        ...
        CSL_CPINTC_enableHostInterrupt (hnd, hostIntr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_enableHostInterrupt 
(
    CSL_CPINTC_Handle           hnd,
    CSL_CPINTCHostInterrupt     hostIntr
)
{
    /* Write the hostIntr to the HINT_ENABLE_SET_INDEX_REG to enable the interrupt. */
    ((CSL_CPINTC_RegsOvly)hnd)->HINT_ENABLE_SET_INDEX_REG = 
            (((hostIntr) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_CPINTCdisableHostInterrupt
 *
 *   @b Description
 *   @n This API disables the host interrupt in the interrupt controller.
 *      
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        sysIntr    Host Interrupt which is to be disabled.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  The specific Host Interrupt is enabled in the controller and
 *       can now generate host interrupts.
 *
 *   @b  Writes
 *   @n  CPINTC_HINT_ENABLE_CLR_INDEX_REG_HINT_ENABLE_CLR_INDEX
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCHostInterrupt     hostIntr;
        CSL_CPINTC_HANDLE           hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTCdisableHostInterrupt (hnd, hostIntr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_disableHostInterrupt
(
    CSL_CPINTC_Handle           hnd,
    CSL_CPINTCHostInterrupt     hostIntr
)
{
    /* Write the hostIntr to the HINT_ENABLE_CLR_INDEX_REG to disable the interrupt. */
    ((CSL_CPINTC_RegsOvly)hnd)->HINT_ENABLE_CLR_INDEX_REG = 
            (((hostIntr) << (0x00000000u)) & (0x000000FFu));        
}

/** ============================================================================
 *   @n@b CSL_CPINTC_isInterruptPending
 *
 *   @b Description
 *   @n This API is used to check if there are any pending interrupts active
 *      in the system or not.
 * 
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       TRUE  - Interrupts are pending.
 *       FALSE - No interrupts are pending.
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Reads
 *   @n  CPINTC_GLB_PRI_INTR_REG_GLB_NONE
 *
 *   @b  Example
 *   @verbatim
        Bool                pendingStatus;
        CSL_CPINTC_HANDLE   hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        pendingStatus = CSL_CPINTCisInterruptPending(hnd);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline Bool CSL_CPINTC_isInterruptPending (CSL_CPINTC_Handle hnd)
{
    Int32   pendStatus;
    
    /* Read the 'GLB_PRI_INTR_REG' to determine if there is a pending interrupt or not? */
    pendStatus = (((((CSL_CPINTC_RegsOvly)hnd)->GLB_PRI_INTR_REG) & (0x80000000u)) >> (0x0000001Fu));
    return (pendStatus == 1) ? 0 : 1; 
}

/** ============================================================================
 *   @n@b CSL_CPINTC_getPendingInterrupt
 *
 *   @b Description
 *   @n This API gets the current highest priority pending interrupt. This API
 *      should only be called after checking if there are pending interrupts 
 *      using the 'CSL_CPINTCisInterruptPending'.
 * 
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_CPINTCHostInterrupt - Highest Priority System Interrupt.
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Reads
 *   @n  CPINTC_GLB_PRI_INTR_REG_GLB_PRI_INTR
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCHostInterrupt intr;
        Bool                    pendingStatus;
        CSL_CPINTC_HANDLE       hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        pendingStatus = CSL_CPINTC_isInterruptPending(hnd);
        if (pendingStatus == TRUE)
        {
            intr = CSL_CPINTC_getPendingInterrupt(hnd);
        }
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_CPINTCSystemInterrupt CSL_CPINTC_getPendingInterrupt (CSL_CPINTC_Handle hnd)
{
    return (CSL_CPINTCHostInterrupt)((((((CSL_CPINTC_RegsOvly)hnd)->GLB_PRI_INTR_REG) & (0x000003FFu)) >> (0x00000000u)));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_isHostInterruptPending
 *
 *   @b Description
 *   @n This API is used to check if there are any pending interrupts active
 *      for a particular host.
 * 
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        hostIntr   This is the specific host interrupt output.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       TRUE  - Interrupts are pending.
 *       FALSE - No interrupts are pending.
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Reads
 *   @n  CPINTC_PRI_HINT_REG0_NONE_HINT_0..CPINTC_PRI_HINT_REG255_NONE_HINT_255
 *
 *   @b  Example
 *   @verbatim
        Bool                pendingStatus;
        CSL_CPINTC_HANDLE   hnd;
        CSL_CPINTCHostInterrupt host;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        pendingStatus = CSL_CPINTC_isHostInterruptPending(hnd, host);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline Bool CSL_CPINTC_isHostInterruptPending 
(
	CSL_CPINTC_Handle hnd, 
    CSL_CPINTCHostInterrupt     hostIntr
)
{
    Int32   pendStatus;
    
    /* Read the 'PRI_HINT_REG' to determine if there is a pending interrupt for this host */
    pendStatus = (((((CSL_CPINTC_RegsOvly)hnd)->PRI_HINT_REG[hostIntr]) & (0x80000000u)) >> (0x0000001Fu));
    return (pendStatus == 1) ? 0 : 1; 
}

/** ============================================================================
 *   @n@b CSL_CPINTC_getPendingHostInterrupt
 *
 *   @b Description
 *   @n This API gets the current highest priority pending interrupt for a
 *      given host. This API should only be called after checking if there
 *      are pending interrupts using the 'CSL_CPINTCisHostInterruptPending'.
 * 
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        hostIntr   This is the specific host interrupt output.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       CSL_CPINTCSystemInterrupt - Highest Priority System Interrupt.
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Reads
 *   @n  CPINTC_PRI_HINT_REG0_PRI_HINT_0..CPINTC_PRI_HINT_REG255_PRI_HINT_255
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCSystemInterrupt intr;
        Bool                      pendingStatus;
        CSL_CPINTC_HANDLE         hnd;
        CSL_CPINTCHostInterrupt   host;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        pendingStatus = CSL_CPINTC_isHostInterruptPending(hnd, host);
        if (pendingStatus == TRUE)
        {
            intr = CSL_CPINTC_getPendingHostInterrupt(hnd, host);
        }
        ...
     @endverbatim
 * ===========================================================================
 */
static inline CSL_CPINTCSystemInterrupt CSL_CPINTC_getPendingHostInterrupt 
(
	CSL_CPINTC_Handle hnd,
    CSL_CPINTCHostInterrupt     hostIntr
)
{
    return (CSL_CPINTCSystemInterrupt)((((((CSL_CPINTC_RegsOvly)hnd)->PRI_HINT_REG[hostIntr]) & (0x000003FFu)) >> (0x00000000u)));
}

/** ============================================================================
 *   @n@b CSL_CPINTC_getRawInterruptStatus
 *
 *   @b Description
 *   @n The function is used to get the contents of the RAW Interrupt status
 *      register. 
 * 
 *   @b Arguments
 *   @verbatim
        hnd         This is the handle to the CPINTC instance.
        index       RAW Status Index register which is to be read
        rawStatus   RAW Status which indicates which interrupts are pending.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Reads
 *   @n  CPINTC_RAW_STATUS_REG
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTC_HANDLE   hnd;
        Uint32              rawStatus;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        // Check if there are any interrupts between 0-31 pending.
        CSL_CPINTC_getRawInterruptStatus(hnd, 0, &rawStatus);
        if (rawStatus != 0)
        {
            // An Interrupt from 0-31 is pending.
        }
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_getRawInterruptStatus 
(
    CSL_CPINTC_Handle   hnd,
    Uint8               index,
    Uint32*             rawStatus
)
{
    *rawStatus = ((CSL_CPINTC_RegsOvly)hnd)->RAW_STATUS_REG[index];
}

/** ============================================================================
 *   @n@b CSL_CPINTC_mapSystemIntrToChannel
 *
 *   @b Description
 *   @n This API is used to map a system interrupt to a specific channel.
 *
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        sysIntr    System Interrupt which is to be mapped
        channel    Channel Number to which the interrupt is to be mapped.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  CPINTC_CH_MAP_REG0_CH_MAP_0..CPINTC_CH_MAP_REG49_CH_MAP_196
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCSystemInterrupt sysIntr;
        CSL_CPINTCChannel         channel;
        CSL_CPINTC_HANDLE         hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTC_mapSystemIntrToChannel(hnd, sysIntr, channel);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_mapSystemIntrToChannel 
(
    CSL_CPINTC_Handle           hnd,
    CSL_CPINTCSystemInterrupt   sysIntr,
    CSL_CPINTCChannel           channel
)
{

    ((CSL_CPINTC_RegsOvly)hnd)->CH_MAP[sysIntr] = channel;
   return;
}

/** ============================================================================
 *   @n@b CSL_CPINTC_mapChannelToHostInterrupt
 *
 *   @b Description
 *   @n This API is used to map the channel to the host interrupt.
 *
 *   @b Arguments
 *   @verbatim
        hnd        This is the handle to the CPINTC instance.
        channel    Channel Number to be mapped
        sysIntr    Host Interrupt to which the channel is mapped to.
     @endverbatim
 *
 *   <b> Return Value </b> 
 *       None 
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPINTC_open() must be called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b  Writes
 *   @n  CPINTC_HINT_MAP_REG0_HINT_MAP_0..CPINTC_HINT_MAP_REG49_HINT_MAP_196
 *
 *   @b  Example
 *   @verbatim
        CSL_CPINTCHostInterrupt hostIntr;
        CSL_CPINTCChannel       channel;
        CSL_CPINTC_HANDLE       hnd;
        ...
        hnd = CSL_CPINTC_open (0);    // Opens CPINTC Instance 0
        ...
        CSL_CPINTC_mapChannelToHostInterrupt(hnd, channel, hostIntr);
        ...
     @endverbatim
 * ===========================================================================
 */
static inline void CSL_CPINTC_mapChannelToHostInterrupt 
(
    CSL_CPINTC_Handle         hnd,
    CSL_CPINTCChannel         channel,
    CSL_CPINTCHostInterrupt   hostIntr
)
{

    ((CSL_CPINTC_RegsOvly)hnd)->HINT_MAP[hostIntr] = channel;
    return;
}

/**
@}
*/




//#include <std.h>
//#include <xdc/std.h>
//#include <DataType.h>
//#include <hwi.h>
/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/*
 *  @(#) ti.sysbios.hal; 2, 0, 0, 0,547; 3-20-2012 14:03:16; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef void (*ti_sysbios_interfaces_IHwi_FuncPtr)(xdc_UArg);

/* Irp */
typedef xdc_UArg ti_sysbios_interfaces_IHwi_Irp;

/* HookSet */
struct ti_sysbios_interfaces_IHwi_HookSet {
    void (*registerFxn)(xdc_Int);
    void (*createFxn)(ti_sysbios_interfaces_IHwi_Handle, xdc_runtime_Error_Block*);
    void (*beginFxn)(ti_sysbios_interfaces_IHwi_Handle);
    void (*endFxn)(ti_sysbios_interfaces_IHwi_Handle);
    void (*deleteFxn)(ti_sysbios_interfaces_IHwi_Handle);
};

/* MaskingOption */
enum ti_sysbios_interfaces_IHwi_MaskingOption {
    ti_sysbios_interfaces_IHwi_MaskingOption_NONE,
    ti_sysbios_interfaces_IHwi_MaskingOption_ALL,
    ti_sysbios_interfaces_IHwi_MaskingOption_SELF,
    ti_sysbios_interfaces_IHwi_MaskingOption_BITMASK,
    ti_sysbios_interfaces_IHwi_MaskingOption_LOWER
};
typedef enum ti_sysbios_interfaces_IHwi_MaskingOption ti_sysbios_interfaces_IHwi_MaskingOption;

/* StackInfo */
struct ti_sysbios_interfaces_IHwi_StackInfo {
    xdc_SizeT hwiStackPeak;
    xdc_SizeT hwiStackSize;
    xdc_Ptr hwiStackBase;
};


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_interfaces_IHwi_Args__create {
    xdc_Int intNum;
    ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn;
} ti_sysbios_interfaces_IHwi_Args__create;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_interfaces_IHwi_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    ti_sysbios_interfaces_IHwi_MaskingOption maskSetting;
    xdc_UArg arg;
    xdc_Bool enableInt;
    xdc_Int eventId;
    xdc_Int priority;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_interfaces_IHwi_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*getStackInfo)(ti_sysbios_interfaces_IHwi_StackInfo*, xdc_Bool);
    void (*startup)(void);
    xdc_UInt (*disable)(void);
    xdc_UInt (*enable)(void);
    void (*restore)(xdc_UInt);
    void (*switchFromBootStack)(void);
    void (*post)(xdc_UInt);
    xdc_Char* (*getTaskSP)(void);
    xdc_UInt (*disableInterrupt)(xdc_UInt);
    xdc_UInt (*enableInterrupt)(xdc_UInt);
    void (*restoreInterrupt)(xdc_UInt, xdc_UInt);
    void (*clearInterrupt)(xdc_UInt);
    ti_sysbios_interfaces_IHwi_FuncPtr (*getFunc)(void*, xdc_UArg*);
    void (*setFunc)(void*, ti_sysbios_interfaces_IHwi_FuncPtr, xdc_UArg);
    xdc_Ptr (*getHookContext)(void*, xdc_Int);
    void (*setHookContext)(void*, xdc_Int, xdc_Ptr);
    ti_sysbios_interfaces_IHwi_Irp (*getIrp)(void*);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base ti_sysbios_interfaces_IHwi_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* create */
static inline ti_sysbios_interfaces_IHwi_Handle ti_sysbios_interfaces_IHwi_create( ti_sysbios_interfaces_IHwi_Module __mod, xdc_Int intNum, ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn, const ti_sysbios_interfaces_IHwi_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_interfaces_IHwi_Args__create __args;
    __args.intNum = intNum;
    __args.hwiFxn = hwiFxn;
    return (ti_sysbios_interfaces_IHwi_Handle) __mod->__sysp->__create(0, 0, &__args, (const xdc_UChar*)__prms, sizeof (ti_sysbios_interfaces_IHwi_Params), __eb);
}

/* delete */
static inline void ti_sysbios_interfaces_IHwi_delete( ti_sysbios_interfaces_IHwi_Handle* instp )
{
    (*instp)->__fxns->__sysp->__delete(instp);
}

/* Handle_to_Module */
static inline ti_sysbios_interfaces_IHwi_Module ti_sysbios_interfaces_IHwi_Handle_to_Module( ti_sysbios_interfaces_IHwi_Handle inst )
{
    return inst->__fxns;
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_interfaces_IHwi_Handle_label( ti_sysbios_interfaces_IHwi_Handle inst, xdc_runtime_Types_Label* lab )
{
    return inst->__fxns->__sysp->__label(inst, lab);
}

/* Module_id */
static inline xdc_runtime_Types_ModuleId ti_sysbios_interfaces_IHwi_Module_id( ti_sysbios_interfaces_IHwi_Module mod )
{
    return mod->__sysp->__mid;
}

/* getStackInfo */
static inline xdc_Bool ti_sysbios_interfaces_IHwi_getStackInfo( ti_sysbios_interfaces_IHwi_Module __inst, ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth )
{
    return __inst->getStackInfo(stkInfo, computeStackDepth);
}

/* startup */
static inline void ti_sysbios_interfaces_IHwi_startup( ti_sysbios_interfaces_IHwi_Module __inst )
{
    __inst->startup();
}

/* disable */
static inline xdc_UInt ti_sysbios_interfaces_IHwi_disable( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return __inst->disable();
}

/* enable */
static inline xdc_UInt ti_sysbios_interfaces_IHwi_enable( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return __inst->enable();
}

/* restore */
static inline void ti_sysbios_interfaces_IHwi_restore( ti_sysbios_interfaces_IHwi_Module __inst, xdc_UInt key )
{
    __inst->restore(key);
}

/* switchFromBootStack */
static inline void ti_sysbios_interfaces_IHwi_switchFromBootStack( ti_sysbios_interfaces_IHwi_Module __inst )
{
    __inst->switchFromBootStack();
}

/* post */
static inline void ti_sysbios_interfaces_IHwi_post( ti_sysbios_interfaces_IHwi_Module __inst, xdc_UInt intNum )
{
    __inst->post(intNum);
}

/* getTaskSP */
static inline xdc_Char* ti_sysbios_interfaces_IHwi_getTaskSP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return __inst->getTaskSP();
}

/* disableInterrupt */
static inline xdc_UInt ti_sysbios_interfaces_IHwi_disableInterrupt( ti_sysbios_interfaces_IHwi_Module __inst, xdc_UInt intNum )
{
    return __inst->disableInterrupt(intNum);
}

/* enableInterrupt */
static inline xdc_UInt ti_sysbios_interfaces_IHwi_enableInterrupt( ti_sysbios_interfaces_IHwi_Module __inst, xdc_UInt intNum )
{
    return __inst->enableInterrupt(intNum);
}

/* restoreInterrupt */
static inline void ti_sysbios_interfaces_IHwi_restoreInterrupt( ti_sysbios_interfaces_IHwi_Module __inst, xdc_UInt intNum, xdc_UInt key )
{
    __inst->restoreInterrupt(intNum, key);
}

/* clearInterrupt */
static inline void ti_sysbios_interfaces_IHwi_clearInterrupt( ti_sysbios_interfaces_IHwi_Module __inst, xdc_UInt intNum )
{
    __inst->clearInterrupt(intNum);
}

/* getFunc */
static inline ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_interfaces_IHwi_getFunc( ti_sysbios_interfaces_IHwi_Handle __inst, xdc_UArg* arg )
{
    return __inst->__fxns->getFunc((void*)__inst, arg);
}

/* setFunc */
static inline void ti_sysbios_interfaces_IHwi_setFunc( ti_sysbios_interfaces_IHwi_Handle __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg )
{
    __inst->__fxns->setFunc((void*)__inst, fxn, arg);
}

/* getHookContext */
static inline xdc_Ptr ti_sysbios_interfaces_IHwi_getHookContext( ti_sysbios_interfaces_IHwi_Handle __inst, xdc_Int id )
{
    return __inst->__fxns->getHookContext((void*)__inst, id);
}

/* setHookContext */
static inline void ti_sysbios_interfaces_IHwi_setHookContext( ti_sysbios_interfaces_IHwi_Handle __inst, xdc_Int id, xdc_Ptr hookContext )
{
    __inst->__fxns->setHookContext((void*)__inst, id, hookContext);
}

/* getIrp */
static inline ti_sysbios_interfaces_IHwi_Irp ti_sysbios_interfaces_IHwi_getIrp( ti_sysbios_interfaces_IHwi_Handle __inst )
{
    return __inst->__fxns->getIrp((void*)__inst);
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getStackInfo_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_interfaces_IHwi_getStackInfo_FxnT)(ti_sysbios_interfaces_IHwi_StackInfo*, xdc_Bool);
static inline ti_sysbios_interfaces_IHwi_getStackInfo_FxnT ti_sysbios_interfaces_IHwi_getStackInfo_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_getStackInfo_FxnT)__inst->getStackInfo;
}

/* startup_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_IHwi_startup_FxnT)(void);
static inline ti_sysbios_interfaces_IHwi_startup_FxnT ti_sysbios_interfaces_IHwi_startup_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_startup_FxnT)__inst->startup;
}

/* disable_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_interfaces_IHwi_disable_FxnT)(void);
static inline ti_sysbios_interfaces_IHwi_disable_FxnT ti_sysbios_interfaces_IHwi_disable_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_disable_FxnT)__inst->disable;
}

/* enable_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_interfaces_IHwi_enable_FxnT)(void);
static inline ti_sysbios_interfaces_IHwi_enable_FxnT ti_sysbios_interfaces_IHwi_enable_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_enable_FxnT)__inst->enable;
}

/* restore_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_IHwi_restore_FxnT)(xdc_UInt);
static inline ti_sysbios_interfaces_IHwi_restore_FxnT ti_sysbios_interfaces_IHwi_restore_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_restore_FxnT)__inst->restore;
}

/* switchFromBootStack_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_IHwi_switchFromBootStack_FxnT)(void);
static inline ti_sysbios_interfaces_IHwi_switchFromBootStack_FxnT ti_sysbios_interfaces_IHwi_switchFromBootStack_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_switchFromBootStack_FxnT)__inst->switchFromBootStack;
}

/* post_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_IHwi_post_FxnT)(xdc_UInt);
static inline ti_sysbios_interfaces_IHwi_post_FxnT ti_sysbios_interfaces_IHwi_post_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_post_FxnT)__inst->post;
}

/* getTaskSP_{FxnT,fxnP} */
typedef xdc_Char* (*ti_sysbios_interfaces_IHwi_getTaskSP_FxnT)(void);
static inline ti_sysbios_interfaces_IHwi_getTaskSP_FxnT ti_sysbios_interfaces_IHwi_getTaskSP_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_getTaskSP_FxnT)__inst->getTaskSP;
}

/* disableInterrupt_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_interfaces_IHwi_disableInterrupt_FxnT)(xdc_UInt);
static inline ti_sysbios_interfaces_IHwi_disableInterrupt_FxnT ti_sysbios_interfaces_IHwi_disableInterrupt_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_disableInterrupt_FxnT)__inst->disableInterrupt;
}

/* enableInterrupt_{FxnT,fxnP} */
typedef xdc_UInt (*ti_sysbios_interfaces_IHwi_enableInterrupt_FxnT)(xdc_UInt);
static inline ti_sysbios_interfaces_IHwi_enableInterrupt_FxnT ti_sysbios_interfaces_IHwi_enableInterrupt_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_enableInterrupt_FxnT)__inst->enableInterrupt;
}

/* restoreInterrupt_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_IHwi_restoreInterrupt_FxnT)(xdc_UInt, xdc_UInt);
static inline ti_sysbios_interfaces_IHwi_restoreInterrupt_FxnT ti_sysbios_interfaces_IHwi_restoreInterrupt_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_restoreInterrupt_FxnT)__inst->restoreInterrupt;
}

/* clearInterrupt_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_IHwi_clearInterrupt_FxnT)(xdc_UInt);
static inline ti_sysbios_interfaces_IHwi_clearInterrupt_FxnT ti_sysbios_interfaces_IHwi_clearInterrupt_fxnP( ti_sysbios_interfaces_IHwi_Module __inst )
{
    return (ti_sysbios_interfaces_IHwi_clearInterrupt_FxnT)__inst->clearInterrupt;
}

/* getFunc_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_IHwi_FuncPtr (*ti_sysbios_interfaces_IHwi_getFunc_FxnT)(void*, xdc_UArg*);
static inline ti_sysbios_interfaces_IHwi_getFunc_FxnT ti_sysbios_interfaces_IHwi_getFunc_fxnP( ti_sysbios_interfaces_IHwi_Handle __inst )
{
    return (ti_sysbios_interfaces_IHwi_getFunc_FxnT)__inst->__fxns->getFunc;
}

/* setFunc_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_IHwi_setFunc_FxnT)(void*, ti_sysbios_interfaces_IHwi_FuncPtr, xdc_UArg);
static inline ti_sysbios_interfaces_IHwi_setFunc_FxnT ti_sysbios_interfaces_IHwi_setFunc_fxnP( ti_sysbios_interfaces_IHwi_Handle __inst )
{
    return (ti_sysbios_interfaces_IHwi_setFunc_FxnT)__inst->__fxns->setFunc;
}

/* getHookContext_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_interfaces_IHwi_getHookContext_FxnT)(void*, xdc_Int);
static inline ti_sysbios_interfaces_IHwi_getHookContext_FxnT ti_sysbios_interfaces_IHwi_getHookContext_fxnP( ti_sysbios_interfaces_IHwi_Handle __inst )
{
    return (ti_sysbios_interfaces_IHwi_getHookContext_FxnT)__inst->__fxns->getHookContext;
}

/* setHookContext_{FxnT,fxnP} */
typedef void (*ti_sysbios_interfaces_IHwi_setHookContext_FxnT)(void*, xdc_Int, xdc_Ptr);
static inline ti_sysbios_interfaces_IHwi_setHookContext_FxnT ti_sysbios_interfaces_IHwi_setHookContext_fxnP( ti_sysbios_interfaces_IHwi_Handle __inst )
{
    return (ti_sysbios_interfaces_IHwi_setHookContext_FxnT)__inst->__fxns->setHookContext;
}

/* getIrp_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_IHwi_Irp (*ti_sysbios_interfaces_IHwi_getIrp_FxnT)(void*);
static inline ti_sysbios_interfaces_IHwi_getIrp_FxnT ti_sysbios_interfaces_IHwi_getIrp_fxnP( ti_sysbios_interfaces_IHwi_Handle __inst )
{
    return (ti_sysbios_interfaces_IHwi_getIrp_FxnT)__inst->__fxns->getIrp;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.interfaces; 2, 0, 0, 0,545; 3-20-2012 14:03:22; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.interfaces; 2, 0, 0, 0,545; 3-20-2012 14:03:22; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_hal_Hwi_HwiProxy_FuncPtr;

/* Irp */
typedef ti_sysbios_interfaces_IHwi_Irp ti_sysbios_hal_Hwi_HwiProxy_Irp;

/* HookSet */
typedef ti_sysbios_interfaces_IHwi_HookSet ti_sysbios_hal_Hwi_HwiProxy_HookSet;

/* MaskingOption */
typedef ti_sysbios_interfaces_IHwi_MaskingOption ti_sysbios_hal_Hwi_HwiProxy_MaskingOption;

/* StackInfo */
typedef ti_sysbios_interfaces_IHwi_StackInfo ti_sysbios_hal_Hwi_HwiProxy_StackInfo;


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_hal_Hwi_HwiProxy_Args__create {
    xdc_Int intNum;
    ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn;
} ti_sysbios_hal_Hwi_HwiProxy_Args__create;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_hal_Hwi_HwiProxy_Module__diagsEnabled;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__diagsEnabled ti_sysbios_hal_Hwi_HwiProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_hal_Hwi_HwiProxy_Module__diagsIncluded;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__diagsIncluded ti_sysbios_hal_Hwi_HwiProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_hal_Hwi_HwiProxy_Module__diagsMask;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__diagsMask ti_sysbios_hal_Hwi_HwiProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_hal_Hwi_HwiProxy_Module__gateObj;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__gateObj ti_sysbios_hal_Hwi_HwiProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_hal_Hwi_HwiProxy_Module__gatePrms;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__gatePrms ti_sysbios_hal_Hwi_HwiProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_hal_Hwi_HwiProxy_Module__id;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__id ti_sysbios_hal_Hwi_HwiProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerDefined;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerDefined ti_sysbios_hal_Hwi_HwiProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerObj;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerObj ti_sysbios_hal_Hwi_HwiProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn0;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn0 ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn1;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn1 ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn2;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn2 ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn4;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn4 ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn8;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn8 ti_sysbios_hal_Hwi_HwiProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_hal_Hwi_HwiProxy_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Module__startupDoneFxn ti_sysbios_hal_Hwi_HwiProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_hal_Hwi_HwiProxy_Object__count;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Object__count ti_sysbios_hal_Hwi_HwiProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_hal_Hwi_HwiProxy_Object__heap;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Object__heap ti_sysbios_hal_Hwi_HwiProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_hal_Hwi_HwiProxy_Object__sizeof;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Object__sizeof ti_sysbios_hal_Hwi_HwiProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_hal_Hwi_HwiProxy_Object__table;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_Object__table ti_sysbios_hal_Hwi_HwiProxy_Object__table__C;

/* dispatcherAutoNestingSupport */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_HwiProxy_dispatcherAutoNestingSupport;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_dispatcherAutoNestingSupport ti_sysbios_hal_Hwi_HwiProxy_dispatcherAutoNestingSupport__C;

/* dispatcherSwiSupport */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_HwiProxy_dispatcherSwiSupport;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_dispatcherSwiSupport ti_sysbios_hal_Hwi_HwiProxy_dispatcherSwiSupport__C;

/* dispatcherTaskSupport */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_HwiProxy_dispatcherTaskSupport;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_dispatcherTaskSupport ti_sysbios_hal_Hwi_HwiProxy_dispatcherTaskSupport__C;

/* dispatcherIrpTrackingSupport */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_HwiProxy_dispatcherIrpTrackingSupport;
extern far const CT__ti_sysbios_hal_Hwi_HwiProxy_dispatcherIrpTrackingSupport ti_sysbios_hal_Hwi_HwiProxy_dispatcherIrpTrackingSupport__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_hal_Hwi_HwiProxy_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    ti_sysbios_interfaces_IHwi_MaskingOption maskSetting;
    xdc_UArg arg;
    xdc_Bool enableInt;
    xdc_Int eventId;
    xdc_Int priority;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_hal_Hwi_HwiProxy_Struct {
    const ti_sysbios_hal_Hwi_HwiProxy_Fxns__* __fxns;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_hal_Hwi_HwiProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*getStackInfo)(ti_sysbios_interfaces_IHwi_StackInfo*, xdc_Bool);
    void (*startup)(void);
    xdc_UInt (*disable)(void);
    xdc_UInt (*enable)(void);
    void (*restore)(xdc_UInt);
    void (*switchFromBootStack)(void);
    void (*post)(xdc_UInt);
    xdc_Char* (*getTaskSP)(void);
    xdc_UInt (*disableInterrupt)(xdc_UInt);
    xdc_UInt (*enableInterrupt)(xdc_UInt);
    void (*restoreInterrupt)(xdc_UInt, xdc_UInt);
    void (*clearInterrupt)(xdc_UInt);
    ti_sysbios_interfaces_IHwi_FuncPtr (*getFunc)(ti_sysbios_hal_Hwi_HwiProxy_Handle, xdc_UArg*);
    void (*setFunc)(ti_sysbios_hal_Hwi_HwiProxy_Handle, ti_sysbios_interfaces_IHwi_FuncPtr, xdc_UArg);
    xdc_Ptr (*getHookContext)(ti_sysbios_hal_Hwi_HwiProxy_Handle, xdc_Int);
    void (*setHookContext)(ti_sysbios_hal_Hwi_HwiProxy_Handle, xdc_Int, xdc_Ptr);
    ti_sysbios_interfaces_IHwi_Irp (*getIrp)(ti_sysbios_hal_Hwi_HwiProxy_Handle);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_hal_Hwi_HwiProxy_Fxns__ ti_sysbios_hal_Hwi_HwiProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_hal_Hwi_HwiProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_hal_Hwi_HwiProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_HwiProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_hal_Hwi_HwiProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_hal_Hwi_HwiProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_HwiProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_HwiProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_HwiProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_hal_Hwi_HwiProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool ti_sysbios_hal_Hwi_HwiProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_HwiProxy_Proxy__delegate__S( void );

/* getStackInfo__E */

extern xdc_Bool ti_sysbios_hal_Hwi_HwiProxy_getStackInfo__E( ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth );

extern xdc_Bool ti_sysbios_hal_Hwi_HwiProxy_getStackInfo__R( ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth );

/* startup__E */

extern void ti_sysbios_hal_Hwi_HwiProxy_startup__E( void );

extern void ti_sysbios_hal_Hwi_HwiProxy_startup__R( void );

/* disable__E */

extern xdc_UInt ti_sysbios_hal_Hwi_HwiProxy_disable__E( void );

extern xdc_UInt ti_sysbios_hal_Hwi_HwiProxy_disable__R( void );

/* enable__E */

extern xdc_UInt ti_sysbios_hal_Hwi_HwiProxy_enable__E( void );

extern xdc_UInt ti_sysbios_hal_Hwi_HwiProxy_enable__R( void );

/* restore__E */

extern void ti_sysbios_hal_Hwi_HwiProxy_restore__E( xdc_UInt key );

extern void ti_sysbios_hal_Hwi_HwiProxy_restore__R( xdc_UInt key );

/* switchFromBootStack__E */

extern void ti_sysbios_hal_Hwi_HwiProxy_switchFromBootStack__E( void );

extern void ti_sysbios_hal_Hwi_HwiProxy_switchFromBootStack__R( void );

/* post__E */

extern void ti_sysbios_hal_Hwi_HwiProxy_post__E( xdc_UInt intNum );

extern void ti_sysbios_hal_Hwi_HwiProxy_post__R( xdc_UInt intNum );

/* getTaskSP__E */

extern xdc_Char* ti_sysbios_hal_Hwi_HwiProxy_getTaskSP__E( void );

extern xdc_Char* ti_sysbios_hal_Hwi_HwiProxy_getTaskSP__R( void );

/* disableInterrupt__E */

extern xdc_UInt ti_sysbios_hal_Hwi_HwiProxy_disableInterrupt__E( xdc_UInt intNum );

extern xdc_UInt ti_sysbios_hal_Hwi_HwiProxy_disableInterrupt__R( xdc_UInt intNum );

/* enableInterrupt__E */

extern xdc_UInt ti_sysbios_hal_Hwi_HwiProxy_enableInterrupt__E( xdc_UInt intNum );

extern xdc_UInt ti_sysbios_hal_Hwi_HwiProxy_enableInterrupt__R( xdc_UInt intNum );

/* restoreInterrupt__E */

extern void ti_sysbios_hal_Hwi_HwiProxy_restoreInterrupt__E( xdc_UInt intNum, xdc_UInt key );

extern void ti_sysbios_hal_Hwi_HwiProxy_restoreInterrupt__R( xdc_UInt intNum, xdc_UInt key );

/* clearInterrupt__E */

extern void ti_sysbios_hal_Hwi_HwiProxy_clearInterrupt__E( xdc_UInt intNum );

extern void ti_sysbios_hal_Hwi_HwiProxy_clearInterrupt__R( xdc_UInt intNum );

/* getFunc__E */

extern ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_hal_Hwi_HwiProxy_getFunc__E( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst, xdc_UArg* arg );

extern ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_hal_Hwi_HwiProxy_getFunc__R( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst, xdc_UArg* arg );

/* setFunc__E */

extern void ti_sysbios_hal_Hwi_HwiProxy_setFunc__E( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg );

extern void ti_sysbios_hal_Hwi_HwiProxy_setFunc__R( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg );

/* getHookContext__E */

extern xdc_Ptr ti_sysbios_hal_Hwi_HwiProxy_getHookContext__E( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst, xdc_Int id );

extern xdc_Ptr ti_sysbios_hal_Hwi_HwiProxy_getHookContext__R( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst, xdc_Int id );

/* setHookContext__E */

extern void ti_sysbios_hal_Hwi_HwiProxy_setHookContext__E( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

extern void ti_sysbios_hal_Hwi_HwiProxy_setHookContext__R( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

/* getIrp__E */

extern ti_sysbios_interfaces_IHwi_Irp ti_sysbios_hal_Hwi_HwiProxy_getIrp__E( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst );

extern ti_sysbios_interfaces_IHwi_Irp ti_sysbios_hal_Hwi_HwiProxy_getIrp__R( ti_sysbios_hal_Hwi_HwiProxy_Handle __inst );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getFunc_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_IHwi_FuncPtr (*ti_sysbios_hal_Hwi_HwiProxy_getFunc_FxnT)(void*, xdc_UArg*);
static inline ti_sysbios_hal_Hwi_HwiProxy_getFunc_FxnT ti_sysbios_hal_Hwi_HwiProxy_getFunc_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_HwiProxy_getFunc_FxnT)ti_sysbios_hal_Hwi_HwiProxy_getFunc__E; 
}

/* setFunc_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Hwi_HwiProxy_setFunc_FxnT)(void*, ti_sysbios_interfaces_IHwi_FuncPtr, xdc_UArg);
static inline ti_sysbios_hal_Hwi_HwiProxy_setFunc_FxnT ti_sysbios_hal_Hwi_HwiProxy_setFunc_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_HwiProxy_setFunc_FxnT)ti_sysbios_hal_Hwi_HwiProxy_setFunc__E; 
}

/* getHookContext_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_hal_Hwi_HwiProxy_getHookContext_FxnT)(void*, xdc_Int);
static inline ti_sysbios_hal_Hwi_HwiProxy_getHookContext_FxnT ti_sysbios_hal_Hwi_HwiProxy_getHookContext_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_HwiProxy_getHookContext_FxnT)ti_sysbios_hal_Hwi_HwiProxy_getHookContext__E; 
}

/* setHookContext_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Hwi_HwiProxy_setHookContext_FxnT)(void*, xdc_Int, xdc_Ptr);
static inline ti_sysbios_hal_Hwi_HwiProxy_setHookContext_FxnT ti_sysbios_hal_Hwi_HwiProxy_setHookContext_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_HwiProxy_setHookContext_FxnT)ti_sysbios_hal_Hwi_HwiProxy_setHookContext__E; 
}

/* getIrp_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_IHwi_Irp (*ti_sysbios_hal_Hwi_HwiProxy_getIrp_FxnT)(void*);
static inline ti_sysbios_hal_Hwi_HwiProxy_getIrp_FxnT ti_sysbios_hal_Hwi_HwiProxy_getIrp_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_HwiProxy_getIrp_FxnT)ti_sysbios_hal_Hwi_HwiProxy_getIrp__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline ti_sysbios_interfaces_IHwi_Module ti_sysbios_hal_Hwi_HwiProxy_Module_upCast( void )
{
    return (ti_sysbios_interfaces_IHwi_Module)ti_sysbios_hal_Hwi_HwiProxy_Proxy__delegate__S();
}

/* Module_to_ti_sysbios_interfaces_IHwi */

/* Handle_upCast */
static inline ti_sysbios_interfaces_IHwi_Handle ti_sysbios_hal_Hwi_HwiProxy_Handle_upCast( ti_sysbios_hal_Hwi_HwiProxy_Handle i )
{
    return (ti_sysbios_interfaces_IHwi_Handle)i;
}

/* Handle_to_ti_sysbios_interfaces_IHwi */

/* Handle_downCast */
static inline ti_sysbios_hal_Hwi_HwiProxy_Handle ti_sysbios_hal_Hwi_HwiProxy_Handle_downCast( ti_sysbios_interfaces_IHwi_Handle i )
{
    ti_sysbios_interfaces_IHwi_Handle i2 = (ti_sysbios_interfaces_IHwi_Handle)i;
if (ti_sysbios_hal_Hwi_HwiProxy_Proxy__abstract__S()) return (ti_sysbios_hal_Hwi_HwiProxy_Handle)i;
    return (void*)i2->__fxns == (void*)ti_sysbios_hal_Hwi_HwiProxy_Proxy__delegate__S() ? (ti_sysbios_hal_Hwi_HwiProxy_Handle)i : 0;
}

/* Handle_from_ti_sysbios_interfaces_IHwi */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_hal_Hwi_HwiProxy_Module__id ti_sysbios_hal_Hwi_HwiProxy_Module_id( void ) 
{
    return ti_sysbios_hal_Hwi_HwiProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */

/* Params_init */
static inline void ti_sysbios_hal_Hwi_HwiProxy_Params_init( ti_sysbios_hal_Hwi_HwiProxy_Params* prms ) 
{
    if (prms) {
        ti_sysbios_hal_Hwi_HwiProxy_Params__init__S(prms, 0, sizeof(ti_sysbios_hal_Hwi_HwiProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_hal_Hwi_HwiProxy_Params_copy( ti_sysbios_hal_Hwi_HwiProxy_Params* dst, const ti_sysbios_hal_Hwi_HwiProxy_Params* src ) 
{
    if (dst) {
        ti_sysbios_hal_Hwi_HwiProxy_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_hal_Hwi_HwiProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* create */
static inline ti_sysbios_hal_Hwi_HwiProxy_Handle ti_sysbios_hal_Hwi_HwiProxy_create( xdc_Int intNum, ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn, const ti_sysbios_hal_Hwi_HwiProxy_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_hal_Hwi_HwiProxy_Args__create __args;
    __args.intNum = intNum;
    __args.hwiFxn = hwiFxn;
    return (ti_sysbios_hal_Hwi_HwiProxy_Handle)ti_sysbios_hal_Hwi_HwiProxy_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_hal_Hwi_HwiProxy_Params), __eb);
}

/* delete */
static inline void ti_sysbios_hal_Hwi_HwiProxy_delete( ti_sysbios_hal_Hwi_HwiProxy_Handle* instp )
{
    ti_sysbios_hal_Hwi_HwiProxy_Object__delete__S(instp);
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_hal_Hwi_FuncPtr;

/* Irp */
typedef ti_sysbios_interfaces_IHwi_Irp ti_sysbios_hal_Hwi_Irp;

/* HookSet */
typedef ti_sysbios_interfaces_IHwi_HookSet ti_sysbios_hal_Hwi_HookSet;

/* MaskingOption */
typedef ti_sysbios_interfaces_IHwi_MaskingOption ti_sysbios_hal_Hwi_MaskingOption;

/* StackInfo */
typedef ti_sysbios_interfaces_IHwi_StackInfo ti_sysbios_hal_Hwi_StackInfo;

/* MaskingOption_NONE */

/* MaskingOption_ALL */

/* MaskingOption_SELF */

/* MaskingOption_BITMASK */

/* MaskingOption_LOWER */


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_hal_Hwi_Args__create {
    xdc_Int intNum;
    ti_sysbios_hal_Hwi_FuncPtr hwiFxn;
} ti_sysbios_hal_Hwi_Args__create;


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_hal_Hwi_Module__diagsEnabled;
extern far const CT__ti_sysbios_hal_Hwi_Module__diagsEnabled ti_sysbios_hal_Hwi_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_hal_Hwi_Module__diagsIncluded;
extern far const CT__ti_sysbios_hal_Hwi_Module__diagsIncluded ti_sysbios_hal_Hwi_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_hal_Hwi_Module__diagsMask;
extern far const CT__ti_sysbios_hal_Hwi_Module__diagsMask ti_sysbios_hal_Hwi_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_hal_Hwi_Module__gateObj;
extern far const CT__ti_sysbios_hal_Hwi_Module__gateObj ti_sysbios_hal_Hwi_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_hal_Hwi_Module__gatePrms;
extern far const CT__ti_sysbios_hal_Hwi_Module__gatePrms ti_sysbios_hal_Hwi_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_hal_Hwi_Module__id;
extern far const CT__ti_sysbios_hal_Hwi_Module__id ti_sysbios_hal_Hwi_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_Module__loggerDefined;
extern far const CT__ti_sysbios_hal_Hwi_Module__loggerDefined ti_sysbios_hal_Hwi_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_hal_Hwi_Module__loggerObj;
extern far const CT__ti_sysbios_hal_Hwi_Module__loggerObj ti_sysbios_hal_Hwi_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_hal_Hwi_Module__loggerFxn0;
extern far const CT__ti_sysbios_hal_Hwi_Module__loggerFxn0 ti_sysbios_hal_Hwi_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_hal_Hwi_Module__loggerFxn1;
extern far const CT__ti_sysbios_hal_Hwi_Module__loggerFxn1 ti_sysbios_hal_Hwi_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_hal_Hwi_Module__loggerFxn2;
extern far const CT__ti_sysbios_hal_Hwi_Module__loggerFxn2 ti_sysbios_hal_Hwi_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_hal_Hwi_Module__loggerFxn4;
extern far const CT__ti_sysbios_hal_Hwi_Module__loggerFxn4 ti_sysbios_hal_Hwi_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_hal_Hwi_Module__loggerFxn8;
extern far const CT__ti_sysbios_hal_Hwi_Module__loggerFxn8 ti_sysbios_hal_Hwi_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_hal_Hwi_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_hal_Hwi_Module__startupDoneFxn ti_sysbios_hal_Hwi_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_hal_Hwi_Object__count;
extern far const CT__ti_sysbios_hal_Hwi_Object__count ti_sysbios_hal_Hwi_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_hal_Hwi_Object__heap;
extern far const CT__ti_sysbios_hal_Hwi_Object__heap ti_sysbios_hal_Hwi_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_hal_Hwi_Object__sizeof;
extern far const CT__ti_sysbios_hal_Hwi_Object__sizeof ti_sysbios_hal_Hwi_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_hal_Hwi_Object__table;
extern far const CT__ti_sysbios_hal_Hwi_Object__table ti_sysbios_hal_Hwi_Object__table__C;

/* dispatcherAutoNestingSupport */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_dispatcherAutoNestingSupport;
extern far const CT__ti_sysbios_hal_Hwi_dispatcherAutoNestingSupport ti_sysbios_hal_Hwi_dispatcherAutoNestingSupport__C;

/* dispatcherSwiSupport */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_dispatcherSwiSupport;
extern far const CT__ti_sysbios_hal_Hwi_dispatcherSwiSupport ti_sysbios_hal_Hwi_dispatcherSwiSupport__C;

/* dispatcherTaskSupport */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_dispatcherTaskSupport;
extern far const CT__ti_sysbios_hal_Hwi_dispatcherTaskSupport ti_sysbios_hal_Hwi_dispatcherTaskSupport__C;

/* dispatcherIrpTrackingSupport */
typedef xdc_Bool CT__ti_sysbios_hal_Hwi_dispatcherIrpTrackingSupport;
extern far const CT__ti_sysbios_hal_Hwi_dispatcherIrpTrackingSupport ti_sysbios_hal_Hwi_dispatcherIrpTrackingSupport__C;

/* E_stackOverflow */
typedef xdc_runtime_Error_Id CT__ti_sysbios_hal_Hwi_E_stackOverflow;
extern far const CT__ti_sysbios_hal_Hwi_E_stackOverflow ti_sysbios_hal_Hwi_E_stackOverflow__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_hal_Hwi_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    ti_sysbios_interfaces_IHwi_MaskingOption maskSetting;
    xdc_UArg arg;
    xdc_Bool enableInt;
    xdc_Int eventId;
    xdc_Int priority;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_hal_Hwi_Struct {
    const ti_sysbios_hal_Hwi_Fxns__* __fxns;
    ti_sysbios_hal_Hwi_HwiProxy_Handle __f0;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_hal_Hwi_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*getStackInfo)(ti_sysbios_interfaces_IHwi_StackInfo*, xdc_Bool);
    void (*startup)(void);
    xdc_UInt (*disable)(void);
    xdc_UInt (*enable)(void);
    void (*restore)(xdc_UInt);
    void (*switchFromBootStack)(void);
    void (*post)(xdc_UInt);
    xdc_Char* (*getTaskSP)(void);
    xdc_UInt (*disableInterrupt)(xdc_UInt);
    xdc_UInt (*enableInterrupt)(xdc_UInt);
    void (*restoreInterrupt)(xdc_UInt, xdc_UInt);
    void (*clearInterrupt)(xdc_UInt);
    ti_sysbios_interfaces_IHwi_FuncPtr (*getFunc)(ti_sysbios_hal_Hwi_Handle, xdc_UArg*);
    void (*setFunc)(ti_sysbios_hal_Hwi_Handle, ti_sysbios_interfaces_IHwi_FuncPtr, xdc_UArg);
    xdc_Ptr (*getHookContext)(ti_sysbios_hal_Hwi_Handle, xdc_Int);
    void (*setHookContext)(ti_sysbios_hal_Hwi_Handle, xdc_Int, xdc_Ptr);
    ti_sysbios_interfaces_IHwi_Irp (*getIrp)(ti_sysbios_hal_Hwi_Handle);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_hal_Hwi_Fxns__ ti_sysbios_hal_Hwi_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_hal_Hwi_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_hal_Hwi_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_hal_Hwi_Module_startup__R( xdc_Int state );

/* Instance_init__F */

extern int ti_sysbios_hal_Hwi_Instance_init__F( ti_sysbios_hal_Hwi_Object*, xdc_Int intNum, ti_sysbios_hal_Hwi_FuncPtr hwiFxn, const ti_sysbios_hal_Hwi_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__F */

extern void ti_sysbios_hal_Hwi_Instance_finalize__F( ti_sysbios_hal_Hwi_Object* , int );

/* Instance_init__R */

extern int ti_sysbios_hal_Hwi_Instance_init__R( ti_sysbios_hal_Hwi_Object*, xdc_Int intNum, ti_sysbios_hal_Hwi_FuncPtr hwiFxn, const ti_sysbios_hal_Hwi_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__R */

extern void ti_sysbios_hal_Hwi_Instance_finalize__R( ti_sysbios_hal_Hwi_Object* , int );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_hal_Hwi_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_hal_Hwi_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_hal_Hwi_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_hal_Hwi_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_hal_Hwi_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_hal_Hwi_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* getStackInfo__E */

extern xdc_Bool ti_sysbios_hal_Hwi_getStackInfo__E( ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth );

extern xdc_Bool ti_sysbios_hal_Hwi_getStackInfo__F( ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth );
extern xdc_Bool ti_sysbios_hal_Hwi_getStackInfo__R( ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth );

/* startup__E */

extern void ti_sysbios_hal_Hwi_startup__E( void );

extern void ti_sysbios_hal_Hwi_startup__F( void );
extern void ti_sysbios_hal_Hwi_startup__R( void );

/* switchFromBootStack__E */

extern void ti_sysbios_hal_Hwi_switchFromBootStack__E( void );

extern void ti_sysbios_hal_Hwi_switchFromBootStack__F( void );
extern void ti_sysbios_hal_Hwi_switchFromBootStack__R( void );

/* post__E */

extern void ti_sysbios_hal_Hwi_post__E( xdc_UInt intNum );

extern void ti_sysbios_hal_Hwi_post__F( xdc_UInt intNum );
extern void ti_sysbios_hal_Hwi_post__R( xdc_UInt intNum );

/* getTaskSP__E */

extern xdc_Char* ti_sysbios_hal_Hwi_getTaskSP__E( void );

extern xdc_Char* ti_sysbios_hal_Hwi_getTaskSP__F( void );
extern xdc_Char* ti_sysbios_hal_Hwi_getTaskSP__R( void );

/* disableInterrupt__E */

extern xdc_UInt ti_sysbios_hal_Hwi_disableInterrupt__E( xdc_UInt intNum );

extern xdc_UInt ti_sysbios_hal_Hwi_disableInterrupt__F( xdc_UInt intNum );
extern xdc_UInt ti_sysbios_hal_Hwi_disableInterrupt__R( xdc_UInt intNum );

/* enableInterrupt__E */

extern xdc_UInt ti_sysbios_hal_Hwi_enableInterrupt__E( xdc_UInt intNum );

extern xdc_UInt ti_sysbios_hal_Hwi_enableInterrupt__F( xdc_UInt intNum );
extern xdc_UInt ti_sysbios_hal_Hwi_enableInterrupt__R( xdc_UInt intNum );

/* restoreInterrupt__E */

extern void ti_sysbios_hal_Hwi_restoreInterrupt__E( xdc_UInt intNum, xdc_UInt key );

extern void ti_sysbios_hal_Hwi_restoreInterrupt__F( xdc_UInt intNum, xdc_UInt key );
extern void ti_sysbios_hal_Hwi_restoreInterrupt__R( xdc_UInt intNum, xdc_UInt key );

/* clearInterrupt__E */

extern void ti_sysbios_hal_Hwi_clearInterrupt__E( xdc_UInt intNum );

extern void ti_sysbios_hal_Hwi_clearInterrupt__F( xdc_UInt intNum );
extern void ti_sysbios_hal_Hwi_clearInterrupt__R( xdc_UInt intNum );

/* getFunc__E */

extern ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_hal_Hwi_getFunc__E( ti_sysbios_hal_Hwi_Handle __inst, xdc_UArg* arg );

extern ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_hal_Hwi_getFunc__F( ti_sysbios_hal_Hwi_Object* __inst, xdc_UArg* arg );
extern ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_hal_Hwi_getFunc__R( ti_sysbios_hal_Hwi_Handle __inst, xdc_UArg* arg );

/* setFunc__E */

extern void ti_sysbios_hal_Hwi_setFunc__E( ti_sysbios_hal_Hwi_Handle __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg );

extern void ti_sysbios_hal_Hwi_setFunc__F( ti_sysbios_hal_Hwi_Object* __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg );
extern void ti_sysbios_hal_Hwi_setFunc__R( ti_sysbios_hal_Hwi_Handle __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg );

/* getIrp__E */

extern ti_sysbios_interfaces_IHwi_Irp ti_sysbios_hal_Hwi_getIrp__E( ti_sysbios_hal_Hwi_Handle __inst );

extern ti_sysbios_interfaces_IHwi_Irp ti_sysbios_hal_Hwi_getIrp__F( ti_sysbios_hal_Hwi_Object* __inst );
extern ti_sysbios_interfaces_IHwi_Irp ti_sysbios_hal_Hwi_getIrp__R( ti_sysbios_hal_Hwi_Handle __inst );

/* getHookContext__E */

extern xdc_Ptr ti_sysbios_hal_Hwi_getHookContext__E( ti_sysbios_hal_Hwi_Handle __inst, xdc_Int id );

extern xdc_Ptr ti_sysbios_hal_Hwi_getHookContext__F( ti_sysbios_hal_Hwi_Object* __inst, xdc_Int id );
extern xdc_Ptr ti_sysbios_hal_Hwi_getHookContext__R( ti_sysbios_hal_Hwi_Handle __inst, xdc_Int id );

/* setHookContext__E */

extern void ti_sysbios_hal_Hwi_setHookContext__E( ti_sysbios_hal_Hwi_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

extern void ti_sysbios_hal_Hwi_setHookContext__F( ti_sysbios_hal_Hwi_Object* __inst, xdc_Int id, xdc_Ptr hookContext );
extern void ti_sysbios_hal_Hwi_setHookContext__R( ti_sysbios_hal_Hwi_Handle __inst, xdc_Int id, xdc_Ptr hookContext );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getFunc_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_IHwi_FuncPtr (*ti_sysbios_hal_Hwi_getFunc_FxnT)(void*, xdc_UArg*);
static inline ti_sysbios_hal_Hwi_getFunc_FxnT ti_sysbios_hal_Hwi_getFunc_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_getFunc_FxnT)ti_sysbios_hal_Hwi_getFunc__E; 
}

/* setFunc_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Hwi_setFunc_FxnT)(void*, ti_sysbios_interfaces_IHwi_FuncPtr, xdc_UArg);
static inline ti_sysbios_hal_Hwi_setFunc_FxnT ti_sysbios_hal_Hwi_setFunc_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_setFunc_FxnT)ti_sysbios_hal_Hwi_setFunc__E; 
}

/* getIrp_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_IHwi_Irp (*ti_sysbios_hal_Hwi_getIrp_FxnT)(void*);
static inline ti_sysbios_hal_Hwi_getIrp_FxnT ti_sysbios_hal_Hwi_getIrp_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_getIrp_FxnT)ti_sysbios_hal_Hwi_getIrp__E; 
}

/* getHookContext_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_hal_Hwi_getHookContext_FxnT)(void*, xdc_Int);
static inline ti_sysbios_hal_Hwi_getHookContext_FxnT ti_sysbios_hal_Hwi_getHookContext_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_getHookContext_FxnT)ti_sysbios_hal_Hwi_getHookContext__E; 
}

/* setHookContext_{FxnT,fxnP} */
typedef void (*ti_sysbios_hal_Hwi_setHookContext_FxnT)(void*, xdc_Int, xdc_Ptr);
static inline ti_sysbios_hal_Hwi_setHookContext_FxnT ti_sysbios_hal_Hwi_setHookContext_fxnP( void )
{
    return (ti_sysbios_hal_Hwi_setHookContext_FxnT)ti_sysbios_hal_Hwi_setHookContext__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline ti_sysbios_interfaces_IHwi_Module ti_sysbios_hal_Hwi_Module_upCast( void )
{
    return (ti_sysbios_interfaces_IHwi_Module)&ti_sysbios_hal_Hwi_Module__FXNS__C;
}

/* Module_to_ti_sysbios_interfaces_IHwi */

/* Handle_upCast */
static inline ti_sysbios_interfaces_IHwi_Handle ti_sysbios_hal_Hwi_Handle_upCast( ti_sysbios_hal_Hwi_Handle i )
{
    return (ti_sysbios_interfaces_IHwi_Handle)i;
}

/* Handle_to_ti_sysbios_interfaces_IHwi */

/* Handle_downCast */
static inline ti_sysbios_hal_Hwi_Handle ti_sysbios_hal_Hwi_Handle_downCast( ti_sysbios_interfaces_IHwi_Handle i )
{
    ti_sysbios_interfaces_IHwi_Handle i2 = (ti_sysbios_interfaces_IHwi_Handle)i;
    return (void*)i2->__fxns == (void*)&ti_sysbios_hal_Hwi_Module__FXNS__C ? (ti_sysbios_hal_Hwi_Handle)i : 0;
}

/* Handle_from_ti_sysbios_interfaces_IHwi */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_hal_Hwi_Module__id ti_sysbios_hal_Hwi_Module_id( void ) 
{
    return ti_sysbios_hal_Hwi_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_hal_Hwi_Module_hasMask( void ) 
{
    return ti_sysbios_hal_Hwi_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_hal_Hwi_Module_getMask( void ) 
{
    return ti_sysbios_hal_Hwi_Module__diagsMask__C != 0 ? *ti_sysbios_hal_Hwi_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_hal_Hwi_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_hal_Hwi_Module__diagsMask__C != 0) *ti_sysbios_hal_Hwi_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_hal_Hwi_Params_init( ti_sysbios_hal_Hwi_Params* prms ) 
{
    if (prms) {
        ti_sysbios_hal_Hwi_Params__init__S(prms, 0, sizeof(ti_sysbios_hal_Hwi_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_hal_Hwi_Params_copy( ti_sysbios_hal_Hwi_Params* dst, const ti_sysbios_hal_Hwi_Params* src ) 
{
    if (dst) {
        ti_sysbios_hal_Hwi_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_hal_Hwi_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_hal_Hwi_Handle ti_sysbios_hal_Hwi_Object_get( ti_sysbios_hal_Hwi_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_hal_Hwi_Handle)ti_sysbios_hal_Hwi_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_hal_Hwi_Handle ti_sysbios_hal_Hwi_Object_first( void )
{
    return (ti_sysbios_hal_Hwi_Handle)ti_sysbios_hal_Hwi_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_hal_Hwi_Handle ti_sysbios_hal_Hwi_Object_next( ti_sysbios_hal_Hwi_Object* obj )
{
    return (ti_sysbios_hal_Hwi_Handle)ti_sysbios_hal_Hwi_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_hal_Hwi_Handle_label( ti_sysbios_hal_Hwi_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_hal_Hwi_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_hal_Hwi_Handle_name( ti_sysbios_hal_Hwi_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_hal_Hwi_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_hal_Hwi_Handle ti_sysbios_hal_Hwi_create( xdc_Int intNum, ti_sysbios_hal_Hwi_FuncPtr hwiFxn, const ti_sysbios_hal_Hwi_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_hal_Hwi_Args__create __args;
    __args.intNum = intNum;
    __args.hwiFxn = hwiFxn;
    return (ti_sysbios_hal_Hwi_Handle)ti_sysbios_hal_Hwi_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_hal_Hwi_Params), __eb);
}

/* construct */
static inline void ti_sysbios_hal_Hwi_construct( ti_sysbios_hal_Hwi_Struct* __obj, xdc_Int intNum, ti_sysbios_hal_Hwi_FuncPtr hwiFxn, const ti_sysbios_hal_Hwi_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_hal_Hwi_Args__create __args;
    __args.intNum = intNum;
    __args.hwiFxn = hwiFxn;
    ti_sysbios_hal_Hwi_Object__create__S(__obj, sizeof (ti_sysbios_hal_Hwi_Struct), &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_hal_Hwi_Params), __eb);
}

/* delete */
static inline void ti_sysbios_hal_Hwi_delete( ti_sysbios_hal_Hwi_Handle* instp )
{
    ti_sysbios_hal_Hwi_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_hal_Hwi_destruct( ti_sysbios_hal_Hwi_Struct* obj )
{
    ti_sysbios_hal_Hwi_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_hal_Hwi_Handle ti_sysbios_hal_Hwi_handle( ti_sysbios_hal_Hwi_Struct* str )
{
    return (ti_sysbios_hal_Hwi_Handle)str;
}

/* struct */
static inline ti_sysbios_hal_Hwi_Struct* ti_sysbios_hal_Hwi_struct( ti_sysbios_hal_Hwi_Handle inst )
{
    return (ti_sysbios_hal_Hwi_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */

/* 
 * Use intrinsics for ALL C6x and ARM 32bit targets (excluding arm M3)
 */



/*
 *  ======== Hwi_disable ========
 */

/*
 *  ======== Hwi_enable ========
 */

/*
 *  ======== Hwi_restore ========
 */


/*
 *  @(#) ti.sysbios.hal; 2, 0, 0, 0,547; 3-20-2012 14:03:16; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */





/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/*
 *  @(#) ti.sysbios.hal; 2, 0, 0, 0,547; 3-20-2012 14:03:16; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

//#include <log.h>
//#include<xdc/runtime/LoggerBuf.h> // should be removed , this is not the required one
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

//#include <c64.h>
/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  ======== C66.h ========
 *  DO NOT MODIFY: This header is generated from stddef.xdt
 *
 *  This header contains target-specific definitions of target-independent
 *  macros required by the ITarget interface.  These definitions allow C/C++
 *  sources to portably compile for multiple targets (using #ifdef ...).
 */
/*
 *  @(#) ti.targets; 1, 0, 3,531; 4-27-2012 17:07:37; /db/ztree/library/trees/xdctargets/xdctargets-f21x/src/ xlibrary

 */

/*
===============================================================================
//  Copyright(C):
//
//  FILENAME: <IntrTable.h> (Platfform.pjt)
//
//  Subsystem: Low Level Driver Library.
//
//  Purpose of file:
//  
//      To enable the user to have a well defined interface for creating 
//  and reading the Interrupt Table 
//
//  Dependencies, Limitations, and Design Notes:
//  	Interrupt module.
//
//=============================================================================
// Version   Date     Modification_History                               Author
//=============================================================================
//  
// 								   	
//
===============================================================================
*/

//#include <csl_cic.h>//in CCS5 this include file is not present, that's why removed by remesh
//#include <csl_intcAux.h>//in CCS5 this include file is not present, that's why removed by remesh

typedef struct {
	CSL_IntcEventId 		nIntcEventId;
	CSL_IntcVectId 			eIntcVectorId;
	BOOL					bCicRequired;
//	CSL_CicEventId			nCicEventId; // not present in ccs5.2
//	CSL_CicEctlEvtId		eCicVectorId; // not present in ccs5.2
	CSL_CPINTCSystemInterrupt   SysInt;
	CSL_CPINTCHostInterrupt		HostInt;
} IntrTable;

//Add the New Interrupt Item name here
typedef enum {
	INTR_ITEM_GPIO_13 = 0,
	INTR_ITEM_ETH_TX,
	INTR_ITEM_ETH_RX,
	INTR_ITEM_RX_MCBSP_FLASH,
	INTR_ITEM_RX_MCBSP_FPGA,
//	INTR_ITEM_TIMER_1,
	INTR_ITEM_TIMER_2,
	INTR_ITEM_IPC,
	INTR_ITEM_TIMER_3,
	INTR_ITEM_SRIO_ERROR,
	INTR_ITEM_SRIO_LSU,
	INTR_ITEM_SRIO_DBELL,
	INTR_ITEM_TIMER_13,
	MAX_INTR_ITEM
} IntrItem;

extern void IntrDB_GetIntrTableParam(IntrTable *pThis, IntrItem eName);


/*************************************EOF*************************************/
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== module ti.sysbios.family.c66.tci66xx.CpIntc ========
 */

typedef struct ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap;
typedef struct ti_sysbios_family_c66_tci66xx_CpIntc_DispatchTabElem ti_sysbios_family_c66_tci66xx_CpIntc_DispatchTabElem;
typedef struct ti_sysbios_family_c66_tci66xx_CpIntc_Module_State ti_sysbios_family_c66_tci66xx_CpIntc_Module_State;



/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef void (*ti_sysbios_family_c66_tci66xx_CpIntc_FuncPtr)(xdc_UArg);

/* RegisterMap */
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_5C;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_5C[9];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_5C __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_5C;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_98;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_98[26];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_98 __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_98;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PPMR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PPMR[64];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PPMR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PPMR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SRSR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SRSR[32];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SRSR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SRSR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SECR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SECR[32];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SECR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SECR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ESR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ESR[32];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ESR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ESR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ECR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ECR[32];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ECR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ECR;
typedef xdc_UInt8 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__CMR;
typedef xdc_UInt8 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__CMR[1024];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__CMR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__CMR;
typedef xdc_UInt8 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIMR;
typedef xdc_UInt8 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIMR[256];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIMR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIMR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPIR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPIR[256];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPIR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPIR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PR[32];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__TR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__TR[32];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__TR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__TR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__WER;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__WER[64];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__WER __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__WER;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__DSR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__DSR[64];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__DSR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__DSR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SER;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SER[32];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SER __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SER;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SDR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SDR[32];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SDR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SDR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HINLR;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HINLR[256];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HINLR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HINLR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIER;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIER[8];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIER __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIER;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1520;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1520[56];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1520 __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1520;
typedef xdc_Ptr* __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPVR;
typedef xdc_Ptr* __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPVR[256];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPVR __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPVR;
typedef xdc_UInt32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1A00;
typedef xdc_UInt32 __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1A00[384];
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1A00 __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1A00;
struct ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap {
    xdc_UInt32 REV;
    xdc_UInt32 CR;
    xdc_UInt32 RES_08;
    xdc_UInt32 HCR;
    xdc_UInt32 GER;
    xdc_UInt32 RES_14;
    xdc_UInt32 RES_18;
    xdc_UInt32 GNLR;
    xdc_UInt32 SISR;
    xdc_UInt32 SICR;
    xdc_UInt32 EISR;
    xdc_UInt32 EICR;
    xdc_UInt32 GWER;
    xdc_UInt32 HIEISR;
    xdc_UInt32 HIDISR;
    xdc_UInt32 RES_3C;
    xdc_UInt32 PPR;
    xdc_UInt32 RES_44;
    xdc_UInt32 RES_48;
    xdc_UInt32 RES_4C;
    xdc_Ptr* VBR;
    xdc_UInt32 VSR;
    xdc_Ptr VNR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_5C RES_5C;
    xdc_Int32 GPIR;
    xdc_Ptr* GPVR;
    xdc_UInt32 RES_88;
    xdc_UInt32 RES_8C;
    xdc_UInt32 GSIER;
    xdc_UInt32 SPIR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES_98 RES_98;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PPMR PPMR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SRSR SRSR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SECR SECR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ESR ESR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__ECR ECR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__CMR CMR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIMR HIMR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPIR HIPIR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__PR PR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__TR TR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__WER WER;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__DSR DSR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SER SER;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__SDR SDR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HINLR HINLR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIER HIER;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1520 RES1520;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__HIPVR HIPVR;
    __TA_ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap__RES1A00 RES1A00;
};


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* DispatchTabElem */
struct ti_sysbios_family_c66_tci66xx_CpIntc_DispatchTabElem {
    ti_sysbios_family_c66_tci66xx_CpIntc_FuncPtr fxn;
    xdc_UArg arg;
};

/* Module_State */
typedef volatile ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap* __T1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__controller;
typedef volatile ti_sysbios_family_c66_tci66xx_CpIntc_RegisterMap* *__ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__controller;
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__controller __TA_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__controller;
typedef xdc_Bits32 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__initSIER;
typedef xdc_Bits32 *__ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__initSIER;
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__initSIER __TA_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__initSIER;
typedef xdc_UInt8 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__hostIntToSysInt;
typedef xdc_UInt8 *__ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__hostIntToSysInt;
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__hostIntToSysInt __TA_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__hostIntToSysInt;
typedef ti_sysbios_family_c66_tci66xx_CpIntc_DispatchTabElem __T1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__dispatchTab;
typedef ti_sysbios_family_c66_tci66xx_CpIntc_DispatchTabElem *__ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__dispatchTab;
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__dispatchTab __TA_ti_sysbios_family_c66_tci66xx_CpIntc_Module_State__dispatchTab;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsEnabled;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsEnabled ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsIncluded;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsIncluded ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsMask;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsMask ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__gateObj;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__gateObj ti_sysbios_family_c66_tci66xx_CpIntc_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__gatePrms;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__gatePrms ti_sysbios_family_c66_tci66xx_CpIntc_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__id;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__id ti_sysbios_family_c66_tci66xx_CpIntc_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerDefined;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerDefined ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerObj;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerObj ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn0;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn0 ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn1;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn1 ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn2;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn2 ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn4;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn4 ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn8;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn8 ti_sysbios_family_c66_tci66xx_CpIntc_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__startupDoneFxn ti_sysbios_family_c66_tci66xx_CpIntc_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_family_c66_tci66xx_CpIntc_Object__count;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Object__count ti_sysbios_family_c66_tci66xx_CpIntc_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_family_c66_tci66xx_CpIntc_Object__heap;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Object__heap ti_sysbios_family_c66_tci66xx_CpIntc_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_family_c66_tci66xx_CpIntc_Object__sizeof;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Object__sizeof ti_sysbios_family_c66_tci66xx_CpIntc_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_family_c66_tci66xx_CpIntc_Object__table;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_Object__table ti_sysbios_family_c66_tci66xx_CpIntc_Object__table__C;

/* E_unpluggedSysInt */
typedef xdc_runtime_Error_Id CT__ti_sysbios_family_c66_tci66xx_CpIntc_E_unpluggedSysInt;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_E_unpluggedSysInt ti_sysbios_family_c66_tci66xx_CpIntc_E_unpluggedSysInt__C;

/* numSysInts */
typedef xdc_UInt32 CT__ti_sysbios_family_c66_tci66xx_CpIntc_numSysInts;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_numSysInts ti_sysbios_family_c66_tci66xx_CpIntc_numSysInts__C;

/* numStatusRegs */
typedef xdc_Int CT__ti_sysbios_family_c66_tci66xx_CpIntc_numStatusRegs;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_numStatusRegs ti_sysbios_family_c66_tci66xx_CpIntc_numStatusRegs__C;

/* sysIntToHostInt */
typedef xdc_UInt8 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_sysIntToHostInt;
typedef xdc_UInt8 *__ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_sysIntToHostInt;
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_sysIntToHostInt __TA_ti_sysbios_family_c66_tci66xx_CpIntc_sysIntToHostInt;
typedef __TA_ti_sysbios_family_c66_tci66xx_CpIntc_sysIntToHostInt CT__ti_sysbios_family_c66_tci66xx_CpIntc_sysIntToHostInt;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_sysIntToHostInt ti_sysbios_family_c66_tci66xx_CpIntc_sysIntToHostInt__C;

/* hostIntToEventId */
typedef xdc_UInt8 __T1_ti_sysbios_family_c66_tci66xx_CpIntc_hostIntToEventId;
typedef xdc_UInt8 *__ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_hostIntToEventId;
typedef __ARRAY1_ti_sysbios_family_c66_tci66xx_CpIntc_hostIntToEventId __TA_ti_sysbios_family_c66_tci66xx_CpIntc_hostIntToEventId;
typedef __TA_ti_sysbios_family_c66_tci66xx_CpIntc_hostIntToEventId CT__ti_sysbios_family_c66_tci66xx_CpIntc_hostIntToEventId;
extern far const CT__ti_sysbios_family_c66_tci66xx_CpIntc_hostIntToEventId ti_sysbios_family_c66_tci66xx_CpIntc_hostIntToEventId__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_family_c66_tci66xx_CpIntc_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_family_c66_tci66xx_CpIntc_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_family_c66_tci66xx_CpIntc_Module_startup__R( xdc_Int state );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_family_c66_tci66xx_CpIntc_Module__startupDone__S( void );

/* clearSysInt__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_clearSysInt__E( xdc_UInt id, xdc_UInt sysInt );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_clearSysInt__F( xdc_UInt id, xdc_UInt sysInt );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_clearSysInt__R( xdc_UInt id, xdc_UInt sysInt );

/* disableAllHostInts__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableAllHostInts__E( xdc_UInt id );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableAllHostInts__F( xdc_UInt id );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableAllHostInts__R( xdc_UInt id );

/* disableHostInt__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableHostInt__E( xdc_UInt id, xdc_UInt hostInt );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableHostInt__F( xdc_UInt id, xdc_UInt hostInt );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableHostInt__R( xdc_UInt id, xdc_UInt hostInt );

/* disableSysInt__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableSysInt__E( xdc_UInt id, xdc_UInt sysInt );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableSysInt__F( xdc_UInt id, xdc_UInt sysInt );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_disableSysInt__R( xdc_UInt id, xdc_UInt sysInt );

/* dispatch__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_dispatch__E( xdc_UInt hostInt );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_dispatch__F( xdc_UInt hostInt );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_dispatch__R( xdc_UInt hostInt );

/* dispatchPlug__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_dispatchPlug__E( xdc_UInt sysInt, ti_sysbios_family_c66_tci66xx_CpIntc_FuncPtr fxn, xdc_UArg arg, xdc_Bool unmask );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_dispatchPlug__F( xdc_UInt sysInt, ti_sysbios_family_c66_tci66xx_CpIntc_FuncPtr fxn, xdc_UArg arg, xdc_Bool unmask );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_dispatchPlug__R( xdc_UInt sysInt, ti_sysbios_family_c66_tci66xx_CpIntc_FuncPtr fxn, xdc_UArg arg, xdc_Bool unmask );

/* enableAllHostInts__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableAllHostInts__E( xdc_UInt id );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableAllHostInts__F( xdc_UInt id );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableAllHostInts__R( xdc_UInt id );

/* enableHostInt__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableHostInt__E( xdc_UInt id, xdc_UInt hostInt );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableHostInt__F( xdc_UInt id, xdc_UInt hostInt );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableHostInt__R( xdc_UInt id, xdc_UInt hostInt );

/* enableSysInt__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableSysInt__E( xdc_UInt id, xdc_UInt sysInt );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableSysInt__F( xdc_UInt id, xdc_UInt sysInt );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_enableSysInt__R( xdc_UInt id, xdc_UInt sysInt );

/* getEventId__E */

extern xdc_Int ti_sysbios_family_c66_tci66xx_CpIntc_getEventId__E( xdc_UInt hostInt );

extern xdc_Int ti_sysbios_family_c66_tci66xx_CpIntc_getEventId__F( xdc_UInt hostInt );
extern xdc_Int ti_sysbios_family_c66_tci66xx_CpIntc_getEventId__R( xdc_UInt hostInt );

/* mapSysIntToHostInt__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_mapSysIntToHostInt__E( xdc_UInt id, xdc_UInt sysInt, xdc_UInt hostInt );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_mapSysIntToHostInt__F( xdc_UInt id, xdc_UInt sysInt, xdc_UInt hostInt );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_mapSysIntToHostInt__R( xdc_UInt id, xdc_UInt sysInt, xdc_UInt hostInt );

/* postSysInt__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_postSysInt__E( xdc_UInt id, xdc_UInt sysInt );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_postSysInt__F( xdc_UInt id, xdc_UInt sysInt );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_postSysInt__R( xdc_UInt id, xdc_UInt sysInt );

/* unused__E */

extern void ti_sysbios_family_c66_tci66xx_CpIntc_unused__E( xdc_UArg arg );

extern void ti_sysbios_family_c66_tci66xx_CpIntc_unused__F( xdc_UArg arg );
extern void ti_sysbios_family_c66_tci66xx_CpIntc_unused__R( xdc_UArg arg );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_family_c66_tci66xx_CpIntc_Module__id ti_sysbios_family_c66_tci66xx_CpIntc_Module_id( void ) 
{
    return ti_sysbios_family_c66_tci66xx_CpIntc_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_family_c66_tci66xx_CpIntc_Module_hasMask( void ) 
{
    return ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_family_c66_tci66xx_CpIntc_Module_getMask( void ) 
{
    return ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsMask__C != 0 ? *ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_family_c66_tci66xx_CpIntc_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsMask__C != 0) *ti_sysbios_family_c66_tci66xx_CpIntc_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) ti.sysbios.family.c66.tci66xx; 2, 0, 0, 0,153; 3-20-2012 14:02:46; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

typedef void (*Intr_Handler)(void *);

typedef struct{
	IntrTable					oIntrTableParam;
	//CSL_CicObj 					CicObj;     changed for new chip
	//CSL_CicHandle 				CicHandle;  //changed for new chip
	CSL_CPINTC_Handle          CicHandle;  // we are using old name even thoug the type is different for easy migration
	CSL_CPINTCSystemInterrupt   SysInt;		    //newly added for TRS by nachi
	CSL_CPINTCHostInterrupt		HostInt;	//newly added for TRS by nachi
	CSL_CPINTCChannel			Channel;			//newly added for TRS by nachi
//	VOID						*pIntrHandlerArg;
	//HWI_Attrs					oHwi; //DSP BIOS parameter
	ti_sysbios_hal_Hwi_Params					oHwi; // SYS BIOS parameter
	ti_sysbios_hal_Hwi_Handle 					oHwiHandle ;// SYS BIOS parameter
	xdc_runtime_Error_Block 				eb;
} Intr;

extern BOOL Intr_Init(Intr *pThis, IntrItem eIntrItem, Intr_Handler pfnIntr_Handler, void *pIntrHandlerArg);
extern BOOL Intr_EnableEvent(Intr *pThis);
extern BOOL Intr_DisableEvent(Intr *pThis);


/*************************************EOF*************************************/
//#include <DataType.h>
typedef struct {
	Intr			oIntr;
	CSL_TmrHandle 	oHandle;
	CSL_TmrObj		oObj;
	CSL_TmrEnamode	eCountMode;
	UINT64			nTimeUs;
	BOOL			bIntrMode;
} Timer;

extern BOOL Timer_Init(Timer *pThis, UINT8 nTimerNo, UINT64 nTimeUs, CSL_TmrEnamode eCountMode,		  				void (*pIntrHandler)(void *), void *Arg, IntrItem eIntrItemName);
extern void Timer_GetTicksUsec(Timer *pThis, UINT64 *pTimeUsec);
extern void Timer_GetTicksMsec(Timer *pThis, UINT64 *pTimeMsec);
extern void Timer_GetTicksSec(Timer *pThis, UINT64 *pTimeSec);
extern BOOL Timer_Start(Timer *pThis);
extern BOOL Timer_Stop(Timer *pThis);
extern void Timer_Add(Timer *pThis);
extern void Timer_Delete(Timer *pThis);
extern void Timer_Print(Timer *pThis);
extern void Timer_Restart(Timer *pThis, UINT32 nNewUsecs);


/*************************************EOF*************************************/



typedef struct SysTime
{
	UINT32		nSec;
	UINT32		nUSec;

}SysTime;

extern void SysTime_Init(INT8 nTimerNo);

/* Set the value to DSP Time */
extern void SysTime_Now( SysTime *pThis );
/* Set the value to DSP time + offset */
void SysTime_Future( SysTime *pThis, UINT32 nOffsetMS);

/* Return difference from other (other-self) in ms*/
INT32 SysTime_Delta(SysTime *pThis, SysTime *pOther );

/*Elapsed time in ms */
INT32 SysTime_Elapsed( SysTime *pThis);

/*Remaining time in ms */
INT32 SysTime_Remaining( SysTime *pThis);

/*Elapsed time in ms */
BOOL SysTime_Passed( SysTime *pThis);

/* Time in ms */
UINT32 SysTime_Get( SysTime *pThis );

void SysTime_Print( SysTime *pThis );

extern INT8 SysTime_Cmp(SysTime *pFirst, SysTime *pSecond, UINT64 *pDiffUsecs);
extern INT64 SysTime_DeltaUs(SysTime *pThis, SysTime *pOther);
extern void SysTime_AddUsecs( SysTime *pThis, INT32 nUSecs);
extern INT64 SysTime_RemainingUs(SysTime *pThis);
extern BOOL SysTime_isTimeOver( SysTime *pThis);






//Header structure
typedef struct {
	UINT8		nIdentity;
	UINT8		nCommand;
	UINT8		nSeqNum;
	UINT8		nByteCnt;
} PacketHeader;

//Sender/Source
typedef enum {
	SENDER_IPU 	= 	(0 << 6),
	SENDER_FPGA = 	(1 << 6),
	SENDER_DSP  = 	(2 << 6),
	SENDER_INVALID =(3 << 6)
} PacketSender;

//Command/Response/Data
typedef enum {
	DATA_PKT	=						(0 << 2),
	CMD_FROM_SRC =						(1 << 2),
	IMD_ACK_FOR_CMD =					(2 << 2),
	CMD_SUCCESSFULL =					(3 << 2),
	IMD_NAK_FOR_INVALID_DST =			(4 << 2),
	IMD_NAK_FOR_INVALID_SRC =			(5 << 2),
	IMD_NAK_FOR_INVALID_CMD =			(6 << 2),
	IMD_NAK_FOR_INVALID_SEQNUM =		(7 << 2),
	IMD_NAK_FOR_INVALID_LEN =			(8 << 2),
	SPU_RF_COMM_FAILED_SENDER_FPGA =	(9 << 2),
	DXC_TUNING_FAILED_SENDER_FPGA =		(10 << 2),
	DSP_FPGA_COMM_FAILED_SENDER_DSP =	(11 << 2),
	SPU_RESOURCES_NOT_AVAIL_SENDER_DSP =(12 << 2),
	NO_L2_PAYLOAD_SENDER_IPU =			(13 << 2),
	DSP_FPGA_COMM_FAILED_SENDER_IPU =	(14 << 2),
	PACKET_TYPE_INVALID = 				(15 << 2)
} PacketType;

//Receiver/Destination
typedef enum {
	RECEIVER_IPU = 		(0 << 0),
	RECEIVER_FPGA = 	(1 << 0),
	RECEIVER_DSP =		(2 << 0),
	RECEIVER_INVALID = 	(3 << 0)
} PacketReceiver;

//Commands  
typedef enum {
	DATA_PACKET 						= 0,
	IPU_TO_DSP_SCAN_BEACON_FREQ,
	IPU_TO_DSP_CONFIGURE_RECEIVER,
	IPU_TO_DSP_CONFIGURE_TRANSMITTER,
	IPU_TO_DSP_CONFIGURE_VBTS_MODE,
	IPU_TO_DSP_CONFIG_AREA_JAMMING,
	IPU_TO_DSP_SET_TSC_FOR_RECEIVER,
	IPU_TO_DSP_SET_TSC_FOR_TRANSMITTER,
	IPU_TO_DSP_SET_TSC_FOR_VBTS_MODE,
	IPU_TO_DSP_CHANNEL_MODIFY,
	IPU_TO_DSP_PLAYBACK_START  = 11,
	IPU_TO_DSP_DECODING_START           = 12,
	IPU_TO_DSP_DECODE_IQ_DATA			=14,
	IPU_TO_DSP_CONFIGURE_RECORD_RECEIVER = 15,
	IPU_TO_DSP_STOP_RECORD_RECEIVER,
	IPU_TO_DSP_STOP_SCANING_BAND 		= 32,
	IPU_TO_DSP_STOP_RECEIVER,
	IPU_TO_DSP_STOP_TRANSMITTER,
	IPU_TO_DSP_STOP_VBTS_MODE,
	IPU_TO_DSP_STOP_AREA_JAMMING,
	IPU_TO_DSP_STOP_SCANNING_ARFCN,
	IPU_TO_DSP_STOP_PLAYBACK,
	IPU_TO_DSP_STOP_DECODING,
	IPU_TO_FPGA_SEND_SPU_VERSION		= 64,
	IPU_TO_FPGA_SEND_SPU_STATUS,
	IPU_TO_FPGA_SEND_GPS_STATUS,
	DSP_TO_IPU_SEND_L2_PACKET 			= 80,
	DSP_TO_IPU_RATSCCH_MESSAGE,
	DSP_TO_FPGA_CONFIG_SRIO 			= 96,
	DSP_TO_FPGA_RX_TUNE,
	DSP_TO_FPGA_TX_TUNE,
	DSP_TO_FPGA_AREA_JAMMING,
	DSP_TO_FPGA_STOP_AREA_JAMMING,
	DSP_TO_FPGA_DAC_CONFIG,				// 101
	DSP_TO_FPGA_SET_DDC,
	DSP_TO_FPGA_SET_DDC2_CONFIGURATION,
	DSP_TO_FPGA_SEND_STE_OPERATION,
	DSP_TO_FPGA_SEND_DSP_STATUS, //105
	DSP_TO_FPGA_START_GPS,
	DSP_TO_FPGA_SEND_GPS_DATA,
	DSP_TO_FPGA_STOP_GPS,
	DSP_TO_FPGA_REQUEST_HM,
	DSP_TO_FPGA_CONTROL_RF,      //110
	DSP_TO_FPGA_SEND_RF_STATUS,
//	DSP_TO_FPGA_SEND_RF_TEMP,
	DSP_TO_FPGA_SEND_DSP_TEMP,

	//FPGA_TO_DSP_CONFIG_SRIO 			= 112,
	//FPGA_TO_DSP_SEND_DSP_VERSION,
	//FPGA_TO_DSP_SEND_DSP_STATUS,
//	FPGA_TO_DSP_GPSDATA_TO_IPU,
//	FPGA_TO_DSP_FPGAHEALTHINFO_TO_IPU,
	COMMAND_INVALID
} CommandType;

typedef enum {
	SENDER_ERROR,
	RECEIVER_ERROR,
	PACKET_TYPE_ERROR,
	COMMAND_ERROR,
	PACKET_LEN_ERROR = (252 + 1),
	PACKET_VALID
} PacketStatus;

typedef struct {
	PacketHeader	Header;
	UINT8			nData[172];
	UINT8			nCommand;
	UINT8			nRxMgr;
	UINT8			nTxMgr;
	UINT8 			nDDCNum;
	UINT8           nCoreno;
	SysTime			oNow;
} Packet;

typedef struct {

	PacketHeader	Header;
	UINT8			nData[252];
}Packet2;

//RF Board commands for TRS
typedef	enum {
		PA_TMA_3GJammer_RX_TX_enable_disable_status = 11,
				PA_TMA_3GJammer_RX_TX_enable_disable = 43,
				RX_VGA1_Read = 64,
				RX_VGA2_Read,
				RX_VGA3_Read,
				RX_VGA4_Read,
				RX_VGA5_Read,
				RX_VGA6_Read,
				RX_Temp_Read= 70,

				RX_AGC_Status=74,
				RX_PLL_AlertPin_AGC_Status =76,
				RX_VGA1_Write = 96,
				RX_VGA2_Write,
				RX_VGA3_Write,
				RX_VGA4_Write,
				RX_VGA5_Write,
				RX_VGA6_Write,
				RX_Enable_disable_AGC=106


}RfBoardCommands;



/*******************************************************/
// SHARED DATA MEMORY FOR L2PACKET TO CORE 0
// L2 PACKET from DSP to IPU
typedef struct L2PacketInfo
{
	BOOL	bWrote;
	BOOL	bSkipSend;
	Packet2	*pInfo;
}L2PacketInfo;

typedef struct SharedL2PacketMgr
{
	UINT16			nWriteIndex;	// dynamic
	UINT16			nReadIndex;	// dynamic
	L2PacketInfo	oPayload[1024];
}SharedL2PacketMgr;



/**************************************************************************/
// STATIC MEMORY ALLOCATION FOR L2PACKET TO IPU
// L2 packet from DSP to IPU
typedef struct L2PacketMgr
{

//	UINT32			nWriteIndex;
	Packet2			oPayloadInfo[1024];	

}L2PacketMgr;
/************************************************************************/





/** Type and TDMA offset of a logical channel, from GSM 04.08 10.5.2.5 */
typedef enum TypeAndOffset {

	TDMA_MISC=0,

	TCHF_0=1,

	TCHH_0=2, TCHH_1=3,

	SDCCH_4_0=4, SDCCH_4_1=5, SDCCH_4_2=6, SDCCH_4_3=7,

	SDCCH_8_0=8, SDCCH_8_1=9, SDCCH_8_2=10, SDCCH_8_3=11,

	SDCCH_8_4=12, SDCCH_8_5=13, SDCCH_8_6=14, SDCCH_8_7=15,

	/// An extra one for our internal use.
	TDMA_BEACON=255

}TypeAndOffset;


typedef enum MULTIFRAME_TYPE {
	MF_TCH_26	=	26,
	MF_CCH_51	=	51
}MULTIFRAME_TYPE;

/**@name Modulus operations for frame numbers. */



typedef struct GSMTime
{
   UINT32 nFN;
   UINT8  nTN;
   INT32 FrameCount;
   UINT8 Hyperframe;
}GSMTime;



void GSMTime_Init( GSMTime *pThis, UINT32 nFN, UINT8 nTN);
void GSMTime_FrameCountInit(GSMTime *pThis,INT32,UINT8);
void GSMTime_Copy( GSMTime *pThis, GSMTime *pOther);
void GSMTime_Print( GSMTime *pThis);
void GSMTime_RollForward( GSMTime *pThis, UINT32 nFN, UINT16 nModules);
UINT32 GSMTime_FN( GSMTime *pThis);
UINT8 GSMTime_TN( GSMTime *pThis);

void GSMTime_SetFN( GSMTime *pThis, UINT32 nFN);
void GSMTime_SetTN( GSMTime *pThis, UINT8 nTN);

void GSMTime_Inc( GSMTime *pThis, INT32 nStep);
void GSMTime_Dec( GSMTime *pThis, INT32 nStep);

void GSMTime_IncTN( GSMTime *pThis, INT8 nStep);
void GSMTime_DecTN( GSMTime *pThis, INT8 nStep);

GSMTime GSMTime_Add( GSMTime *pThis, INT32 nStep);
GSMTime GSMTime_Sub( GSMTime *pThis, INT32 nStep);

GSMTime GSMTime_AddTime( GSMTime *pThis, GSMTime *pOther);
INT32   GSMTime_SubTime( GSMTime *pThis, GSMTime *pOther);

BOOL    GSMTime_IsLessThanTime( GSMTime *pThis, GSMTime *pOther);
BOOL    GSMTime_IsMoreThanTime( GSMTime *pThis, GSMTime *pOther);
BOOL    GSMTime_IsLessOrEquThanTime( GSMTime *pThis, GSMTime *pOther);
BOOL    GSMTime_IsMoreOrEquThanTime( GSMTime *pThis, GSMTime *pOther);
BOOL    GSMTime_IsEquTime( GSMTime *pThis, GSMTime *pOther);

UINT32	GSMTime_SFN( GSMTime *pThis );
UINT16	GSMTime_MFN( GSMTime *pThis, MULTIFRAME_TYPE eType);
UINT32	GSMTime_T1( GSMTime *pThis );
UINT32	GSMTime_T2( GSMTime *pThis );
UINT32	GSMTime_T3( GSMTime *pThis );
	/** GSM 05.02 3.3.2.2.1. */
UINT32	GSMTime_T3p( GSMTime *pThis );
	/** GSM 05.02 6.3.1.3. */
UINT32	GSMTime_TC( GSMTime *pThis );
	/** GSM 04.08 10.5.2.30. */
UINT32	GSMTime_T1p( GSMTime *pThis );
	/** GSM 05.02 6.2.3 */
UINT32	GSMTime_T1R( GSMTime *pThis );






/************************************************************************
 * File:
 *      $RCSfile: gsm_constants.h,v $
 *      $Revision: 1.7 $
 *      $Date: 2010/04/04 00:03:32 $
 *
 *      (c) 2001 DelCom Systems, Inc.
 *      The Source Code contained herein is DelCom
 *      Systems, Inc. Confidential material and subject to Non-Disclosure.
 *
 *      The Source Code is and shall remain owned by DelCom
 *      Systems, Inc. and/or its suppliers and is protected by United
 *      States copyright laws and international treaty provisions.  As an
 *      express condition of the executed Source License Agreement, title
 *      to, ownership of, and all rights in patents, copyrights, trade
 *      secrets and any other intellectual property rights in this Source
 *      Code and/or any copy or part thereof is and shall remain in DelCom
 *      Systems, Inc. and/or its suppliers.  It is understood
 *      by the user of the Source Code that valuable, confidential
 *      information and trade secrets are contained within and that
 *      unauthorized use and/or copying shall be harmful to DelCom
 *      Systems, Inc.
 *
 *      THE SOURCE CODE MAY NOT BE MODIFIED, ADAPTED, TRANSLATED, RENTED,
 *      LEASED, LOANED, RESOLD FOR PROFIT, DISTRIBUTED OR OTHERWISE ASSIGNED
 *      OR TRANSFERRED NOR MAY DERIVITATIVE WORKS BASED UPON THIS SOFTWARE
 *      OR ANY PART THEREOF BE DEVELOPED WITHOUT WRITTEN AGREEMENT BY DelCom
 *      Systems, INC. 
 *
 *
 ************************************************************************/

/************************************************************************
 * Constant:
 *      GMSKEQ_SAMPLES_PER_SYMBOL
 *
 * Purpose:
 *      This constant defines the number of base-band samples per symbol
 *	for the input of the GMSK Equalizer
 *
 * Operation:
 *      It's value is either 1 or 2
 *
 * Notes/Issues:
 *
 ************************************************************************/






/************************************************************************
 * Constant:
 *      GSM_DCS_NUM_USEFUL_SYMBOLS
 *
 * Purpose:
 *      This constant defines the maximum number of "useful" symbols
 *      produced by a multframe object in the DCS implementation of
 *      the GSM physical layer.
 *
 * Operation:
 *      It's value is 148.
 *
 * Notes/Issues:
 *      The specs occasionally define the "useful" part of a burst as
 *      containing 147 symbols instead of 148.  This is because they
 *      trim off .5 symbol at the beginning and the end of each burst
 *      to account for transients.  For our purposes, we should just
 *      stick with 148 symbols.
 ************************************************************************/

/************************************************************************
 * Constant:
 *      GSM_DCS_MAX_SYMBOLS_PER_BURST
 *
 * Purpose:
 *      This constant defines the maximum number of symbols in a burst
 *      produced by the timeslot multiplexor (and possibly other) objects
 *      in the DCS implementation of the GSM physical layer.
 *
 * Operation:
 *      It's value is 157.
 *
 * Notes/Issues:
 *      Technically, a burst contains 156.25 symbols.  Since it is
 *      very difficult to represent 0.25 of a symbol, we simply define
 *      the maximum burst length to be 157 symbols.
 ************************************************************************/

/************************************************************************
 * Constant:
 *      GSM_DCS_SYNC_TSC_LEN
 *
 * Purpose:
 *      This constant defines the number of bits in an extended
 *      training sequence used in synchronization bursts,
 *      in the DCS implementation of the GSM physical layer.
 *
 * Operation:
 *      It's value is 64.
 *
 * Notes/Issues:
 *
 ************************************************************************/

/************************************************************************
 * Constant:
 *      GSM_DCS_NORMAL_TSC_LEN
 *
 * Purpose:
 *      This constant defines the number of bits in the
 *      training sequences used in normal bursts,
 *      in the DCS implementation of the GSM physical layer.
 *
 * Operation:
 *      It's value is 26.
 *
 * Notes/Issues:
 *
 ************************************************************************/

/************************************************************************
 * Constant:
 *      GSM_DCS_ACCESS_TS_LEN
 *
 * Purpose:
 *      This constant defines the number of bits in the
 *      training sequences used in access bursts,
 *      in the DCS implementation of the GSM physical layer.
 *
 * Operation:
 *      It's value is 41.
 *
 * Notes/Issues:
 *
 ************************************************************************/

/* # of data bits in a GSM normal burst */

/* # of data bits in a GSM synchronization burst */

/* # of data bits in a GSM random access burst */

/* # of information bits delivered to the 
 * TCH_FS/SCH/SACCH/FACCH channel encoder 
 */

/* Tail bit lengths */











//#define SIM_UL_AS_DL

/************************************************************************
 * File:
 *      $RCSfile: gsm_toolbox.h,v $
 *      $Revision: 1.23 $
 *      $Date: 2010/06/16 02:40:25 $
 *
 *      (c) 2004 DelCom Systems, Inc.
 *      The Source Code contained herein is DelCom
 *      Systems, Inc. Confidential material and subject to Non-Disclosure.
 *
 *      The Source Code is and shall remain owned by DelCom
 *      Systems, Inc. and/or its suppliers and is protected by United
 *      States copyright laws and international treaty provisions.  As an
 *      express condition of the executed Source License Agreement, title
 *      to, ownership of, and all rights in patents, copyrights, trade
 *      secrets and any other intellectual property rights in this Source
 *      Code and/or any copy or part thereof is and shall remain in DelCom
 *      Systems, Inc. and/or its suppliers.  It is understood
 *      by the user of the Source Code that valuable, confidential
 *      information and trade secrets are contained within and that
 *      unauthorized use and/or copying shall be harmful to DelCom
 *      Systems, Inc.
 *
 *      THE SOURCE CODE MAY NOT BE MODIFIED, ADAPTED, TRANSLATED, RENTED,
 *      LEASED, LOANED, RESOLD FOR PROFIT, DISTRIBUTED OR OTHERWISE ASSIGNED
 *      OR TRANSFERRED NOR MAY DERIVITATIVE WORKS BASED UPON THIS SOFTWARE
 *      OR ANY PART THEREOF BE DEVELOPED WITHOUT WRITTEN AGREEMENT BY DELCOM
 *      SYSTEMS, INC. 
 *
 *
 ************************************************************************/


/************************************************************************
 * Type Definition:
 *        DUMMY_BURST_OPTIONS
 *
 * Purpose:
 *        Lists possible options for assembling the dummy burst
 *        as given in GSM 5.02 Section A.2 ( Implementation 
 *        Options for TCH Channels).
 *
 * Operation:
 *        Used to enumarate the input to DCS_GSM_assemble_dummy_burst()
 *        function.
 *
 * Notes/Issues:
 *       
 ************************************************************************/
typedef enum
{
  DUMMY_BURST_DEFAULT,
  DUMMY_BURST_A211,
  DUMMY_BURST_A212,
  DUMMY_BURST_A213
} DUMMY_BURST_OPTIONS;


/************************************************************************
 * Type Definition:
 *        GSM_DEMOD_STATUS
 *
 * Purpose:
 *        Lists possible values for burst demodulation result.
 *
 * Operation:
 *        'GMSKEQ_equalize()' function returns the success of demodulation
 *        attempt, as an enumarated variable. Returned value can be 
 *        one of the three listed below.
 *
 * Notes/Issues:
 *       
 ************************************************************************/
typedef enum
{
  GOOD_DEMOD = 0,
  TSC_NOT_FOUND,
  UNRECOVERABLE_DEMOD_ERROR
} GSM_DEMOD_STATUS;

/************************************************************************
 * Type Definition:
 *        GSM_BURST_TYPE
 *
 * Purpose:
 *        Indicates possible physical channel burst types of GSM
 *
 * Operation:
 *
 * Notes/Issues:
 *
 ************************************************************************/
typedef enum
{
  NORMAL_BURST = 0,
  RACH_BURST, /* ACCESS BURST */
  FCCH_BURST,
  SCH_BURST,
  DUMMY_BURST,
  RACH_BURST_DET_ALT,
  NO_BURST
} GSM_BURST_TYPE;


/************************************************************************
 * Type Definition:
 *        enum SYNC_TYPE
 *
 * Purpose:
 *        The extended training sequence bits in a synchronization 
 *        burst is fixed, but CTS, and COMPACT sync bursts have a 
 *        slightly different training sequences. This enumarated 
 *        variable is usedto distinguish CTS and COMPACT sync bursts.
 *
 * Operation:
 *        The fourth input parameter of 'assemble_sync_burst()' function
 *        should specify the type of sync burst using one of the 
 *        listed values. 
 *
 * Notes/Issues:
 *
 ************************************************************************/
typedef enum {
  SYNC_DEFAULT,
  SYNC_CTS,
  SYNC_COMPACT
} SYNC_TYPE;

/************************************************************************
 * Type Definition:
 *        enum ACCESS_TS_TYPE
 *
 * Purpose:
 *        The training sequence bits in an access burstis fixed. 
 *        but there are two alternative training sequences defined
 *        for the access byrst on the pyhsical channel. 
 *        This enumarated variable is used to list/specify
 *        the choice of training sequence for the access burst.
 *
 * Operation:
 *        The fourth input parameter of 'assemble_access_burst()' function
 *        should specify the choice of training sequence to be used
 *        as one of the values listed here. 
 *
 * Notes/Issues:
 *
 ************************************************************************/
typedef enum {
  ACCESS_TS_DEFAULT,
  ACCESS_TS_ALTERNATE1,
  ACCESS_TS_ALTERNATE2
} ACCESS_TS_TYPE;




/*****************************************************************************
 ***************************************************************************/
GSM_DEMOD_STATUS
GMSKEQ_equalize(const COMPLEX16 *data, 
              UINT16           npts_data, 
              UINT8            tsc_num, 
              GSM_BURST_TYPE   burst_type, 
              UINT8            num_search_symbs, 
              INT16           *bst_bits, 
              UINT8            samps_per_symb, 
              INT16          *burst_start_index,
              INT32           *burst_snr,
              SCRATCH         *scratch1,
              SCRATCH         *scratch2);


void GMSKEQ_get_scratch_size_maus(UINT16 *scratch1Size, 
                                   UINT16 *scratch2Size,
                                   UINT16 maxbasebandInputSamples
                                   );

/************************************************************************/


struct GSM_fcch_detect_rx_obj {

  COMPLEX16 data_buffer[(157*2*2)];
  INT16 toggle_phase; /* 0 or 1 */
  INT16 newSampleIdx; 
  INT16 delta_buf[64];
  INT16 delta_oldestIdx;
  INT16 delta_avg;
  INT16 FCCH_detect_count; //count the number of continuous samples exceed the FCCH_thrshld
  INT16 FCCH_detected; 
  INT16 dec_phase; /* 0 - 7 */
  INT16 est_freq; /* S15.0 */
  INT16 est_tau; 
  INT16 avg_est_freq; //smoothed frequency offset estimation S15.0
  INT16 avg_freq_flag; //0-2: number of points being averaged, "2" stands for all >=2 cases
  INT16 sample_count;

};


void GSM_fcch_detect_freq_est_sync_init(struct GSM_fcch_detect_rx_obj *p);

UINT16 GSM_DCS_est_fcch_freq_offset(COMPLEX16 *,UINT16, INT16 *,SCRATCH *,SCRATCH *);


void GSM_fcch_detect_freq_est_sync_reset(struct GSM_fcch_detect_rx_obj *p);


UINT16 
GSM_fcch_detect_freq_est_sync(struct GSM_fcch_detect_rx_obj  *state,
                              const COMPLEX16 *data, 
                              UINT16           npts_data,
                              INT32           *est_freq_off, 
                              INT16           *ave_freq_off, 
                              INT16           *est_tau,
                              INT16           *real_tau,
                              SCRATCH         *scratch1,
                              SCRATCH         *scratch2);



                                
void GSM_fcch_get_scratch_size_maus(UINT16 *scratch1Size, 
                                   UINT16 *scratch2Size,
                                   UINT16 maxbasebandInputSamples);                            


INT16 GMSKEQ_normalize(COMPLEX16 *x, COMPLEX16 *y, int N,int noDCremoval);    

void GSM_DCS_pack_bits(BIT_TYPE *in, OCTET *out, int N);
void GSM_DCS_unpack_bits(OCTET *in, BIT_TYPE *out,  int N);       



/* Generate bits only with no modulation */

void GSM_DCS_assemble_freq_burst_rawbits(BIT_TYPE  *outbuf,
                            UINT8       nbits,
                            UINT8      is_COMPACT /* not supported*/);

void
GSM_DCS_assemble_dummy_burst_rawbits(BIT_TYPE   *outbuf,
                              UINT8      tsc_num, 
                              int      nbits,  
							  DUMMY_BURST_OPTIONS dum_burst_opt);
                                                       
void
GSM_DCS_assemble_normal_burst_rawbits(BIT_TYPE   *outbuf,
                              UINT8      tsc_num,
                              BIT_TYPE  *payload_bits,
                              BIT_TYPE  *steal_bits,  
                              int      nbits);
                                                                                       
void GSM_DCS_assemble_sync_burst_rawbits(BIT_TYPE  *outbuf,
                            BIT_TYPE   *input_bits,
                            UINT8       nbits,
                            SYNC_TYPE   sync_type);

void GSM_DCS_assemble_access_burst_rawbits(BIT_TYPE  *outbuf,
                          BIT_TYPE      *input_bits,
                          UINT8          nbits,
                          ACCESS_TS_TYPE access_ts_type);




                 
void GSM_DCS_map_gmsk_burst(COMPLEX16    *outbuf,
                 const BIT_TYPE  	*inbuf,
                 UINT16           	num_bits);

INT16 GMSKEQ_burst_agc(const COMPLEX16 *x, COMPLEX16 *y, int N,int measureOnly,int dcAdjust,
	INT16 *rxLevel_q8, INT16 *dc_r_arg, INT16 *dc_i_arg, UINT32 *power, int *exp);



int GSM_DCS_freq_hop_seq_gen( UINT16 HSN, UINT16 N,INT16 MAIO, UINT32 FN);






/// The longest "repeat length" of any channel we support is 104 for the SACCH/TF.

/**
	A description of a channel's multiplexing pattern.
	From GSM 05.02 Clause 7.
	This object encodes a line from tables 1-4 in the spec.
	The columns of interest in this encoding are:
		- 1, Channel Designation
		- 2, Subchannel
		- 3, Direction
		- 4, Allowable Time Slot Assignments
		- 5, Allowable RF Channel Assignments
		- 7, Repeat Length in TDMA Frames
		- 8, Interleaved Block TDMA Frame Mapping

	Col 6, Burst Type, is implied by 1 & 2 and encoded into the transcevier source code.
*/
typedef struct TDFrm {

	CHAR *sName;
    TypeAndOffset nTypeAndOffset;				///< col 1, 2, encoded as per GSM 04.08 10.5.2.5
	BOOL bDownlink;								///< col 3, true for downlink channels
	BOOL bUplink;								///< col 3, true for uplink channels
	CHAR cAllowedSlots;							///< col 4, an 8-bit mask
	BOOL bC0Only;								///< col 5, true if channel is limited to C0
	INT8 nRepeatLength;						///< col 7
	INT8 nNumFrames;						///< number of occupied frames in col 8
	const INT8 *pFrameMapping;				///< col 8
	UINT8		nSubSlot;					// for SACCH/4, SACCH/8, SDCCH/4, SDCCH/8 only
	INT8 nReverseMapping[104];	///< index reversal of mapping, -1 means unused

}TDFrm;



/**
	Construct a TDMAMapping, encoding one line of GSM 05.02 Clause 7 Tables 1-4.
	@param wTypeAndOffset Encoding of "Channel designnation".  See GSM 04.08 10.5.2.5.
	@param wDownlink True for downlink and bidirectional hannels
	@param wUplink True for uplink and bidirectional channels
	@param wRepeatLength "Repeat Length in TDMA Frames"
	@param wNumFrames Number of occupied TDMA frames in frame mapping.
	@param wFrameMapping "Interleaved Block TDMA Frame Mapping" -- MUST PERSIST!!
*/

extern void TDFrm_Init(
	TDFrm *pThis,
    CHAR  *sName,
	TypeAndOffset wTypeAndOffset,
	BOOL bDownlink, 
	BOOL bUplink, 
	CHAR cAllowedSlots, 
	BOOL bC0Only,
	INT8 nRepeatLength, 
	INT8 nNumFrames, 
	UINT8 nSubSlot,
	const INT8 *pFrameMapping
);
/** Given a count of frames sent, return the corresponding frame number. */
extern INT8 TDFrm_GetFrameMapping (TDFrm *pThis, INT8 nCount );


/** Given a frame number, return the corresponding count, modulo patten length. */
extern INT8 TDFrm_GetReverseMapping (TDFrm *pThis, INT16 FN);

/**@name Simple accessors. */
//@{
extern INT8 TDFrm_GetNumFrames(TDFrm *pThis);

extern INT8 TDFrm_GetRepeatLength(TDFrm *pThis);

extern TypeAndOffset TDFrm_GetTypeAndOffset (TDFrm *pThis);

extern BOOL TDFrm_IsUplink (TDFrm *pThis); 

extern BOOL TDFrm_IsDownlink (TDFrm *pThis); 

extern BOOL TDFrm_IsC0Only (TDFrm *pThis); 
	//@}
///< Return true if this channel is allowed on this slot.
extern BOOL TDFrm_IsAllowedSlot(TDFrm *pThis, UINT16 nSslot); 

extern void TDFrm_Print (TDFrm *pThis);

extern CHAR *TDFrm_GetName( TDFrm *pThis);

extern void TDFrm_PrintHeader( void );

extern UINT8 TDFrm_GetSubSlot( TDFrm *pThis );





typedef struct TDFrmLst
{
  TDFrm IDLE;

  TDFrm IDLE_26;
   /**@name Mux parameters for standard channels, from GSM 05.03 Clause 7 Tables 1-4. */
//@{
/**@name Beacon channels */
//@{
  TDFrm FCCH;		///< GSM 05.02 Clause 7 Table 3 Line 1 B0-B4
  TDFrm SCH;		///< GSM 05.02 Clause 7 Table 3 Line 2 B0-B4
  TDFrm BCCH;		///< GSM 05.02 Clause 7 Table 3 Line 3
/// GSM 05.02 Clause 7 Table 3 Line 7 B0-B50, excluding C-V SDCCH parts (SDCCH/4 and SCCH/C4)
  TDFrm RACHC5;
  TDFrm RACHC4_6;
  TDFrm CCCH_0;	///< GSM 05.02 Clause 7 Table 3 Line 5 B0
  TDFrm CCCH_1;	///< GSM 05.02 Clause 7 Table 3 Line 5 B1
  TDFrm CCCH_2;	///< GSM 05.02 Clause 7 Table 3 Line 5 B2
  TDFrm CCCH_3;	///< GSM 05.02 Clause 7 Table 3 Line 5 B3
  TDFrm CCCH_4;	///< GSM 05.02 Clause 7 Table 3 Line 5 B4
  TDFrm CCCH_5;	///< GSM 05.02 Clause 7 Table 3 Line 5 B5
  TDFrm CCCH_6;	///< GSM 05.02 Clause 7 Table 3 Line 5 B6
  TDFrm CCCH_7;	///< GSM 05.02 Clause 7 Table 3 Line 5 B7
  TDFrm CCCH_8;	///< GSM 05.02 Clause 7 Table 3 Line 5 B8
//@}
/**@name SDCCH */
//@{
///@name For Combination V
//@{
  TDFrm SDCCH_4_0D;	///< GSM 05.02 Clause 7 Table 3 Line 10/0D
  TDFrm SDCCH_4_0U;	///< GSM 05.02 Clause 7 Table 3 Line 10/0U
  TDFrm SDCCH_4_1D;
  TDFrm SDCCH_4_1U;
  TDFrm SDCCH_4_2D;
  TDFrm SDCCH_4_2U;
  TDFrm SDCCH_4_3D;
  TDFrm SDCCH_4_3U;
//@}
///@name For Combination VII
//@{
  TDFrm SDCCH_8_0D;
  TDFrm SDCCH_8_0U;
  TDFrm SDCCH_8_1D;
  TDFrm SDCCH_8_1U;
  TDFrm SDCCH_8_2D;
  TDFrm SDCCH_8_2U;
  TDFrm SDCCH_8_3D;
  TDFrm SDCCH_8_3U;
  TDFrm SDCCH_8_4D;
  TDFrm SDCCH_8_4U;
  TDFrm SDCCH_8_5D;
  TDFrm SDCCH_8_5U;
  TDFrm SDCCH_8_6D;
  TDFrm SDCCH_8_6U;
  TDFrm SDCCH_8_7D;
  TDFrm SDCCH_8_7U;
//@}
//@}
/**@name SACCH */
//@{
/**name SACCH for SDCCH */
//@{
///@name For Combination V
//@{
  TDFrm SACCH_C4_0D;
  TDFrm SACCH_C4_0U;
  TDFrm SACCH_C4_1D;
  TDFrm SACCH_C4_1U;
  TDFrm SACCH_C4_2D;
  TDFrm SACCH_C4_2U;
  TDFrm SACCH_C4_3D;
  TDFrm SACCH_C4_3U;
//@}
///@name For Combination VII
//@{
  TDFrm SACCH_C8_0D;
  TDFrm SACCH_C8_0U;
  TDFrm SACCH_C8_1D;
  TDFrm SACCH_C8_1U;
  TDFrm SACCH_C8_2D;
  TDFrm SACCH_C8_2U;
  TDFrm SACCH_C8_3D;
  TDFrm SACCH_C8_3U;
  TDFrm SACCH_C8_4D;
  TDFrm SACCH_C8_4U;
  TDFrm SACCH_C8_5D;
  TDFrm SACCH_C8_5U;
  TDFrm SACCH_C8_6D;
  TDFrm SACCH_C8_6U;
  TDFrm SACCH_C8_7D;
  TDFrm SACCH_C8_7U;
//@}
//@}
/**@name SACCH for TCH/F on different timeslots. */
//@{
  TDFrm SACCH_TF_T0;
  TDFrm SACCH_TF_T1;
  TDFrm SACCH_TF_T2;
  TDFrm SACCH_TF_T3;
  TDFrm SACCH_TF_T4;
  TDFrm SACCH_TF_T5;
  TDFrm SACCH_TF_T6;
  TDFrm SACCH_TF_T7;
//@}
//@}
/**name FACCH+TCH/F placement */
//@{
  //TDFrm FACCH_TCHF;
//@}
/**name FACCH+TCH/H Subchannel 0 */
  TDFrm FACCH_TCHH_S0;

/**name FACCH+TCH/H Subchannel 1 */
  TDFrm FACCH_TCHH_S1;
/**@name SACCH for TCH/H for subchannel 0  on different timeslots. */
  TDFrm SACCH_TH_S0_T0;
  TDFrm SACCH_TH_S0_T1;
  TDFrm SACCH_TH_S0_T2;
  TDFrm SACCH_TH_S0_T3;
  TDFrm SACCH_TH_S0_T4;
  TDFrm SACCH_TH_S0_T5;
  TDFrm SACCH_TH_S0_T6;
  TDFrm SACCH_TH_S0_T7;	

/**@name SACCH for TCH/H subchannel 1 on different timeslots. */
  TDFrm SACCH_TH_S1_T0;
  TDFrm SACCH_TH_S1_T1;
  TDFrm SACCH_TH_S1_T2;
  TDFrm SACCH_TH_S1_T3;
  TDFrm SACCH_TH_S1_T4;
  TDFrm SACCH_TH_S1_T5;
  TDFrm SACCH_TH_S1_T6;
  TDFrm SACCH_TH_S1_T7;
/**name FACCH+TCH/F placement */
//@{
  TDFrm FACCH_TCHF;
//@}
/**@name Test fixtures. */
  TDFrm LoopbackTestFull;
//  TDFrm LoopbackTestHalfU;
//  TDFrm LoopbackTestHalfD;
//@}

}TDFrmLst;


typedef struct TDFrmTbl
{

   TDFrmLst    Frame;

}TDFrmTbl;

extern TDFrm	*gSACCH_TF[8];
extern TDFrm 	*gSACCH_TH_S0[8];
extern TDFrm 	*gSACCH_TH_S1[8];


void TDFrmTbl_Init( void );
void TDFrmTbl_Print( void );
extern TDFrmTbl   gTDMA;


//Enable this for New Rx tune command






// Little endian





// Big endian (host to network)
// (network to host)








//Command ID 1 & 32
/*
typedef struct {
	UINT8 nBAND;
	UINT8 nReserved[3];	
} ParamsFreq; 
*/

typedef struct {
	UINT8 nData[(0x3 + 4 ) + 1];
} _ParamsFreq;



//Command ID 37
/*
typedef struct {
	UINT8 	nBAND;
	UINT16	nARFCN;
	UINT8	nReserved[3];
} ParamsArfcn;
*/

typedef struct {
	UINT8 	nData[(0x5 + 4 ) + 1];
} _ParamsArfcn;



//Command ID 2, 3 & 4


/*
typedef struct {
	UINT8 	nBAND;
	UINT16 	nARFCN;
	UINT8	nTS;
	UINT8	nDirection;
	UINT8	nChannelComb;
	UINT8	nTSC;
	UINT8	nBSIC;
	UINT8	nVoEncoderType;
	UINT8	nCiphering;
	UINT8	nHopping;
	UINT8	nHSN;
	UINT16	nMAIO;
	UINT8	nNumHopFreq;
	UINT8	nBeaconBand;
	UINT16	nBeaconARFCN;
	UINT8	nReserved[3];
	UINT16	nHopARFCN[64];   //Max 181 Bytes ????????????????
} ParamsConfig;
*/
typedef struct {
	UINT8 	nData[(156 + 4 ) + 1];
} _ParamsConfig;


//Command ID 5 & 36

/*#define PARAMSAREA_BAND1				1
#define PARAMSAREA_ARFCN1				2
#define PARAMSAREA_BAND2				4
#define PARAMSAREA_ARFCN2				5
#define PARAMSAREA_BAND3				7
#define PARAMSAREA_ARFCN3				8
#define PARAMSAREA_BAND4				10
#define PARAMSAREA_ARFCN4				11
#define PARAMSAREA_BAND5				13
#define PARAMSAREA_ARFCN5				14
#define PARAMSAREA_BAND6				16
#define PARAMSAREA_ARFCN6				17*/

/*
typedef struct {
	UINT8	nNumSerProviders;
	UINT8	nBAND1;
	UINT16	nARFCN1;
	UINT8	nBAND2;
	UINT16	nARFCN2;
	UINT8	nBAND3;
	UINT16	nARFCN3;
	UINT8	nBAND4;
	UINT16	nARFCN4;
	UINT8	nBAND5;
	UINT16	nARFCN5;
	UINT8	nBAND6;
	UINT16	nARFCN6;
	UINT8 	nReserved[3];	
} ParamsArea;
*/
typedef struct {
	UINT8 	nData[(21 + 4 ) + 1];	
} _ParamsArea;



//Command ID 6, 7 & 8



/*
typedef struct {
	UINT8 	nBAND;
	UINT16 	nARFCN;
	UINT8	nTS;
	UINT8	nDirection;
	UINT8	nChannelComb;
	UINT8	nTSC;
	UINT8	nSubSlot;
	UINT8 	nReserved[3];	
} ParamsTsc;
*/
typedef struct {
	UINT8 	nData[(20 + 4 ) + 1];	
} _ParamsTsc;



//Command ID 33, 34 & 35
/*
typedef struct {
	UINT8 	nBAND;
	UINT16 	nARFCN;
	UINT8	nTS;
	UINT8	nDirection;
	UINT8	nChannelComb;
	UINT8 	nReserved[3];	
} ParamsStop;
*/
typedef struct {
	UINT8 	nData[(9 + 4 ) + 1];	
} _ParamsStop;


//Command ID 64
/*
typedef struct {
	CHAR	cFPGA[8];
	CHAR	cDSPBoot[8];
	CHAR	cDSPApp[8];
	CHAR	cCMDPkt[8];
	UINT8	nReserved[3];
} ParamsVersion;
*/
typedef struct {
	UINT8	nData[34 + 1];
} _ParamsVersion;


/*
//Command ID 65
typedef struct {
	UINT8 a;
	//????????????????????????????
} ParamCmdId_65;
*/
//Command ID 80

//Command 81

//#define PARAMS_DLFN				(7 + IPU_INTERNAL_USE_FLAG_SIZE )
//#define PARAMS_ULFN				(11	 + IPU_INTERNAL_USE_FLAG_SIZE )

//#define	Params_SetDLFN(pParam,nDLFN) SetDWord(pParam,PARAMS_DLFN, nDLFN)
//#define	Params_SetULFN(pParam,nULFN) SetDWord(pParam,PARAMS_ULFN,nULFN)

/*
typedef struct {
	UINT8 	nBAND;
	UINT16 	nARFCN;
	UINT8	nTS;
	UINT8	nDirection;
	UINT8	nChannelComb;
	UINT8	nMulFrmNum;
	UINT8	nReserved[3];
} ParamsL2;
*/
typedef struct {
	UINT8	nData[(15 + 4 ) + 1];
} _ParamsL2;



//Command ID 96

/*#define PARAMSFPGASRIO_SRIO1RXMEMPTR			0
#define PARAMSFPGASRIO_SRIO1MEMBUFFSIZE			4
#define PARAMSFPGASRIO_SRIO1DBELLINTRVL			8
#define PARAMSFPGASRIO_RESERVED					10
#define PARAMSFPGASRIO_SRIO2RXMEMPTR			16
#define PARAMSFPGASRIO_SRIO2MEMBUFFSIZE			20
#define PARAMSFPGASRIO_SRIO2DBELLINTRVL			24
#define PARAMSFPGASRIO_RESERVED1				26*/


typedef struct {
	UINT32	nSRIO1RxMemPtr;
	UINT32	nSRIO1MemBuffSize;
	UINT16	nSRIO1DBellIntrvl;
	UINT16	nReserved[3];
	UINT32	nSRIO2RxMemPtr;
	UINT32	nSRIO2MemBuffSize;
	UINT16	nSRIO2DBellIntrvl;
	UINT16	nReserved1[3];	
} ParamsFpgaSRIO;

typedef struct {
	UINT8	nData[31 + 1];	
} _ParamsFpgaSRIO;



//Command ID 97


/*
typedef struct {
	UINT8	nDLDDCNum;
	UINT8	nULDDCNum;
	UINT8 	nBAND;
	UINT16	nDLFreq;
	UINT16	nULFreq;
	UINT8	nReserved[3];
} ParamsRx;
*/
typedef struct {
	UINT8	nData[8 + 4]; // instead of 4 it was 1, now UINT16 is using for ddc numbers instead of UINT8
} _ParamsRx;





//Command ID 98
/*
typedef struct {
	UINT8	nDLDUCNum;
	UINT8	nULDUCNum;
	UINT8 	nBAND;
	UINT16	nDLFreq;
	UINT16	nULFreq;	
	UINT8	nReserved[3];
} ParamsTx;
*/
typedef struct {
	UINT8	nData[4 + 1];
} _ParamsTx;



//Command ID 102

typedef struct {
	UINT8	nData[3 + 1];
} _ParamsDDC1;



//Command ID 103

typedef struct {
	UINT8	nData[3 + 1];
} _ParamsDDC2;



//Command ID <Need to Arrive> Introduced by Bala..Yet to check wwith Protocol document.
/*
typedef struct {
	UINT8 	nMODE;
} ParamsOperation;
*/
typedef struct {
	UINT8 	nData[0 + 1];
} _ParamsOperation;


/*
//Command ID 112
typedef struct {
	UINT8 nReserved[16];
} ParamsDspSRIO;
*/
//Command ID 113
/*
typedef struct {
	CHAR	cDSPBoot[8];
	CHAR	cDSPApp[8];
	CHAR	cCMDPkt[8];	
	UINT8	nReserved[3];
} ParamsDspVersion;
*/
typedef struct {
	UINT8	nData[26 + 1];
} _ParamsDspVersion;



//Command ID 114
/*
typedef struct {
	UINT8 a;
//????????????????????????
} ParamCmdId_114;
*/

//Command ID 100 // DSP_TO_FPGA_AREA_JAMMING




/*
typedef struct
{
	UINT32  nFreqWord[24]; //[MAX_NCO * MAX_FRQ_PER_NCO];
	UINT8   nDAC_NCOFuse[6];//[MAX_DACS];
	UINT16  nUsTimer;  
	UINT8   NoiseData[18]; 
} ParamsDsp_Fpga_AreaJam;
*/
typedef struct {
	UINT8	nData[127 + 1];  // 96 + 6 + 2 + 20
} _ParamsFpgaAreaJam;


//Command ID 101

/*
typedef struct {
	UINT8	nDACNCOFuse[6];
} ParamsDspVersion;
*/
typedef struct {
	UINT8	nData[7 + 1];
} _ParamsDACconfig;



// CONSTANTS (NOT TO BE MODIFIED)


//#define  MAX_RX_MGR			(MAX_DDC_CHANNEL)/(MAX_DIRECTION)








typedef enum BTS_CLOCK_REF
{
	USE_REF_BTS_CLOCK_SOURCE = 0,
	USE_GEN_BTS_CLOCK_SOURCE

}BTS_CLOCK_REF;


// enum
typedef enum
{
	I	=	1,	// TCH/F + SACCH/F + FACCH/F
	II	=	2,
	III	=	3,
	IV	=	4,	// FCCH + SCH + BCCH + CCCH(0...8)
	V	=	5,	// FCCH + SCH + BCCH + CCCH (0...3) + SACCH/4 + SDCCH/4
	VI	=	6,  // BCCH + CCCH
	VII=	7	// SDCCH/8 + SACCH/8

}CHANNEL_COMB;

typedef enum
{
	PGSM = 0X01,
	EGSM = 0X02,
	DCS1800 = 0X04
}BAND;

typedef enum
{
	DCS_1,
	DCS_2
}DCSPART;

typedef enum
{
	DL	=	0,
	UL	=	1,
	MAX_DIRECTIONS

}DIRECTION;

typedef enum
{
	EVEN_FRAME	=	0	,
	ODD_FRAME	=	1	
}SUBCHANNEL;
typedef enum
{
 	 TCH_EFS_244 		=	0	,
	 TCH_FS_260 		=	1	,
	 TCH_AFS_AMR		=	2	,
	 TCH_HS_112			=	3	,
	 TCH_AHS_AMR		=	4	,
	 VOCODER_TYPE_INVALID	=	255	
}VOCODER_TYPE;


// Structure
typedef struct BurstType
{
	GSM_BURST_TYPE	eBurstType[2][51];

}BurstType;


typedef struct FreqInfo
{
	UINT8		nBand;
	UINT16		nARFCN;
}FreqInfo;

typedef struct HoppingInfo
{
	UINT8 		nHSN;
	UINT8		nNumFreq;
	UINT16		nMAIO;
	FreqInfo	oFreq[64];
	BOOL		bConfigured;

}HoppingInfo;



typedef struct AGC
{
	BOOL	bMeasureOnly;
	BOOL	bDCAdjust;

}AGC;

typedef void	(*fnOnCmd)( void *pThis, void *pCmdPkt);
typedef struct CommandMap
{
	UINT8	nCmd;
	fnOnCmd	pfnOnCmd;

}CommandMap;





typedef union AllottedInfo
{
	struct
	{
		int _0	:	1;
		int _1	:	1;
		int _2	:	1;
		int _3	:	1;
		int _4	:	1;
		int _5	:	1;
		int _6	:	1;
		int _7	:	1;
	}nTNChannel;
	
	UINT8	nFreqChannel;															

}AllottedInfo;

typedef struct DDCMatrix
{
	DIRECTION 	eDir;
	UINT8		nRxManagerID;
}DDCMatrix;

typedef enum
{
	TN_OFF,
	TN_CONFIGURED,
	TN_ON
}TN_CHANNEL_STATE;

typedef enum TN_ENABLED
{
	TN_0	=	0X01,
	TN_1	=	0X02,
	TN_2	=	0X04,
	TN_3	=	0X08,
	TN_4	=	0X10,
	TN_5	=	0X20,
	TN_6	=	0X40,
	TN_7	=	0X80
}TN_ENABLED;


extern DDCMatrix	gDDCMatrix[32*2+1]; 
extern const UINT32       gRxFreqWord[1024];
extern const UINT32       gTxFreqWord[1024];



// function
void TRXCommon_Init( void );
extern DCSPART TRX_GetDCSPart(UINT16 nARFCN);
extern UINT8 *Get_fill_frame_bcch(UINT8 tsc_num, UINT8 burst_counter);
extern UINT8 *Get_fill_frame_dcch(UINT8 tsc_num, UINT8 burst_counter);
extern UINT8 *Get_dummy_burst_tch(UINT8 tsc_num);
extern UINT8* Get_dummy_burst_C0TX(void);




typedef struct Burst
{
	UINT32		nLastPktNum;
	UINT32		nNumSamples;
	UINT8		nDDCNum;
	GSMTime		oTime;
	SysTime		oLastSampleTime;
	UINT16		nARFCN;
	COMPLEX16	oBaseband[157*2+5]; // can hold upto two burst samples
	UINT64		nJobCompPakNum;
	UINT8		nRXMgrId;
	DIRECTION	eDir;
	UINT64		BurstSeqNo;  // For Testing
	SysTime 	oCurrent;    // For  Testing
}Burst;


void Burst_Init(Burst *pThis );
void Burst_SetTime( Burst *pThis, GSMTime oTime );
void Burst_SetDDCNum( Burst *pThis, UINT8 nDDCNum);
UINT8 Burst_GetDDCNum( Burst *pThis);
GSMTime Burst_GetTime(Burst *pThis );
BOOL    Burst_ValidateNumSamples ( UINT16 nNumSamples);
COMPLEX16 *Burst_GetBasebandData( Burst *pThis );
void		Burst_UpdateLastSampleTime( Burst *pThis);
void Burst_UpdateSampleTime( Burst *pThis, SysTime oSysTime);
void Burst_UpdateNumSamples(Burst *pThis, UINT32 nSamples);





/************************************************************************
 * File:
 *      $RCSfile: logchan.h,v $
 *      $Revision: 1.12 $
 *      $Date: 2009/08/12 03:45:01 $
 *
 *      (c) 2006 DelCom Systems, Inc.
 *      The Source Code contained herein is DelCom
 *      Systems, Inc. Confidential material and subject to Non-Disclosure.
 *
 *      The Source Code is and shall remain owned by DelCom
 *      Systems, Inc. and/or its suppliers and is protected by United
 *      States copyright laws and international treaty provisions.  As an
 *      express condition of the executed Source License Agreement, title
 *      to, ownership of, and all rights in patents, copyrights, trade
 *      secrets and any other intellectual property rights in this Source
 *      Code and/or any copy or part thereof is and shall remain in DelCom
 *      Systems, Inc. and/or its suppliers.  It is understood
 *      by the user of the Source Code that valuable, confidential
 *      information and trade secrets are contained within and that
 *      unauthorized use and/or copying shall be harmful to DelCom
 *      Systems, Inc.
 *
 *      THE SOURCE CODE MAY NOT BE MODIFIED, ADAPTED, TRANSLATED, RENTED,
 *      LEASED, LOANED, RESOLD FOR PROFIT, DISTRIBUTED OR OTHERWISE ASSIGNED
 *      OR TRANSFERRED NOR MAY DERIVITATIVE WORKS BASED UPON THIS SOFTWARE
 *      OR ANY PART THEREOF BE DEVELOPED WITHOUT WRITTEN AGREEMENT BY DELCOM
 *      SYSTEMS, INC. 
 *
 ************************************************************************/

/************************************************************************
 * File:
 *      $RCSfile: logchantypes.h,v $
 *      $Revision: 1.6 $
 *      $Date: 2009/04/14 23:38:45 $
 *
 *      (c) 2006 DelCom Systems, Inc.
 *      The Source Code contained herein is DelCom
 *      Systems, Inc. Confidential material and subject to Non-Disclosure.
 *
 *      The Source Code is and shall remain owned by DelCom
 *      Systems, Inc. and/or its suppliers and is protected by United
 *      States copyright laws and international treaty provisions.  As an
 *      express condition of the executed Source License Agreement, title
 *      to, ownership of, and all rights in patents, copyrights, trade
 *      secrets and any other intellectual property rights in this Source
 *      Code and/or any copy or part thereof is and shall remain in DelCom
 *      Systems, Inc. and/or its suppliers.  It is understood
 *      by the user of the Source Code that valuable, confidential
 *      information and trade secrets are contained within and that
 *      unauthorized use and/or copying shall be harmful to DelCom
 *      Systems, Inc.
 *
 *      THE SOURCE CODE MAY NOT BE MODIFIED, ADAPTED, TRANSLATED, RENTED,
 *      LEASED, LOANED, RESOLD FOR PROFIT, DISTRIBUTED OR OTHERWISE ASSIGNED
 *      OR TRANSFERRED NOR MAY DERIVITATIVE WORKS BASED UPON THIS SOFTWARE
 *      OR ANY PART THEREOF BE DEVELOPED WITHOUT WRITTEN AGREEMENT BY DELCOM
 *      SYSTEMS, INC. 
 *
 *
 ************************************************************************/

/* WARNING: If this changes please update dcs_gsm_L1_PH.h */

typedef enum{
	/*** API DEFINED, do not change order/numbering */
	SACCH  = 0,
	SDCCH,		/*1*/	
	AGCH,		/*2*/
	PCH,		/*3*/
	RACH,		/*4*/
	FACCH,		/*5*/
	BCCH,		/*6*/
	BCH,		/*7*/
	BCH_EXT,	/*8*/
	
	FCCH,		/*9*/
  	SCH, 		/*10*/
  	CCCH,		/*11*/
  	PDTCH_F,       /*12 */
     PTCCH,       /* 13 */
     PRACH,	   /* 14 */
  	/*****END API DEFINED *********/
	IDLE=20,	/*20*/
	TCH_FS,		/*21*/
	TCH_EFS,		/*22*/
  	
  	
  	  TCH_HS,
  TCH_AFS,
  TCH_AHS,
  TCH_WFS,
  TCH_F14_4,
  TCH_F9_6,
  TCH_F4_8,
  TCH_F2_4,
  FACCH_H,
/* Not really used right now */
  TCH_H4_8,
  TCH_H2_4,
  ETCH_F43_2,
  ETCH_F32_0,
  ETCH_F28_8,

  NCH,
  PACCH_F,
  PACCH_H,
  PACCH_SHORT_ACK, /* For Uplink, PACCH uses ACCESS bursts at handover */
  PBCCH,
  PAGCH,
  PPCH,
  PNCH,
  PDTCH_H,
  
  CPBCCH,
  CPAGCH,
  CPPCH,
  CPNCH,
  CFCCH,
  CSCH,
  CPRACH,

  CTSBCH_SB,
  CTSARCH,
  CTSAGCH,
  CTSPCH
} GSM_LOGCHAN_TYPE;

/* Note: Current Test Apps require equivalent TX and RX types to have the same value */

	

/* Internal DelCom use only */






	



/* Internal DelCom use only */


/**********TCH/AHS/AFS ACS (Active Codec Set) Rate Definitions ******************/





/*******************TCH/AHS/AFS ENCODER Input buffer Layout *********************/

/******************TCH/AHS/AFS DECODER Output buffer Layout ********************/


/****************DELCOM INTERNAL USE ONLY *********************************/
typedef enum {
     GSM_DCS_TCH_AFS_NODATA = 0,
	GSM_DCS_TCH_AFS_SID_UPDATE,
	GSM_DCS_TCH_AFS_SID_FIRST,
	GSM_DCS_TCH_AFS_ONSET,
	GSM_DCS_TCH_AFS_SPEECH12_2,
	GSM_DCS_TCH_AFS_SPEECH10_2,
	GSM_DCS_TCH_AFS_SPEECH7_95,
	GSM_DCS_TCH_AFS_SPEECH7_4,
	GSM_DCS_TCH_AFS_SPEECH6_7,
	GSM_DCS_TCH_AFS_SPEECH5_9,
	GSM_DCS_TCH_AFS_SPEECH5_15,
	GSM_DCS_TCH_AFS_SPEECH4_75,
	GSM_DCS_TCH_AFS_RATSCCH,
	GSM_DCS_TCH_AFS_FACCH,
	GSM_DCS_TCH_WFS_SPEECH12_65,
	GSM_DCS_TCH_WFS_SPEECH8_85,
	GSM_DCS_TCH_WFS_SPEECH6_60
} GSM_DCS_TCH_AFS_FRAME_FORMAT;

typedef enum {
  GSM_DCS_TCH_AHS_NODATA = 0,
	GSM_DCS_TCH_AHS_SID_UPDATE,
	GSM_DCS_TCH_AHS_SID_FIRST,
	GSM_DCS_TCH_AHS_ONSET,
	GSM_DCS_TCH_AHS_SPEECH7_95,
	GSM_DCS_TCH_AHS_SPEECH7_4,
	GSM_DCS_TCH_AHS_SPEECH6_7,
	GSM_DCS_TCH_AHS_SPEECH5_9,
	GSM_DCS_TCH_AHS_SPEECH5_15,
	GSM_DCS_TCH_AHS_SPEECH4_75,
	GSM_DCS_TCH_AHS_RATSCCH,
	GSM_DCS_TCH_AHS_RATSCCH_MARKER,
	GSM_DCS_TCH_AHS_RATSCCH_DATA,
	GSM_DCS_TCH_AHS_SID_UPDATE_INH,
	GSM_DCS_TCH_AHS_SID_FIRST_P1,
	GSM_DCS_TCH_AHS_SID_FIRST_P2,
	GSM_DCS_TCH_AHS_SID_FIRST_INH
} GSM_DCS_TCH_AHS_FRAME_FORMAT;



struct GSM_time_class {
  struct GSM_time_fxns *fxns;
  UINT32 FN;  /* frame number, range: 0 to (26 x 51 x 2048)-1 */
  int    T1;  /**/
  int    T2;  /* speech frame counter: 0 to 25 */
  int    T3;  /* signalling frame counter: 0 to 50 */
  int	 T2P;
  UINT8  TN;   /* time slot number, range: 0 to 7 */
 
  
};

struct GSM_time_fxns
{
  UINT32 (*increment_time)(struct GSM_time_class *time_obj, int slots);
};


struct GSM_logchantx_class
{
  struct GSM_logchantx_fxns *fxns;
  GSM_LOGCHAN_TYPE logchantx_type;
  UINT16 bitsReady;
  /* Internal state variables */
  size_t scratch1_buf;
  size_t scratch2_buf;
}; 

struct GSM_logchantx_fxns
{
  /* returns 114 coded bits for GSM_ctrl_logchan_class           */
  /* returns 114 coded bits for GSM_voicefull_logchan_class      */
  /* returns 114 coded bits for GSM_voicehalf_logchan_class      */
  /* returns 114 coded bits for GSM_pktdata_logchan_class (GMSK) */
  /* returns 456 coded bits for GSM_pktdata_logchan_class (EDGE) */
  /* returns 78 coded bits for GSM_ctrl_sch_logchan_class        */
  /* returns 36 coded bits for GSM_ctrl_rach_logchan_class       */

  UINT16 (*encode_bits)(
    struct GSM_logchantx_class *log_chan_obj,
    BIT_TYPE                   *inbuf, //added to bypass fp 
    BIT_TYPE                   *outbuf,
    BIT_TYPE                   *steal_bits,
    UINT8                       block_phase,
    UINT16				  nbits,
    SCRATCH                    *scratch1,
    SCRATCH                    *scratch2);
};


struct GSM_tx_info_rts_req 
{
	UINT32 FN;
	UINT16 state;		/* see states above  */
	UINT8  chanType;
	UINT8  mode;        /* used for GPRS coding scheme */
	INT16  nbits;
	INT16  pad32;
	OCTET  data[64];	
};

struct GSM_logchantx_info_class
{
  struct GSM_logchantx_info_fxns *fxns;
  
  /* Internal state variables */
  struct GSM_tx_info_rts_req  rts_req;  
  
  
  size_t scratch1_buf;
  size_t scratch2_buf;
};

struct GSM_logchantx_info_fxns
{
  UINT16 (*get_info_bits)(
    struct GSM_logchantx_info_class *chan_info_obj,
    BIT_TYPE                        *outbuf,
    UINT16                          output_length,
    SCRATCH                         *scratch1,
    SCRATCH                         *scratch2);
};


struct GSM_ctrl_logchantx_info_class
{
  /* SACCH,FACCH,BCCH,CBCH,PCH,AGCH,SDCCH,CTSAGCH,CTSPCH           */
  /* PACCH,PBCCH,PAGCH,PPCH,PNCH,PTCCH/D,CPBCCH,CPAGCH,CPPCH,CPNCH */
  /* These channels use a block of 184 data bits                   */

  struct GSM_logchantx_info_class base;
  struct GSM_time_class *time_obj;
//  int *bs_or_ms_data;   /* ptr to structs GSM_ms_data or GSM_bs_data */
  UINT8	L1header[2];
 
  /* Internal state variables */

};

struct GSM_ctrl_logchantx_class
{
  /* SACCH,FACCH,BCCH,CBCH,PCH,AGCH,SDCCH,CTSAGCH,CTSPCH           */
  /* PACCH,PBCCH,PAGCH,PPCH,PNCH,PTCCH/D,CPBCCH,CPAGCH,CPPCH,CPNCH */
  /* These channels use a block of 456 coded bits distributed over */
  /* 4 bursts with rectangular interleaving                        */

  struct GSM_logchantx_class base;
  struct GSM_ctrl_logchantx_info_class *info_obj;
  struct GSM_time_class *time_obj;

  
  /* Internal state variables */
  BIT_TYPE intlv_buf[456]; /* contains rectangularly interleaved bits */
};

struct GSM_ctrl_sch_logchantx_info_class
{
  /* SCH,CSCH,CTSBCH-SB,CTSARCH */
  /* These channels use a block of 25 data bits */

  struct GSM_logchantx_info_class base;
  struct GSM_time_class *time_obj;
  UINT8  *BSIC;

  /* Internal state variables */

};

struct GSM_ctrl_sch_logchantx_class
{
  /* SCH,CSCH,CTSBCH-SB,CTSARCH */
  /* These channels use a block of 78 coded bits on 1 burst */

  struct GSM_logchantx_class base;
  struct GSM_ctrl_sch_logchantx_info_class *info_obj;
  /* Internal state variables */

};

struct GSM_logchanrx_class
{
  struct GSM_logchanrx_fxns *fxns;
  GSM_LOGCHAN_TYPE logchan_type;
  struct GSM_Measurement *measurement;
  /* Internal state variables */
  size_t scratch1_buf;
  size_t scratch2_buf;
}; 

struct GSM_logchanrx_fxns
{
  /* input 116 coded bits for GSM_ctrl_logchanrx_class           */
  /* input 116 coded bits for GSM_voicefull_logchanrx_class      */
  /* input 116 coded bits for GSM_voicehalf_logchanrx_class      */
  /* input 116 coded bits for GSM_pktdata_logchanrx_class (GMSK) */
  /* input 456 coded bits for GSM_pktdata_logchanrx_class (EDGE) */
  /* input 78 coded bits for GSM_ctrl_sch_logchanrx_class        */
  /* input 36 coded bits for GSM_ctrl_rach_logchanrx_class       */
  
  INT16 (*decode_bits)(
    struct GSM_logchanrx_class *log_chan_obj,
    const INT16                *inbuf,       /* soft bits */
    BIT_TYPE	               *outbuf,      /* added to bypass fp of info class*/
    UINT8                      block_phase,
    UINT16			*paramOut,
    SCRATCH                    *scratch1,
    SCRATCH                    *scratch2);
};

struct GSM_logchanrx_info_class
{
  struct GSM_logchanrx_info_fxns *fxns;

  /* Internal state variables */

  size_t scratch1_buf;
  size_t scratch2_buf;
};

struct GSM_logchanrx_info_fxns
{
  UINT16 (*put_info_bits)(
    struct GSM_logchanrx_info_class *chan_info_obj,
    const BIT_TYPE                  *inbuf,
    UINT16                          info_bits_length,
    SCRATCH                         *scratch1,
    SCRATCH                         *scratch2);
};




struct GSM_ctrl_logchanrx_info_class
{
  /* SACCH,FACCH,BCCH,CBCH,PCH,AGCH,SDCCH,CTSAGCH,CTSPCH           */
  /* PACCH,PBCCH,PAGCH,PPCH,PNCH,PTCCH/D,CPBCCH,CPAGCH,CPPCH,CPNCH */
  /* These channels use a block of 184 data bits                   */

  struct GSM_logchanrx_info_class base;
  struct GSM_time_class *time_obj;
  UINT8	    sacchL3IndEnable;
 
  /* Internal state variables */

};

struct GSM_ctrl_logchanrx_class
{
  /* SACCH,FACCH,BCCH,CBCH,PCH,AGCH,SDCCH,CTSAGCH,CTSPCH           */
  /* PACCH,PBCCH,PAGCH,PPCH,PNCH,PTCCH/D,CPBCCH,CPAGCH,CPPCH,CPNCH */
  /* These channels use a block of 456 coded bits distributed over */
  /* 4 bursts with rectangular interleaving                        */

  struct GSM_logchanrx_class base;
  struct GSM_ctrl_logchanrx_info_class *info_obj;
  struct GSM_time_class *time_obj;
  
  /* Internal state variables */
  INT16 intlv_buf[456]; /* contains rectangularly interleaved bits */
  INT16 steal_bits[8];   /* soft decision bits */
};

struct GSM_ctrl_sch_logchanrx_info_class
{
  /* SCH,CSCH,CTSBCH-SB,CTSARCH */
  /* These channels use a block of 25 data bits */

  struct GSM_logchanrx_info_class base;
  struct GSM_time_class *time_obj;
  OCTET BSIC;

  /* Internal state variables */

};

struct GSM_ctrl_sch_logchanrx_class
{
  /* SCH,CSCH,CTSBCH-SB,CTSARCH */
  /* These channels use a block of 78 coded bits on 1 burst */

  struct GSM_logchanrx_class base;
  struct GSM_ctrl_sch_logchanrx_info_class *info_obj;
  

  /* Internal state variables */

};

struct GSM_voicefull_logchantx_info_class
{
  struct GSM_logchantx_info_class base;

  /* Internal state variables */

};
struct GSM_voicefull_logchantx_class
{
  /* TCH/FS, TCH/EFS, TCH/AFS                                      */
  /* These channels use a block of 456 coded bits distributed over */
  /* 8 bursts with diagonal interleaving                           */

  struct GSM_logchantx_class base;
  struct GSM_voicefull_logchantx_info_class *info_obj;
  struct GSM_ctrl_logchantx_info_class *FACCH_obj;
  struct GSM_time_class *time_obj;
  
  /* Internal state variables */
  BIT_TYPE intlv_buf[2][456];
  BIT_TYPE even_steal_bits[2];
  BIT_TYPE odd_steal_bits[2];
  BIT_TYPE intlv_buf_index;
  
  UINT8 facchL2RTSDisable;
 
};

struct GSM_voicefull_logchanrx_info_class
{
  struct GSM_logchanrx_info_class base;

  /* Internal state variables */

};
struct GSM_voicefull_logchanrx_class
{
  /* TCH/FS, TCH/EFS, TCH/AFS                                      */
  /* These channels use a block of 456 coded bits distributed over */
  /* 8 bursts with diagonal interleaving                           */

  struct GSM_logchanrx_class base;
  struct GSM_voicefull_logchanrx_info_class *info_obj;
  struct GSM_ctrl_logchanrx_info_class      *FACCH_obj;
  struct GSM_time_class *time_obj;
  
  /* Internal state variables */
  INT16 intlv_buf[2][456];
  INT16 steal_bits[2][8];
  BIT_TYPE intlv_buf_index;
};

struct GSM_ctrl_rach_logchantx_class
{
  /* RACH,PRACH,CPRACH,PTCCH/U */
  /* These channels use a block of 36 coded bits on 1 burst */

  struct GSM_logchantx_class base;
  struct GSM_ctrl_rach_logchantx_info_class *info_obj;
  UINT8 is_extended_rach;  /* 0 = no, 1 = yes */
  UINT8 *BSIC;

  /* Internal state variables */

};

struct GSM_ctrl_rach_logchanrx_class
{
  /* RACH,PRACH,CPRACH,PTCCH/U */
  /* These channels use a block of 36 coded bits on 1 burst */

  struct GSM_logchanrx_class base;
  struct GSM_ctrl_rach_logchanrx_info_class *info_obj;
  UINT8 is_extended_rach;  /* 0 = no, 1 = yes */
  UINT8 *BSIC;

  /* Internal state variables */

};
struct GSM_ctrl_rach_logchantx_info_class
{
  struct GSM_logchantx_info_class base;

  /* Internal state variables */

};
struct GSM_ctrl_rach_logchanrx_info_class
{
  struct GSM_logchanrx_info_class base;

  /* Internal state variables */

};

struct GSM_tch_hs_logchantx_info_class
{
  struct GSM_logchantx_info_class base;

  /* Internal state variables */

};
struct GSM_tch_hs_logchanrx_info_class
{
  struct GSM_logchanrx_info_class base;

  /* Internal state variables */

};
struct GSM_tch_hs_logchantx_class
{
  /* TCH/HS                                                       */
  struct GSM_logchantx_class base;
  struct GSM_tch_hs_logchantx_info_class *info_obj;
  /* Internal state variables */
  BIT_TYPE intlv_buf[3][228];
  BIT_TYPE even_steal_bits[3];
  BIT_TYPE odd_steal_bits[3];
  unsigned int intlv_buf_index;
  unsigned int facch_flag;
 
};

struct GSM_tch_hs_logchanrx_class
{
  /* TCH/HS   */
  
  struct GSM_logchanrx_class base;
  struct GSM_tch_hs_logchanrx_info_class *info_obj;
  /* Internal state variables */
  INT16 intlv_buf[4][228];
  INT16 steal_bits[4][4];
  unsigned int intlv_buf_index;

};

void
GSM_DCS_init_ctrl_logchantx_class_object(struct GSM_ctrl_logchantx_class *obj);

void
GSM_DCS_init_ctrl_logchanrx_class_object(struct GSM_ctrl_logchanrx_class *obj);

void
GSM_DCS_init_ctrl_sch_logchantx_class_object(struct GSM_ctrl_sch_logchantx_class *obj);

void
GSM_DCS_init_ctrl_sch_logchanrx_class_object(struct GSM_ctrl_sch_logchanrx_class *obj);

void
GSM_DCS_init_tch_fs_logchantx_class_object(struct GSM_voicefull_logchantx_class *obj);

void
GSM_DCS_init_tch_fs_logchanrx_class_object(struct GSM_voicefull_logchanrx_class *obj);

void
GSM_DCS_init_ctrl_rach_logchantx_class_object(struct GSM_ctrl_rach_logchantx_class *obj,UINT8 *BSIC);
void
GSM_DCS_init_ctrl_rach_logchanrx_class_object(struct GSM_ctrl_rach_logchanrx_class *obj, UINT8 *BSIC);


void GSM_DCS_init_tch_hs_logchantx_class_object(struct GSM_tch_hs_logchantx_class *obj);
void GSM_DCS_init_tch_hs_logchanrx_class_object(struct GSM_tch_hs_logchanrx_class *obj);


/************************************************************************
 * File:
 *      $RCSfile: gsm_constants_amr.h,v $
 *      $Revision: 1.2 $
 *      $Date: 2008/03/03 22:21:34 $
 *
 *      (c) 2006 DelCom Systems, Inc.
 *      The Source Code contained herein is DelCom
 *      Systems, Inc. Confidential material and subject to Non-Disclosure.
 *
 *      The Source Code is and shall remain owned by DelCom
 *      Systems, Inc. and/or its suppliers and is protected by United
 *      States copyright laws and international treaty provisions.  As an
 *      express condition of the executed Source License Agreement, title
 *      to, ownership of, and all rights in patents, copyrights, trade
 *      secrets and any other intellectual property rights in this Source
 *      Code and/or any copy or part thereof is and shall remain in DelCom
 *      Systems, Inc. and/or its suppliers.  It is understood
 *      by the user of the Source Code that valuable, confidential
 *      information and trade secrets are contained within and that
 *      unauthorized use and/or copying shall be harmful to DelCom
 *      Systems, Inc.
 *
 *      THE SOURCE CODE MAY NOT BE MODIFIED, ADAPTED, TRANSLATED, RENTED,
 *      LEASED, LOANED, RESOLD FOR PROFIT, DISTRIBUTED OR OTHERWISE ASSIGNED
 *      OR TRANSFERRED NOR MAY DERIVITATIVE WORKS BASED UPON THIS SOFTWARE
 *      OR ANY PART THEREOF BE DEVELOPED WITHOUT WRITTEN AGREEMENT BY DelCom
 *      Systems, INC. 
 *
 *
 ************************************************************************/




/* AMR channels */





















































/************************************************************************
 * File:
 *      $RCSfile: logchan_amr.h,v $
 *      $Revision: 1.3 $
 *      $Date: 2008/03/20 17:39:17 $
 *
 *      (c) 2006 DelCom Systems, Inc.
 *      The Source Code contained herein is DelCom
 *      Systems, Inc. Confidential material and subject to Non-Disclosure.
 *
 *      The Source Code is and shall remain owned by DelCom
 *      Systems, Inc. and/or its suppliers and is protected by United
 *      States copyright laws and international treaty provisions.  As an
 *      express condition of the executed Source License Agreement, title
 *      to, ownership of, and all rights in patents, copyrights, trade
 *      secrets and any other intellectual property rights in this Source
 *      Code and/or any copy or part thereof is and shall remain in DelCom
 *      Systems, Inc. and/or its suppliers.  It is understood
 *      by the user of the Source Code that valuable, confidential
 *      information and trade secrets are contained within and that
 *      unauthorized use and/or copying shall be harmful to DelCom
 *      Systems, Inc.
 *
 *      THE SOURCE CODE MAY NOT BE MODIFIED, ADAPTED, TRANSLATED, RENTED,
 *      LEASED, LOANED, RESOLD FOR PROFIT, DISTRIBUTED OR OTHERWISE ASSIGNED
 *      OR TRANSFERRED NOR MAY DERIVITATIVE WORKS BASED UPON THIS SOFTWARE
 *      OR ANY PART THEREOF BE DEVELOPED WITHOUT WRITTEN AGREEMENT BY DELCOM
 *      SYSTEMS, INC. 
 *
 ************************************************************************/


typedef enum {
  GSM_AMR_CODEC_MODE_1 = 0,
  GSM_AMR_CODEC_MODE_2,
  GSM_AMR_CODEC_MODE_3,
  GSM_AMR_CODEC_MODE_4
}GSM_AMR_INBAND_DATA_ID;



struct GSM_tch_afs_logchantx_class
{
  /* TCH/AFS */

  struct GSM_logchantx_class base;
  
  
  /* Internal state variables */
  BIT_TYPE intlv_buf[2][456];
  BIT_TYPE even_steal_bits[2];
  BIT_TYPE odd_steal_bits[2];
  UINT8  active_codec_set[4];
  int intlv_buf_index;
  int codec_mode;
  
};


struct GSM_tch_afs_logchanrx_class
{
  /*  TCH/AFS                                      */
  /* These channels use a block of 456 coded bits distributed over */
  /* 8 bursts with diagonal interleaving                           */

  struct GSM_logchanrx_class base;
  
  
  /* Internal state variables */
  INT16 intlv_buf[2][456];
  INT16 steal_bits[2][8];
  UINT8  active_codec_set[4];
  int intlv_buf_index;
  int codec_mode;
  int downlink;
  int rif_phase;
  
};


struct GSM_tch_ahs_logchantx_class
{
  /* TCH/AHS                                                       */
             
  struct GSM_logchantx_class base;
  
  /* Internal state variables */
  BIT_TYPE intlv_buf[3][228];
  BIT_TYPE even_steal_bits[3];
  BIT_TYPE odd_steal_bits[3];
  UINT8  active_codec_set[4];
  unsigned int intlv_buf_index;
  unsigned int facch_flag;
  int sid_update_phase;
  int sid_first_phase;
  int     codec_mode;
 
};



struct GSM_tch_ahs_logchanrx_class
{
  /* TCH/AHS   */
  
  struct GSM_logchanrx_class base;
  
  /* Internal state variables */
  INT16 intlv_buf[4][228];
  INT16 steal_bits[4][4];
  unsigned int intlv_buf_index;

  
  UINT8  active_codec_set[4];

  int sid_update_phase;
  int sid_first_phase;
  int ratscch_phase;
  int codec_mode;
  int downlink;	/* true for downlink reception */
  int rif_phase;
};
void GSM_DCS_init_tch_afs_logchantx_class_object(struct GSM_tch_afs_logchantx_class *obj);

void GSM_DCS_init_tch_afs_logchanrx_class_object(struct GSM_tch_afs_logchanrx_class *obj);

void GSM_DCS_init_tch_ahs_logchantx_class_object(struct GSM_tch_ahs_logchantx_class *obj);
void GSM_DCS_init_tch_ahs_logchanrx_class_object(struct GSM_tch_ahs_logchanrx_class *obj);


/************************************************************************
 * Function:
 *  GSM_DCS_set_tch_ahs_logchanrx_acs(struct GSM_tch_ahs_logchanrx_class *obj, UINT8 *rates)
 *
 * Purpose: 
 *  Sets active set of 4 Speech Rates selected by ID1 Indication
 ************************************************************************/
void GSM_DCS_set_tch_ahs_logchanrx_acs(struct GSM_tch_ahs_logchanrx_class *obj, UINT8 *rates);
/************************************************************************
 * Function:
 *  GSM_DCS_set_tch_ahs_logchantx_acs(struct GSM_tch_ahs_logchantx_class *obj, UINT8 *rates)
 *
 * Purpose: 
 *  Sets active set of 4 Speech Rates selected by ID1 Indication
 ************************************************************************/
void GSM_DCS_set_tch_ahs_logchantx_acs(struct GSM_tch_ahs_logchantx_class *obj, UINT8 *rates);
/************************************************************************
 * Function:
 *  GSM_DCS_set_tch_afs_logchantx_acs(struct GSM_tch_afs_logchantx_class *obj, UINT8 *rates)
 *
 * Purpose: 
 *  Sets active set of 4 Speech Rates selected by ID1 Indication
 ************************************************************************/
void GSM_DCS_set_tch_afs_logchantx_acs(struct GSM_tch_afs_logchantx_class *obj, UINT8 *rates);
/************************************************************************
 * Function:
 *  GSM_DCS_set_tch_afs_logchanrx_acs(struct GSM_tch_afs_logchanrx_class *obj, UINT8 *rates)
 *
 * Purpose: 
 *  Sets active set of 4 Speech Rates selected by ID1 Indication
 ************************************************************************/
void GSM_DCS_set_tch_afs_logchanrx_acs(struct GSM_tch_afs_logchanrx_class *obj, UINT8 *rates);

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


typedef enum L1FEC_TYPE
{
	L1FEC_DECODER = 0,
	L1FEC_ENCODER

}L1FEC_TYPE;

typedef struct L1FEC
{

	TDFrm				*pTDFrm;
	GSM_LOGCHAN_TYPE	eLogChanType;
	GSM_BURST_TYPE		eBurstType;
	MULTIFRAME_TYPE		eMultiFrameType;
	BOOL				bJustConfigured;
	struct GSM_logchanrx_class *pRxObj;
	struct GSM_logchantx_class *pTxObj;
	UINT16				nInfoBitsLength;
	SUBCHANNEL		eSubChannel;

}L1FEC;


void 	L1FEC_Init( L1FEC *pThis, TDFrm *pTDFrm, GSM_LOGCHAN_TYPE eLogChanType );
TDFrm 	*L1FEC_GetTDFrm(L1FEC *pThis);
struct GSM_logchanrx_class *L1FEC_GetRxObj( L1FEC *pThis);
struct GSM_logchantx_class *L1FEC_GetTxObj( L1FEC *pThis);
GSM_BURST_TYPE L1FEC_GetBurstType(L1FEC *pThis);
GSM_LOGCHAN_TYPE L1FEC_GetLogChanType( L1FEC *pThis);
MULTIFRAME_TYPE	L1FEC_GetMultiFrameType (L1FEC *pThis);
BOOL L1FEC_DoChannelDecoding( L1FEC *pThis, 
const INT16 *pInBuf,
BIT_TYPE	*pOutBuf,
UINT16		*pDecParam,
UINT32		nFrameNum,
SCRATCH		*pScratchM1,
SCRATCH		*pScratchM2,
UINT8		*pBlockPhase,
UINT16		*pRetVal

);

BOOL L1FEC_DoChannelEncoding( L1FEC *pThis, 
BIT_TYPE	*pInBuf,
BIT_TYPE	*pOutBuf,
BIT_TYPE	*pSteal_Bits,
UINT16		nNumBits,
UINT32		nFrameNum,
SCRATCH		*pScratchM1,
SCRATCH		*pScratchM2,
UINT8		*pBlockPhase,
UINT16		*pRetVal

);

UINT16		L1FEC_GetInfoBitsLength( L1FEC *pThis );
void		L1FEC_UpdateACS(L1FEC *pThis, UINT8 *pRates, UINT8 ICM);

typedef struct L1FCCHFEC
{
	L1FEC oL1fec;

}L1FCCHFEC;

typedef struct L1SCHFEC
{
	L1FEC oL1fec;
}L1SCHFEC;

typedef struct L1XCCHFEC
{
	L1FEC oL1fec;
}L1XCCHFEC;

typedef struct L1TCHFSFEC
{
	L1FEC oL1fec;
}L1TCHFSFEC;

typedef struct L1TCHAFSFEC
{
	L1FEC	oL1fec;
	UINT16	nFrameFormat;
}L1TCHAFSFEC;
typedef struct L1TCHAHSFEC
{
	L1FEC oL1fec;
}L1TCHAHSFEC;

typedef struct L1RACHFEC
{
	L1FEC oL1fec;
	UINT8	  nBSIC;

}L1RACHFEC;

struct GSM_fcch_detect_rx_obj	*L1FEC_GetFCCHRxObj( L1FEC *pThis );
void L1FCCHFEC_Init( L1FCCHFEC *pThis,void	*pObj, L1FEC_TYPE eL1fecType );
void L1SCHFEC_Init( L1SCHFEC *pThis, void   *pObj, L1FEC_TYPE eL1fecType );
void L1RACHFEC_Init( L1RACHFEC *pThis, void *pObj, GSM_LOGCHAN_TYPE eLogChanType, TDFrm *pTDFrm, UINT8 nBSIC, L1FEC_TYPE eL1fecType );			
void L1TCHFSFEC_Init( L1TCHFSFEC *pThis, void*pObj, GSM_LOGCHAN_TYPE eLogChanType, TDFrm *pFrm, L1FEC_TYPE eL1fecType );
void L1XCCHFEC_Init( L1XCCHFEC *pThis, void *pObj, GSM_LOGCHAN_TYPE eLogChanType, TDFrm *pFrm, L1FEC_TYPE eL1fecType );
void L1TCHAFSFEC_Init( L1TCHAFSFEC *pThis, void*pObj, GSM_LOGCHAN_TYPE eLogChanType, TDFrm *pFrm, L1FEC_TYPE eL1fecType,UINT8 eDir );





typedef struct L1Config
{

	L1FEC			**pL1FECTable;
	void			*pL1FECPtr[16];
	void			*pLogChanPtr[4];
	DIRECTION		eDir;
	CHANNEL_COMB	eChannelComb;
	UINT8			nBSIC;
	UINT8			nTN;
	VOCODER_TYPE	eVocoderType;
	L1FEC_TYPE		eL1fec_Type;

	UINT8 nMaxL1FECBlockPerChannel;
	UINT8 nMaxLogChanClassPerChannel;

	SUBCHANNEL		eSubChannel;	
}L1Config;

void L1Config_Setup( L1Config *pThis,CHANNEL_COMB eChannelComb, DIRECTION eDir, VOCODER_TYPE eVocoderType, UINT8 nTN, UINT8 nBSIC, L1FEC_TYPE eL1fec_Type, L1FEC **pL1FECTable);
void L1Config_Delete( L1Config *pThis);
void L1Config_Dump(L1Config *pThis);


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



typedef struct {
	Packet *pPacket; 	
} CmdPkt;

extern void CmdPkt_Parse(CmdPkt *pThis, Packet *packet);
extern PacketSender CmdPkt_GetSender(CmdPkt *pThis);
extern PacketReceiver CmdPkt_GetReceiver(CmdPkt *pThis);
extern PacketType CmdPkt_GetPacketType(CmdPkt *pThis);
extern CommandType CmdPkt_GetCommand(CmdPkt *pThis);
extern UINT8 CmdPkt_GetSeqNumber(CmdPkt *pThis);
extern UINT8 CmdPkt_GetDataCount(CmdPkt *pThis);
extern PacketHeader * CmdPkt_GetHeader(CmdPkt *pThis);
extern void * CmdPkt_GetParam(CmdPkt *pThis);
extern PacketStatus CmdPkt_ValidatePacket(CmdPkt *pThis);
extern BOOL CmdPkt_IsWritePkt(CmdPkt *pThis);
extern void CmdPkt_Make(CmdPkt *pThis , Packet *CmdPacket, 
						PacketReceiver eReceiver, UINT8 nDataSize, 
						CommandType eCmd, PacketType ePacketType, UINT8 nSeqNum);

extern void CmdPkt_SetHeader(CmdPkt *pThis, PacketHeader *pHeader);
extern void CmdPkt_UpdateSender(CmdPkt *pThis, PacketSender eSender);
extern void CmdPkt_UpdateReceiver(CmdPkt *pThis, PacketReceiver eReceiver);
extern void CmdPkt_UpdatePacketType(CmdPkt *pThis, PacketType ePacketType);




/*********************Real Size packets********************************/
typedef struct RealDataRx1 {
	UINT32		DDCFlag;
	COMPLEX16	DDC[64][2];   // it was DDC[28][2];, modified for TRS
	//UINT8 Byte[228];
} RealDataRx1;


typedef struct RealL2DspToIpuHeader {
	UINT8 Byte[18];
	} RealL2DspToIpuHeader;

typedef struct RealL2IpuToDspHeader 
{
	UINT8 Byte[18];
} RealL2IpuToDspHeader;



typedef struct RealTrafficTx1 {
	UINT8					nType;
	UINT8					L2ValidFlag;
	UINT16					nReserved;
	RealL2DspToIpuHeader	Data1Header;
	UINT8					nData1[36];
	RealL2DspToIpuHeader	Data2Header;
	UINT8					nData2[36];
	RealL2DspToIpuHeader	Data3Header;
	UINT8					nData3[36];
	RealL2DspToIpuHeader	Data4Header;
	UINT8					nData4[36];
	//UINT8 Byte[220];
} RealTrafficTx1;

typedef struct RealControlTx1 
{
	UINT8					nType;
	UINT8					L2ValidFlag;
	UINT16					nReserved;
	RealL2DspToIpuHeader	Data1Header;
	UINT8					nData1[23];
	RealL2DspToIpuHeader	Data2Header;
	UINT8					nData2[23];
	RealL2DspToIpuHeader	Data3Header;
	UINT8					nData3[23];
	RealL2DspToIpuHeader	Data4Header;
	UINT8					nData4[23];
	RealL2DspToIpuHeader	Data5Header;
	UINT8					nData5[23];
	RealL2DspToIpuHeader	Data6Header;
	UINT8					nData6[23];
	UINT8					PAD[2];
	//UINT8 Byte[252];
} RealControlTx1;

typedef struct RealRachTx1 
{
	UINT8					nType;
	UINT8					L2ValidFlag;
	UINT16					nReserved;
	RealL2DspToIpuHeader	Data1Header;
	UINT8					nData1[6];
	RealL2DspToIpuHeader	Data2Header;
	UINT8					nData2[6];
	RealL2DspToIpuHeader	Data3Header;
	UINT8					nData3[6];
	RealL2DspToIpuHeader	Data4Header;
	UINT8					nData4[6];
	RealL2DspToIpuHeader	Data5Header;
	UINT8					nData5[6];
	RealL2DspToIpuHeader	Data6Header;
	UINT8					nData6[6];
	//UINT8 Byte[148];
} RealRachTx1;

typedef struct RealDemodTx1 
{
	UINT8					nType;
	UINT8					L2ValidFlag;
	UINT16					nReserved;
	RealL2DspToIpuHeader	Data1Header;
	UINT8					nData1[15];
	UINT8					PAD[7];
	//UINT8 Byte[172];
} RealDemodTx1;

typedef struct RealDataTx1 
{
	UINT8					nType;
	UINT8					L2ValidFlag;
	UINT16					nReserved;
	RealL2IpuToDspHeader	Data1Header;
	UINT8					nData1[33];
	RealL2IpuToDspHeader	Data2Header;
	UINT8					nData2[33];
	RealL2IpuToDspHeader	Data3Header;
	UINT8					nData3[33];
	RealL2IpuToDspHeader	Data4Header;
	UINT8					nData4[33];
	UINT8					PAD[4];
	//UINT8 Byte[212];
} RealDataTx1;

/*
typedef union {
	UINT32 Ddc1  : 1;
	UINT32 Ddc2  : 1;
	UINT32 Ddc3  : 1;
	UINT32 Ddc4  : 1;
	UINT32 Ddc5  : 1;
	UINT32 Ddc6  : 1;
	UINT32 Ddc7  : 1;
	UINT32 Ddc8  : 1;
	UINT32 Ddc9  : 1;
	UINT32 Ddc10 : 1;
	UINT32 Ddc11 : 1;
	UINT32 Ddc12 : 1;
	UINT32 Ddc13 : 1;
	UINT32 Ddc14 : 1;
	UINT32 Ddc15 : 1;
	UINT32 Ddc16 : 1;
	UINT32 Ddc17 : 1;
	UINT32 Ddc18 : 1;
	UINT32 Ddc19 : 1;
	UINT32 Ddc20 : 1;
	UINT32 Ddc21 : 1;
	UINT32 Ddc22 : 1;
	UINT32 Ddc23 : 1;
	UINT32 Ddc24 : 1;
	UINT32 Ddc25 : 1;
	UINT32 Ddc26 : 1;
	UINT32 Ddc27 : 1;
	UINT32 Ddc28 : 1;

	UINT32 DdcFlags;
} DataDdcFlag;
*/

typedef enum {
	DDC1  = 0x00000001,
	DDC2  = 0x00000002,
	DDC3  = 0x00000004,
	DDC4  = 0x00000008,
	DDC5  = 0x00000010,
	DDC6  = 0x00000020,
	DDC7  = 0x00000040,
	DDC8  = 0x00000080,
	DDC9  = 0x00000100,
	DDC10 = 0x00000200,
	DDC11 = 0x00000400,
	DDC12 = 0x00000800,
	DDC13 = 0x00001000,
	DDC14 = 0x00002000,
	DDC15 = 0x00004000,
	DDC16 = 0x00008000,
	DDC17 = 0x00010000,
	DDC18 = 0x00020000,
	DDC19 = 0x00040000,
	DDC20 = 0x00080000,
	DDC21 = 0x00100000,
	DDC22 = 0x00200000,
	DDC23 = 0x00400000,
	DDC24 = 0x00800000,
	DDC25 = 0x01000000,
	DDC26 = 0x02000000,
	DDC27 = 0x04000000,
	DDC28 = 0x08000000
} DataDDCFlag;

typedef struct {
	PacketHeader Header;
	UINT32		DDCFlag;
	COMPLEX16	DDC[16][2];  // modified for TRS, it was DDC[28][2]  ***#####
//TODO actually 64 DDC are using in TRS, FPGA will send the data as a group of 16 DDC
} DDC_RxData;

/*********************************/

/*typedef union {
	UINT32 DUC1  : 1;
	UINT32 DUC2  : 1;
	UINT32 DUC3  : 1;
	UINT32 DUC4  : 1;

	UINT32 DucValidFlags;
} DataDucValidFlag;
*/

typedef enum {
	DUC1 = 0x00000001,
	DUC2 = 0x00000002,
	DUC3 = 0x00000004,
	DUC4 = 0x00000008
} DataDUCFlag;

typedef struct {
	UINT8	Data[20];
} DspToFpgaBurst;

typedef struct {
	DataDUCFlag			ValidDUCFlag;
	DspToFpgaBurst		DUCBurst;
} DataTxDUC;

typedef struct {
	PacketHeader Header;
	DataTxDUC    oData;
	UINT32		 DummyData;		// added in Tx packet so that no of bytes transmitted is divisible by 8
} DUC_TxData;
/*************************************/

typedef enum {
	TRAFFIC_DATA = 0,
	CONTROL_DATA,
	RACH_SCH,
	IQ_SAMPLES
} L2PacketType;

/*
typedef union {
	UINT8	Channel1 : 1;
	UINT8	Channel2 : 1;
	UINT8	Channel3 : 1;
	UINT8	Channel4 : 1;

	UINT8	ValidFlags;
} L2TrafficValidFlag;
*/

/*
typedef union {
	UINT16	nArfcn 		: 13;
	UINT8	nBand  		: 3;
	UINT8	nTs	   		: 4;  
	UINT8	nDirection 	: 1;
	UINT8	nTsc		: 3;
	UINT32	nFrameNum	: 24;
	UINT8	nChannelType: 5;
	UINT8	nSubSlotNum : 3;
	UINT16	nSnrAtSte; 
	UINT16	nRxLevelAtSte;
	UINT8	nToaAtSte;
	UINT8	nCipherMode	: 1;
	UINT8	nFhEnabled	: 1;
	UINT16	nArfcnFh	: 14;
	UINT16	nErrorCode;
	UINT16	nReserved;
	UINT8	nHeader[18];
} L2DspToIpuHeader;
*/

typedef struct L2DspToIpuHeader
{
	UINT16	nARFCN;
	UINT8	nBAND;
	UINT8	bScanning;
	UINT8	nTS;  
	UINT8	nDirection;
	UINT8	nTSC;
	UINT32	nFrameNum;
	UINT8	nChannelType;
	UINT8	nSubSlotNum;
	UINT16	nSNRinQ8; 
	UINT16	nRxLevel;
	UINT8	nTOA;
	UINT8	nCipherMode;
	UINT8	nFHEnabled;
	UINT16	nARFCN_FH;
	UINT16	nReceiverID;
	UINT16	nBeaconRef;
} L2DspToIpuHeader;

typedef enum {
	TRAFFIC_CH_1 = 0x01,
	TRAFFIC_CH_2 = 0x02,
	TRAFFIC_CH_3 = 0x04,
	TRAFFIC_CH_4 = 0x08
} DataTrafficChFlag;

typedef struct{

	L2DspToIpuHeader	oHeader;
	INT8					*pData;
	
}L2DspToIpuPayload;

typedef struct {

	L2PacketType		eType;
	UINT8				L2ValidFlag;
	UINT16				nReserved;

}L2DspToIpuPayloadInfo;


typedef struct {
	L2DspToIpuPayloadInfo	oInfo;
	L2DspToIpuPayload		oL2DspToIpuPayload[4];
//	UINT8					PAD[4];
} TrafficTx1;

/*
typedef union {
	UINT8	Channel1 : 1;
	UINT8	Channel2 : 1;
	UINT8	Channel3 : 1;
	UINT8	Channel4 : 1;
	UINT8	Channel5 : 1;
	UINT8	Channel6 : 1;

	UINT8	ValidFlags;
} L2ControlValidFlag;
*/

typedef enum {
	CONTROL_CH_1 = 0x01,
	CONTROL_CH_2 = 0x02,
	CONTROL_CH_3 = 0x04,
	CONTROL_CH_4 = 0x08,
	CONTROL_CH_5 = 0x10,
	CONTROL_CH_6 = 0x20
} DataControlChFlag;

typedef struct {
	L2DspToIpuPayloadInfo	oInfo;
	L2DspToIpuPayload	oL2DspToIpuPayload[6];
//	UINT8					PAD[2];
} ControlTx1;

/*typedef union {
	UINT8	Channel1 : 1;
	UINT8	Channel2 : 1;
	UINT8	Channel3 : 1;
	UINT8	Channel4 : 1;
	UINT8	Channel5 : 1;
	UINT8	Channel6 : 1;

	UINT8	ValidFlags;
} L2RachValidFlag;
*/
typedef enum {
	RACH_CH_1 = 0x01,
	RACH_CH_2 = 0x02,
	RACH_CH_3 = 0x04,
	RACH_CH_4 = 0x08,
	RACH_CH_5 = 0x10,
	RACH_CH_6 = 0x20
} DataRachChFlag;

typedef struct {
	L2DspToIpuPayloadInfo	oInfo;
	L2DspToIpuPayload	oL2DspToIpuPayload[6];
} RachTx1;

/*typedef union {
	UINT8	Data1 : 1;

	UINT8	ValidFlags;
} L2DemodValidFlag;
*/

typedef enum {
	DEMOD_DATA = 0x01
} DataDemodDataFlag;

typedef struct {
	L2DspToIpuPayloadInfo	oInfo;
	L2DspToIpuPayload	oL2DspToIpuPayload[1];
//	UINT8					PAD[4];
} DemodTx1;

/***********************************************/

typedef struct L2IpuToDspHeader
{
	UINT16	nARFCN;
	UINT8	nBAND;
	UINT8	nTS;  
	UINT8	nDirection;
	UINT8	nTSC;
	UINT32	nFrameNum;
	UINT8	nChannelType;
	UINT8	nSubSlotNum;
	UINT16	nTxLevelinQ8;
	UINT16	nTA;
	UINT8	nReserved[7];
} L2IpuToDspHeader;

/*typedef union {
	UINT8	Channel1 : 1;
	UINT8	Channel2 : 1;
	UINT8	Channel3 : 1;
	UINT8	Channel4 : 1;

	UINT8	ValidFlags;
} L2DataValidFlag;
*/

typedef struct {
	UINT8				nType;
	UINT8				L2ValidFlag;
	UINT16				nReserved;
	L2IpuToDspHeader	Data1Header;
	UINT8				nData1[33];
	L2IpuToDspHeader	Data2Header;
	UINT8				nData2[33];
	L2IpuToDspHeader	Data3Header;
	UINT8				nData3[33];
	L2IpuToDspHeader	Data4Header;
	UINT8				nData4[33];
} DataTx1;

typedef struct
{
	PacketHeader Header;
	DataTx1      L2Data;
}L2Pak;
typedef enum
{
	BCCH_184bits,
	CCCH_184bits,
	SDCCH_4_184bits,
	SACCH_4_184bits,
	SDCCH_8_184bits,
	SACCH_8_184bits,
	SACCH_F_184bits,
	FACCH_F_184bits,			//7
	RACH_8bits,
	SCH_25bits,
	TCH_EFS_244bits,
	TCH_FS_260bits,
	TCH_AFS4_75_94bits,			//12
	TCH_AFS5_15_103bits,
	TCH_AFS5_9_118bits,			//14
	TCH_AFS6_7_134bits,
	TCH_AFS7_4_148bits,
	TCH_AFS7_95_159bits,		//17
	TCH_AFS10_2_204bits,
	TCH_AFS12_2_244bits,		//19
	TCH_AFS_RATSCCH_35bits,
	INVALID_CHANNELTYPE

}CHANNEL_TYPE_IPU;

typedef enum
{
	NO_ERROR					=		0x0000,
	DEMOD_1_BURST_TSC_NOT_FOUND	=		0x0001,
	DEMOD_1_UNRECOVERABLE_ERROR	=		0x0002,
	DEMOD_2_BURST_TSC_NOT_FOUND	=		0x0004,
	DEMOD_2_UNRECOVERABLE_ERROR	=		0x0008,
	DEMOD_3_BURST_TSC_NOT_FOUND	=		0x0010,
	DEMOD_3_UNRECOVERABLE_ERROR	=		0x0020,
	DEMOD_4_BURST_TSC_NOT_FOUND	=		0x0040,
	DEMOD_4_UNRECOVERABLE_ERROR	=		0x0080,
	COULD_NOT_DECODE			=		0x0100,
	RX_TUNE_FAILED				=		0x0200

}L2PKT_ERROR_CODE;





typedef struct Clock
{
	Mutex	oLock;
	INT32	nBaseFN;
	SysTime	oBaseTime;
}Clock;

void Clock_Init( Clock *pThis );

// Set the clock to a value
void Clock_Set (Clock *pThis, GSMTime Time);

// Read the clock
INT32 Clock_FN( Clock *pThis );

// Read the Clock
GSMTime Clock_Get( Clock *pThis );

/** Block until the clock passes a given time. */
void Clock_Wait( GSMTime Time );




typedef struct GSMConfig
{

	// one time update
	BOOL			bConfigured;
	BOOL			bSynchronized;
	BTS_CLOCK_REF	eClockSource;

	UINT16			nNCC;		///< network color code
	UINT16	 		nBCC;		//< basestation color code
	FreqInfo		oOperatingFreq;
	UINT16			nBSIC;
	UINT16			nDDCNum;
	UINT8			nTSC;		// broadcast channel TSC
	// update with every sync
	UINT32			nLastSyncPktNum;
	UINT64			nLastSyncJobCompPktNum;
	UINT32			nLastSyncFN;
	SysTime			oLastSyncTime;
	Clock			oClock;
	// update with every FN
	UINT32			nCurrentFN;
	UINT8           nNUMDecodeFailCnt ;
	UINT32          nFailStartFrame;

}GSMConfig; 

void GSMConfig_Init( GSMConfig *pThis );

void GSMConfig_Start( GSMConfig *pThis,
BTS_CLOCK_REF eClockSource,
Clock oClock,
UINT16 nNCC,
UINT16 nBCC,
FreqInfo   oOperatingFreq);

void GSMConfig_Stop (GSMConfig *pThis);

UINT32 GSMConfig_FN( GSMConfig *pThis );

FreqInfo GSMConfig_FreqInfo(GSMConfig *pThis);

INT32	 GSMConfig_Elapsed(GSMConfig *pThis );




/* Extra samples to look for SCH (20 is max) after course FCCH detection*/



//FCCH to be detected in 100 bursts. However, considering failure of SCH detection, 5 attempts can be made to reconfirm the FCCH false detection...


typedef enum
{
	FCCH_SYNC,
	SCH_SYNC,
	SYNCHRONIZED,
	FAILED

}BURST_SYNC_STATE;


typedef enum
{
	DECODING_SUCCESS,
	DECODING_PROGRESS,
	DECODING_FAILED,
	DEMOD_RECORD

}DECODING_STATE;

typedef struct RATSCCH
{
	UINT32 nFN[2];					// GSM Frame number at which RATSCCH received in DL & ACK received in UL 
	UINT8 ACS_Ctrl;					// ACS Ctrl Word
	UINT8 ACS[4];					// Active Codec Set for four modes
	UINT8 ICM;						// Initial Codec Mode	
	UINT8 nNumCodecs;				// Number of Codecs in ACS
	UINT8 RIF;						// Req or Indication flag
	UINT8 CMI_flag;					// Command Mode Indication flag
	UINT8 nARFCN;
	UINT8 nTN;
	BOOL bRatscch_Received;			// If RATSCCH received wait for ack
	BOOL bIsACK_Received;			// If ACK received or not?
	BOOL bSendCmd;

}RATSCCH;

typedef struct AMR_Config
{
	BOOL	bIsACS_Set;
	BOOL	bIsAMR;
	UINT8 	ACS[4];
	UINT8	ICM;
	UINT8   nPrevChanType;
}AMR_Config;

typedef struct StoreDemodBits
{
	UINT32 		nFN;
	INT8		nSoftOutputs[15];

}StoreDemodBits;

typedef struct LFSR_Reg{
	UINT32 R1;
	UINT32 R2;
	UINT32 R3;
}LFSR_REGS;

typedef struct A5_1Decipher
{
	UINT8  nKC[8];
	LFSR_REGS oLFSR_REGS;
}A5_1Decipher;
typedef struct L1Receiver
{
	// input
	SCRATCH					*pScratchM1;
	SCRATCH					*pScratchM2;
	L1FEC					**pMFNTable;
	Burst					*pBurstData;
	INT16					*pOutputBits;

	UINT8					nTSC_DedicatedChannel;
	UINT8					*pSDCCHTSC;
	BOOL					*pbIsSDCCHOFF;
	BOOL					*pbIsSDCCHCiphered;
	FreqInfo				oOperatingFreq;
	DIRECTION				eDir;
	CHANNEL_COMB			eChannelComb;
	// input and output

	GSMTime					oTime;
	GSMTime					oLastSyncFN;
	INT16					nNextBurstOffset;
	INT16					nNextBurstSize;
	StoreDemodBits          oStoreDemodBits[4];
	A5_1Decipher			oA5_1Decipher;
	AMR_Config				oAMR_Config;
	AGC						oAGC;
	RATSCCH					oRATSCCH;
	struct L1Receiver		*pPartner;
	struct DemodData		*pDemodData;
	volatile GSMConfig				*pBTS;

	UINT32					nGoodBurstCounter;
	UINT32					nCount_SDCCH;
	INT32					nFreqOffset;

	INT32					nSNR;
	INT16					nRxLevel_q8;
	INT16					nBurstStartIndex;
	GSM_DEMOD_STATUS		eGSMDemodStatus;
	DECODING_STATE			eDecodingState;
	L2PKT_ERROR_CODE		eErrorCode;
	BURST_SYNC_STATE		eSyncState;
	BOOL					bDecodedStatus;
    BOOL              		bIsFACCH;
	BOOL					bSynchronized;
	BOOL					bScanning;
	BOOL					bCiphered;
	BOOL					bFirstEntry;
	BOOL					bSyncAchieved;
	BOOL					bIsSDCCHOFF;
	BOOL					bIsSDCCHCiphered;
	BOOL					bFirstFreqMeasurement;
	BOOL					bCopySamples;
	BOOL					bBeaconChannel;
	BOOL					bCipheredFrameDecoded;
	UINT32					CipheredFN;
	UINT8					nChannelType;
	UINT16					nNumBurstSearchedForFCCH;
	UINT8					nTSC_BroadcastChannel;
	UINT8					nTSC;
	UINT16					nDecodedBitsLen;
	UINT16					nFCCHSearchCount;
	UINT8					nDTXField[3];
	SysTime					oOldTime;
	INT16					nHwGain;
	UINT32 					nNumSpeechPak;
	UINT32					nNumDemodFail;
	UINT32					nNumDecodeFail;
	UINT32					nNumDemodSucess;
	UINT32					nNumDecodeSucess;
	UINT32					nLastFN;
	UINT32					nSpeechPak;
	UINT32					nSidPak;
	UINT32					nRxNoData;
	UINT16					nCount_SACCH;
	UINT8					nBSCC;
	UINT8					nDemod_ReceiverId;
	UINT8					nPhase;				// to be removed
	struct 					GSM_ctrl_logchanrx_class *pRxObj;			//	*pRxObj
	UINT32					nAvgPow;
	INT16					ndBFS;					
	SUBCHANNEL				eSubChannel;
	UINT8					nSubSlotFlag;
	UINT8					nRxUniqueID;
	GSM_BURST_TYPE  Test_eBurstType;

}L1Receiver;
      

typedef enum
{
	ACK_OK =1,
	ACK_ERR,
	ACK_UNKNOWN,
	CMI_PHASE_REQ,
	AMR_CONFIG_REQ = 7
}Ratscch_Msg; 


typedef enum
{
	 RX_SPEECH_GOOD = 0,
     RX_SPEECH_DEGRADED,
     RX_ONSET,
     RX_SPEECH_BAD,
     RX_SID_FIRST,
     RX_SID_UPDATE,
     RX_SID_BAD,
     RX_NO_DATA
}RXFrameType;




void L1Receiver_CaptureBurst(L1Receiver *pThis, Burst *pBurstIn, INT16 **pOutputBits, BOOL *pBurstProcessed,GSM_LOGCHAN_TYPE *pLogChanType );

void L1Receiver_Reset(L1Receiver *pThis );

void L1Receiver_Init(L1Receiver *pThis, 
	SCRATCH					*pScratchM1,
	SCRATCH					*pScratchM2,
	L1FEC					**pMFNTable,
	UINT8					nTSC_DedicatedChannel,
	UINT8					*pSDCCHTSC,
	BOOL					*pbIsSDCCHOFF,
	BOOL					*pbIsSDCCHCiphered,
	BOOL					bCiphered,
	BOOL					bScanning,
	FreqInfo				oOperatingFreq,
	DIRECTION				eDir,
	CHANNEL_COMB			eChannelComb,
	// input and output
	BURST_SYNC_STATE		eSyncState,
	GSMConfig					*pBTS
	);

void L1Receiver_SetTN(L1Receiver *pThis, UINT8 nTN);
void L1Receiver_SetFN(L1Receiver *pThis, UINT32 nFN);
void L1Receiver_SetBTSReference(L1Receiver *pThis, volatile GSMConfig *pBTS);
volatile GSMConfig *L1Receiver_GetBTSReference(L1Receiver *pThis);
FreqInfo	L1Receiver_RunSFH(L1Receiver *pThis, UINT32 nFN, HoppingInfo *pHoppingInfo);
void L1Receiver_Dump(L1Receiver *pThis);
void L1Receiver_UpdateAMRConfig(L1Receiver *pThis, UINT8 ACS_Ctrl,UINT8 ICM, UINT8 NumCodecs);
void L1Receiver_DiscardRATSCCH(L1Receiver *pThis);



	




typedef struct BurstInfo
{
	BOOL		bUseReferenceBurstInfo;
	GSMTime 	oTime;
	FreqInfo 	oFreq;
	UINT8		nDDCNum;
	DIRECTION 	eDir;
	INT32		nNextBurstOffset;
	UINT16		nNextBurstSize;
	UINT64		nSeqNum;
	UINT8		nRxTuneCmd[20];
	BOOL		bSendCmd;
	UINT8		nRxSwitchCmd[36];
	BOOL		bSendSwitchCmd;
	BOOL		bCopySamples;
	volatile GSMConfig	*gBTS;
	DSP_CORE	nCoreNum;
	UINT8		nRXMgrId;
	SysTime     oCreation;
	BOOL		bReceiverStopped;
	GSM_BURST_TYPE test_eBurstType;
}BurstInfo;



typedef struct BurstInfoReq
{
	void		*pRxManager; // RxManager
	DIRECTION	eDir;
	UINT8		nTN;
}BurstInfoReq;




typedef struct RxTimeSlotInfo
{
	// Inputs
	BOOL				bIsCiphered;
//	BOOL				bIsHopped;
	BOOL				bTuning;

	BOOL				bIsSDCCHOFF[8];
	BOOL				bIsSDCCHCiphered[8];

	UINT8				SDCCHTSC[8];
	UINT8				nTSC;
	UINT16				nRxUniqueID;


	CHANNEL_COMB		eChannelComb;
//	HoppingInfo			oHoppingInfo;
	Packet				oLastReceivedCmd;

	L1FEC				*pL1FECTable[104];
	L1Config			oL1Config;
	L1Receiver			oL1Receiver;
	BOOL				bReceiverStopped;
	UINT32             count_fr_num ; // for test only
}RxTimeSlotInfo;



typedef struct RxFreqInfo
{
	UINT8			nID;
	FreqInfo		oCurrent;
	FreqInfo		oBeacon;
	FreqInfo		oPrevFreq;
	DCSPART			ePrevDCSBand;
	TN_ENABLED		eTN;
	UINT8			nBandEnabledForScanning;
	BOOL			bCommandToSwitchARFCNReceived;
	BOOL			bIsHopped;
	HoppingInfo		oHoppingInfo;
	RxTimeSlotInfo	oTN[8];
}RxFreqInfo;






typedef struct {
	SysTime oCurrentTime;
	SysTime oCreationTime;
	BOOL	bPktCreated;
	//Packet2	*pPkt;
	L2PacketInfo  *pL2PacketInfo;
} L2PktDetails;




//#include <csl_srio.h>
/**
 *   @file  csl_srio.h
 *
 *   @brief
 *      This is the header file for the SRIO CSL Functional Layer.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** @defgroup CSL_SRIO_API SRIO
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *  RapidIOTM is a non-proprietary high-bandwidth system level interconnect. It is 
 *  intended to offer giga-byte per second performance levels for chip-to-chip and 
 *  board-to-board communication. Its layered architecture, allows a highly 
 *  scalable interconnect capable of future enhancements.
 *
 * @subsection References
 *   -# Rapid IO Module Specification
 *
 */
 


/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a)  RIO_TLM_SP_BRR_0_CTL,RIO_TLM_SP_BRR_0_PATTERN_MATCH to
 *          RIO_TLM_SP_BRR_3_CTL,RIO_TLM_SP_BRR_3_PATTERN_MATCH 
 *          was made into an array of structures.
 *      b)  Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for block_enable_status
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_BLK_EN;
    volatile Uint32 RIO_BLK_EN_STAT;
} CSL_SrioBlock_enable_statusRegs;

/*************************************************************************** Register Overlay Structure for pf_cntl
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_PF_16B_CNTL;
    volatile Uint32 RIO_PF_8B_CNTL;
} CSL_SrioPf_cntlRegs;

/*************************************************************************** Register Overlay Structure for doorbell_icsr_iccr
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_DOORBELL_ICSR;
    volatile Uint8 RSVD0[4];
    volatile Uint32 RIO_DOORBELL_ICCR;
    volatile Uint8 RSVD3[4];
} CSL_SrioDoorbell_icsr_iccrRegs;

/*************************************************************************** Register Overlay Structure for lsu_icsr_iccr
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_LSU_ICSR;
    volatile Uint8 RSVD0[4];
    volatile Uint32 RIO_LSU_ICCR;
    volatile Uint8 RSVD5[4];
} CSL_SrioLsu_icsr_iccrRegs;

/*************************************************************************** Register Overlay Structure for doorbell_icrr
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_DOORBELL_ICRR1;
    volatile Uint32 RIO_DOORBELL_ICRR2;
    volatile Uint8 RSVD9[4];
} CSL_SrioDoorbell_icrrRegs;

/*************************************************************************** Register Overlay Structure for rxu_map
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_RXU_MAP_L;
    volatile Uint32 RIO_RXU_MAP_H;
    volatile Uint32 RIO_RXU_MAP_QID;
} CSL_SrioRxu_mapRegs;

/*************************************************************************** Register Overlay Structure for rxu_type9_map
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_RXU_TYPE9_MAP0;
    volatile Uint32 RIO_RXU_TYPE9_MAP1;
    volatile Uint32 RIO_RXU_TYPE9_MAP2;
} CSL_SrioRxu_type9_mapRegs;

/*************************************************************************** Register Overlay Structure for amu_window
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_AMU_WINDOW_REG0;
    volatile Uint32 RIO_AMU_WINDOW_REG1;
    volatile Uint32 RIO_AMU_WINDOW_REG2;
} CSL_SrioAmu_windowRegs;

/*************************************************************************** Register Overlay Structure for lsu_cmd
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_LSU_REG0;
    volatile Uint32 RIO_LSU_REG1;
    volatile Uint32 RIO_LSU_REG2;
    volatile Uint32 RIO_LSU_REG3;
    volatile Uint32 RIO_LSU_REG4;
    volatile Uint32 RIO_LSU_REG5;
    volatile Uint32 RIO_LSU_REG6;
} CSL_SrioLsu_cmdRegs;

/*************************************************************************** Register Overlay Structure for tx_channel_global_config
\**************************************************************************/
typedef struct  {
    volatile Uint32 TX_CHANNEL_GLOBAL_CONFIG_REG_A;
    volatile Uint32 TX_CHANNEL_GLOBAL_CONFIG_REG_B;
    volatile Uint8 RSVD19[24];
} CSL_SrioTx_channel_global_configRegs;

/*************************************************************************** Register Overlay Structure for rx_channel_global_config
\**************************************************************************/
typedef struct  {
    volatile Uint32 RX_CHANNEL_GLOBAL_CONFIG_REG;
    volatile Uint8 RSVD21[28];
} CSL_SrioRx_channel_global_configRegs;

/*************************************************************************** Register Overlay Structure for rx_flow_config
\**************************************************************************/
typedef struct  {
    volatile Uint32 RX_FLOW_CONFIG_REG_A;
    volatile Uint32 RX_FLOW_CONFIG_REG_B;
    volatile Uint32 RX_FLOW_CONFIG_REG_C;
    volatile Uint32 RX_FLOW_CONFIG_REG_D;
    volatile Uint32 RX_FLOW_CONFIG_REG_E;
    volatile Uint32 RX_FLOW_CONFIG_REG_F;
    volatile Uint32 RX_FLOW_CONFIG_REG_G;
    volatile Uint32 RX_FLOW_CONFIG_REG_H;
} CSL_SrioRx_flow_configRegs;

/*************************************************************************** Register Overlay Structure for rio_sp
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_SP_LM_REQ;
    volatile Uint32 RIO_SP_LM_RESP;
    volatile Uint32 RIO_SP_ACKID_STAT;
    volatile Uint8 RSVD0[8];
    volatile Uint32 RIO_SP_CTL2;
    volatile Uint32 RIO_SP_ERR_STAT;
    volatile Uint32 RIO_SP_CTL;
} CSL_SrioRio_spRegs;

/*************************************************************************** Register Overlay Structure for rio_sp_err
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_SP_ERR_DET;
    volatile Uint32 RIO_SP_RATE_EN;
    volatile Uint32 RIO_SP_ERR_ATTR_CAPT;
    volatile Uint32 RIO_SP_ERR_CAPT_0;
    volatile Uint32 RIO_SP_ERR_CAPT_1;
    volatile Uint32 RIO_SP_ERR_CAPT_2;
    volatile Uint32 RIO_SP_ERR_CAPT_3;
    volatile Uint8 RSVD0[12];
    volatile Uint32 RIO_SP_ERR_RATE;
    volatile Uint32 RIO_SP_ERR_THRESH;
    volatile Uint8 RSVD36[16];
} CSL_SrioRio_sp_errRegs;

/*************************************************************************** Register Overlay Structure for rio_lane
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_LANE_STAT0;
    volatile Uint32 RIO_LANE_STAT1;
    volatile Uint8 RSVD39[24];
} CSL_SrioRio_laneRegs;

/*************************************************************************** Register Overlay Structure for rio_plm
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_PLM_SP_IMP_SPEC_CTL;
    volatile Uint32 RIO_PLM_SP_PWDN_CTL;
    volatile Uint8 RSVD0[8];
    volatile Uint32 RIO_PLM_SP_STATUS;
    volatile Uint32 RIO_PLM_SP_INT_ENABLE;
    volatile Uint32 RIO_PLM_SP_PW_ENABLE;
    volatile Uint32 RIO_PLM_SP_EVENT_GEN;
    volatile Uint32 RIO_PLM_SP_ALL_INT_EN;
    volatile Uint32 RIO_PLM_SP_ALL_PW_EN;
    volatile Uint8 RSVD1[8];
    volatile Uint32 RIO_PLM_SP_PATH_CTL;
    volatile Uint32 RIO_PLM_SP_DISCOVERY_TIMER;
    volatile Uint32 RIO_PLM_SP_SILENCE_TIMER;
    volatile Uint32 RIO_PLM_SP_VMIN_EXP;
    volatile Uint32 RIO_PLM_SP_POL_CTL;
    volatile Uint8 RSVD2[4];
    volatile Uint32 RIO_PLM_SP_DENIAL_CTL;
    volatile Uint8 RSVD3[4];
    volatile Uint32 RIO_PLM_SP_RCVD_MECS;
    volatile Uint8 RSVD4[4];
    volatile Uint32 RIO_PLM_SP_MECS_FWD;
    volatile Uint8 RSVD5[4];
    volatile Uint32 RIO_PLM_SP_LONG_CS_TX1;
    volatile Uint32 RIO_PLM_SP_LONG_CS_TX2;
    volatile Uint8 RSVD42[24];
} CSL_SrioRio_plmRegs;


typedef struct  {
    volatile Uint32 RIO_TLM_SP_BRR_CTL;
    volatile Uint32 RIO_TLM_SP_BRR_PATTERN_MATCH;
    volatile Uint8 RSVD1[8];
}CSL_SrioRio_BRRConfig;


/*************************************************************************** Register Overlay Structure for rio_tlm
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_TLM_SP_CONTROL;
    volatile Uint8 RSVD0[12];
    volatile Uint32 RIO_TLM_SP_STATUS;
    volatile Uint32 RIO_TLM_SP_INT_ENABLE;
    volatile Uint32 RIO_TLM_SP_PW_ENABLE;
    volatile Uint32 RIO_TLM_SP_EVENT_GEN;
    CSL_SrioRio_BRRConfig   brr[4];
    volatile Uint8          RSVD45[32];
} CSL_SrioRio_tlmRegs;

/*************************************************************************** Register Overlay Structure for rio_pbm
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_PBM_SP_CONTROL;
    volatile Uint8 RSVD0[12];
    volatile Uint32 RIO_PBM_SP_STATUS;
    volatile Uint32 RIO_PBM_SP_INT_ENABLE;
    volatile Uint32 RIO_PBM_SP_PW_ENABLE;
    volatile Uint32 RIO_PBM_SP_EVENT_GEN;
    volatile Uint32 RIO_PBM_SP_IG_RESOURCES;
    volatile Uint32 RIO_PBM_SP_EG_RESOURCES;
    volatile Uint8 RSVD1[8];
    volatile Uint32 RIO_PBM_SP_IG_WATERMARK0;
    volatile Uint32 RIO_PBM_SP_IG_WATERMARK1;
    volatile Uint32 RIO_PBM_SP_IG_WATERMARK2;
    volatile Uint32 RIO_PBM_SP_IG_WATERMARK3;
    volatile Uint8 RSVD48[64];
} CSL_SrioRio_pbmRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 RIO_PID;
    volatile Uint32 RIO_PCR;
    volatile Uint8 RSVD0[12];
    volatile Uint32 RIO_PER_SET_CNTL;
    volatile Uint32 RIO_PER_SET_CNTL1;
    volatile Uint8 RSVD1[8];
    volatile Uint32 RIO_GBL_EN;
    volatile Uint32 RIO_GBL_EN_STAT;
    CSL_SrioBlock_enable_statusRegs BLOCK_ENABLE_STATUS[10];
    volatile Uint8 RSVD2[68];
    volatile Uint32 RIO_MULTIID_REG[8];
    CSL_SrioPf_cntlRegs PF_CNTL[8];
    volatile Uint8 RSVD4[96];
    CSL_SrioDoorbell_icsr_iccrRegs DOORBELL_ICSR_ICCR[4];
    CSL_SrioLsu_icsr_iccrRegs LSU_ICSR_ICCR[2];
    volatile Uint32 RIO_ERR_RST_EVNT_ICSR;
    volatile Uint8 RSVD6[4];
    volatile Uint32 RIO_ERR_RST_EVNT_ICCR;
    volatile Uint8 RSVD7[4];
    volatile Uint32 RIO_AMU_ICSR;
    volatile Uint8 RSVD8[4];
    volatile Uint32 RIO_AMU_ICCR;
    volatile Uint8 RSVD10[4];
    CSL_SrioDoorbell_icrrRegs DOORBELL_ICRR[4];
    volatile Uint32 RIO_LSU0_MODULE_ICRR[4];
    volatile Uint32 RIO_LSU1_MODULE_ICRR;
    volatile Uint8 RSVD11[12];
    volatile Uint32 RIO_ERR_RST_EVNT_ICRR;
    volatile Uint32 RIO_ERR_RST_EVNT_ICRR2;
    volatile Uint32 RIO_ERR_RST_EVNT_ICRR3;
    volatile Uint32 RIO_AMU_ICRR1;
    volatile Uint32 RIO_AMU_ICRR2;
    volatile Uint32 RIO_INTERRUPT_CTL;
    volatile Uint8 RSVD12[8];
    volatile Uint32 RIO_INTDST_DECODE[24];
    volatile Uint32 RIO_INTDST_RATE_CNT[16];
    volatile Uint32 RIO_INTDST_RATE_DIS;
    volatile Uint8 RSVD13[236];
    CSL_SrioRxu_mapRegs RXU_MAP[64];
    CSL_SrioRxu_type9_mapRegs RXU_TYPE9_MAP[64];
    volatile Uint32 RIO_AMU_SRCID_MAP[4];
    volatile Uint8 RSVD14[4];
    CSL_SrioAmu_windowRegs AMU_WINDOW[16];
    volatile Uint32 RIO_AMU_PRIORITY_MAP;
    volatile Uint32 RIO_AMU_CAPT0_MAP;
    volatile Uint32 RIO_AMU_CAPT1_MAP;
    volatile Uint32 RIO_AMU_WINDOW_PANE[128];
    volatile Uint32 RIO_AMU_FLOW_MASKS0;
    volatile Uint8 RSVD15[28];
    CSL_SrioLsu_cmdRegs LSU_CMD[8];
    volatile Uint32 RIO_LSU_SETUP_REG0;
    volatile Uint32 RIO_LSU_SETUP_REG1;
    volatile Uint32 LSU_STAT_REG[6];
    volatile Uint32 RIO_LSU_FLOW_MASKS[4];
    volatile Uint8 RSVD16[60];
    volatile Uint32 RIO_SUPERVISOR_ID;
    volatile Uint32 RIO_FLOW_CNTL[16];
    volatile Uint8 RSVD17[32];
    volatile Uint32 RIO_TX_CPPI_FLOW_MASKS[8];
    volatile Uint32 RIO_TX_QUEUE_SCH_INFO[4];
    volatile Uint32 RIO_GARBAGE_COLL_QID0;
    volatile Uint32 RIO_GARBAGE_COLL_QID1;
    volatile Uint32 RIO_GARBAGE_COLL_QID2;
    volatile Uint8 RSVD18[276];
    volatile Uint32 REVISION_REG;
    volatile Uint32 PERF_CONTROL_REG;
    volatile Uint32 EMULATION_CONTROL_REG;
    volatile Uint32 PRIORITY_CONTROL_REG;
    volatile Uint32 QM_BASE_ADDRESS_REG[4];
    volatile Uint8 RSVD20[992];
    CSL_SrioTx_channel_global_configRegs TX_CHANNEL_GLOBAL_CONFIG[16];
    volatile Uint8 RSVD22[512];
    CSL_SrioRx_channel_global_configRegs RX_CHANNEL_GLOBAL_CONFIG[16];
    volatile Uint8 RSVD23[512];
    volatile Uint32 TX_CHANNEL_SCHEDULER_CONFIG_REG[16];
    volatile Uint8 RSVD24[960];
    CSL_SrioRx_flow_configRegs RX_FLOW_CONFIG[20];
    volatile Uint8 RSVD25[36224];
    volatile Uint32 RIO_DEV_ID;
    volatile Uint32 RIO_DEV_INFO;
    volatile Uint32 RIO_ASBLY_ID;
    volatile Uint32 RIO_ASBLY_INFO;
    volatile Uint32 RIO_PE_FEAT;
    volatile Uint32 RIO_SW_PORT;
    volatile Uint32 RIO_SRC_OP;
    volatile Uint32 RIO_DEST_OP;
    volatile Uint8 RSVD26[28];
    volatile Uint32 RIO_DS_INFO;
    volatile Uint8 RSVD27[8];
    volatile Uint32 RIO_DS_LL_CTL;
    volatile Uint32 RIO_PE_LL_CTL;
    volatile Uint8 RSVD28[8];
    volatile Uint32 RIO_LCL_CFG_HBAR;
    volatile Uint32 RIO_LCL_CFG_BAR;
    volatile Uint32 RIO_BASE_ID;
    volatile Uint8 RSVD29[4];
    volatile Uint32 RIO_HOST_BASE_ID_LOCK;
    volatile Uint32 RIO_COMP_TAG;
    volatile Uint8 RSVD30[144];
    volatile Uint32 RIO_SP_MB_HEAD;
    volatile Uint8 RSVD31[28];
    volatile Uint32 RIO_SP_LT_CTL;
    volatile Uint32 RIO_SP_RT_CTL;
    volatile Uint8 RSVD32[20];
    volatile Uint32 RIO_SP_GEN_CTL;
    CSL_SrioRio_spRegs RIO_SP[4];
    volatile Uint8 RSVD33[3648];
    volatile Uint32 RIO_ERR_RPT_BH;
    volatile Uint8 RSVD34[4];
    volatile Uint32 RIO_ERR_DET;
    volatile Uint32 RIO_ERR_EN;
    volatile Uint32 RIO_H_ADDR_CAPT;
    volatile Uint32 RIO_ADDR_CAPT;
    volatile Uint32 RIO_ID_CAPT;
    volatile Uint32 RIO_CTRL_CAPT;
    volatile Uint8 RSVD35[8];
    volatile Uint32 RIO_PW_TGT_ID;
    volatile Uint8 RSVD37[20];
    CSL_SrioRio_sp_errRegs RIO_SP_ERR[4];
    volatile Uint8 RSVD38[7872];
    volatile Uint32 RIO_PER_LANE_BH;
    volatile Uint8 RSVD40[12];
    CSL_SrioRio_laneRegs RIO_LANE[4];
    volatile Uint8 RSVD41[53104];
    volatile Uint32 RIO_PLM_BH;
    volatile Uint8 RSVD43[124];
    CSL_SrioRio_plmRegs RIO_PLM[4];
    volatile Uint8 RSVD44[128];
    volatile Uint32 RIO_TLM_BH;
    volatile Uint8 RSVD46[124];
    CSL_SrioRio_tlmRegs RIO_TLM[4];
    volatile Uint8 RSVD47[128];
    volatile Uint32 RIO_PBM_BH;
    volatile Uint8 RSVD49[124];
    CSL_SrioRio_pbmRegs RIO_PBM[4];
    volatile Uint8 RSVD50[128];
    volatile Uint32 RIO_EM_BH;
    volatile Uint8 RSVD51[12];
    volatile Uint32 RIO_EM_INT_STAT;
    volatile Uint32 RIO_EM_INT_ENABLE;
    volatile Uint32 RIO_EM_INT_PORT_STAT;
    volatile Uint8 RSVD52[4];
    volatile Uint32 RIO_EM_PW_STAT;
    volatile Uint32 RIO_EM_PW_EN;
    volatile Uint32 RIO_EM_PW_PORT_STAT;
    volatile Uint8 RSVD53[4];
    volatile Uint32 RIO_EM_DEV_INT_EN;
    volatile Uint32 RIO_EM_DEV_PW_EN;
    volatile Uint8 RSVD54[4];
    volatile Uint32 RIO_EM_MECS_STAT;
    volatile Uint32 RIO_EM_MECS_INT_EN;
    volatile Uint32 RIO_EM_MECS_CAP_EN;
    volatile Uint32 RIO_EM_MECS_TRIG_EN;
    volatile Uint32 RIO_EM_MECS_REQ;
    volatile Uint32 RIO_EM_MECS_PORT_STAT;
    volatile Uint8 RSVD55[8];
    volatile Uint32 RIO_EM_MECS_EVENT_GEN;
    volatile Uint32 RIO_EM_RST_PORT_STAT;
    volatile Uint8 RSVD56[4];
    volatile Uint32 RIO_EM_RST_INT_EN;
    volatile Uint8 RSVD57[4];
    volatile Uint32 RIO_EM_RST_PW_EN;
    volatile Uint8 RSVD58[140];
    volatile Uint32 RIO_PW_BH;
    volatile Uint32 RIO_PW_CTL;
    volatile Uint32 RIO_PW_ROUTE;
    volatile Uint8 RSVD59[4];
    volatile Uint32 RIO_PW_RX_STAT;
    volatile Uint32 RIO_PW_RX_EVENT_GEN;
    volatile Uint8 RSVD60[8];
    volatile Uint32 RIO_PW_RX_CAPT[4];
    volatile Uint8 RSVD61[720];
    volatile Uint32 RIO_LLM_BH;
    volatile Uint8 RSVD62[32];
    volatile Uint32 RIO_WHITEBOARD;
    volatile Uint32 RIO_PORT_NUMBER;
    volatile Uint8 RSVD63[4];
    volatile Uint32 RIO_PRESCALAR_SRV_CLK;
    volatile Uint32 RIO_REG_RST_CTL;
    volatile Uint8 RSVD64[16];
    volatile Uint32 RIO_LOCAL_ERR_DET;
    volatile Uint32 RIO_LOCAL_ERR_EN;
    volatile Uint32 RIO_LOCAL_H_ADDR_CAPT;
    volatile Uint32 RIO_LOCAL_ADDR_CAPT;
    volatile Uint32 RIO_LOCAL_ID_CAPT;
    volatile Uint32 RIO_LOCAL_CTRL_CAPT;
    volatile Uint8 RSVD65[160];
    volatile Uint32 RIO_FABRIC_BH;
    volatile Uint8 RSVD66[12];
    volatile Uint32 RIO_FABRIC_CSR;
    volatile Uint8 RSVD67[44];
    volatile Uint32 RIO_SP_FABRIC_STATUS[4];
} CSL_SrioRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* rio_blk_en */



/* rio_blk_en_stat */



/* rio_pf_16b_cntl */




/* rio_pf_8b_cntl */





/* rio_doorbell_icsr */



/* rio_doorbell_iccr */



/* rio_lsu_icsr */



/* rio_lsu_iccr */



/* rio_doorbell_icrr1 */










/* rio_doorbell_icrr2 */










/* rio_rxu_map_l */







/* rio_rxu_map_h */







/* rio_rxu_map_qid */




/* rio_rxu_type9_map0 */





/* rio_rxu_type9_map1 */






/* rio_rxu_type9_map2 */




/* rio_amu_window_reg0 */






/* rio_amu_window_reg1 */



/* rio_amu_window_reg2 */



/* rio_lsu_reg0 */



/* rio_lsu_reg1 */



/* rio_lsu_reg2 */



/* rio_lsu_reg3 */




/* rio_lsu_reg4 */










/* rio_lsu_reg5 */






/* rio_lsu_reg6 */











/* tx_channel_global_config_reg_a */





/* tx_channel_global_config_reg_b */







/* rx_channel_global_config_reg */





/* rx_flow_config_reg_a */










/* rx_flow_config_reg_b */






/* rx_flow_config_reg_c */







/* rx_flow_config_reg_d */






/* rx_flow_config_reg_e */






/* rx_flow_config_reg_f */




/* rx_flow_config_reg_g */





/* rx_flow_config_reg_h */






/* rio_sp_lm_req */



/* rio_sp_lm_resp */





/* rio_sp_ackid_stat */






/* rio_sp_ctl2 */


















/* rio_sp_err_stat */






















/* rio_sp_ctl */



















/* rio_sp_err_det */















/* rio_sp_rate_en */















/* rio_sp_err_attr_capt */






/* rio_sp_err_capt_0 */



/* rio_sp_err_capt_1 */



/* rio_sp_err_capt_2 */



/* rio_sp_err_capt_3 */



/* rio_sp_err_rate */






/* rio_sp_err_thresh */




/* rio_lane_stat0 */
















/* rio_lane_stat1 */












/* rio_plm_sp_imp_spec_ctl */















/* rio_plm_sp_pwdn_ctl */



/* rio_plm_sp_status */














/* rio_plm_sp_int_enable */








/* rio_plm_sp_pw_enable */








/* rio_plm_sp_event_gen */









/* rio_plm_sp_all_int_en */



/* rio_plm_sp_all_pw_en */



/* rio_plm_sp_path_ctl */





/* rio_plm_sp_discovery_timer */



/* rio_plm_sp_silence_timer */



/* rio_plm_sp_vmin_exp */





/* rio_plm_sp_pol_ctl */










/* rio_plm_sp_denial_ctl */





/* rio_plm_sp_rcvd_mecs */



/* rio_plm_sp_mecs_fwd */




/* rio_plm_sp_long_cs_tx1 */








/* rio_plm_sp_long_cs_tx2 */




/* rio_tlm_sp_control */







/* rio_tlm_sp_status */




/* rio_tlm_sp_int_enable */




/* rio_tlm_sp_pw_enable */




/* rio_tlm_sp_event_gen */




/* rio_tlm_sp_brr_0_ctl */





/* rio_tlm_sp_brr_0_pattern_match */




/* rio_tlm_sp_brr_1_ctl */





/* rio_tlm_sp_brr_1_pattern_match */




/* rio_tlm_sp_brr_2_ctl */





/* rio_tlm_sp_brr_2_pattern_match */




/* rio_tlm_sp_brr_3_ctl */





/* rio_tlm_sp_brr_3_pattern_match */




/* rio_pbm_sp_control */




/* rio_pbm_sp_status */








/* rio_pbm_sp_int_enable */






/* rio_pbm_sp_pw_enable */






/* rio_pbm_sp_event_gen */






/* rio_pbm_sp_ig_resources */




/* rio_pbm_sp_eg_resources */




/* rio_pbm_sp_ig_watermark0 */




/* rio_pbm_sp_ig_watermark1 */




/* rio_pbm_sp_ig_watermark2 */




/* rio_pbm_sp_ig_watermark3 */




/* rio_pid */









/* rio_pcr */







/* rio_per_set_cntl */


















/* rio_per_set_cntl1 */







/* rio_gbl_en */



/* rio_gbl_en_stat */




/* rio_multiid_reg */




/* rio_err_rst_evnt_icsr */










/* rio_err_rst_evnt_iccr */










/* rio_amu_icsr */



/* rio_amu_iccr */



/* rio_lsu0_module_icrr */










/* rio_lsu1_module_icrr */










/* rio_err_rst_evnt_icrr */





/* rio_err_rst_evnt_icrr2 */






/* rio_err_rst_evnt_icrr3 */



/* rio_amu_icrr1 */










/* rio_amu_icrr2 */










/* rio_interrupt_ctl */



/* rio_intdst_decode */



/* rio_intdst_rate_cnt */



/* rio_intdst_rate_dis */



/* rio_amu_srcid_map */










/* rio_amu_priority_map */










/* rio_amu_capt0_map */



/* rio_amu_capt1_map */





/* rio_amu_window_pane */






/* rio_amu_flow_masks0 */




/* rio_lsu_setup_reg0 */












/* rio_lsu_setup_reg1 */




/* lsu_stat_reg */



/* rio_lsu_flow_masks */



/* rio_supervisor_id */




/* rio_flow_cntl */




/* rio_tx_cppi_flow_masks */



/* rio_tx_queue_sch_info */






/* rio_garbage_coll_qid0 */




/* rio_garbage_coll_qid1 */




/* rio_garbage_coll_qid2 */




/* revision_reg */









/* perf_control_reg */




/* emulation_control_reg */





/* priority_control_reg */




/* qm_base_address_reg */



/* tx_channel_scheduler_config_reg */



/* rio_dev_id */




/* rio_dev_info */



/* rio_asbly_id */




/* rio_asbly_info */




/* rio_pe_feat */
















/* rio_sw_port */




/* rio_src_op */
































/* rio_dest_op */
































/* rio_ds_info */




/* rio_ds_ll_ctl */





/* rio_pe_ll_ctl */



/* rio_lcl_cfg_hbar */




/* rio_lcl_cfg_bar */




/* rio_base_id */




/* rio_host_base_id_lock */



/* rio_comp_tag */



/* rio_sp_mb_head */




/* rio_sp_lt_ctl */



/* rio_sp_rt_ctl */



/* rio_sp_gen_ctl */





/* rio_err_rpt_bh */




/* rio_err_det */



















/* rio_err_en */



















/* rio_h_addr_capt */



/* rio_addr_capt */




/* rio_id_capt */






/* rio_ctrl_capt */






/* rio_pw_tgt_id */





/* rio_per_lane_bh */




/* rio_plm_bh */





/* rio_tlm_bh */





/* rio_pbm_bh */





/* rio_em_bh */





/* rio_em_int_stat */








/* rio_em_int_enable */






/* rio_em_int_port_stat */



/* rio_em_pw_stat */







/* rio_em_pw_en */




/* rio_em_pw_port_stat */



/* rio_em_dev_int_en */



/* rio_em_dev_pw_en */



/* rio_em_mecs_stat */



/* rio_em_mecs_int_en */



/* rio_em_mecs_cap_en */



/* rio_em_mecs_trig_en */




/* rio_em_mecs_req */




/* rio_em_mecs_port_stat */



/* rio_em_mecs_event_gen */



/* rio_em_rst_port_stat */



/* rio_em_rst_int_en */



/* rio_em_rst_pw_en */



/* rio_pw_bh */





/* rio_pw_ctl */




/* rio_pw_route */



/* rio_pw_rx_stat */








/* rio_pw_rx_event_gen */




/* rio_pw_rx_capt */



/* rio_llm_bh */





/* rio_whiteboard */



/* rio_port_number */




/* rio_prescalar_srv_clk */



/* rio_reg_rst_ctl */



/* rio_local_err_det */




/* rio_local_err_en */




/* rio_local_h_addr_capt */



/* rio_local_addr_capt */




/* rio_local_id_capt */






/* rio_local_ctrl_capt */





/* rio_fabric_bh */





/* rio_fabric_csr */




/* rio_sp_fabric_status */





/**
@defgroup CSL_SRIO_SYMBOL  SRIO Symbols Defined
@ingroup CSL_SRIO_API
*/
/**
@defgroup CSL_SRIO_DATASTRUCT  SRIO Data Structures
@ingroup CSL_SRIO_API
*/
/**
@defgroup CSL_SRIO_FUNCTION  SRIO Functions
@ingroup CSL_SRIO_API
*/

/** @addtogroup CSL_SRIO_DATASTRUCT
 @{ */
        
/** @brief This is the handle to the SRIO instance */
typedef volatile CSL_SrioRegs*   CSL_SrioHandle;

/** @brief SRIO Message Description.
 *
 * This structure is used to define a SRIO message and is used by the
 * SRIO module to compare all received RIO packets to determine the 
 * receive queue where the packet is pushed to.
 */
typedef struct SRIO_MESSAGE
{
    Uint16  srcId;
    Uint8   mbx;
    Uint8   ltr;
    Uint8   mbxMask;
    Uint8   ltrMask;
    Uint8   segMap;
    Uint8   srcProm;
    Uint8   tt;
    Uint8   dstProm;
    Uint16  dstId;
    Uint8   flowId;
}SRIO_MESSAGE;

/** @brief SRIO Type 9 Message Description.
 *
 * This structure is used to define the TYPE9 Message. This is then
 * used to MAP Type9 messages to a specific destination queue.
 */
typedef struct SRIO_TYPE9_MESSAGE
{
    Uint16  srcId;
    Uint8   cos;
    Uint8   cosMask;
    Uint8   srcProm;
    Uint8   tt;
    Uint8   dstProm;
    Uint16  dstId;
    Uint16  streamId;
    Uint16  streamMask;
    Uint8   flowId;
}SRIO_TYPE9_MESSAGE;

/** @brief SRIO AMU Window
 *
 * This structure is used to define the SRIO AMU Window
 * properties.
 */
typedef struct SRIO_AMU_WINDOW
{
    Uint8   xambs;
    Uint8   paneCount;
    Uint16  paneSize;
    Uint8   winSize;
    Uint32  rapidIOMsb;
    Uint32  rapidIOLsb;
}SRIO_AMU_WINDOW;

/** @brief SRIO AMU Pane
 *
 * This structure is used to define the SRIO AMU Pane
 * properties.
 */
typedef struct SRIO_AMU_PANE
{
    Uint8   cmdEnc;
    Uint8   portId;
    Uint8   idSize;
    Uint16  dstID;
}SRIO_AMU_PANE;

/** @brief SRIO LSU Transfer
 *
 * This structure is used to configure LSU module for Transfer
 */
typedef struct SRIO_LSU_TRANSFER 
{
    Uint32  rapidIOMSB;
    Uint32  rapidIOLSB;
    Uint32  dspAddress;
    Uint32  bytecount;
    Uint8   doorbellValid;
    Uint8   intrRequest;
    Uint8   supInt;
    Uint8   xambs;
    Uint8   priority;
    Uint8   outPortID;
    Uint8   idSize;
    Uint8   srcIDMap;
    Uint16  dstID;
    Uint8   ttype;
    Uint8   ftype;
    Uint8   hopCount;
    Uint16  doorbellInfo;
}SRIO_LSU_TRANSFER;

/** @brief SRIO Processing Element Features
 *
 * This structure is used to configure the Tundra 
 * Processing Element Features.
 */
typedef struct SRIO_PE_FEATURES 
{
    Uint8   isBridge;
    Uint8   isEndpoint;
    Uint8   isProcessor;
    Uint8   isSwitch;
    Uint8   isMultiport;
    Uint8   isFlowArbiterationSupported;
    Uint8   isMulticastSupported;
    Uint8   isExtendedRouteConfigSupported;
    Uint8   isStandardRouteConfigSupported;
    Uint8   isFlowControlSupported;
    Uint8   isCRFSupported;
    Uint8   isCTLSSupported;
    Uint8   isExtendedFeaturePtrValid;
    Uint8   numAddressBitSupported;
}SRIO_PE_FEATURES;

/** @brief SRIO Operation Capability Register
 *
 * This structure is used to store the operation capability
 * configuration. 
 */
typedef struct SRIO_OP_CAR
{
    Uint8   gsmRead;
    Uint8   gsmInstrnRead;
    Uint8   gsmReadOwn;
    Uint8   gsmDataCacheInvalidate;
    Uint8   gsmCastout;
    Uint8   gsmDataCacheFlush;
    Uint8   gsmIORead;
    Uint8   gsmInstrnCacheInvalidate;
    Uint8   gsmTLBInvalidate;
    Uint8   gsmTLBSync;
    Uint8   dataStreamingTM;
    Uint8   dataStreamingSupport;
    Uint8   implnDefined;
    Uint8   readSupport;
    Uint8   writeSupport;
    Uint8   streamWriteSupport;
    Uint8   writeResponseSupport;
    Uint8   dataMessageSupport;
    Uint8   doorbellSupport;
    Uint8   atomicCompareSwapSupport;
    Uint8   atomicTestSwapSupport;
    Uint8   atomicIncSupport;
    Uint8   atomicDecSupport;
    Uint8   atomicSetSupport;
    Uint8   atomicClearSupport;
    Uint8   atomicSwapSupport;
    Uint8   portWriteOperationSupport;
    Uint8   implnDefined2;
}SRIO_OP_CAR;

/** @brief SRIO Error Rate 
 *
 * This structure is used to store the error rate CSR configuration
 * which is used to monitor and control the port physical layer
 * errors. 
 */
typedef struct SRIO_ERR_RATE
{
    Uint8   errRateBias;
    Uint8   errRateRecovery;
    Uint8   peak;
    Uint8   errRateCnt;
}SRIO_ERR_RATE;

/** @brief SRIO Lane Status
 *
 * This structure is used to store the lane status information.
 */
typedef struct SRIO_LANE_STATUS
{
    Uint8   portNum;
    Uint8   laneNum;
    Uint8   txType;
    Uint8   txMode;
    Uint8   rxType;
    Uint8   rxInv;
    Uint8   rxTrn;
    Uint8   rxSync;
    Uint8   rxReady;
    Uint8   errCnt;
    Uint8   chgSync;
    Uint8   chgTrn;
    Uint8   stat1;
    Uint8   stat2_7;
    Uint8   idle2;
    Uint8   infoOk;
    Uint8   chg;
    Uint8   implSpecific;
    Uint8   lpRxTrn;
    Uint8   lpWidth;
    Uint8   lpLaneNum;
    Uint8   lpTapM1;
    Uint8   lpTapP1;
    Uint8   lpScrm;
}SRIO_LANE_STATUS;

/** @brief SRIO Lane Status
 *
 * This structure is used to store the PLM Implementation specific
 * control register
 */
typedef struct SRIO_PLM_IMPL_CONTROL
{
    Uint8   payloadCapture;
    Uint8   useIdle2;
    Uint8   useIdle1;
    Uint8   dlbEn;
    Uint8   forceReinit;
    Uint8   softRstPort;
    Uint8   txBypass;
    Uint8   lineLoopbackMode;
    Uint8   portSelfReset;
    Uint8   selfReset;
    Uint8   swapTx;
    Uint8   swapRx;
    Uint8   dltThresh;
}SRIO_PLM_IMPL_CONTROL;

/** @brief SRIO PLM VMin Exponent
 *
 * This structure is used to store the PLM VMin Exponent configuration
 */
typedef struct SRIO_PLM_VMIN_EXPONENT
{
    Uint8   vminExp;
    Uint8   imax;
    Uint8   mmax;
}SRIO_PLM_VMIN_EXPONENT;

/** @brief SRIO PLM Polarity Control
 *
 * This structure is used to store the PLM Polarity Control
 */
typedef struct SRIO_PLM_POLARITY_CONTROL
{
    Uint8   tx3Pol;
    Uint8   tx2Pol;
    Uint8   tx1Pol;
    Uint8   tx0Pol;
    Uint8   rx3Pol;
    Uint8   rx2Pol;
    Uint8   rx1Pol;
    Uint8   rx0Pol;
}SRIO_PLM_POLARITY_CONTROL;

/** @brief SRIO PLM Control Symbol Configuration
 *
 * This structure is used to store the PLM Control Symbol configuration
 */
typedef struct SRIO_PLM_CONTROL_SYMBOL
{
    Uint8   stype0;
    Uint8   par0;
    Uint8   par1;
    Uint8   csEmb;
    Uint8   stype1;
    Uint8   cmd;
    Uint8   stype2;
    Uint8   parm;
}SRIO_PLM_CONTROL_SYMBOL;

/** @brief SRIO TLM Control Configuration
 *
 * This structure is used to store the SRIO TLM Control configuration
 */
typedef struct SRIO_TLM_CONTROL
{
    Uint8   portGroupSelect;
    Uint8   voqSelect;
    Uint8   tgtIDDis;
    Uint8   mtcTgtIDDis;
    Uint8   length;
}SRIO_TLM_CONTROL;

/**
@}
*/

/* Device specific API which opens the SRIO instance and returns a handle used in all subsequent calls */
extern CSL_SrioHandle CSL_SRIO_Open (Int32 instNum);





/* CSL SRIO Functional Layer */
/**
 *   @file  csl_srioAux.h
 *
 *   @brief   
 *      This is the SRIO Auxilary Header File which exposes the various
 *      CSL Functional Layer API's to configure the SRIO Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008-2011, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/




/** @addtogroup CSL_SRIO_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_SRIO_GetPID
 *
 *   @b Description
 *   @n This function reads the peripheral ID register which identifies the 
 *      peripheral number for the peripheral.
 *
 *   @b Arguments
     @verbatim
          revInfo      Peripheral Revision populated by this API
          classInfo    Peripheral class populated by this API
          typeInfo     Peripheral Type populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PID
 *
 *   @b Example
 *   @verbatim
        Uint32          pid;
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the SRIO Peripheral Identification.
        CSL_SRIO_GetPID (hSrio, &pid);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPID 
(
    CSL_SrioHandle  hSrio,
    Uint32*         pid
)
{
    *pid = hSrio->RIO_PID;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePeripheral
 *
 *   @b Description
 *   @n This function sets the PEREN bit in the Peripheral Control register and
 *      if not set this will prevent the peripheral from participating in any
 *      transmit transactions and will disable all incoming requests. This should
 *      be the last enable bit when bringing the device out of reset.
 *
 *   @b Arguments
     @verbatim
          hSrio   Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PCR_PEREN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the SRIO peripheral. 
        CSL_SRIO_EnablePeripheral (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePeripheral (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_PCR) = ((hSrio->RIO_PCR) & ~(0x00000004u)) | (((1) << (0x00000002u)) & (0x00000004u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePeripheral
 *
 *   @b Description
 *   @n This function resets the PEREN bit in the Peripheral Control register 
 *      and disables the SRIO peripheral.
 *
 *   @b Arguments
     @verbatim
          hSrio   Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PCR_PEREN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the SRIO peripheral. 
        CSL_SRIO_DisablePeripheral (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePeripheral (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_PCR) = ((hSrio->RIO_PCR) & ~(0x00000004u)) | (((0) << (0x00000002u)) & (0x00000004u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetMAUSwappingMode
 *
 *   @b Description
 *   @n This function sets the Little Endian Swapping Mode for the Memory Access
 *      Unit.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          mode      Little Endian Swapping Mode for the MAU.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_MAU_LEND_SWAP_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Ensure that the Memory Access Unit operates in mode A
        CSL_SRIO_SetMAUSwappingMode (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetMAUSwappingMode (CSL_SrioHandle hSrio, Uint8 mode)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0xC0000000u)) | (((mode) << (0x0000001Eu)) & (0xC0000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetMAUSwappingMode
 *
 *   @b Description
 *   @n This function gets the Little Endian Swapping Mode for the Memory Access
 *      Unit.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          mode      Little Endian Swapping Mode for the MAU populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_MAU_LEND_SWAP_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           mode;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Memory Access Unit Swapping Mode.
        CSL_SRIO_GetMAUSwappingMode (hSrio, &mode);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetMAUSwappingMode (CSL_SrioHandle hSrio, Uint8* mode)
{
    *mode = (((hSrio->RIO_PER_SET_CNTL) & (0xC0000000u)) >> (0x0000001Eu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUSwappingMode
 *
 *   @b Description
 *   @n This function sets the Little Endian Swapping Mode for the Load Store 
 *      Unit
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          mode      Little Endian Swapping Mode for the LSU.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_LSU_LEND_SWAP_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Ensure that the LSU operates in mode A
        CSL_SRIO_SetLSUSwappingMode (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUSwappingMode (CSL_SrioHandle hSrio, Uint8 mode)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x30000000u)) | (((mode) << (0x0000001Cu)) & (0x30000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLSUSwappingMode
 *
 *   @b Description
 *   @n This function gets the Little Endian Swapping Mode for the Load Store 
 *      Unit.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          mode      Little Endian Swapping Mode for the LSU populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_LSU_LEND_SWAP_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           mode;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the LSU Swapping Mode.
        CSL_SRIO_GetLSUSwappingMode (hSrio, &mode);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLSUSwappingMode (CSL_SrioHandle hSrio, Uint8* mode)
{
    *mode = (((hSrio->RIO_PER_SET_CNTL) & (0x30000000u)) >> (0x0000001Cu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePromiscuous
 *
 *   @b Description
 *   @n This function enables the LOG_TGT_ID_DIS bit which ensures that the SRIO
 *      packets are accepted at the logical layer even if there is no match with 
 *      the destination identifier.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_LOG_TGT_ID_DIS=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Operate the peripheral in PROMISCUOUS mode.
        CSL_SRIO_EnablePromiscuous (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePromiscuous (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x08000000u)) | (((1) << (0x0000001Bu)) & (0x08000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePromiscuous
 *
 *   @b Description
 *   @n This function disables the LOG_TGT_ID_DIS bit which ensures that the SRIO
 *      packets are accepted at the logical layer only if there is a match with the
 *      specific destination identifier.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_LOG_TGT_ID_DIS=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Operate the peripheral in non-PROMISC mode.
        CSL_SRIO_DisablePromiscuous (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePromiscuous (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x08000000u)) | (((0) << (0x0000001Bu)) & (0x08000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPromiscuous
 *
 *   @b Description
 *   @n This function returns the status of the peripheral as TRUE if the device
 *      is operating in PROMISCUOUS mode else FALSE.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  TRUE  - Device is in PROMISCUOUS Mode.
 *   @n  FALSE - Device is in NON-PROMISCUOUS Mode.
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_LOG_TGT_ID_DIS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if we are operating in PROMISCUOUS mode or not?
        if (CSL_SRIO_IsPromiscuous (hSrio) == TRUE)
        {
            // Device is in PROMISCUOUS Mode.
        }
        else
        {
            // Device is in Non-PROMISCUOUS Mode.
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPromiscuous (CSL_SrioHandle hSrio)
{
    if ((((hSrio->RIO_PER_SET_CNTL) & (0x08000000u)) >> (0x0000001Bu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetAMUSwappingMode
 *
 *   @b Description
 *   @n This function sets the Little Endian Swapping Mode for the AMU
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          mode      Little Endian Swapping Mode for the AMU
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_AMU_LEND_SWAP_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Ensure that the AMU operates in mode A
        CSL_SRIO_SetAMUSwappingMode (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetAMUSwappingMode (CSL_SrioHandle hSrio, Uint8 mode)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x06000000u)) | (((mode) << (0x00000019u)) & (0x06000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAMUSwappingMode
 *
 *   @b Description
 *   @n This function gets the Little Endian Swapping Mode for the AMU
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          mode      Little Endian Swapping Mode for the AMU populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_AMU_LEND_SWAP_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           mode;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the AMU Swapping Mode.
        CSL_SRIO_GetAMUSwappingMode (hSrio, &mode);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAMUSwappingMode (CSL_SrioHandle hSrio, Uint8* mode)
{
    *mode = (((hSrio->RIO_PER_SET_CNTL) & (0x06000000u)) >> (0x00000019u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetBootComplete
 *
 *   @b Description
 *   @n This function sets the boot complete flag as specified.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          bootCompleteFlag  Boot Complete Flag to be set in the register.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_BOOT_COMPLETE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Boot Complete Flag to 1 
        CSL_SRIO_SetBootComplete (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetBootComplete (CSL_SrioHandle hSrio, Uint8 bootCompleteFlag)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x01000000u)) | (((bootCompleteFlag) << (0x00000018u)) & (0x01000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetBootComplete
 *
 *   @b Description
 *   @n This function gets the boot complete flag.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          bootCompleteFlag  Boot Complete Flag populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_BOOT_COMPLETE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           bootCompleteFlag;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Boot Complete Flag
        bootCompleteFlag = CSL_SRIO_GetBootComplete (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetBootComplete (CSL_SrioHandle hSrio, Uint8* bootCompleteFlag)
{
    *bootCompleteFlag = (((hSrio->RIO_PER_SET_CNTL) & (0x01000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTXURXUSwappingMode
 *
 *   @b Description
 *   @n This function sets the Little Endian Swapping Mode for the TXU and RXU
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          mode      Little Endian Swapping Mode for the TXU and RXU.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_TXU_RXU_LEND_SWAP_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Ensure that the TXU and RXU operates in mode A
        CSL_SRIO_SetTXURXUSwappingMode (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTXURXUSwappingMode (CSL_SrioHandle hSrio, Uint8 mode)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x00C00000u)) | (((mode) << (0x00000016u)) & (0x00C00000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTXURXUSwappingMode
 *
 *   @b Description
 *   @n This function gets the Little Endian Swapping Mode for the Memory Access
 *      Unit.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          mode      Little Endian Swapping Mode for the TXU and RXU populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_TXU_RXU_LEND_SWAP_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           mode;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TXU and RXU Swapping Mode.
        CSL_SRIO_GetTXURXUSwappingMode (hSrio, &mode);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTXURXUSwappingMode (CSL_SrioHandle hSrio, Uint8* mode)
{
    *mode = (((hSrio->RIO_PER_SET_CNTL) & (0x00C00000u)) >> (0x00000016u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableAutomaticPriorityPromotion
 *
 *   @b Description
 *   @n This function enables the automatic promotion of response priority by 
 *      RXU and MAU.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_PROMOTE_DIS=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Automatic Priority Promotion.
        CSL_SRIO_EnableAutomaticPriorityPromotion (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableAutomaticPriorityPromotion (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x00200000u)) | (((0) << (0x00000015u)) & (0x00200000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableAutomaticPriorityPromotion
 *
 *   @b Description
 *   @n This function disables the automatic promotion of response priority by 
 *      RXU and MAU.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_PROMOTE_DIS=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable Automatic Priority Promotion.
        CSL_SRIO_DisableAutomaticPriorityPromotion (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableAutomaticPriorityPromotion (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x00200000u)) | (((1) << (0x00000015u)) & (0x00200000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsAutomaticPriorityPromotionEnabled
 *
 *   @b Description
 *   @n This function check if the automatic promotion of response priority by 
 *      RXU and MAU is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  TRUE  - Automatic Priority Promotion is enabled
 *   @n  FALSE - Automatic Priority Promotion is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_PROMOTE_DIS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Automatic Priority Promotion.
        if (CSL_SRIO_IsAutomaticPriorityPromotionEnabled (hSrio) == TRUE)
        {
            // Automatic Priority Promotion is enabled.
        }
        else
        {
            // Automatic Priority Promotion is disabled.
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsAutomaticPriorityPromotionEnabled (CSL_SrioHandle hSrio)
{
    if ((((hSrio->RIO_PER_SET_CNTL) & (0x00200000u)) >> (0x00000015u)) == 0)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTxCreditThreshold
 *
 *   @b Description
 *   @n This function sets the transmit credit threshold for priority packets
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          priority  Priority of the Transmit Buffers
          credit    Credit Threshold for the priority which is to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_TX_PRI2_WM;SRIO_RIO_PER_SET_CNTL_TX_PRI1_WM;
 *      SRIO_RIO_PER_SET_CNTL_TX_PRI0_WM
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Transmit Credit Threshold as 8 for priority 2
        CSL_SRIO_SetTxCreditThreshold (hSrio, 2, 8);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTxCreditThreshold (CSL_SrioHandle hSrio,Uint8 priority,Uint8 credit)
{
    if (priority == 2)
    {
        ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x001C0000u)) | (((credit) << (0x00000012u)) & (0x001C0000u)));
    }
    else if (priority == 1)
    {
        ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x00038000u)) | (((credit) << (0x0000000Fu)) & (0x00038000u)));
    }
    else if (priority == 0)
    {
        ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x00007000u)) | (((credit) << (0x0000000Cu)) & (0x00007000u)));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTxCreditThreshold
 *
 *   @b Description
 *   @n This function gets the transmit credit threshold for priority packets
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          priority  Priority of the Transmit Buffers
          credit    Credit Threshold for the priority which is populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_TX_PRI2_WM;SRIO_RIO_PER_SET_CNTL_TX_PRI1_WM;
 *      SRIO_RIO_PER_SET_CNTL_TX_PRI0_WM
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           credit;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Transmit Credit Threshold for priority 2
        CSL_SRIO_GetTxCreditThreshold (hSrio, 2, &credit);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTxCreditThreshold (CSL_SrioHandle hSrio,Uint8 priority,Uint8* credit)
{
    if (priority == 2)
    {
        *credit = (((hSrio->RIO_PER_SET_CNTL) & (0x001C0000u)) >> (0x00000012u));
    }
    else if (priority == 1)
    {
        *credit = (((hSrio->RIO_PER_SET_CNTL) & (0x00038000u)) >> (0x0000000Fu));
    }
    else if (priority == 0)
    {
        *credit = (((hSrio->RIO_PER_SET_CNTL) & (0x00007000u)) >> (0x0000000Cu));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTransactionPriority
 *
 *   @b Description
 *   @n This function sets the DSP System transaction priority. 0 implies 
 *   Highest Priority while 7 implies lowest.
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          priority  Priority to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_CBA_TRANS_PRI
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the transaction priority to be HIGHEST
        CSL_SRIO_SetTransactionPriority (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTransactionPriority (CSL_SrioHandle hSrio,Uint8 priority)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x00000E00u)) | (((priority) << (0x00000009u)) & (0x00000E00u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTransactionPriority
 *
 *   @b Description
 *   @n This function gets the DSP System transaction priority. 
 *
 *   @b Arguments
     @verbatim
          hSrio     Handle of the SRIO device
          priority  Priority to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_CBA_TRANS_PRI
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           priority;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the transaction priority 
        CSL_SRIO_GetTransactionPriority (hSrio, &priority);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTransactionPriority (CSL_SrioHandle hSrio,Uint8 *priority)
{
    *priority = (((hSrio->RIO_PER_SET_CNTL) & (0x00000E00u)) >> (0x00000009u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPrescalarSelect
 *
 *   @b Description
 *   @n This function sets the prescalar select for SRIO
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          prescalarSelect   Prescalar Select which is to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL_PRESCALER_SELECT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the SRIO Prescalar select to operate in the range of 44.7 to 89.5
        CSL_SRIO_SetPrescalarSelect (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPrescalarSelect (CSL_SrioHandle hSrio, Uint8 prescalarSelect)
{
    ((hSrio->RIO_PER_SET_CNTL) = ((hSrio->RIO_PER_SET_CNTL) & ~(0x000000F0u)) | (((prescalarSelect) << (0x00000004u)) & (0x000000F0u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPrescalarSelect
 *
 *   @b Description
 *   @n This function gets the prescalar select for SRIO
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          prescalarSelect   Prescalar Select which is to be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL_PRESCALER_SELECT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           prescalarSelect;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the SRIO Prescalar select.
        CSL_SRIO_GetPrescalarSelect (hSrio, &prescalarSelect);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPrescalarSelect (CSL_SrioHandle hSrio, Uint8* prescalarSelect)
{
    *prescalarSelect = (((hSrio->RIO_PER_SET_CNTL) & (0x000000F0u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetResponseCRF
 *
 *   @b Description
 *   @n This function sets the CRF value in the response
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          value             CRF value to be set in the response.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL1_CRF
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Response CRF to be always set to 1
        CSL_SRIO_SetResponseCRF (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetResponseCRF (CSL_SrioHandle hSrio, Uint8 value)
{
    ((hSrio->RIO_PER_SET_CNTL1) = ((hSrio->RIO_PER_SET_CNTL1) & ~(0x00000001u)) | (((value) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetResponseCRF
 *
 *   @b Description
 *   @n This function gets the CRF value in the response
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          value             CRF value populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL1_CRF
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           crfValue;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Response CRF 
        CSL_SRIO_GetResponseCRF (hSrio, &crfValue);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetResponseCRF (CSL_SrioHandle hSrio, Uint8* value)
{
    *value = (((hSrio->RIO_PER_SET_CNTL1) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetRXUWatermark
 *
 *   @b Description
 *   @n This function sets the RXU Watermark value.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          value             0/1 to disable/enable RXU context assignment based on 
                            priority.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL1_RXU_WATERMARK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the RXU Watermark to to 1
        CSL_SRIO_SetRXUWatermark (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetRXUWatermark (CSL_SrioHandle hSrio, Uint8 value)
{
    ((hSrio->RIO_PER_SET_CNTL1) = ((hSrio->RIO_PER_SET_CNTL1) & ~(0x00000002u)) | (((value) << (0x00000001u)) & (0x00000002u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetRXUWatermark
 *
 *   @b Description
 *   @n This function gets the RXU Watermark setting
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          value             RXU Watermark setting read 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL1_RXU_WATERMARK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           value;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the RXU Watermark
        CSL_SRIO_GetRXUWatermark (hSrio, &value);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetRXUWatermark (CSL_SrioHandle hSrio, Uint8* value)
{
    *value = (((hSrio->RIO_PER_SET_CNTL1) & (0x00000002u)) >> (0x00000001u));
}


/** ============================================================================
 *   @n@b CSL_SRIO_SetSysClkSel
 *
 *   @b Description
 *   @n This function sets the SYS_CLK source
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          value             SYS_CLK source to configure
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL1_SYS_CLK_SEL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the SYS_CLK source to 1
        CSL_SRIO_SetSysClkSel (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetSysClkSel (CSL_SrioHandle hSrio, Uint8 value)
{
    ((hSrio->RIO_PER_SET_CNTL1) = ((hSrio->RIO_PER_SET_CNTL1) & ~(0x0000000Cu)) | (((value) << (0x00000002u)) & (0x0000000Cu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetSysClkSel
 *
 *   @b Description
 *   @n This function retrieves the SYS_CLK source for the port.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          value             SYS_CLK source read
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL1_SYS_CLK_SEL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           value;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the SYS_CLK source
        CSL_SRIO_GetSysClkSel (hSrio, &value);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetSysClkSel (CSL_SrioHandle hSrio, Uint8* value)
{
    *value = (((hSrio->RIO_PER_SET_CNTL1) & (0x0000000Cu)) >> (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLoopbackMode
 *
 *   @b Description
 *   @n This function sets the port to operate in loopback mode.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           Port Number for which loopback mode must be enabled
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL1_LOOPBACK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Port 0 to work in loopback mode.
        CSL_SRIO_SetLoopbackMode (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLoopbackMode (CSL_SrioHandle hSrio,Uint8 portNum)
{
    ((hSrio->RIO_PER_SET_CNTL1) = ((hSrio->RIO_PER_SET_CNTL1) &~ (((1 << (((0x00000004u) + portNum) - ((0x00000004u) + portNum) + 1)) - 1) << ((0x00000004u) + portNum))) | (((1) & ((1 << (((0x00000004u) + portNum) - ((0x00000004u) + portNum) + 1)) - 1)) << ((0x00000004u) + portNum)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetNormalMode
 *
 *   @b Description
 *   @n This function sets the port to operate in Normal mode.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           Port Number for which normal mode must be enabled
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL1_LOOPBACK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the port 0 to work in normal mode.
        CSL_SRIO_SetNormalMode (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetNormalMode (CSL_SrioHandle hSrio,Uint8 portNum)
{
    ((hSrio->RIO_PER_SET_CNTL1) = ((hSrio->RIO_PER_SET_CNTL1) &~ (((1 << (((0x00000004u) + portNum) - ((0x00000004u) + portNum) + 1)) - 1) << ((0x00000004u) + portNum))) | (((0) & ((1 << (((0x00000004u) + portNum) - ((0x00000004u) + portNum) + 1)) - 1)) << ((0x00000004u) + portNum)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsLoopbackMode
 *
 *   @b Description
 *   @n This function checks if the port specified is operating in loopback 
 *      mode or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           Port Number for which mode settings must be retrieved
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  TRUE   -   Port is operating in loopback mode
 *   @n  FALSE  -   Port is operating in Normal Mode.
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL1_LOOPBACK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the port 0 to work in normal mode.
        if (CSL_SRIO_IsLoopbackMode(hSrio, 0) == TRUE)
        {
            // Port 0 is operating in loopback mode.
        }
        else
        {
            // Port 0 is operating in normal mode.
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsLoopbackMode (CSL_SrioHandle hSrio,Uint8 portNum)
{
    if ((((hSrio->RIO_PER_SET_CNTL1) >> ((0x00000004u) + portNum)) & ((1 << (((0x00000004u) + portNum) - ((0x00000004u) + portNum) + 1)) - 1)) == 1)
    {
        return 1;
    }
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableCOS
 *
 *   @b Description
 *   @n This function enables Class of Service
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL1_COS_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Class of Service
        CSL_SRIO_EnableCOS (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableCOS (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_PER_SET_CNTL1) = ((hSrio->RIO_PER_SET_CNTL1) & ~(0x00000100u)) | (((1) << (0x00000008u)) & (0x00000100u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableCOS
 *
 *   @b Description
 *   @n This function disables Class of Service for the device.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PER_SET_CNTL1_COS_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable COS.
        CSL_SRIO_DisableCOS (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableCOS (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_PER_SET_CNTL1) = ((hSrio->RIO_PER_SET_CNTL1) & ~(0x00000100u)) | (((0) << (0x00000008u)) & (0x00000100u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsCOSEnabled
 *
 *   @b Description
 *   @n This function checks if COS has been enabled or not for the device?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - COS is enabled
 *   @n FALSE - COS is disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PER_SET_CNTL1_COS_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if COS is enabled
        if (CSL_SRIO_IsCOSEnabled (hSrio) == TRUE)
        {
            // COS is ENABLED
        }
        else
        {
            // COS is DISABLED
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsCOSEnabled (CSL_SrioHandle hSrio)
{
    if ((((hSrio->RIO_PER_SET_CNTL1) & (0x00000100u)) >> (0x00000008u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GlobalEnable
 *
 *   @b Description
 *   @n This function globally enables the SRIO peripheral and all blocks.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_GBL_EN_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Globally Enable the SRIO peripheral.
        CSL_SRIO_GlobalEnable (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GlobalEnable (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_GBL_EN) = ((hSrio->RIO_GBL_EN) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GlobalDisable
 *
 *   @b Description
 *   @n This function globally disables the SRIO peripheral and all blocks.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_GBL_EN_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Globally Disable the SRIO peripheral.
        CSL_SRIO_GlobalDisable (hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GlobalDisable (CSL_SrioHandle hSrio)
{
    ((hSrio->RIO_GBL_EN) = ((hSrio->RIO_GBL_EN) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsSRIOEnabled
 *
 *   @b Description
 *   @n This function checks if the SRIO peripheral has been globally enabled or
 *      not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - SRIO Peripheral is enabled
 *   @n FALSE - SRIO Peripheral is disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_GBL_EN_STAT_GBL_EN_STAT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Ensure that the SRIO Peripheral is enabled or disabled.
        if (CSL_SRIO_IsSRIOEnabled (hSrio) == TRUE)
        {
            // SRIO Peripheral is ENABLED
        }
        else
        {
            // SRIO Peripheral is DISABLED
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsSRIOEnabled (CSL_SrioHandle hSrio)
{
    if ((((hSrio->RIO_GBL_EN_STAT) & (0x00000001u)) >> (0x00000000u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableBlock
 *
 *   @b Description
 *   @n This function enables the specific block in the SRIO peripheral.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          blockNum          Block Number to be enabled.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_BLK_EN_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the SRIO block for LSU .
        CSL_SRIO_GlobalEnable (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableBlock (CSL_SrioHandle hSrio, Uint16 blockNumber)
{
    ((hSrio->BLOCK_ENABLE_STATUS[blockNumber]. RIO_BLK_EN) = ((hSrio->BLOCK_ENABLE_STATUS[blockNumber]. RIO_BLK_EN) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u))); 
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableBlock
 *
 *   @b Description
 *   @n This function disables the specific block in the SRIO peripheral.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          blockNum          Block Number to be disabled.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_BLK_EN_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the SRIO Block 1 for LSU.
        CSL_SRIO_DisableBlock (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableBlock (CSL_SrioHandle hSrio, Uint16 blockNumber)
{
    ((hSrio->BLOCK_ENABLE_STATUS[blockNumber]. RIO_BLK_EN) = ((hSrio->BLOCK_ENABLE_STATUS[blockNumber]. RIO_BLK_EN) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u))); 
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsSRIOBlockEnabled
 *
 *   @b Description
 *   @n This function checks if the SRIO block is enabled or disabled?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          blockNumber       SRIO Block Number to be checked.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - SRIO Block is enabled
 *   @n FALSE - SRIO Block is disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_BLK_EN_STAT_EN_STATUS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Ensure that the SRIO Block 1 for LSU is enabled or not? 
        if (CSL_SRIO_IsSRIOBlockEnabled (hSrio, 1) == TRUE)
        {
            // SRIO Block 1 for LSU is ENABLED
        }
        else
        {
            // SRIO Block 1 for LSU is DISABLED
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsSRIOBlockEnabled (CSL_SrioHandle hSrio, Uint16 blockNumber)
{
    return (Bool)(((hSrio->BLOCK_ENABLE_STATUS[blockNumber]. RIO_BLK_EN_STAT) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetDeviceID
 *
 *   @b Description
 *   @n This function sets the DEVICE ID Register. There are multiple device
 *      ID registers which can exist in the system. The index parameter is used
 *      to indicate which register is to be configured.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             Index of the Device ID register to be configured (0-Based)
          NodeId8bit        8 Bit Device Identifier to be configured
          NodeId16bit       16 Bit Device Identifier to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_MULTIID_REG_8B_NODEID,SRIO_RIO_MULTIID_REG_16B_NODEID 
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Configure the First Device ID register with a 16 bit identifer as 0xDEAD
        // and no 8 bit identifier.
        CSL_SRIO_SetDeviceID (hSrio, 0, 0x0, 0xDEAD);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetDeviceID 
(
    CSL_SrioHandle  hSrio, 
    Uint8           index,
    Uint8           NodeId8bit,
    Uint16          NodeId16bit
)
{
    /* Set the 8bit and 16bit device identifiers. */
    hSrio->RIO_MULTIID_REG[index] = 
                (((NodeId8bit) << (0x00000010u)) & (0x00FF0000u)) | 
                (((NodeId16bit) << (0x00000000u)) & (0x0000FFFFu));

}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDeviceID
 *
 *   @b Description
 *   @n This function gets the DEVICE ID Register. There are multiple device
 *      ID registers which can exist in the system. The index parameter is used
 *      to indicate which register is to be retreived.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             Index of the Device ID register to be configured (0-Based)
          NodeId8bit        8 Bit Device Identifier to be populated by this API
          NodeId16bit       16 Bit Device Identifier to be populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_MULTIID_REG_8B_NODEID,SRIO_RIO_MULTIID_REG_16B_NODEID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           NodeId8bit;
        Uint16          NodeId16bit;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Device ID register contents 
        CSL_SRIO_GetDeviceID (hSrio, 0, &NodeId8bit, &NodeId16bit);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDeviceID 
(
    CSL_SrioHandle  hSrio, 
    Uint8           index,
    Uint8*          NodeId8bit,
    Uint16*         NodeId16bit
)
{
    Uint32 value;

    /* Get the value from the register */
    value = hSrio->RIO_MULTIID_REG[index];

    /* Populate the 8bit and 16bit device identifiers. */
    *NodeId8bit  = (((value) & (0x00FF0000u)) >> (0x00000010u));
    *NodeId16bit = (((value) & (0x0000FFFFu)) >> (0x00000000u));
    return;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPacketForwarding
 *
 *   @b Description
 *   @n The function sets the packet forwarding for the SRIO peripheral. There
 *   exist multiple packet forwarding registers and the parameter index is to used
 *   to select which register is to be configured.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             Index of the Packet forwarding register to be configured (0-Based)
          low16bitDeviceID  Lower bound 16bit Device Identifier which can use this
          up16bitDeviceID   Upper bound 16bit Device Identifier which can use this
          low8bitDeviceID   Lower bound 8bit Device Identifier which can use this
          up8bitDeviceID    Upper bound 8bit Device Identifier which can use this
          outPort           Outgoing SRIO port to be used.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PF_16B_CNTL_DEVID_16B_UP, SRIO_RIO_PF_16B_CNTL_DEVID_16B_LO,
 *      SRIO_RIO_PF_8B_CNTL_DEVID_8B_LO,SRIO_RIO_PF_8B_CNTL_DEVID_8B_UP,
 *      SRIO_RIO_PF_8B_CNTL_OUT_PORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Create a packet forwarding entry for device ID 0xBEEF to be forwarded
        // to port 1; we dont care about the 8-bit identifiers hence these are 
        // set to reset values.
        CSL_SRIO_SetPacketForwarding (hSrio, 0, 0xBEEF, 0xBEEF, 0xFF, 0xFF, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPacketForwarding 
(
    CSL_SrioHandle  hSrio, 
    Uint8           index,
    Uint16          low16bitDeviceID,
    Uint16          up16bitDeviceID,
    Uint8           low8bitDeviceID,
    Uint8           up8bitDeviceID,
    Uint8           outPort
)
{
    hSrio->PF_CNTL[index].RIO_PF_16B_CNTL = 
            (((up16bitDeviceID) << (0x00000010u)) & (0xFFFF0000u)) |
            (((low16bitDeviceID) << (0x00000000u)) & (0x0000FFFFu));

    hSrio->PF_CNTL[index].RIO_PF_8B_CNTL = 
            (((outPort) << (0x00000010u)) & (0x00030000u))           |
            (((up8bitDeviceID) << (0x00000008u)) & (0x0000FF00u))    |
            (((low8bitDeviceID) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPacketForwarding
 *
 *   @b Description
 *   @n The function gets the packet forwarding for the SRIO peripheral. There
 *   exist multiple packet forwarding registers and the parameter index is to used
 *   to select which register is to be retreived.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             Index of the Packet forwarding register to be configured (0-Based)
          low16bitDeviceID  Lower bound 16bit Device Identifier populated by this API
          up16bitDeviceID   Upper bound 16bit Device Identifier populated by this API
          low8bitDeviceID   Lower bound 8bit Device Identifier populated by this API
          up8bitDeviceID    Upper bound 8bit Device Identifier populated by this API
          outPort           Outgoing SRIO port populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PF_16B_CNTL_DEVID_16B_LO, SRIO_RIO_PF_16B_CNTL_DEVID_16B_UP, 
 *      SRIO_RIO_PF_8B_CNTL_DEVID_8B_LO,SRIO_RIO_PF_8B_CNTL_DEVID_8B_UP,
 *      SRIO_RIO_PF_8B_CNTL_OUT_PORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          low16bitDeviceID;
        Uint16          up16bitDeviceID;
        Uint8           low8bitDeviceID;
        Uint8           up8bitDeviceID;
        Uint8           outPort;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the packet forwarding entry 0.
        CSL_SRIO_GetPacketForwarding (hSrio, 0, &low16bitDeviceID, &up16bitDeviceID, 
                                      &low8bitDeviceID, &up8bitDeviceID, &outPort);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPacketForwarding 
(
    CSL_SrioHandle  hSrio, 
    Uint8           index,
    Uint16*         low16bitDeviceID,
    Uint16*         up16bitDeviceID,
    Uint8*          low8bitDeviceID,
    Uint8*          up8bitDeviceID,
    Uint8*          outPort
)
{
    Uint32 value = hSrio->PF_CNTL[index].RIO_PF_16B_CNTL;
    *up16bitDeviceID  = (((value) & (0xFFFF0000u)) >> (0x00000010u));
    *low16bitDeviceID = (((value) & (0x0000FFFFu)) >> (0x00000000u));

    value = hSrio->PF_CNTL[index].RIO_PF_8B_CNTL;
    *outPort         = (((value) & (0x00030000u)) >> (0x00000010u));
    *up8bitDeviceID  = (((value) & (0x0000FF00u)) >> (0x00000008u));
    *low8bitDeviceID = (((value) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDoorbellPendingInterrupt
 *
 *   @b Description
 *   @n The function reads the DOORBELL status register to determine if there
 *      are any pending door bell interrupts or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          port              SRIO Port (Zero Based) for which the doorbell status is required.
          doorbellStatus    Door Bell Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_DOORBELL_ICSR_RIO_DOORBELL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          doorbellStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the status of doorbell interrupts for port 0
        CSL_SRIO_GetDoorbellPendingInterrupt (hSrio, 0, &doorbellStatus);
        if (doorbellStatus != 0)
        {
            // Door bell Interrupts were pending and need to be serviced.
        }
        else
        {
            // There are no door bell interrupts pending.
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDoorbellPendingInterrupt
(
    CSL_SrioHandle  hSrio, 
    Uint8           port,
    Uint16*         doorbellStatus
)
{
    *doorbellStatus = (((hSrio->DOORBELL_ICSR_ICCR[port]. RIO_DOORBELL_ICSR) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearDoorbellPendingInterrupt
 *
 *   @b Description
 *   @n The function clears a specific door bell interrupt in the specified door
 *   bell interrupt register.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          port              SRIO Port (Zero Based) for which the doorbell status is required.
          doorbellInterrupt Door Bell Interrupt to be cleared.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_DOORBELL_ICCR
 *
 *   @b Affects
 *   @n SRIO_RIO_DOORBELL_ICSR_RIO_DOORBELL=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          doorbellStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the status of doorbell interrupts for port 0
        CSL_SRIO_GetDoorbellPendingInterrupt (hSrio, 0, &doorbellStatus);
        if (doorbellStatus != 0)
        {
            // Door bell Interrupts were pending and need to be serviced.
            ...
            // Clear the Door Bell Pending Interrupts.
            CSL_SRIO_ClearDoorbellPendingInterrupt (hSrio, 0, doorbellStatus);
        }
        else
        {
            // There are no door bell interrupts pending.
        }        
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearDoorbellPendingInterrupt 
(
    CSL_SrioHandle  hSrio, 
    Uint8           port,
    Uint16          doorbellInterrupt
)
{
    /* Clear all the specified doorbell interrupts. */ 
    hSrio->DOORBELL_ICSR_ICCR[port].RIO_DOORBELL_ICCR = doorbellInterrupt;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLSUPendingInterrupt
 *
 *   @b Description
 *   @n The function returns the LSU pending interrupt status.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device          
          lsuStatus1        LSU Pending Status populated by this API
          lsuStatus2        LSU Pending Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LSU_ICSR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          lsuStatus1;
        Uint32          lsuStatus2;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check the LSU Pending Interrupt Status.
        CSL_SRIO_GetLSUPendingInterrupt (hSrio, &lsuStatus1, &lsuStatus2);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLSUPendingInterrupt
(
    CSL_SrioHandle  hSrio, 
    Uint32*         lsuStatus1,
    Uint32*         lsuStatus2
)
{
    *lsuStatus1 = hSrio->LSU_ICSR_ICCR[0].RIO_LSU_ICSR;
    *lsuStatus2 = hSrio->LSU_ICSR_ICCR[1].RIO_LSU_ICSR;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearLSUPendingInterrupt
 *
 *   @b Description
 *   @n The function clears the LSU pending interrupt 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device          
          lsuInterrupt1     LSU Interrupt to be cleared.
          lsuInterrupt2     LSU Interrupt to be cleared.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_ICCR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          lsuStatus1;
        Uint32          lsuStatus2;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check the LSU Pending Interrupt Status.
        CSL_SRIO_GetLSUPendingInterrupt (hSrio, &lsuStatus1, &lsuStatus2);
        ...
        // Clear the pending interrupts.
        CSL_SRIO_ClearLSUPendingInterrupt (hSrio, lsuStatus1, lsuStatus);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearLSUPendingInterrupt
(
    CSL_SrioHandle  hSrio, 
    Uint32          lsuInterrupt1,
    Uint32          lsuInterrupt2
)
{
    hSrio->LSU_ICSR_ICCR[0].RIO_LSU_ICCR = lsuInterrupt1;
    hSrio->LSU_ICSR_ICCR[1].RIO_LSU_ICCR = lsuInterrupt2;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearLSU0PendingInterrupt
 *
 *   @b Description
 *   @n The function clears the LSU0 pending interrupt 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device          
          lsuInterrupt      LSU Interrupt to be cleared.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_ICCR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Clear the ICS0 indicating that the SRCID0 Transaction was successfully complete.
        CSL_SRIO_ClearLSU0PendingInterrupt (hSrio, 0x1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearLSU0PendingInterrupt
(
    CSL_SrioHandle  hSrio, 
    Uint32          lsuInterrupt
)
{
    hSrio->LSU_ICSR_ICCR[0].RIO_LSU_ICCR = lsuInterrupt;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorPendingInterrupt
 *
 *   @b Description
 *   @n The function returns the interrupt status of any error interrupts 
 *      which are pending.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device          
          errStatus         Error Pending Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_ERR_RST_EVNT_ICSR_MCAST_INT_RECEIVED,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT_WRITE_IN_RECEIVED,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_LLERR_CAPTURE,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT0_ERR,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT1_ERR,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT2_ERR,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT3_ERR,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_DEVICE_RST_INT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          errStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get any pending errors 
        CSL_SRIO_GetErrorPendingInterrupt (hSrio, &errStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorPendingInterrupt
(
    CSL_SrioHandle  hSrio, 
    Uint32*         errStatus
)
{
    /* All the errors are present in the lower order 17 bits. */
    *errStatus = (((hSrio->RIO_ERR_RST_EVNT_ICSR) >> (0)) & ((1 << ((16) - (0) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearErrorPendingInterrupt
 *
 *   @b Description
 *   @n The function clears the pending error interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device          
          errStatus         Error Status to be cleared.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_ERR_RST_EVNT_ICCR_MCAST_INT_RECEIVED,
 *      SRIO_RIO_ERR_RST_EVNT_ICCR_PORT_WRITE_IN_REQUEST_RECEIVED,
 *      SRIO_RIO_ERR_RST_EVNT_ICCR_LOGICAL_LAYER_ERROR_MANAGEMENT_EVENT_CAPTURE,
 *      SRIO_RIO_ERR_RST_EVNT_ICCR_PORT0_ERROR,
 *      SRIO_RIO_ERR_RST_EVNT_ICCR_PORT1_ERROR,
 *      SRIO_RIO_ERR_RST_EVNT_ICCR_PORT2_ERROR,
 *      SRIO_RIO_ERR_RST_EVNT_ICCR_PORT3_ERROR,
 *      SRIO_RIO_ERR_RST_EVNT_ICCR_DEVICE_RST_INT
 *
 *   @b Affects
 *   @n SRIO_RIO_ERR_RST_EVNT_ICSR_MCAST_INT_RECEIVED=0,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT_WRITE_IN_RECEIVED=0,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_LLERR_CAPTURE=0,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT0_ERR=0,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT1_ERR=0,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT2_ERR=0,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_PORT3_ERR=0,
 *      SRIO_RIO_ERR_RST_EVNT_ICSR_DEVICE_RST_INT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          errStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get any pending error status.
        CSL_SRIO_GetErrorPendingInterrupt (hSrio,&errStatus);
        if (errStatus != 0)
        {
            // Pending error interrupts detected.
            ...
            // Clear the pending interrupts.
            CSL_SRIO_ClearErrorPendingInterrupt (hSrio, errStatus);
        }
        else
        {
            // No pending error status
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearErrorPendingInterrupt
(
    CSL_SrioHandle  hSrio, 
    Uint32          errStatus
)
{
    ((hSrio->RIO_ERR_RST_EVNT_ICCR) = ((hSrio->RIO_ERR_RST_EVNT_ICCR) &~ (((1 << ((16) - (0) + 1)) - 1) << (0))) | (((errStatus) & ((1 << ((16) - (0) + 1)) - 1)) << (0)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAMUPendingInterrupt
 *
 *   @b Description
 *   @n The function returns the interrupt status of any AMU interrupts.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device          
          amuIntrStatus     AMU Interrupt Pending Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_AMU_ICSR_CPRIVID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          amuIntrStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the pending AMU interrupt status
        CSL_SRIO_GetAMUPendingInterrupt (hSrio, &amuIntrStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAMUPendingInterrupt
(
    CSL_SrioHandle  hSrio, 
    Uint16*         amuIntrStatus
)
{
    *amuIntrStatus = (((hSrio->RIO_AMU_ICSR) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearAMUPendingInterrupt
 *
 *   @b Description
 *   @n The function clears the AMU pending interrupts.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device          
          amuIntrStatus     AMU pending interrupt status to be cleared.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_AMU_ICCR_CPRIVID
 *
 *   @b Affects
 *   @n SRIO_RIO_AMU_ICSR_CPRIVID=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          amuIntrStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the pending AMU interrupt status
        CSL_SRIO_GetAMUPendingInterrupt (hSrio, &amuIntrStatus);
        if (amuIntrStatus != 0)
        {
            // Pending AMU interrupts detected.
            ...
            // Clear the pending interrupts.
            CSL_SRIO_ClearAMUPendingInterrupt (hSrio, amuIntrStatus);
        }
        else
        {
            // No AMU interrupts were pending.
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearAMUPendingInterrupt
(
    CSL_SrioHandle  hSrio, 
    Uint16          amuIntrStatus
)
{
    ((hSrio->RIO_AMU_ICCR) = ((hSrio->RIO_AMU_ICCR) & ~(0x0000FFFFu)) | (((amuIntrStatus) << (0x00000000u)) & (0x0000FFFFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_RouteDoorbellInterrupts
 *
 *   @b Description
 *   @n The function routes the doorbell interrupts for the specified doorbell
 *      register to a specific destination.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          regNum            Doorbell Register Number
          doorBellBit       Doorbell bit which is to be routed
          destination       Destination to which the interrupt bit is routed.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_DOORBELL_ICRR1_ICR0,SRIO_RIO_DOORBELL_ICRR1_ICR1,
 *      SRIO_RIO_DOORBELL_ICRR1_ICR2,SRIO_RIO_DOORBELL_ICRR1_ICR3,
 *      SRIO_RIO_DOORBELL_ICRR1_ICR4,SRIO_RIO_DOORBELL_ICRR1_ICR5,
 *      SRIO_RIO_DOORBELL_ICRR1_ICR6,SRIO_RIO_DOORBELL_ICRR1_ICR7;
 *   @n SRIO_RIO_DOORBELL_ICRR2_ICR8,SRIO_RIO_DOORBELL_ICRR2_ICR9,
 *      SRIO_RIO_DOORBELL_ICRR2_ICR10,SRIO_RIO_DOORBELL_ICRR2_ICR11,
 *      SRIO_RIO_DOORBELL_ICRR2_ICR12,SRIO_RIO_DOORBELL_ICRR2_ICR13,
 *      SRIO_RIO_DOORBELL_ICRR2_ICR14,SRIO_RIO_DOORBELL_ICRR2_ICR15
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Route the Doorbell bits 1 for Doorbell 2 to destination 2
        CSL_SRIO_RouteDoorbellInterrupts (hSrio, 2, 1, 2);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_RouteDoorbellInterrupts
(
    CSL_SrioHandle  hSrio, 
    Uint8           regNum,
    Uint8           doorBellBit,
    Uint8           destination
)
{
    if (doorBellBit < 8)
    {
        /* This handles interrupts requests between 0 and 7 */
        ((hSrio->DOORBELL_ICRR[regNum]. RIO_DOORBELL_ICRR1) = ((hSrio->DOORBELL_ICRR[regNum]. RIO_DOORBELL_ICRR1) &~ (((1 << ((((doorBellBit << 2) + 3)) - ((doorBellBit << 2)) + 1)) - 1) << ((doorBellBit << 2)))) | (((destination) & ((1 << ((((doorBellBit << 2) + 3)) - ((doorBellBit << 2)) + 1)) - 1)) << ((doorBellBit << 2))));
    }
    else
    {
        /* This handles interrupts requests between 8 and 15 */
        doorBellBit = doorBellBit - 8;
        ((hSrio->DOORBELL_ICRR[regNum]. RIO_DOORBELL_ICRR2) = ((hSrio->DOORBELL_ICRR[regNum]. RIO_DOORBELL_ICRR2) &~ (((1 << ((((doorBellBit << 2) + 3)) - ((doorBellBit << 2)) + 1)) - 1) << ((doorBellBit << 2)))) | (((destination) & ((1 << ((((doorBellBit << 2) + 3)) - ((doorBellBit << 2)) + 1)) - 1)) << ((doorBellBit << 2))));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_RouteLSUInterrupts
 *
 *   @b Description
 *   @n The function routes the LSU interrupts to a specific destination.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsuIntrReq        LSU Interrupt request which is to be routed
          destination       Destination to which the interrupt bit is routed.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_LSU_ICRR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Route the LSU Interrupts 1 to destination 6
        CSL_SRIO_RouteLSUInterrupts (hSrio, 1, 6);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_RouteLSUInterrupts
(
    CSL_SrioHandle  hSrio, 
    Uint8           lsuIntrReq,
    Uint8           destination
)
{
    if (lsuIntrReq < 8)
    {
        /* This handles interrupts requests between 0 and 7 */
        ((hSrio->RIO_LSU0_MODULE_ICRR[0]) = ((hSrio->RIO_LSU0_MODULE_ICRR[0]) &~ (((1 << ((((lsuIntrReq << 2) + 3)) - ((lsuIntrReq << 2)) + 1)) - 1) << ((lsuIntrReq << 2)))) | (((destination) & ((1 << ((((lsuIntrReq << 2) + 3)) - ((lsuIntrReq << 2)) + 1)) - 1)) << ((lsuIntrReq << 2))));
    }
    else if (lsuIntrReq < 16)
    {
        /* This handles interrupts requests between 8 and 15 */
        lsuIntrReq = lsuIntrReq - 8;
        ((hSrio->RIO_LSU0_MODULE_ICRR[1]) = ((hSrio->RIO_LSU0_MODULE_ICRR[1]) &~ (((1 << ((((lsuIntrReq << 2) + 3)) - ((lsuIntrReq << 2)) + 1)) - 1) << ((lsuIntrReq << 2)))) | (((destination) & ((1 << ((((lsuIntrReq << 2) + 3)) - ((lsuIntrReq << 2)) + 1)) - 1)) << ((lsuIntrReq << 2))));
    }
    else if (lsuIntrReq < 24)
    {
        /* This handles interrupts requests between 16 and 23 */
        lsuIntrReq = lsuIntrReq - 16;
        ((hSrio->RIO_LSU0_MODULE_ICRR[2]) = ((hSrio->RIO_LSU0_MODULE_ICRR[2]) &~ (((1 << ((((lsuIntrReq << 2) + 3)) - ((lsuIntrReq << 2)) + 1)) - 1) << ((lsuIntrReq << 2)))) | (((destination) & ((1 << ((((lsuIntrReq << 2) + 3)) - ((lsuIntrReq << 2)) + 1)) - 1)) << ((lsuIntrReq << 2))));
    }
    else
    {
        /* This handles interrupts requests between 24 and 31 */
        lsuIntrReq = lsuIntrReq - 24;
        ((hSrio->RIO_LSU0_MODULE_ICRR[3]) = ((hSrio->RIO_LSU0_MODULE_ICRR[3]) &~ (((1 << ((((lsuIntrReq << 2) + 3)) - ((lsuIntrReq << 2)) + 1)) - 1) << ((lsuIntrReq << 2)))) | (((destination) & ((1 << ((((lsuIntrReq << 2) + 3)) - ((lsuIntrReq << 2)) + 1)) - 1)) << ((lsuIntrReq << 2))));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_RouteErrorInterrupts
 *
 *   @b Description
 *   @n The function routes the error interrupts to a specific destination.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          errIntrReq        Error Interrupt request which is to be routed
          destination       Destination to which the interrupt bit is routed.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_ERR_RST_EVNT_ICRR_ICR0;SRIO_RIO_ERR_RST_EVNT_ICRR_ICR1;
 *      SRIO_RIO_ERR_RST_EVNT_ICRR_ICR2;
 *   @n SRIO_RIO_ERR_RST_EVNT_ICRR2_ICR8;SRIO_RIO_ERR_RST_EVNT_ICRR2_ICR9;
 *      SRIO_RIO_ERR_RST_EVNT_ICRR2_ICR10;SRIO_RIO_ERR_RST_EVNT_ICRR2_ICR11;
 *   @n SRIO_RIO_ERR_RST_EVNT_ICRR3_ICR16
 *
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Route the Error Interrupts 1 to destination 6
        CSL_SRIO_RouteErrorInterrupts (hSrio, 1, 6);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_RouteErrorInterrupts
(
    CSL_SrioHandle  hSrio, 
    Uint8           errIntrReq,
    Uint8           destination
)
{
    if (errIntrReq < 3)
    {
        /* This handles interrupts requests between 0 and 2 */
        ((hSrio->RIO_ERR_RST_EVNT_ICRR) = ((hSrio->RIO_ERR_RST_EVNT_ICRR) &~ (((1 << ((((errIntrReq << 2) + 3)) - ((errIntrReq << 2)) + 1)) - 1) << ((errIntrReq << 2)))) | (((destination) & ((1 << ((((errIntrReq << 2) + 3)) - ((errIntrReq << 2)) + 1)) - 1)) << ((errIntrReq << 2))));
    }
    else if (errIntrReq < 12)
    {
        /* This handles interrupts requests between 8 and 15; note that 3 to 7 are not used. */
        errIntrReq = errIntrReq - 8;
        ((hSrio->RIO_ERR_RST_EVNT_ICRR2) = ((hSrio->RIO_ERR_RST_EVNT_ICRR2) &~ (((1 << ((((errIntrReq << 2) + 3)) - ((errIntrReq << 2)) + 1)) - 1) << ((errIntrReq << 2)))) | (((destination) & ((1 << ((((errIntrReq << 2) + 3)) - ((errIntrReq << 2)) + 1)) - 1)) << ((errIntrReq << 2))));
    }
    else
    {
        /* This handles interrupts request 16; all else is reserved.*/
        errIntrReq = errIntrReq - 16;
        ((hSrio->RIO_ERR_RST_EVNT_ICRR3) = ((hSrio->RIO_ERR_RST_EVNT_ICRR3) &~ (((1 << ((((errIntrReq << 2) + 3)) - ((errIntrReq << 2)) + 1)) - 1) << ((errIntrReq << 2)))) | (((destination) & ((1 << ((((errIntrReq << 2) + 3)) - ((errIntrReq << 2)) + 1)) - 1)) << ((errIntrReq << 2))));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_RouteAMUInterrupts
 *
 *   @b Description
 *   @n The function routes the AMU interrupts to a specific destination.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          amuIntr           AMU Interrupt request which is to be routed
          destination       Destination to which the interrupt bit is routed.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_AMU_ICRR1_ICR0;SRIO_RIO_AMU_ICRR1_ICR1;SRIO_RIO_AMU_ICRR1_ICR2;
 *      SRIO_RIO_AMU_ICRR1_ICR3;SRIO_RIO_AMU_ICRR1_ICR4;SRIO_RIO_AMU_ICRR1_ICR5;
 *      SRIO_RIO_AMU_ICRR1_ICR6;SRIO_RIO_AMU_ICRR1_ICR7;
 *      SRIO_RIO_AMU_ICRR2_ICR8;SRIO_RIO_AMU_ICRR2_ICR9;SRIO_RIO_AMU_ICRR2_ICR10;
 *      SRIO_RIO_AMU_ICRR2_ICR11;SRIO_RIO_AMU_ICRR2_ICR12;SRIO_RIO_AMU_ICRR2_ICR13;
 *      SRIO_RIO_AMU_ICRR2_ICR14;SRIO_RIO_AMU_ICRR2_ICR15
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Route the AMU Interrupts 1 to destination 6
        CSL_SRIO_RouteAMUInterrupts (hSrio, 1, 6);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_RouteAMUInterrupts
(
    CSL_SrioHandle  hSrio, 
    Uint8           amuIntr,
    Uint8           destination
)
{
    if (amuIntr < 8)
    {
        /* This handles AMU interrupts requests between 0 and 7 */
        ((hSrio->RIO_AMU_ICRR1) = ((hSrio->RIO_AMU_ICRR1) &~ (((1 << ((((amuIntr << 2) + 3)) - ((amuIntr << 2)) + 1)) - 1) << ((amuIntr << 2)))) | (((destination) & ((1 << ((((amuIntr << 2) + 3)) - ((amuIntr << 2)) + 1)) - 1)) << ((amuIntr << 2))));
    }
    else
    {
        /* This handles AMU interrupts requests between 8 and 15.*/
        amuIntr = amuIntr - 8;
        ((hSrio->RIO_AMU_ICRR2) = ((hSrio->RIO_AMU_ICRR2) &~ (((1 << ((((amuIntr << 2) + 3)) - ((amuIntr << 2)) + 1)) - 1) << ((amuIntr << 2)))) | (((destination) & ((1 << ((((amuIntr << 2) + 3)) - ((amuIntr << 2)) + 1)) - 1)) << ((amuIntr << 2))));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDoorbellRoute
 *
 *   @b Description
 *   @n The function gets the doorbell routing information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          route             Routing Information populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_INTERRUPT_CTL_DBLL_ROUTE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           routeInfo;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Doorbell routing information
        CSL_SRIO_GetDoorbellRoute (hSrio, &routeInfo);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDoorbellRoute
(
    CSL_SrioHandle  hSrio, 
    Uint8*          routeInfo
)
{
    *routeInfo = (((hSrio->RIO_INTERRUPT_CTL) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetDoorbellRoute
 *
 *   @b Description
 *   @n The function sets the doorbell routing information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          route             Routing Information to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_INTERRUPT_CTL_DBLL_ROUTE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           routeInfo;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Doorbell routing information to use dedicated interrupts.
        CSL_SRIO_SetDoorbellRoute (hSrio, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetDoorbellRoute
(
    CSL_SrioHandle  hSrio, 
    Uint8           routeInfo
)
{
    hSrio->RIO_INTERRUPT_CTL = (((routeInfo) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetInterruptStatusDecode
 *
 *   @b Description
 *   @n The function gets the interrupt status for a specified interrupt 
 *      destination
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          intrDst           Interrupt Destination for which the status is required.
          status            Decode Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_INTDST_DECODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          status;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Interrupt Status for destination 0
        CSL_SRIO_GetInterruptStatusDecode (hSrio, 0, &status);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetInterruptStatusDecode
(
    CSL_SrioHandle  hSrio, 
    Uint8           intrDst,
    Uint32*         status
)
{
    *status = hSrio->RIO_INTDST_DECODE[intrDst];
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableInterruptPacing
 *
 *   @b Description
 *   @n The function enables interrupt pacing for the specific destination.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          destination       Destination Address for which interrupt pacing is enabled.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;
 *   SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_IO_INTDST_RATE_DIS_RATEN_DIS=0;
 *   SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;
 *   SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=0;
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          rate;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Interrupt Pacing for Destination 4.
        CSL_SRIO_EnableInterruptPacing (hSrio, 4);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableInterruptPacing
(
    CSL_SrioHandle  hSrio, 
    Uint8           destination
)
{
    ((hSrio->RIO_INTDST_RATE_DIS) = ((hSrio->RIO_INTDST_RATE_DIS) &~ (((1 << ((destination) - (destination) + 1)) - 1) << (destination))) | (((0) & ((1 << ((destination) - (destination) + 1)) - 1)) << (destination)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableInterruptPacing
 *
 *   @b Description
 *   @n The function disables interrupt pacing for the specific destination.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          destination       Destination Address for which interrupt pacing is disabled.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;
 *   SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;
 *   SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;
 *   SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1;SRIO_RIO_INTDST_RATE_DIS_RATEN_DIS=1
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          rate;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable Interrupt Pacing for Destination 5.
        CSL_SRIO_DisableInterruptPacing (hSrio, 5);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableInterruptPacing
(
    CSL_SrioHandle  hSrio, 
    Uint8           destination
)
{
    ((hSrio->RIO_INTDST_RATE_DIS) = ((hSrio->RIO_INTDST_RATE_DIS) &~ (((1 << ((destination) - (destination) + 1)) - 1) << (destination))) | (((1) & ((1 << ((destination) - (destination) + 1)) - 1)) << (destination)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetInterruptRate
 *
 *   @b Description
 *   @n The function sets the rate for each interrupt destination.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          destination       Destination Address for which the status is read.
          rate              Interrupt Rate to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_INTDST_RATE_CNT_COUNT_DOWN_VALUE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Interrupt Pacing for Destination 2.
        CSL_SRIO_EnableInterruptPacing (hSrio, 2);
        
        // Set the slowest Interrupt Rate for destination 2.
        CSL_SRIO_SetInterruptRate (hSrio, 2, 0xFFFFFFFF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetInterruptPacing
(
    CSL_SrioHandle  hSrio, 
    Uint8           destination,
    Uint32          rate
)
{
    hSrio->RIO_INTDST_RATE_CNT[destination] = rate; 
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetInterruptPacing
 *
 *   @b Description
 *   @n The function gets the rate for each interrupt destination.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          destination       Destination Address for which the status is read.
          rate              Interrupt Rate to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_INTDST_RATE_CNT_COUNT_DOWN_VALUE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          rate;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Interrupt Pacing for Destination 4.
        CSL_SRIO_EnableInterruptPacing (hSrio, 4);
        ...
        // Get the Interrupt rate for destination 4
        CSL_SRIO_GetInterruptRate (hSrio, 4, &rate);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetInterruptRate
(
    CSL_SrioHandle  hSrio, 
    Uint8           destination,
    Uint32*         rate
)
{
    *rate = hSrio->RIO_INTDST_RATE_CNT[destination];
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetType11PSInfo
 *
 *   @b Description
 *   @n The function creates the type11 protocol specific information.
 *
 *   @b Arguments
     @verbatim
        psInfo      - 8 bytes of PS information populated by this API
        dstID       - Destination Identifier.
        srcId       - Source Identifier.
        mbox        - Mail Box
        ltr         - Letter 
        tt          - Identifies if 8 bit or 16 bit identifiers are to be used.
        ssize       - Standard Message Payload Size
        retryCount  - Total Number of retries allowed for this message.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          psInfo[2];

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
       
        // Create the Protocol Specific Information.
        CSL_SRIO_SetType11PSInfo(psInfo, 0xDEAD, 0xBEED, 0x1, 0x2, 0x1, 0xe, 0x0);

        // Set the PS Information into the Buffer Descriptor.
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetType11PSInfo
(
    Uint32  psInfo[2],
    Uint16  dstId,
    Uint16  srcId,
    Uint8   mbox,
    Uint8   letter,
    Uint8   tt,
    Uint8   ssize,
    Uint8   retryCount
)
{
    psInfo[0] = (((srcId) & ((1 << ((31) - (16) + 1)) - 1)) << (16)) |
                (((dstId) & ((1 << ((15) - (0) + 1)) - 1)) << (0));

    psInfo[1] = (((mbox) & ((1 << ((5) - (0) + 1)) - 1)) << (0))      |
                (((letter) & ((1 << ((8) - (6) + 1)) - 1)) << (6))    |
                (((tt) & ((1 << ((10) - (9) + 1)) - 1)) << (9))        |
                (((ssize) & ((1 << ((20) - (17) + 1)) - 1)) << (17))     |
                (((retryCount) & ((1 << ((26) - (21) + 1)) - 1)) << (21));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ExtractType11PSInfo
 *
 *   @b Description
 *   @n The function extracts the type11 fields from the Protocol Specific 
 *      information.
 *
 *   @b Arguments
     @verbatim
        psInfo      - 8 bytes of PS information from the descriptor
        dstID       - Destination Identifier populated by the API
        srcId       - Source Identifier populated by the API
        mbox        - Mail Box populated by the API
        ltr         - Letter populated by the API
        tt          - Identifies if 8 bit or 16 bit identifiers are being used.
        pri         - Message Priority populated by the API
        cc          - Completion Code populated by the API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          psInfo[2];
        Uint16          dstId;
        Uint16          srcId;
        Uint8           mbox;
        Uint8           letter;
        Uint8           tt;
        Uint8           pri;
        Uint8           cc;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PS Information from the buffer descriptor.
        ...

        // Populate the Type11 fields from the PS Information.
        CSL_SRIO_ExtractType11PSInfo(psInfo, &dstId, &srcId, &mbox, &letter, &tt, &pri, &cc);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ExtractType11PSInfo
(
    Uint32  psInfo[2],
    Uint16* dstId,
    Uint16* srcId,
    Uint8*  mbox,
    Uint8*  letter,
    Uint8*  tt,
    Uint8*  pri,
    Uint8*  cc
)
{
    *srcId    = (((psInfo[0]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
    *dstId    = (((psInfo[0]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
    *mbox     = (((psInfo[1]) >> (0)) & ((1 << ((5) - (0) + 1)) - 1));
    *letter   = (((psInfo[1]) >> (6)) & ((1 << ((8) - (6) + 1)) - 1));
    *tt       = (((psInfo[1]) >> (9)) & ((1 << ((10) - (9) + 1)) - 1));
    *pri      = (((psInfo[1]) >> (11)) & ((1 << ((14) - (11) + 1)) - 1));
    *cc       = (((psInfo[1]) >> (15)) & ((1 << ((16) - (15) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_SRIO_MapMessageToQueue
 *
 *   @b Description
 *   @n The function maps a specific RIO message to the specific queue
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             Index of the MAP register 
          message           Message Information which is compared with incoming
                            packet.
          queueId           Destination Queue to which the message is sent
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_RXU_MAP_L_SRCID,SRIO_RIO_RXU_MAP_L_MBX,SRIO_RIO_RXU_MAP_L_LTR
 *      SRIO_RIO_RXU_MAP_L_MBX_MASK,SRIO_RIO_RXU_MAP_L_LTR_MASK,
 *   @n SRIO_RIO_RXU_MAP_H_SEG_MAP,SRIO_RIO_RXU_MAP_H_SRC_PROM,SRIO_RIO_RXU_MAP_H_TT,
 *      SRIO_RIO_RXU_MAP_H_DEST_PROM,SRIO_RIO_RXU_MAP_H_DEST_ID,
 *   @n SRIO_RIO_RXU_MAP_QID_DEST_QID,SRIO_RIO_RXU_MAP_QID_FLOWID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        SRIO_MESSAGE    message;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        
        message.srcID   = 0xBEEF;
        message.mbx     = 0;
        message.ltr     = 0;
        message.mbxMask = 0;
        message.ltrMask = 0;
        message.segMap  = 0;     // Single Segment 
        message.srcProm = 1;     // Full Access to the Queue for any Source ID
        message.tt      = 1;     // Match 16bits for Source ID.
        message.dstProm = 0;     // Access to the Queue for the specified Destination ID
        message.dstId   = 0xDEAD;// The destination ID which indicates us.
        message.flowId  = 0x0;
               
        // Map the above message to Queue 4. This is the first mapping which is being done
        CSL_SRIO_MapMessageToQueue (hSrio, 0, &message, 4);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_MapMessageToQueue
(
    CSL_SrioHandle  hSrio, 
    Uint8           index,
    SRIO_MESSAGE*   ptrMessage,
    Uint16          queueId
)
{
    /* Initialize the RXU MAPL register. */
    hSrio->RXU_MAP[index].RIO_RXU_MAP_L = 
            (((ptrMessage ->srcId) << (0x00000000u)) & (0x0000FFFFu))            |
            (((ptrMessage ->mbx) << (0x00000010u)) & (0x003F0000u))              |
            (((ptrMessage ->ltr) << (0x00000016u)) & (0x00C00000u))              |
            (((ptrMessage ->mbxMask) << (0x00000018u)) & (0x3F000000u))       |
            (((ptrMessage ->ltrMask) << (0x0000001Eu)) & (0xC0000000u));

    /* Initialize the RXU MAPH register. */
    hSrio->RXU_MAP[index].RIO_RXU_MAP_H =  
            (((ptrMessage ->segMap) << (0x00000000u)) & (0x00000001u))  |
            (((ptrMessage ->srcProm) << (0x00000001u)) & (0x00000002u))       |
            (((ptrMessage ->tt) << (0x0000000Du)) & (0x00006000u))                  |
            (((ptrMessage ->dstProm) << (0x0000000Fu)) & (0x00008000u))      |
            (((ptrMessage ->dstId) << (0x00000010u)) & (0xFFFF0000u));

    /* Initialize the RXU QID register. */
    hSrio->RXU_MAP[index].RIO_RXU_MAP_QID = 
            (((queueId) << (0x00000000u)) & (0x00003FFFu))                 |
            (((ptrMessage ->flowId) << (0x00000010u)) & (0x00FF0000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetMessageToQueueMapping
 *
 *   @b Description
 *   @n The function gets information about the SRIO Message and Queue to which
 *      it is mapped by reading the specified MAP 'index' register.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             Index of the MAP register 
          message           Message Information populated by this API
          queueId           Destination Queue to which the message is mapped 
                            populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_RXU_MAP_L_SRCID,SRIO_RIO_RXU_MAP_L_MBX,SRIO_RIO_RXU_MAP_L_LTR
 *      SRIO_RIO_RXU_MAP_L_MBX_MASK,SRIO_RIO_RXU_MAP_L_LTR_MASK,
 *   @n SRIO_RIO_RXU_MAP_H_SEG_MAP,SRIO_RIO_RXU_MAP_H_SRC_PROM,SRIO_RIO_RXU_MAP_H_TT,
 *      SRIO_RIO_RXU_MAP_H_DEST_PROM,SRIO_RIO_RXU_MAP_H_DEST_ID,
 *   @n SRIO_RIO_RXU_MAP_QID_DEST_QID,SRIO_RIO_RXU_MAP_QID_FLOWID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        SRIO_MESSAGE    message;
        Uint16          queueId;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the mapping information for the 'first' mapping.
        CSL_SRIO_GetMessageToQueueMapping (hSrio, 0, &message, &queueId);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetMessageToQueueMapping
(
    CSL_SrioHandle  hSrio, 
    Uint8           index,
    SRIO_MESSAGE*   ptrMessage,
    Uint16*         queueId
)
{
    Uint32  value;

    /* Get the RXU MAPL register. */
    value = hSrio->RXU_MAP[index].RIO_RXU_MAP_L;
    ptrMessage->srcId   = (((value) & (0x0000FFFFu)) >> (0x00000000u));
    ptrMessage->mbx     = (((value) & (0x003F0000u)) >> (0x00000010u));
    ptrMessage->ltr     = (((value) & (0x00C00000u)) >> (0x00000016u));
    ptrMessage->mbxMask = (((value) & (0x3F000000u)) >> (0x00000018u));
    ptrMessage->ltrMask = (((value) & (0xC0000000u)) >> (0x0000001Eu));

    /* Get the RXU MAPH register. */
    value = hSrio->RXU_MAP[index].RIO_RXU_MAP_H;
    ptrMessage->segMap  = (((value) & (0x00000001u)) >> (0x00000000u));
    ptrMessage->srcProm = (((value) & (0x00000002u)) >> (0x00000001u));
    ptrMessage->tt      = (((value) & (0x00006000u)) >> (0x0000000Du));
    ptrMessage->dstProm = (((value) & (0x00008000u)) >> (0x0000000Fu));
    ptrMessage->dstId   = (((value) & (0xFFFF0000u)) >> (0x00000010u));

    /* Get the RXU QID register. */
    value = hSrio->RXU_MAP[index].RIO_RXU_MAP_QID;
    *queueId = (((value) & (0x00003FFFu)) >> (0x00000000u));
    ptrMessage->flowId = (((value) & (0x00FF0000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetType9PSInfo
 *
 *   @b Description
 *   @n The function creates the type9 protocol specific information.
 *
 *   @b Arguments
     @verbatim
        psInfo      - 8 bytes of PS information populated by this API
        dstID       - Destination Identifier.
        srcId       - Source Identifier.
        cos         - Class of Service 
        cosMask     - Class of Service Mask
        tt          - Identifies if 8 bit or 16 bit identifiers are to be used.
        streamId    - Stream ID for the transaction
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          psInfo[2];

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
       
        // Create the Protocol Specific Information.
        CSL_SRIO_SetType9PSInfo(psInfo, 0xDEAD, 0xBEED, 0x4, 0x1, 0x1, 0xABCD);

        // Set the PS Information into the Buffer Descriptor.
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetType9PSInfo
(
    Uint32  psInfo[2],
    Uint16  dstId,
    Uint16  srcId,
    Uint8   cos,
    Uint8   cosMask,
    Uint8   tt,
    Uint16  streamId
)
{
    psInfo[0] = (((srcId) & ((1 << ((31) - (16) + 1)) - 1)) << (16))     |
                (((dstId) & ((1 << ((15) - (0) + 1)) - 1)) << (0));

    psInfo[1] = (((cos) & ((1 << ((7) - (0) + 1)) - 1)) << (0))       |
                (((cosMask) & ((1 << ((8) - (8) + 1)) - 1)) << (8))   |
                (((tt) & ((1 << ((10) - (9) + 1)) - 1)) << (9))        |
                (((streamId) & ((1 << ((31) - (16) + 1)) - 1)) << (16));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ExtractType9PSInfo
 *
 *   @b Description
 *   @n The function extracts the type9 protocol specific information.
 *
 *   @b Arguments
     @verbatim
        psInfo      - 8 bytes of PS information
        dstID       - Destination Identifier populated by this API
        srcId       - Source Identifier populated by this API
        cos         - Class of Service populated by this API
        cc          - Completion Code populated by this API
        tt          - Identifies if 8 bit or 16 bit identifiers are to be used.
        pri         - Message Priority populated by this API
        streamId    - Stream Id populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          psInfo[2];
        Uint16          dstId;
        Uint16          srcId;
        Uint8           cos;
        Uint8           cc;
        Uint8           tt;
        Uint8           pri;
        Uint16          streamId;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PS Information into the Buffer Descriptor.
        ...

        // Extract the Type9 fields from the PS Information.
        CSL_SRIO_ExtractType9PSInfo(psInfo, &dstId, &srcId, &cos, &cc, &tt, &pri, &streamId);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ExtractType9PSInfo
(
    Uint32  psInfo[2],
    Uint16* dstId,
    Uint16* srcId,
    Uint8*  cos,
    Uint8*  cc,
    Uint8*  tt,
    Uint8*  pri,
    Uint16* streamId
)
{
    *srcId    = (((psInfo[0]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
    *dstId    = (((psInfo[0]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
    *cos      = (((psInfo[1]) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    *cc       = (((psInfo[1]) >> (8)) & ((1 << ((9) - (8) + 1)) - 1));
    *tt       = (((psInfo[1]) >> (10)) & ((1 << ((10) - (10) + 1)) - 1));
    *pri      = (((psInfo[1]) >> (11)) & ((1 << ((14) - (11) + 1)) - 1));
    *streamId = (((psInfo[1]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_SRIO_MapType9MessageToQueue
 *
 *   @b Description
 *   @n The function maps the specific TYPE9 message to the queue
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             Index of the MAP register 
          message           Type9-Message Information 
          queueId           Destination Queue 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_RXU_TYPE9_MAP0_SRCID,SRIO_RIO_RXU_TYPE9_MAP0_COS,
 *      SRIO_RIO_RXU_TYPE9_MAP0_COS_MASK,
 *   @n SRIO_RIO_RXU_TYPE9_MAP1_SRC_PROM,SRIO_RIO_RXU_TYPE9_MAP1_TT,
 *      SRIO_RIO_RXU_TYPE9_MAP1_DEST_PROM,SRIO_RIO_RXU_TYPE9_MAP1_DEST_ID,
 *   @n SRIO_RIO_RXU_TYPE9_MAP2_STRM_ID,SRIO_RIO_RXU_TYPE9_MAP2_STRM_MASK,
 *   @n SRIO_RIO_RXU_MAP_QID_DEST_QID,SRIO_RIO_RXU_MAP_QID_FLOWID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_TYPE9_MESSAGE  message;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        message.srcId      = 0xBEEF;
        message.cos        = 0;
        message.cosMask    = 0;
        message.srcProm    = 0;
        message.tt         = 1; // Match 16bits for Source ID.
        message.dstProm    = 0;
        message.dstId      = 0xDEAD;
        message.streamId   = 0;
        message.streamMask = 0;
        message.flowId     = 0;
               
        // Map the above message to Queue 5. This is the first mapping which is being done
        CSL_SRIO_MapType9MessageToQueue (hSrio, 0, &message, 5);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_MapType9MessageToQueue
(
    CSL_SrioHandle        hSrio, 
    Uint8                 index,
    SRIO_TYPE9_MESSAGE*   ptrMessage,
    Uint16                queueId
)
{
    /* Initialize the RXU TYPE9 MAP0 register. */
    hSrio->RXU_TYPE9_MAP[index].RIO_RXU_TYPE9_MAP0 = 
                (((ptrMessage ->srcId) << (0x00000000u)) & (0x0000FFFFu))     |
                (((ptrMessage ->cos) << (0x00000010u)) & (0x00FF0000u))       |
                (((ptrMessage ->cosMask) << (0x00000018u)) & (0xFF000000u));

    /* Initialize the RXU TYPE9 MAP1 register. */
    hSrio->RXU_TYPE9_MAP[index].RIO_RXU_TYPE9_MAP1 = 
                (((ptrMessage ->srcProm) << (0x00000001u)) & (0x00000002u))   |
                (((ptrMessage ->tt) << (0x0000000Du)) & (0x00006000u))        |
                (((ptrMessage ->dstProm) << (0x0000000Fu)) & (0x00008000u))   |
                (((ptrMessage ->dstId) << (0x00000010u)) & (0xFFFF0000u));

    /* Initialize the RXU TYPE9 MAP2 register. */
    hSrio->RXU_TYPE9_MAP[index].RIO_RXU_TYPE9_MAP2 =
                (((ptrMessage ->streamId) << (0x00000000u)) & (0x0000FFFFu))  |
                (((ptrMessage ->streamMask) << (0x00000010u)) & (0xFFFF0000u));

    /* Initialize the RXU QID register: The specification states that this is shared between Type9 and Type11 */
    hSrio->RXU_MAP[index].RIO_RXU_MAP_QID = 
            (((queueId) << (0x00000000u)) & (0x00003FFFu))                      |
            (((ptrMessage ->flowId) << (0x00000010u)) & (0x00FF0000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetType9MessageToQueueMapping
 *
 *   @b Description
 *   @n The function gets information about the SRIO TYPE9 Message and Queue 
 *      to which it is mapped by reading the specified MAP 'index' register.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             Index of the MAP register 
          message           Type9-Message Information populated by this API 
          queueId           Destination Queue populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_RXU_TYPE9_MAP0_SRCID,SRIO_RIO_RXU_TYPE9_MAP0_COS,
 *      SRIO_RIO_RXU_TYPE9_MAP0_COS_MASK,
 *   @n SRIO_RIO_RXU_TYPE9_MAP1_SRC_PROM,SRIO_RIO_RXU_TYPE9_MAP1_TT,
 *      SRIO_RIO_RXU_TYPE9_MAP1_DEST_PROM,SRIO_RIO_RXU_TYPE9_MAP1_DEST_ID,
 *   @n SRIO_RIO_RXU_TYPE9_MAP2_STRM_ID,SRIO_RIO_RXU_TYPE9_MAP2_STRM_MASK,
 *   @n SRIO_RIO_RXU_MAP_QID_DEST_QID,SRIO_RIO_RXU_MAP_QID_FLOWID   
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_TYPE9_MESSAGE  message;
        Uint16              queueId;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the first mapping information.
        CSL_SRIO_GetType9MessageToQueueMapping (hSrio, 0, &message, &queueId);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetType9MessageToQueueMapping
(
    CSL_SrioHandle        hSrio, 
    Uint8                 index,
    SRIO_TYPE9_MESSAGE*   ptrMessage,
    Uint16*               queueId
)
{
    Uint32  value;

    /* Get the RXU TYPE9 MAP0 register. */
    value = hSrio->RXU_TYPE9_MAP[index].RIO_RXU_TYPE9_MAP0;
    ptrMessage->srcId   = (((value) & (0x0000FFFFu)) >> (0x00000000u));
    ptrMessage->cos     = (((value) & (0x00FF0000u)) >> (0x00000010u));
    ptrMessage->cosMask = (((value) & (0xFF000000u)) >> (0x00000018u));

    /* Get the RXU TYPE9 MAP1 register. */
    value = hSrio->RXU_TYPE9_MAP[index].RIO_RXU_TYPE9_MAP1;
    ptrMessage->srcProm = (((value) & (0x00000002u)) >> (0x00000001u));
    ptrMessage->tt      = (((value) & (0x00006000u)) >> (0x0000000Du));
    ptrMessage->dstProm = (((value) & (0x00008000u)) >> (0x0000000Fu));
    ptrMessage->dstId   = (((value) & (0xFFFF0000u)) >> (0x00000010u));

    /* Get the RXU TYPE9 MAP2 register. */
    value = hSrio->RXU_TYPE9_MAP[index].RIO_RXU_TYPE9_MAP2;
    ptrMessage->streamId   = (((value) & (0x0000FFFFu)) >> (0x00000000u));
    ptrMessage->streamMask = (((value) & (0xFFFF0000u)) >> (0x00000010u));

    /* Get the RXU QID register: This is shared between the Type9 and Type11 */
    value = hSrio->RXU_MAP[index].RIO_RXU_MAP_QID;
    *queueId = (((value) & (0x00003FFFu)) >> (0x00000000u));
    ptrMessage->flowId = (((value) & (0x00FF0000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_MapAMUPrivIdToSourceId
 *
 *   @b Description
 *   @n The function maps the AMU Priv ID to a specific Source ID.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          privId            AMU Priv ID which is being mapped
          srcId             Source ID to which the priv ID is being mapped to.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_AMU_SRCID_MAP_CPRIVID0_8;SRIO_RIO_AMU_SRCID_MAP_CPRIVID1_9; 
 *   @n SRIO_RIO_AMU_SRCID_MAP_CPRIVID2_10;SRIO_RIO_AMU_SRCID_MAP_CPRIVID3_11;
 *   @n SRIO_RIO_AMU_SRCID_MAP_CPRIVID4_12;SRIO_RIO_AMU_SRCID_MAP_CPRIVID5_13;
 *   @n SRIO_RIO_AMU_SRCID_MAP_CPRIVID6_14;SRIO_RIO_AMU_SRCID_MAP_CPRIVID7_15;
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Map the PRIV-ID 1 to Source ID 3
        CSL_SRIO_MapAMUPrivIdToSourceId (hSrio, 1, 5);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_MapAMUPrivIdToSourceId
(
    CSL_SrioHandle  hSrio, 
    Uint8           privId,
    Uint8           srcId
)
{        
    if (privId < 8)
    {
        ((hSrio->RIO_AMU_SRCID_MAP[0]) = ((hSrio->RIO_AMU_SRCID_MAP[0]) &~ (((1 << (((privId << 2) + 3) - ((privId << 2)) + 1)) - 1) << ((privId << 2)))) | (((srcId) & ((1 << (((privId << 2) + 3) - ((privId << 2)) + 1)) - 1)) << ((privId << 2))));
    }
    else
    {
        privId = privId - 8;
        ((hSrio->RIO_AMU_SRCID_MAP[1]) = ((hSrio->RIO_AMU_SRCID_MAP[1]) &~ (((1 << (((privId << 2) + 3) - ((privId << 2)) + 1)) - 1) << ((privId << 2)))) | (((srcId) & ((1 << (((privId << 2) + 3) - ((privId << 2)) + 1)) - 1)) << ((privId << 2))));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAMUPrivIdToSourceIdMapping
 *
 *   @b Description
 *   @n The function gets the mapping of a specific AMU privID to source Id
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          privId            AMU Priv ID for which the mapping is required.
          srcId             Source ID to which the priv ID has been mapped to
                            populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_AMU_SRCID_MAP_CPRIVID0_8;SRIO_RIO_AMU_SRCID_MAP_CPRIVID1_9; 
 *   @n SRIO_RIO_AMU_SRCID_MAP_CPRIVID2_10;SRIO_RIO_AMU_SRCID_MAP_CPRIVID3_11;
 *   @n SRIO_RIO_AMU_SRCID_MAP_CPRIVID4_12;SRIO_RIO_AMU_SRCID_MAP_CPRIVID5_13;
 *   @n SRIO_RIO_AMU_SRCID_MAP_CPRIVID6_14;SRIO_RIO_AMU_SRCID_MAP_CPRIVID7_15;
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               srcId;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the mapping for Priv ID 1
        CSL_SRIO_GetAMUPrivIdToSourceIdMapping (hSrio, 1, &srcId);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAMUPrivIdToSourceIdMapping
(
    CSL_SrioHandle  hSrio, 
    Uint8           privId,
    Uint8*          srcId
)
{
    if (privId < 8)
    {
        *srcId = (((hSrio->RIO_AMU_SRCID_MAP[0]) >> ((privId << 2))) & ((1 << (((privId << 2) + 3) - ((privId << 2)) + 1)) - 1));
    }
    else
    {
        privId = privId - 8;
        *srcId = (((hSrio->RIO_AMU_SRCID_MAP[1]) >> ((privId << 2))) & ((1 << (((privId << 2) + 3) - ((privId << 2)) + 1)) - 1));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_MapVBUSPriorityToRIO
 *
 *   @b Description
 *   @n The function maps the VBUS Priority to RIO Priority.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          vbusPriority      VBUS Priority which is to be mapped
          priority          RIO Priority to be mapped to.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI0;SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI1;
 *   @n SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI2;SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI3;
 *   @n SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI4;SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI5;
 *   @n SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI6;SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI7
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Map the VBUS Priority 0 to CRITICAL Flow High Priority i.e. 7
        CSL_SRIO_MapVBUSPriorityToRIO (hSrio, 0, 7);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_MapVBUSPriorityToRIO
(
    CSL_SrioHandle  hSrio, 
    Uint8           vbusPriority,
    Uint8           priority
)
{
    ((hSrio->RIO_AMU_PRIORITY_MAP) = ((hSrio->RIO_AMU_PRIORITY_MAP) &~ (((1 << (((vbusPriority << 2) + 3) - ((vbusPriority << 2)) + 1)) - 1) << ((vbusPriority << 2)))) | (((priority) & ((1 << (((vbusPriority << 2) + 3) - ((vbusPriority << 2)) + 1)) - 1)) << ((vbusPriority << 2))));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetVBUSPriorityToRIOMapping
 *
 *   @b Description
 *   @n The function gets the mapping between the VBUS Priority to RIO Priority.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          vbusPriority      VBUS Priority for which the mapping is required.
          priority          Priority level populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI0;SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI1;
 *   @n SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI2;SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI3;
 *   @n SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI4;SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI5;
 *   @n SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI6;SRIO_RIO_AMU_PRIORITY_MAP_DMA_PRI7
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               priority;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the RIO Priority Level for VBUS Priority 0
        CSL_SRIO_GetVBUSPriorityToRIOMapping (hSrio, 0, &priority);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetVBUSPriorityToRIOMapping
(
    CSL_SrioHandle  hSrio,
    Uint8           vbusPriority,
    Uint8*          priority
)
{
    *priority = (((hSrio->RIO_AMU_PRIORITY_MAP) >> ((vbusPriority << 2))) & ((1 << (((vbusPriority << 2) + 3) - ((vbusPriority << 2)) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAMUErrorCaptureInfo
 *
 *   @b Description
 *   @n The function is used to get access to the AMU Error capture information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          transAddress      Transaction Address which caused the error.
          privId            Priv ID which caused the error
          mstID             Master ID which caused the error.
          doorbellInfo      Doorbell Info
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_AMU_CAPT0_MAP,SRIO_RIO_AMU_CAPT1_MAP_CPRIVID,
 *      SRIO_RIO_AMU_CAPT1_MAP_CMSTID,SRIO_RIO_AMU_CAPT1_MAP_DOORBELL_INFO
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint32              transAddress;
        Uint8               privId;
        Uint8               mstID;
        Uint16              doorbellInfo;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the AMU Error Capture Information
        CSL_SRIO_GetAMUErrorCaptureInfo (hSrio, &transAddress, &privId, &mstID, &doorbellInfo);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAMUErrorCaptureInfo
(
    CSL_SrioHandle  hSrio,
    Uint32*         transAddress,
    Uint8*          privId,
    Uint8*          mstID,
    Uint16*         doorbellInfo
)
{
    *transAddress = hSrio->RIO_AMU_CAPT0_MAP;
    *privId = (((hSrio->RIO_AMU_CAPT1_MAP) & (0x00000F00u)) >> (0x00000008u));
    *mstID = (((hSrio->RIO_AMU_CAPT1_MAP) & (0x000000FFu)) >> (0x00000000u));
    *doorbellInfo = (((hSrio->RIO_AMU_CAPT1_MAP) & (0xFFFF0000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetAMUWindow
 *
 *   @b Description
 *   @n The function configures the specific AMU Window register
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             AMU Window to be configured
          amuWindow         AMU Window Properties to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_AMU_WINDOW_REG0_XAMBS,SRIO_RIO_AMU_WINDOW_REG0_PANE_COUNT,
 *      SRIO_RIO_AMU_WINDOW_REG0_PANE_SIZE,SRIO_RIO_AMU_WINDOW_REG0_WINDOW_SIZE,
 *      SRIO_RIO_AMU_WINDOW_REG1,SRIO_RIO_AMU_WINDOW_REG2
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_AMU_WINDOW     amuWindow;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure the AMU Window Properties for AMU Window 1
        CSL_SRIO_SetAMUWindow (hSrio, 1, &amuWindow);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetAMUWindow
(
    CSL_SrioHandle      hSrio, 
    Uint8               index,
    SRIO_AMU_WINDOW*    amuWindow
)
{
    /* Configure the Window0 Register. */
    hSrio->AMU_WINDOW[index].RIO_AMU_WINDOW_REG0 = 
                (((amuWindow->xambs) << (0x00000000u)) & (0x00000003u))     |
                (((amuWindow->paneCount) << (0x0000000Au)) & (0x00000C00u)) |
                (((amuWindow->paneSize) << (0x0000000Cu)) & (0x00FFF000u))  |
                (((amuWindow->winSize) << (0x00000018u)) & (0xFF000000u));

    /* Configure the WINDOW1 and WINDOW2 registers. */
    hSrio->AMU_WINDOW[index].RIO_AMU_WINDOW_REG1 = amuWindow->rapidIOMsb;
    hSrio->AMU_WINDOW[index].RIO_AMU_WINDOW_REG2 = amuWindow->rapidIOLsb;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAMUWindow
 *
 *   @b Description
 *   @n The function gets the specific AMU Window register
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             AMU Window Index 
          amuWindow         AMU Window Properties populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_AMU_WINDOW_REG0_XAMBS,SRIO_RIO_AMU_WINDOW_REG0_PANE_COUNT,
 *      SRIO_RIO_AMU_WINDOW_REG0_PANE_SIZE,SRIO_RIO_AMU_WINDOW_REG0_WINDOW_SIZE,
 *      SRIO_RIO_AMU_WINDOW_REG1,SRIO_RIO_AMU_WINDOW_REG2
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_AMU_WINDOW     amuWindow;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the AMU Window Properties for AMU Window 1
        CSL_SRIO_GetAMUWindow (hSrio, 1, &amuWindow);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAMUWindow
(
    CSL_SrioHandle      hSrio, 
    Uint8               index,
    SRIO_AMU_WINDOW*    amuWindow
)
{
    Uint32 value = hSrio->AMU_WINDOW[index].RIO_AMU_WINDOW_REG0;

    /* Get the Window0 Register. */
    amuWindow->xambs     = (((value) & (0x00000003u)) >> (0x00000000u));
    amuWindow->paneCount = (((value) & (0x00000C00u)) >> (0x0000000Au));
    amuWindow->paneSize  = (((value) & (0x00FFF000u)) >> (0x0000000Cu));
    amuWindow->winSize   = (((value) & (0xFF000000u)) >> (0x00000018u));

    /* Get the WINDOW1 and WINDOW2 registers. */
    amuWindow->rapidIOMsb = hSrio->AMU_WINDOW[index].RIO_AMU_WINDOW_REG1;
    amuWindow->rapidIOLsb = hSrio->AMU_WINDOW[index].RIO_AMU_WINDOW_REG2;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetAMUPane
 *
 *   @b Description
 *   @n The function configures the specific AMU Pane
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             AMU Pane to be configured
          amuPane           AMU Pane Properties to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_AMU_WINDOW_PANE_CMD_ENC,SRIO_RIO_AMU_WINDOW_PANE_PORT_ID,
 *      SRIO_RIO_AMU_WINDOW_PANE_ID_SIZE,SRIO_RIO_AMU_WINDOW_PANE_DESTID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_AMU_PANE       amuPane;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure the AMU Pane Properties for AMU Pane 1
        CSL_SRIO_SetAMUPane (hSrio, 1, &amuPane);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetAMUPane
(
    CSL_SrioHandle      hSrio, 
    Uint8               index,
    SRIO_AMU_PANE*      amuPane
)
{
    /* Configure the Pane Register. */
    hSrio->RIO_AMU_WINDOW_PANE[index] = 
            (((amuPane ->cmdEnc) << (0x00000000u)) & (0x00000003u))    |
            (((amuPane ->portId) << (0x00000002u)) & (0x0000000Cu))    |
            (((amuPane ->idSize) << (0x0000000Eu)) & (0x0000C000u))    |
            (((amuPane ->dstID) << (0x00000010u)) & (0xFFFF0000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAMUPane
 *
 *   @b Description
 *   @n The function gets the specific AMU Pane properties
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             AMU Pane Index
          amuPane           AMU Pane Properties populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_AMU_WINDOW_PANE_CMD_ENC,SRIO_RIO_AMU_WINDOW_PANE_PORT_ID,
 *      SRIO_RIO_AMU_WINDOW_PANE_ID_SIZE,SRIO_RIO_AMU_WINDOW_PANE_DESTID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_AMU_PANE       amuPane;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the AMU Pane Properties for AMU Pane 2
        CSL_SRIO_GetAMUPane (hSrio, 2, &amuPane);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAMUPane
(
    CSL_SrioHandle      hSrio, 
    Uint8               index,
    SRIO_AMU_PANE*      amuPane
)
{
    Uint32 value = hSrio->RIO_AMU_WINDOW_PANE[index];

    /* Get the Pane properties. */
    amuPane->cmdEnc = (((value) & (0x00000003u)) >> (0x00000000u));
    amuPane->portId = (((value) & (0x0000000Cu)) >> (0x00000002u));
    amuPane->idSize = (((value) & (0x0000C000u)) >> (0x0000000Eu));
    amuPane->dstID  = (((value) & (0xFFFF0000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetAMUFlowMask
 *
 *   @b Description
 *   @n The function configures the AMU Flow Mask
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          flowMask          Flow Mask to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_AMU_FLOW_MASKS0_AMU_FLOW_MASK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure the AMU Flow Mask
        CSL_SRIO_SetAMUFlowMask (hSrio, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetAMUFlowMask
(
    CSL_SrioHandle      hSrio, 
    Uint16              flowMask
)
{
    hSrio->RIO_AMU_FLOW_MASKS0 = (((flowMask) << (0x00000000u)) & (0x0000FFFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAMUFlowMask
 *
 *   @b Description
 *   @n The function gets the AMU Flow Mask
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          flowMask          Flow Mask to be populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_AMU_FLOW_MASKS0_AMU_FLOW_MASK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint32              flowMask;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the AMU Flow Mask
        CSL_SRIO_GetAMUFlowMask (hSrio, &flowMask);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAMUFlowMask
(
    CSL_SrioHandle      hSrio, 
    Uint16*             flowMask
)
{
    *flowMask = (((hSrio->RIO_AMU_FLOW_MASKS0) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUTransfer
 *
 *   @b Description
 *   @n The function sets the specified LSU for a DIO Transfer.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number which is to be used for the transfer.
          lsuTransfer       LSU Transfer Information 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG0_RIO_ADDRESS_MSB,
 *   @n SRIO_RIO_LSU_REG1_RIO_ADDRESS_LSB,
 *   @n SRIO_RIO_LSU_REG2_DSP_ADDRESS,
 *   @n SRIO_RIO_LSU_REG3_BYTE_COUNT,SRIO_RIO_LSU_REG3_DRBLL_VALUE,
 *   @n SRIO_RIO_LSU_REG4_INT_REQ,SRIO_RIO_LSU_REG4_SUP_GINT,SRIO_RIO_LSU_REG4_XAMBS,
 *   @n SRIO_RIO_LSU_REG4_PRIORITY,SRIO_RIO_LSU_REG4_OUTPORTID,SRIO_RIO_LSU_REG4_ID_SIZE,
 *   @n SRIO_RIO_LSU_REG4_SRCID_MAP,SRIO_RIO_LSU_REG4_DESTID,
 *   @n SRIO_RIO_LSU_REG5_TTYPE,SRIO_RIO_LSU_REG5_FTYPE,SRIO_RIO_LSU_REG5_HOP_COUNT,
 *      SRIO_RIO_LSU_REG5_DRBLL_INFO
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        SRIO_LSU_TRANSFER  lsuTransfer;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Populate the Transfer Information. 
        lsuTransfer.rapidIOMSB    = 0x0;
        lsuTransfer.rapidIOLSB    = (Uint32)&tx_buffer[0];
        lsuTransfer.dspAddress    = (Uint32)&rx_buffer[0];
        lsuTransfer.bytecount     = 256;
        lsuTransfer.doorbellValid = 0;
        lsuTransfer.intrRequest   = 1;
        lsuTransfer.supInt        = 0;
        lsuTransfer.xambs         = 0;
        lsuTransfer.priority      = 2;
        lsuTransfer.outPortID     = 1;
        lsuTransfer.idSize        = 1;
        lsuTransfer.srcIDMap      = 0;
        lsuTransfer.dstID         = 0xDEAD;
        lsuTransfer.ttype         = 4;
        lsuTransfer.ftype         = 5;
        lsuTransfer.hopCount      = 0;
        lsuTransfer.doorbellInfo  = 0;

        // Send the transfer on LSU 1 
        CSL_SRIO_SetLSUTransfer (hSrio, 1, &lsuTransfer);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUTransfer
(
    CSL_SrioHandle      hSrio, 
    Uint8               lsu,
    SRIO_LSU_TRANSFER*  lsuTransfer
)
{
    /* Configure the Source and Destination Address. */
    hSrio->LSU_CMD[lsu].RIO_LSU_REG0 = lsuTransfer->rapidIOMSB;
    hSrio->LSU_CMD[lsu].RIO_LSU_REG1 = lsuTransfer->rapidIOLSB;
    hSrio->LSU_CMD[lsu].RIO_LSU_REG2 = lsuTransfer->dspAddress;

    /* Configure the number of bytes which need to be transferred. */
    hSrio->LSU_CMD[lsu].RIO_LSU_REG3 = 
                (((lsuTransfer->bytecount) << (0x00000000u)) & (0x000FFFFFu))      |
                (((lsuTransfer->doorbellValid) << (0x0000001Fu)) & (0x80000000u));

    /* Configure outgoing port ID, Priority and other RIO parameters. */
    hSrio->LSU_CMD[lsu].RIO_LSU_REG4 = 
            (((lsuTransfer->intrRequest) << (0x00000000u)) & (0x00000001u))  |
            (((lsuTransfer->srcIDMap) << (0x0000000Cu)) & (0x0000F000u))     |
            (((lsuTransfer->supInt) << (0x00000001u)) & (0x00000002u))       |
            (((lsuTransfer->dstID) << (0x00000010u)) & (0xFFFF0000u))        |
            (((lsuTransfer->idSize) << (0x0000000Au)) & (0x00000C00u))       |
            (((lsuTransfer->xambs) << (0x00000002u)) & (0x0000000Cu))        |
            (((lsuTransfer->priority) << (0x00000004u)) & (0x000000F0u))     |
            (((lsuTransfer->outPortID) << (0x00000008u)) & (0x00000300u));

    /* Configure the type of request, doorbell information etc. */
    hSrio->LSU_CMD[lsu].RIO_LSU_REG5 = 
            (((lsuTransfer->ttype) << (0x00000000u)) & (0x0000000Fu))       |
		    (((lsuTransfer->ftype) << (0x00000004u)) & (0x000000F0u))       |
            (((lsuTransfer->hopCount) << (0x00000008u)) & (0x0000FF00u))    |
            (((lsuTransfer->doorbellInfo) << (0x00000010u)) & (0xFFFF0000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUReg0
 *
 *   @b Description
 *   @n The function configures the REG0 of the specified LSU
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number
          rapidIOMSB        Address to be configured in the REG0
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG0_RIO_ADDRESS_MSB
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure REG0 of LSU 0
        CSL_SRIO_SetLSUReg0(hSrio, 0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUReg0
(
    CSL_SrioHandle      hSrio, 
    Uint8               lsu,
    Uint32              rapidIOMSB
)
{
    hSrio->LSU_CMD[lsu].RIO_LSU_REG0 = rapidIOMSB;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUReg1
 *
 *   @b Description
 *   @n The function configures the REG1 of the specified LSU
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number
          rapidIOLSB        Address to be configured in the REG1
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG1_RIO_ADDRESS_LSB
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure REG1 of LSU 0
        CSL_SRIO_SetLSUReg1(hSrio, 0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUReg1
(
    CSL_SrioHandle      hSrio, 
    Uint8               lsu,
    Uint32              rapidIOLSB
)
{
    hSrio->LSU_CMD[lsu].RIO_LSU_REG1 = rapidIOLSB;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUReg2
 *
 *   @b Description
 *   @n The function configures the REG2 of the specified LSU
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number
          dspAddress        Address to be configured in the REG2
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG2_DSP_ADDRESS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;       

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure REG2 of LSU 0
        CSL_SRIO_SetLSUReg2(hSrio, 0, &myBuffer);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUReg2
(
    CSL_SrioHandle      hSrio, 
    Uint8               lsu,
    Uint32              dspAddress
)
{
    hSrio->LSU_CMD[lsu].RIO_LSU_REG2 = dspAddress;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUReg3
 *
 *   @b Description
 *   @n The function configures the REG3 of the specified LSU
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number
          byteCount         Byte Count
          doorbellValid     Doorbell valid flag 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG3_BYTE_COUNT,SRIO_RIO_LSU_REG3_DRBLL_VALUE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;       

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure REG3 of LSU 0
        CSL_SRIO_SetLSUReg3(hSrio, 0, 100, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUReg3
(
    CSL_SrioHandle      hSrio, 
    Uint8               lsu,
    Uint32              byteCount,
    Uint8               doorbellValid
)
{
    hSrio->LSU_CMD[lsu].RIO_LSU_REG3 = 
                (((byteCount) << (0x00000000u)) & (0x000FFFFFu))      |
                (((doorbellValid) << (0x0000001Fu)) & (0x80000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUReg4
 *
 *   @b Description
 *   @n The function configures the REG4 of the specified LSU
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number
          byteCount         Byte Count
          doorbellValid     Doorbell valid flag 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG4_DESTID, SRIO_RIO_LSU_REG4_SRCID_MAP, SRIO_RIO_LSU_REG4_ID_SIZE,
 *   @n SRIO_RIO_LSU_REG4_OUTPORTID, SRIO_RIO_LSU_REG4_PRIORITY, SRIO_RIO_LSU_REG4_XAMBS,
 *   @n SRIO_RIO_LSU_REG4_SUP_GINT, SRIO_RIO_LSU_REG4_INT_REQ
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;       

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure REG4 of LSU 0
        CSL_SRIO_SetLSUReg4(hSrio, 0, 0xBEEF, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUReg4
(
    CSL_SrioHandle      hSrio, 
    Uint8               lsu,
    Uint16              dstId,
    Uint8               srcIdMap,
    Uint8               idSize,
    Uint8               outPortId,
    Uint8               priority,
    Uint8               xambs,
    Uint8               supGoodInt,
    Uint8               intRequest
)
{
    hSrio->LSU_CMD[lsu].RIO_LSU_REG4 = 
            (((intRequest) << (0x00000000u)) & (0x00000001u))    |
            (((srcIdMap) << (0x0000000Cu)) & (0x0000F000u))      |
            (((supGoodInt) << (0x00000001u)) & (0x00000002u))    |
            (((dstId) << (0x00000010u)) & (0xFFFF0000u))         |
            (((idSize) << (0x0000000Au)) & (0x00000C00u))        |
            (((xambs) << (0x00000002u)) & (0x0000000Cu))         |
            (((priority) << (0x00000004u)) & (0x000000F0u))      |
            (((outPortId) << (0x00000008u)) & (0x00000300u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUReg5
 *
 *   @b Description
 *   @n The function configures the REG5 of the specified LSU
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number
          ttype             TTYPE value
          ftype             FTYPE value
          hopCount          Hop Count
          doorBellInfo      Doorbell Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG5_TTYPE,     SRIO_RIO_LSU_REG5_FTYPE,
 *   @n SRIO_RIO_LSU_REG5_HOP_COUNT, SRIO_RIO_LSU_REG5_DRBLL_INFO
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;       

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Configure REG5 of LSU 0
        CSL_SRIO_SetLSUReg5(hSrio, 0, 4, 5, 1, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUReg5
(
    CSL_SrioHandle      hSrio, 
    Uint8               lsu,
    Uint8               ttype,
    Uint8               ftype,
    Uint8               hopCount,
    Uint16              doorbellInfo
)
{
    hSrio->LSU_CMD[lsu].RIO_LSU_REG5 = 
            (((ttype) << (0x00000000u)) & (0x0000000Fu))       |
		    (((ftype) << (0x00000004u)) & (0x000000F0u))       |
            (((hopCount) << (0x00000008u)) & (0x0000FF00u))    |
            (((doorbellInfo) << (0x00000010u)) & (0xFFFF0000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsLSUFull
 *
 *   @b Description
 *   @n The function checks if the specific LSU is BUSY or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number which is to checked
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - All the LSU Shadow Registers are being used
 *   @n FALSE - There is space in the LSU Shadow Registers
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LSU_REG6_FULL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        SRIO_LSU_TRANSFER  lsuTransfer;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...

        // Wait around till there is space to write 
        while (1)
        {
            if (CSL_SRIO_IsLSUFull (hSrio, 1) == FALSE)
                break;
        }
        
        // Populate the Transfer Information. 
        lsuTransfer.rapidIOMSB    = 0x0;
        lsuTransfer.rapidIOLSB    = (Uint32)&tx_buffer[0];
        lsuTransfer.dspAddress    = (Uint32)&rx_buffer[0];
        lsuTransfer.bytecount     = 256;
        lsuTransfer.doorbellValid = 0;
        lsuTransfer.intrRequest   = 1;
        lsuTransfer.supInt        = 0;
        lsuTransfer.xambs         = 0;
        lsuTransfer.priority      = 2;
        lsuTransfer.outPortID     = 1;
        lsuTransfer.idSize        = 1;
        lsuTransfer.srcIDMap      = 0;
        lsuTransfer.dstID         = 0xDEAD;
        lsuTransfer.ttype         = 4;
        lsuTransfer.ftype         = 5;
        lsuTransfer.hopCount      = 0;
        lsuTransfer.doorbellInfo  = 0;

        // Send the transfer on LSU 1 
        CSL_SRIO_SetLSUTransfer (hSrio, 1, &lsuTransfer);

     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsLSUFull
(
    CSL_SrioHandle  hSrio, 
    Uint8           lsu
)
{
    if ((((hSrio->LSU_CMD[lsu]. RIO_LSU_REG6) & (0x40000000u)) >> (0x0000001Eu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsLSUBusy
 *
 *   @b Description
 *   @n The function checks if the specific LSU is BUSY or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number which is to checked
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - LSU is Busy
 *   @n FALSE - LSU is Free
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LSU_REG6_BUSY
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        SRIO_LSU_TRANSFER  lsuTransfer;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Populate the Transfer Information. 
        lsuTransfer.rapidIOMSB    = 0x0;
        lsuTransfer.rapidIOLSB    = (Uint32)&tx_buffer[0];
        lsuTransfer.dspAddress    = (Uint32)&rx_buffer[0];
        lsuTransfer.bytecount     = 256;
        lsuTransfer.doorbellValid = 0;
        lsuTransfer.intrRequest   = 1;
        lsuTransfer.supInt        = 0;
        lsuTransfer.xambs         = 0;
        lsuTransfer.priority      = 2;
        lsuTransfer.outPortID     = 1;
        lsuTransfer.idSize        = 1;
        lsuTransfer.srcIDMap      = 0;
        lsuTransfer.dstID         = 0xDEAD;
        lsuTransfer.ttype         = 4;
        lsuTransfer.ftype         = 5;
        lsuTransfer.hopCount      = 0;
        lsuTransfer.doorbellInfo  = 0;

        // Send the transfer on LSU 1 
        CSL_SRIO_SetLSUTransfer (hSrio, 1, &lsuTransfer);

        // Wait around till the transfer is completed.
        while (1)
        {
            if (CSL_SRIO_IsLSUBusy (hSrio, 1) == FALSE)
                break;
        }

        // Control comes here indicating that the transfer was completed.
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsLSUBusy
(
    CSL_SrioHandle  hSrio, 
    Uint8           lsu
)
{
    if ((((hSrio->LSU_CMD[lsu]. RIO_LSU_REG6) & (0x80000000u)) >> (0x0000001Fu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLSUContextTransaction
 *
 *   @b Description
 *   @n The function gets the LSU Context bit which can be used by the 
 *      transaction to identify if the context of the completion code is with 
 *      respect to the current transaction or not
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Index
          context           Context Information populated by this API 
          transID           Transaction ID populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LSU_REG6_LCB,SRIO_RIO_LSU_REG6_LTID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint8              context;
        Uint8              transID;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the LSU Context and Transaction Information.
        CSL_SRIO_GetLSUContextTransaction (hSrio, &context, &transID);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLSUContextTransaction
(
    CSL_SrioHandle  hSrio, 
    Uint8           lsu,
    Uint8*          context,
    Uint8*          transID
)
{
    Uint32 value = hSrio->LSU_CMD[lsu].RIO_LSU_REG6;

    /* Populate the context and transaction identifier. */
    *context = (((value) & (0x00000010u)) >> (0x00000004u));
    *transID = (((value) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_CancelLSUTransaction
 *
 *   @b Description
 *   @n The function is used to cancel an LSU Transaction previously submitted. 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Index
          privID            Priv ID of the original transaction submitter.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG6_CBUSY = 1,
 *   @n SRIO_RIO_LSU_REG6_PRIVID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Cancel the LSU Transaction for LSU 0 for PRIV-ID 1
        CSL_SRIO_CancelLSUTransaction (hSrio, 0, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_CancelLSUTransaction
(
    CSL_SrioHandle  hSrio, 
    Uint8           lsu,
    Uint8           privID
)
{
    hSrio->LSU_CMD[lsu].RIO_LSU_REG6 = 
            (((1) << (0x0000001Bu)) & (0x08000000u))       |
            (((privID) << (0x0000001Cu)) & (0xF0000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_RestartLSUTransaction
 *
 *   @b Description
 *   @n The function is used to restart an LSU Transaction which had been halted
 *      due to an error condition.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Index which needs to be restarted
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG6_RESTART=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Restart the LSU transaction 1
        CSL_SRIO_RestartLSUTransaction (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_RestartLSUTransaction
(
    CSL_SrioHandle  hSrio, 
    Uint8           lsu
)
{
    hSrio->LSU_CMD[lsu].RIO_LSU_REG6 = (((1) << (0x00000001u)) & (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_FlushLSUTransaction
 *
 *   @b Description
 *   @n The function is used to flush an LSU Transaction previously submitted 
 *      and which matches the SRCID specified here.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Index which needs to be flushed
          srcIDMap          Source ID 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_REG6_SCRID_MAP, SRIO_RIO_LSU_REG6_FLUSH=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Flush the LSU transaction on LSU 1 with SRC ID 0x0 
        CSL_SRIO_FlushLSUTransaction (hSrio, 1, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_FlushLSUTransaction
(
    CSL_SrioHandle  hSrio, 
    Uint8           lsu,
    Uint8           srcIDMap
)
{
    ((hSrio->LSU_CMD[lsu]. RIO_LSU_REG6) = ((hSrio->LSU_CMD[lsu]. RIO_LSU_REG6) & ~(0x0000003Cu)) | (((srcIDMap) << (0x00000002u)) & (0x0000003Cu)));
    ((hSrio->LSU_CMD[lsu]. RIO_LSU_REG6) = ((hSrio->LSU_CMD[lsu]. RIO_LSU_REG6) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUShadowRegs
 *
 *   @b Description
 *   @n The function is used to configure the number of LSU Shadow Registers.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          shadowGrp0        Number of Shadow Registers associated with LSU0-3
          shadowGrp1        Number of Shadow Registers associated with LSU4-7
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_SETUP_REG0_SHADOW_GRP0, SRIO_RIO_LSU_SETUP_REG0_SHADOW_GRP1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the LSU Shadow Regs as 4 for LSU 0-3 and 4 for LSU 4-7
        CSL_SRIO_SetLSUShadowRegs (hSrio, 0x0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUShadowRegs
(
    CSL_SrioHandle  hSrio,
    Uint32          shadowGrp0,
    Uint32          shadowGrp1
)
{
    hSrio->RIO_LSU_SETUP_REG0 = (((shadowGrp0) << (0x00000000u)) & (0x0000001Fu)) |
                                (((shadowGrp1) << (0x00000010u)) & (0x001F0000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLSUShadowRegs
 *
 *   @b Description
 *   @n The function is used to get the number of shadow registers associated
 *      with each LSU.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Index for which the count is required
          count             Number of Shadow Registers associated with the specified LSU
                            populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LSU_SETUP_REG0_LSU0_CNT;SRIO_RIO_LSU_SETUP_REG0_LSU1_CNT;
 *      SRIO_RIO_LSU_SETUP_REG0_LSU2_CNT;SRIO_RIO_LSU_SETUP_REG0_LSU3_CNT;
 *      SRIO_RIO_LSU_SETUP_REG0_LSU4_CNT;SRIO_RIO_LSU_SETUP_REG0_LSU5_CNT;
 *      SRIO_RIO_LSU_SETUP_REG0_LSU6_CNT;SRIO_RIO_LSU_SETUP_REG0_LSU7_CNT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint8              count;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the number of shadow register for LSU 1 
        CSL_SRIO_GetLSUShadowRegs (hSrio, 1, &count);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLSUShadowRegs
(
    CSL_SrioHandle  hSrio,
    Uint8           index,
    Uint8*          count
)
{
    if (index == 0)
       *count = (((hSrio->RIO_LSU_SETUP_REG0) & (0x0000000Fu)) >> (0x00000000u));
    else if (index == 1)
       *count = (((hSrio->RIO_LSU_SETUP_REG0) & (0x000000F0u)) >> (0x00000004u));
    else if (index == 2)
       *count = (((hSrio->RIO_LSU_SETUP_REG0) & (0x00000F00u)) >> (0x00000008u));
    else if (index == 3)
       *count = (((hSrio->RIO_LSU_SETUP_REG0) & (0x0000F000u)) >> (0x0000000Cu));
    else if (index == 4)
       *count = (((hSrio->RIO_LSU_SETUP_REG0) & (0x000F0000u)) >> (0x00000010u));
    else if (index == 5)
       *count = (((hSrio->RIO_LSU_SETUP_REG0) & (0x00F00000u)) >> (0x00000014u));
    else if (index == 6)
       *count = (((hSrio->RIO_LSU_SETUP_REG0) & (0x0F000000u)) >> (0x00000018u));
    else if (index == 7)
       *count = (((hSrio->RIO_LSU_SETUP_REG0) & (0xF0000000u)) >> (0x0000001Cu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableSrcIDInterrupts
 *
 *   @b Description
 *   @n The function is used to enable the LSU interrupts to based on the SRCID
 *      and not on the LSU specific interrupt bit.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             LSU Index to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=0;SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=0;
 *   @n SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=0;SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=0;
 *   @n SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=06;SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=0;
 *   @n SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Enable Source ID interrupts for LSU 1
        CSL_SRIO_EnableSrcIDInterrupts (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableSrcIDInterrupts
(
    CSL_SrioHandle  hSrio,
    Uint8           index
)
{
    if (index == 0)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((0) - (0) + 1)) - 1) << (0))) | (((0) & ((1 << ((0) - (0) + 1)) - 1)) << (0)));
    else if (index == 1)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((1) - (1) + 1)) - 1) << (1))) | (((0) & ((1 << ((1) - (1) + 1)) - 1)) << (1)));
    else if (index == 2)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((2) - (2) + 1)) - 1) << (2))) | (((0) & ((1 << ((2) - (2) + 1)) - 1)) << (2)));
    else if (index == 3)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((3) - (3) + 1)) - 1) << (3))) | (((0) & ((1 << ((3) - (3) + 1)) - 1)) << (3)));
    else if (index == 4)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((4) - (4) + 1)) - 1) << (4))) | (((0) & ((1 << ((4) - (4) + 1)) - 1)) << (4)));
    else if (index == 5)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((5) - (5) + 1)) - 1) << (5))) | (((0) & ((1 << ((5) - (5) + 1)) - 1)) << (5)));
    else if (index == 6)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((6) - (6) + 1)) - 1) << (6))) | (((0) & ((1 << ((6) - (6) + 1)) - 1)) << (6)));
    else if (index == 7)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((7) - (7) + 1)) - 1) << (7))) | (((0) & ((1 << ((7) - (7) + 1)) - 1)) << (7)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableSrcIDInterrupts
 *
 *   @b Description
 *   @n The function is used to enable the LSU interrupts to based on the LSU 
 *      specific interrupt bit and not on the SRCID.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          index             LSU Index to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=1;SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=2;
 *   @n SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=4;SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=8;
 *   @n SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=16;SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=32;
 *   @n SRIO_RIO_LSU_SETUP_REG1_LSU_EDMA=64
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Disable SRC ID interrupts for LSU 2
        CSL_SRIO_DisableSrcIDInterrupts (hSrio, 2);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableSrcIDInterrupts
(
    CSL_SrioHandle  hSrio,
    Uint8           index
)
{
    if (index == 0)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((0) - (0) + 1)) - 1) << (0))) | (((1) & ((1 << ((0) - (0) + 1)) - 1)) << (0)));
    else if (index == 1)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((1) - (1) + 1)) - 1) << (1))) | (((1) & ((1 << ((1) - (1) + 1)) - 1)) << (1)));
    else if (index == 2)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((2) - (2) + 1)) - 1) << (2))) | (((1) & ((1 << ((2) - (2) + 1)) - 1)) << (2)));
    else if (index == 3)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((3) - (3) + 1)) - 1) << (3))) | (((1) & ((1 << ((3) - (3) + 1)) - 1)) << (3)));
    else if (index == 4)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((4) - (4) + 1)) - 1) << (4))) | (((1) & ((1 << ((4) - (4) + 1)) - 1)) << (4)));
    else if (index == 5)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((5) - (5) + 1)) - 1) << (5))) | (((1) & ((1 << ((5) - (5) + 1)) - 1)) << (5)));
    else if (index == 6)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((6) - (6) + 1)) - 1) << (6))) | (((1) & ((1 << ((6) - (6) + 1)) - 1)) << (6)));
    else if (index == 7)
       ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) &~ (((1 << ((7) - (7) + 1)) - 1) << (7))) | (((1) & ((1 << ((7) - (7) + 1)) - 1)) << (7)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTimeoutCnt
 *
 *   @b Description
 *   @n The function is used to set the number of timecode changes after an error
 *      condition before the current LSU transaction is discarded and a new 
 *      transaction is loaded from the shadow register.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          timeoutCnt        Time out count to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_SETUP_REG1_TIMEOUT_CNT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the Timeout Count to be 1
        CSL_SRIO_SetTimeoutCnt (hSrio, 2);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTimeoutCnt
(
    CSL_SrioHandle  hSrio,
    Uint8           timeoutCnt
)
{
    ((hSrio->RIO_LSU_SETUP_REG1) = ((hSrio->RIO_LSU_SETUP_REG1) & ~(0x00000300u)) | (((timeoutCnt) << (0x00000008u)) & (0x00000300u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTimeoutCnt
 *
 *   @b Description
 *   @n The function is used to get the number of timecode changes after an error
 *      condition before the current LSU transaction is discarded and a new 
 *      transaction is loaded from the shadow register.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          timeoutCnt        Time out count to be populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LSU_SETUP_REG1_TIMEOUT_CNT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint8              timeoutCnt;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the Timeout Count
        CSL_SRIO_GetTimeoutCnt (hSrio, &timeoutCnt);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTimeoutCnt
(
    CSL_SrioHandle  hSrio,
    Uint8*          timeoutCnt
)
{
    *timeoutCnt = (((hSrio->RIO_LSU_SETUP_REG1) & (0x00000300u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLSUCompletionCode
 *
 *   @b Description
 *   @n The function gets the completion code for a previous executed transfer.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number which is to checked
          transId           Transaction ID for which the completion code is
                            required.
          compCode          Completion Code populated by this API
          contextBit        Context Bit populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n  SRIO_LSU_STAT_REG
 
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint8              context;
        Uint8              transID;
        SRIO_LSU_TRANSFER  lsuTransfer;
        Uint8              compCode;
        Uint8              contextBit;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the LSU Context and Transaction Information.
        CSL_SRIO_GetLSUContextTransaction (hSrio, &context, &transID);
        ...
        // Send the transfer on LSU 1 
        CSL_SRIO_SetLSUTransfer (hSrio, 1, &lsuTransfer);

        // Wait around till the transfer is completed.
        while (1)
        {
            if (CSL_SRIO_IsLSUBusy (hSrio, 1) == FALSE)
                break;
        }
        // Get the completion code.
        CSL_SRIO_GetLSUCompletionCode (hSrio, 1, transID, &compCode, &contextBit);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLSUCompletionCode
(
    CSL_SrioHandle  hSrio, 
    Uint8           lsu,
    Uint8           transID,
    Uint8*          compCode,
    Uint8*          contextBit
)
{
    Uint8   lsuRegIndex;

    /* Check the LSU for which the completion code is required. */
    if ((lsu == 0) || (lsu == 4))
    {
        /* LSU0 or LSU4: Determine which register index we need to access.
         *  For LSU0 the register index is 0 and 1; but for LSU4 the register index is 3 and 4 */
        if (lsu == 0)
            lsuRegIndex = 0;
        else
            lsuRegIndex = 3;

        /* There are 9 pending LSU Transaction ID for this. */
        if (transID < 8)
        {
            /* Transaction ID 0-7 are handled here. */
            *compCode   = (((hSrio->LSU_STAT_REG[lsuRegIndex]) >> (((transID << 2) + 1))) & ((1 << ((((transID << 2) + 3)) - (((transID << 2) + 1)) + 1)) - 1));
            *contextBit = (((hSrio->LSU_STAT_REG[lsuRegIndex]) >> ((transID << 2))) & ((1 << (((transID << 2)) - ((transID << 2)) + 1)) - 1));
        }
        else
        {
            /* Transaction ID 8 is handled here. */
            *compCode   = (((hSrio->LSU_STAT_REG[lsuRegIndex+1]) >> (1)) & ((1 << ((3) - (1) + 1)) - 1));
            *contextBit = (((hSrio->LSU_STAT_REG[lsuRegIndex+1]) >> (0)) & ((1 << ((0) - (0) + 1)) - 1));
        }
    }
    else if ((lsu == 1) || (lsu == 5))
    {
        /* LSU1 or LSU5: Determine which register index we need to access.
         *  For LSU1 the register index is 1; but for LSU5 the register index is 4 */
        if (lsu == 1)
            lsuRegIndex = 1;
        else
            lsuRegIndex = 4;

        /* There are 6 pending LSU Transaction ID for this. */
        *compCode   = (((hSrio->LSU_STAT_REG[lsuRegIndex]) >> (((transID << 2) + 5))) & ((1 << ((((transID << 2) + 7)) - (((transID << 2) + 5)) + 1)) - 1));
        *contextBit = (((hSrio->LSU_STAT_REG[lsuRegIndex]) >> (((transID << 2) + 4))) & ((1 << ((((transID << 2) + 4)) - (((transID << 2) + 4)) + 1)) - 1));
    }
    else if ((lsu == 2) || (lsu == 6))
    {
        /* LSU2 or LSU6: Determine which register index we need to access.
         *  For LSU2 the register index is 1 and 2; but for LSU5 the register index is 4 and 5 */
        if (lsu == 2)
            lsuRegIndex = 1;
        else
            lsuRegIndex = 4;

        /* There are 5 pending LSU Transaction ID for this. */
        if (transID == 0)
        {
            /* Transaction ID 0 is handled here. */
            *compCode   = (((hSrio->LSU_STAT_REG[lsuRegIndex]) >> (29)) & ((1 << ((31) - (29) + 1)) - 1));
            *contextBit = (((hSrio->LSU_STAT_REG[lsuRegIndex]) >> (28)) & ((1 << ((28) - (28) + 1)) - 1));
        }
        else
        {
            /* Transaction ID 1-4 are handled here. */
            *compCode   = (((hSrio->LSU_STAT_REG[lsuRegIndex+1]) >> (((transID << 2) - 3))) & ((1 << ((((transID << 2) - 1)) - (((transID << 2) - 3)) + 1)) - 1));
            *contextBit = (((hSrio->LSU_STAT_REG[lsuRegIndex+1]) >> (((transID << 2) - 4))) & ((1 << ((((transID << 2) - 4)) - (((transID << 2) - 4)) + 1)) - 1));
        }
    }
    else if ((lsu == 3) || (lsu == 7))
    {
        /* LSU3 or LSU7: Determine which register index we need to access.
         *  For LSU3 the register index is 2; but for LSU5 the register index is 5 */
        if (lsu == 3)
            lsuRegIndex = 2;
        else
            lsuRegIndex = 5;

        /* There are 4 pending LSU Transaction ID for this. */
        *compCode   = (((hSrio->LSU_STAT_REG[lsuRegIndex]) >> (((transID << 2) + 17))) & ((1 << ((((transID << 2) + 19)) - (((transID << 2) + 17)) + 1)) - 1));
        *contextBit = (((hSrio->LSU_STAT_REG[lsuRegIndex]) >> (((transID << 2) + 16))) & ((1 << ((((transID << 2) + 16)) - (((transID << 2) + 16)) + 1)) - 1));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLSUFlowMask
 *
 *   @b Description
 *   @n The function is used to set the LSU Flow Masks
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number for which flow mask is to be configured          
          flowMask          Flow Mask to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LSU_FLOW_MASKS_LSU_EVEN_FLOW_MASK;SRIO_RIO_LSU_FLOW_MASKS_LSU_ODD_FLOW_MASK 
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the LSU Flow Mask for LSU 0 to use Flow 1
        CSL_SRIO_SetLSUFlowMask (hSrio, 0, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLSUFlowMask
(
    CSL_SrioHandle  hSrio,
    Uint8           lsu,
    Uint16          flowMask
)
{
    switch (lsu)
    {
        case 0:
        {
            ((hSrio->RIO_LSU_FLOW_MASKS[0]) = ((hSrio->RIO_LSU_FLOW_MASKS[0]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 1:
        {
            ((hSrio->RIO_LSU_FLOW_MASKS[0]) = ((hSrio->RIO_LSU_FLOW_MASKS[0]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 2:
        {
            ((hSrio->RIO_LSU_FLOW_MASKS[1]) = ((hSrio->RIO_LSU_FLOW_MASKS[1]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 3:
        {
            ((hSrio->RIO_LSU_FLOW_MASKS[1]) = ((hSrio->RIO_LSU_FLOW_MASKS[1]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 4:
        {
            ((hSrio->RIO_LSU_FLOW_MASKS[2]) = ((hSrio->RIO_LSU_FLOW_MASKS[2]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 5:
        {
            ((hSrio->RIO_LSU_FLOW_MASKS[2]) = ((hSrio->RIO_LSU_FLOW_MASKS[2]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 6:
        {
            ((hSrio->RIO_LSU_FLOW_MASKS[3]) = ((hSrio->RIO_LSU_FLOW_MASKS[3]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 7:
        {
            ((hSrio->RIO_LSU_FLOW_MASKS[3]) = ((hSrio->RIO_LSU_FLOW_MASKS[3]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLSUFlowMask
 *
 *   @b Description
 *   @n The function is used to get the LSU Flow Masks
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          lsu               LSU Number for which flow mask is to be retreived.
          flowMask          Flow Mask to be populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LSU_FLOW_MASKS_LSU_FLOW_MASK 
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint16             flowMask;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the LSU Flow Mask for LSU 0 
        CSL_SRIO_GetLSUFlowMask (hSrio, 0, &flowMask);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLSUFlowMask
(
    CSL_SrioHandle  hSrio,
    Uint8           lsu,
    Uint16*         flowMask
)
{
    switch (lsu)
    {
        case 0:
        {
            *flowMask = (((hSrio->RIO_LSU_FLOW_MASKS[0]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 1:
        {
            *flowMask = (((hSrio->RIO_LSU_FLOW_MASKS[0]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 2:
        {
            *flowMask = (((hSrio->RIO_LSU_FLOW_MASKS[1]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 3:
        {
            *flowMask = (((hSrio->RIO_LSU_FLOW_MASKS[1]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 4:
        {
            *flowMask = (((hSrio->RIO_LSU_FLOW_MASKS[2]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 5:
        {
            *flowMask = (((hSrio->RIO_LSU_FLOW_MASKS[2]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 6:
        {
            *flowMask = (((hSrio->RIO_LSU_FLOW_MASKS[3]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 7:
        {
            *flowMask = (((hSrio->RIO_LSU_FLOW_MASKS[3]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetSupervisorPerms
 *
 *   @b Description
 *   @n The function is used to set the supervisor permissions
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          supervisor16ID    16 bit Supervisor ID
          supervisor8ID     8 bit Supervisor ID
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SUPERVISOR_ID_16B_SUPRVSR_ID,SRIO_RIO_SUPERVISOR_ID_8B_SUPRVSR_ID 
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the Supervisor Permissions for Source ID 0xBEEF
        CSL_SRIO_SetSupervisorPerms (hSrio, 0xBEEF, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetSupervisorPerms
(
    CSL_SrioHandle  hSrio,
    Uint16          supervisor16ID,
    Uint8           supervisor8ID
)
{
    hSrio->RIO_SUPERVISOR_ID = (((supervisor16ID) << (0x00000000u)) & (0x0000FFFFu)) | 
                               (((supervisor8ID) << (0x00000010u)) & (0x00FF0000u)); 
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetSupervisorPerms
 *
 *   @b Description
 *   @n The function is used to get the supervisor source ID.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          supervisor16ID    16 bit Supervisor ID populated by this API
          supervisor8ID     8 bit Supervisor ID populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SUPERVISOR_ID_16B_SUPRVSR_ID,SRIO_RIO_SUPERVISOR_ID_8B_SUPRVSR_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint8              super8ID;
        Uint16             super16ID;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the Supervisor Permissions.
        CSL_SRIO_GetSupervisorPerms (hSrio, &super16ID, &super8ID);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetSupervisorPerms
(
    CSL_SrioHandle  hSrio,
    Uint16*         supervisor16ID,
    Uint8*          supervisor8ID
)
{
    *supervisor16ID = (((hSrio->RIO_SUPERVISOR_ID) & (0x0000FFFFu)) >> (0x00000000u));
    *supervisor8ID  = (((hSrio->RIO_SUPERVISOR_ID) & (0x00FF0000u)) >> (0x00000010u)); 
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetFlowControl
 *
 *   @b Description
 *   @n The function is used to set the RIO flow control.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          flowControlIdx    Flow Control Index which is to be configured. 
          tt                Flag which defines 16 bit or 8 bit identifiers. Set to
                            1 for 16 bit identifiers 0 for 8 bit.
          dstID             Destination ID matching the flow
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_FLOW_CNTL_TT, SRIO_RIO_FLOW_CNTL_FLOW_CNTL_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the SRIO Flow Control 0 for Destination ID 0xBEEF
        // since the destination ID is 16 bit we set the TT flag as 1
        CSL_SRIO_SetFlowControl (hSrio, 0, 1, 0xBEEF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetFlowControl
(
    CSL_SrioHandle  hSrio,
    Uint8           flowControlIdx,
    Uint8           tt,
    Uint16          dstID
)
{
    hSrio->RIO_FLOW_CNTL[flowControlIdx] = (((dstID) << (0x00000000u)) & (0x0000FFFFu)) | 
                                           (((tt) << (0x00000010u)) & (0x00030000u)); 
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetFlowControl
 *
 *   @b Description
 *   @n The function is used to get the RIO flow control.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          flowControlIdx    Flow Control Index for which the configuration is required.
          tt                Flag which defines 16 bit or 8 bit identifiers populated by
                            the API
          dstID             Destination ID matching the flow populated by the API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_FLOW_CNTL_FLOW_CNTL_ID,SRIO_RIO_FLOW_CNTL_TT 
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint8              tt;
        Uint16             dstID;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the SRIO Flow Control 0 
        CSL_SRIO_GetFlowControl (hSrio, 0, &tt, &dstID);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetFlowControl
(
    CSL_SrioHandle  hSrio,
    Uint8           flowControlIdx,
    Uint8*          tt,
    Uint16*         dstID
)
{
    Uint32 value = hSrio->RIO_FLOW_CNTL[flowControlIdx];

    /* Extract the fields from the RIO Flow Control */
    *dstID = (((value) & (0x0000FFFFu)) >> (0x00000000u));
    *tt    = (((value) & (0x00030000u)) >> (0x00000010u)); 
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTxCPPIFlowMask
 *
 *   @b Description
 *   @n The function is used to set the Transmit CPPI Flow Masks
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          txCPPI            Transmit CPPI Flow Index 
          flowMask          Flow Mask to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TX_CPPI_FLOW_MASKS_TX_QUEUE_EVEN_FLOW_MASK;
 *   @n SRIO_RIO_TX_CPPI_FLOW_MASKS_TX_QUEUE_ODD_FLOW_MASK 
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the Transmit CPPI Flow Mask for 0 to use Flow 1
        CSL_SRIO_SetTxCPPIFlowMask (hSrio, 0, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTxCPPIFlowMask
(
    CSL_SrioHandle  hSrio,
    Uint8           txCPPI,
    Uint16          flowMask
)
{
    switch (txCPPI)
    {
        case 0:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[0]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[0]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 1:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[0]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[0]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 2:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[1]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[1]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 3:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[1]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[1]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 4:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[2]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[2]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 5:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[2]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[2]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 6:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[3]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[3]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 7:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[3]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[3]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 8:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[4]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[4]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 9:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[4]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[4]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 10:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[5]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[5]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 11:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[5]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[5]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 12:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[6]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[6]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 13:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[6]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[6]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }
        case 14:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[7]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[7]) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((flowMask) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
            break;
        }
        case 15:
        {
            ((hSrio->RIO_TX_CPPI_FLOW_MASKS[7]) = ((hSrio->RIO_TX_CPPI_FLOW_MASKS[7]) &~ (((1 << ((31) - (16) + 1)) - 1) << (16))) | (((flowMask) & ((1 << ((31) - (16) + 1)) - 1)) << (16)));
            break;
        }        
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTxCPPIFlowMask
 *
 *   @b Description
 *   @n The function is used to get the Transmit CPPI Flow Masks
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          txCPPI            Transmit CPPI Flow Index 
          flowMask          Flow Mask to be populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_TX_CPPI_FLOW_MASKS_TX_QUEUE_FLOW_MASK 
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint16             flowMask;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the Transmit CPPI Flow Mask for 0 to use Flow 1
        CSL_SRIO_GetTxCPPIFlowMask (hSrio, 0, &flowMask);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTxCPPIFlowMask
(
    CSL_SrioHandle  hSrio,
    Uint8           txCPPI,
    Uint16*         flowMask
)
{
    switch (txCPPI)
    {
        case 0:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[0]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 1:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[0]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 2:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[1]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 3:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[1]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 4:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[2]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 5:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[2]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 6:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[3]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 7:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[3]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 8:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[4]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 9:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[4]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 10:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[5]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 11:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[5]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 12:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[6]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 13:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[6]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
        case 14:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[7]) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
            break;
        }
        case 15:
        {
            *flowMask = (((hSrio->RIO_TX_CPPI_FLOW_MASKS[7]) >> (16)) & ((1 << ((31) - (16) + 1)) - 1));
            break;
        }
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTxQueueSchedInfo
 *
 *   @b Description
 *   @n The function is used to set the port and scheduler information for a 
 *      specific transmit queue.
 *
 *   @b Arguments
     @verbatim
          hSrio       Handle of the SRIO device
          txQueue     Transmit Queue Index for which information is configured.
          portNum     Port Number to which the queue is mapped.
          crf         Critical Resource Flow Value              
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE0_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE1_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE2_INFO; 
 *    SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE0_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE1_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE2_INFO;
 *    SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE0_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE1_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE2_INFO;
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the Tx Queue 0 Scheduler Information
        //  - The Queue needs to be mapped to SRIO Port 1
        //  - The Queue sets the CRF Bit.
        CSL_SRIO_SetTxQueueSchedInfo (hSrio, 0, 1, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTxQueueSchedInfo
(
    CSL_SrioHandle  hSrio,
    Uint8           txQueue,
    Uint8           portNum,
    Uint8           crf
)
{
    if (txQueue < 4)
    {
        /* Transmit Queue 0, 1, 2 and 3 are handed in RIO_TX_QUEUE_SCH_INFO[0] */
        ((hSrio->RIO_TX_QUEUE_SCH_INFO[0]) = ((hSrio->RIO_TX_QUEUE_SCH_INFO[0]) &~ (((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1) << ((txQueue << 3)))) | (((crf) & ((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1)) << ((txQueue << 3))));
        ((hSrio->RIO_TX_QUEUE_SCH_INFO[0]) = ((hSrio->RIO_TX_QUEUE_SCH_INFO[0]) &~ (((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1) << ((txQueue << 3) + 4))) | (((portNum) & ((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1)) << ((txQueue << 3) + 4)));
    }
    else if (txQueue < 8)
    {
        /* Transmit Queue 4, 5, 6 and 7 are handed in RIO_TX_QUEUE_SCH_INFO[1] */
        txQueue = txQueue - 4;

        ((hSrio->RIO_TX_QUEUE_SCH_INFO[1]) = ((hSrio->RIO_TX_QUEUE_SCH_INFO[1]) &~ (((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1) << ((txQueue << 3)))) | (((crf) & ((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1)) << ((txQueue << 3))));
        ((hSrio->RIO_TX_QUEUE_SCH_INFO[1]) = ((hSrio->RIO_TX_QUEUE_SCH_INFO[1]) &~ (((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1) << ((txQueue << 3) + 4))) | (((portNum) & ((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1)) << ((txQueue << 3) + 4)));
    } 
    else if (txQueue < 12)
    {
        /* Transmit Queue 8, 9, 10 and 11 are handed in RIO_TX_QUEUE_SCH_INFO[2] */
        txQueue = txQueue - 8;

        ((hSrio->RIO_TX_QUEUE_SCH_INFO[2]) = ((hSrio->RIO_TX_QUEUE_SCH_INFO[2]) &~ (((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1) << ((txQueue << 3)))) | (((crf) & ((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1)) << ((txQueue << 3))));
        ((hSrio->RIO_TX_QUEUE_SCH_INFO[2]) = ((hSrio->RIO_TX_QUEUE_SCH_INFO[2]) &~ (((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1) << ((txQueue << 3) + 4))) | (((portNum) & ((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1)) << ((txQueue << 3) + 4)));
    } 
    else if (txQueue < 16)
    {
        /* Transmit Queue 12, 13, 14 and 15 are handed in RIO_TX_QUEUE_SCH_INFO[2] */
        txQueue = txQueue - 12;

        ((hSrio->RIO_TX_QUEUE_SCH_INFO[3]) = ((hSrio->RIO_TX_QUEUE_SCH_INFO[3]) &~ (((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1) << ((txQueue << 3)))) | (((crf) & ((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1)) << ((txQueue << 3))));
        ((hSrio->RIO_TX_QUEUE_SCH_INFO[3]) = ((hSrio->RIO_TX_QUEUE_SCH_INFO[3]) &~ (((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1) << ((txQueue << 3) + 4))) | (((portNum) & ((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1)) << ((txQueue << 3) + 4)));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTxQueueSchedInfo
 *
 *   @b Description
 *   @n The function is used to get the port and scheduler information for a 
 *      specific transmit queue.
 *
 *   @b Arguments
     @verbatim
          hSrio       Handle of the SRIO device
          txQueue     Transmit Queue Index for which information is configured.
          portNum     Port Number to which the queue is mapped populated by this API
          priority    Priority of the Transmit Queue populated by this API
          crf         Critical Resource Flow Value populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE0_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE1_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE2_INFO; 
 *    SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE0_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE1_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE2_INFO;
 *    SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE0_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE1_INFO,SRIO_RIO_TX_QUEUE_SCH_INFO_QUEUE2_INFO;
 *
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle     hSrio;
        Uint8              portNum;
        Uint8              priority;
        Uint8              crf;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the Tx Queue 1 Information.
        CSL_SRIO_GetTxQueueSchedInfo (hSrio, 1, &portNum, &priority, &crf);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTxQueueSchedInfo
(
    CSL_SrioHandle  hSrio,
    Uint8           txQueue,
    Uint8*          portNum,
    Uint8*          priority,
    Uint8*          crf
)
{
    Uint32 value;

    if (txQueue < 4)
    {
        /* Transmit Queue 0, 1, 2 and 3 are handed in RIO_TX_QUEUE_SCH_INFO[0] */
        value = hSrio->RIO_TX_QUEUE_SCH_INFO[0];
        *crf      = (((value) >> ((txQueue << 3))) & ((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1));
        *priority = (((value) >> ((txQueue << 3) + 1)) & ((1 << (((txQueue << 3) + 2) - ((txQueue << 3) + 1) + 1)) - 1));
        *portNum  = (((value) >> ((txQueue << 3) + 4)) & ((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1));
    }
    else if (txQueue < 8)
    {
        /* Transmit Queue 4, 5, 6 and 7 are handed in RIO_TX_QUEUE_SCH_INFO[1] */
        txQueue = txQueue - 4;
        value = hSrio->RIO_TX_QUEUE_SCH_INFO[1];

        *crf      = (((value) >> ((txQueue << 3))) & ((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1));
        *priority = (((value) >> ((txQueue << 3) + 1)) & ((1 << (((txQueue << 3) + 2) - ((txQueue << 3) + 1) + 1)) - 1));
        *portNum  = (((value) >> ((txQueue << 3) + 4)) & ((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1));
    } 
    else if (txQueue < 12)
    {
        /* Transmit Queue 8, 9, 10 and 11 are handed in RIO_TX_QUEUE_SCH_INFO[2] */
        txQueue = txQueue - 8;
        value = hSrio->RIO_TX_QUEUE_SCH_INFO[2];

        *crf      = (((value) >> ((txQueue << 3))) & ((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1));
        *priority = (((value) >> ((txQueue << 3) + 1)) & ((1 << (((txQueue << 3) + 2) - ((txQueue << 3) + 1) + 1)) - 1));
        *portNum  = (((value) >> ((txQueue << 3) + 4)) & ((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1));
    } 
    else if (txQueue < 16)
    {
        /* Transmit Queue 12, 13, 14 and 15 are handed in RIO_TX_QUEUE_SCH_INFO[3] */
        txQueue = txQueue - 12;
        value = hSrio->RIO_TX_QUEUE_SCH_INFO[3];

        *crf      = (((value) >> ((txQueue << 3))) & ((1 << (((txQueue << 3)) - ((txQueue << 3)) + 1)) - 1));
        *priority = (((value) >> ((txQueue << 3) + 1)) & ((1 << (((txQueue << 3) + 2) - ((txQueue << 3) + 1) + 1)) - 1));
        *portNum  = (((value) >> ((txQueue << 3) + 4)) & ((1 << (((txQueue << 3) + 7) - ((txQueue << 3) + 4) + 1)) - 1));
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTxGarbageCollectionInfo
 *
 *   @b Description
 *   @n The function sets the Transmit Garbage collection information. 
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          qidLength     Length mismatch between size in the UDI to be configured. 
          qidTimeout    Timeout on receiving the segments to be configured.
          qidRetry      Excessive retries to be configured
          qidTransErr   Transaction Error to be configured
          qidProg       Programming Error queue to be configured
          qidSsize      Queue ID Ssize to be configured

     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_GARBAGE_COLL_QID0_GARBAGE_QID_LEN, 
 *   @n SRIO_RIO_GARBAGE_COLL_QID0_GARBAGE_QID_TOUT,
 *   @n SRIO_RIO_GARBAGE_COLL_QID1_GARBAGE_QID_RETRY,
 *   @n SRIO_RIO_GARBAGE_COLL_QID1_GARBAGE_QID_TRANS_ERR,
 *   @n SRIO_RIO_GARBAGE_COLL_QID2_GARBAGE_QID_PROG,
 *   @n SRIO_RIO_GARBAGE_COLL_QID2_GARBAGE_QID_SSIZE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the Transmit Garbage Collection Information.
        CSL_SRIO_SetTxGarbageCollectionInfo (hSrio, 2, 3, 4, 5, 6, 10);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTxGarbageCollectionInfo
(
    CSL_SrioHandle  hSrio,
    Uint16          qidLength,
    Uint16          qidTimeout,
    Uint16          qidRetry,
    Uint16          qidTransErr,
    Uint16          qidProg,
    Uint16          qidSsize
)
{
    hSrio->RIO_GARBAGE_COLL_QID0 = 
            (((qidLength) << (0x00000010u)) & (0x3FFF0000u))   | 
            (((qidTimeout) << (0x00000000u)) & (0x00003FFFu));

    hSrio->RIO_GARBAGE_COLL_QID1 = 
            (((qidRetry) << (0x00000010u)) & (0x3FFF0000u))    |
            (((qidTransErr) << (0x00000000u)) & (0x00003FFFu));

    hSrio->RIO_GARBAGE_COLL_QID2 = 
            (((qidProg) << (0x00000010u)) & (0x3FFF0000u)) |
            (((qidSsize) << (0x00000000u)) & (0x00003FFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTxGarbageCollectionInfo
 *
 *   @b Description
 *   @n The function gets the Transmit Garbage collection information. Descriptors
 *      are placed into the Garbage collection queue when there is an error 
 *      response detected.
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          qidLength     Length mismatch between size in the UDI 
                        packet and receieved payload populated by this API
          qidTimeout    Timeout on receiving the segments populated by this API
          qidRetry      Excessive retries populated by this API
          qidTransErr   Transaction Error populated by this API
          qidProg       Programming error queue read
          qidSsize      Queue ID Ssize populated by this API

     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_GARBAGE_COLL_QID0_GARBAGE_QID_LEN, 
 *   @n SRIO_RIO_GARBAGE_COLL_QID0_GARBAGE_QID_TOUT,
 *   @n SRIO_RIO_GARBAGE_COLL_QID1_GARBAGE_QID_RETRY,
 *   @n SRIO_RIO_GARBAGE_COLL_QID1_GARBAGE_QID_TRANS_ERR,
 *   @n SRIO_RIO_GARBAGE_COLL_QID2_GARBAGE_QID_PROG, 
 *   @n SRIO_RIO_GARBAGE_COLL_QID2_GARBAGE_QID_SSIZE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          qidLength;
        Uint16          qidTimeout;
        Uint16          qidRetry;
        Uint16          qidTransErr;
        Uint16          qidProg;
        Uint16          qidSsize;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the Transmit Garbage Collection Information.
        CSL_SRIO_GetTxGarbageCollectionInfo (hSrio, &qidLength, &qidTimeout, 
                                             &qidRetry, &qidTransErr, &qidProg, &qidSsize);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTxGarbageCollectionInfo
(
    CSL_SrioHandle  hSrio,
    Uint16*         qidLength,
    Uint16*         qidTimeout,
    Uint16*         qidRetry,
    Uint16*         qidTransErr,
    Uint16*         qidProg,
    Uint16*         qidSsize
)
{
    *qidLength  = (((hSrio->RIO_GARBAGE_COLL_QID0) & (0x3FFF0000u)) >> (0x00000010u));
    *qidTimeout = (((hSrio->RIO_GARBAGE_COLL_QID0) & (0x00003FFFu)) >> (0x00000000u));
    *qidRetry   = (((hSrio->RIO_GARBAGE_COLL_QID1) & (0x3FFF0000u)) >> (0x00000010u));
    *qidTransErr= (((hSrio->RIO_GARBAGE_COLL_QID1) & (0x00003FFFu)) >> (0x00000000u));
    *qidProg    = (((hSrio->RIO_GARBAGE_COLL_QID2) & (0x3FFF0000u)) >> (0x00000010u));
    *qidSsize   = (((hSrio->RIO_GARBAGE_COLL_QID2) & (0x00003FFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetQMBaseAddress
 *
 *   @b Description
 *   @n The function gets the QM base address
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          qmIndex           Index of the Queue Manager whose base address is needed
          qmBaseAddress     QM Base Address populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_QM_BASE_ADDRESS_REG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          qmBaseAddress;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Get the QM Base Address information for 0
        CSL_SRIO_GetQMBaseAddress(hSrio, 0, &qmBaseAddress);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetQMBaseAddress
(
    CSL_SrioHandle  hSrio,
    Uint8           qmIndex,
    Uint32*         qmBaseAddress
)
{
    *qmBaseAddress = hSrio->QM_BASE_ADDRESS_REG[qmIndex];
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetQMBaseAddress
 *
 *   @b Description
 *   @n The function sets the QM base address
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          qmIndex           Index of the Queue Manager whose base address is to be set
          qmBaseAddress     QM Base Address to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_QM_BASE_ADDRESS_REG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);
        ...
        // Set the QM Base Address information for 0
        CSL_SRIO_SetQMBaseAddress(hSrio, 0, 0x10800000);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetQMBaseAddress
(
    CSL_SrioHandle  hSrio,
    Uint8           qmIndex,
    Uint32          qmBaseAddress
)
{
    hSrio->QM_BASE_ADDRESS_REG[qmIndex] = qmBaseAddress;
}


/**
@}
*/




/**
 *   @file  csl_srioAuxPhyLayer.h
 *
 *   @brief   
 *      This is the SRIO Auxilary Physical Header File which exposes the various
 *      CSL Functional Layer API's to configure the SRIO Switch.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/




/** @addtogroup CSL_SRIO_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_SRIO_GetDeviceInfo
 *
 *   @b Description
 *   @n The function reads the Device Identifier information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          deviceId          Device Identity populated by this API.
          deviceVendorId    Device Vendor Identity populated by this API  
          deviceRev         Device Revision populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_DEV_ID_DEV_ID,SRIO_RIO_DEV_ID_DEV_VEN_ID,
 *   @n SRIO_RIO_DEV_INFO_DEVICE_REV
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          deviceId;
        Uint16          deviceVendorId;
        Uint32          deviceRev;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Read the Device Identity CAR
        CSL_SRIO_GetDeviceInfo (hSrio, &deviceId, &deviceVendorId, &deviceRev);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDeviceInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16*         deviceId,
    Uint16*         deviceVendorId,
    Uint32*         deviceRev
)
{
    Uint32 value = hSrio->RIO_DEV_ID;

    *deviceId       = (((value) & (0xFFFF0000u)) >> (0x00000010u));
    *deviceVendorId = (((value) & (0x0000FFFFu)) >> (0x00000000u));
    *deviceRev      = (((hSrio->RIO_DEV_INFO) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetDeviceInfo
 *
 *   @b Description
 *   @n The function sets up the Device Identifier information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          deviceId          Device Identity to configure
          deviceVendorId    Device Vendor Identity to configure
          deviceRev         Device Revision to configure
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_DEV_ID_DEV_ID,SRIO_RIO_DEV_ID_DEV_VEN_ID,
 *   @n SRIO_RIO_DEV_INFO_DEVICE_REV
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          deviceId;
        Uint16          deviceVendorId;
        Uint32          deviceRev;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Read the Device Identity CAR
        CSL_SRIO_GetDeviceInfo (hSrio, &deviceId, &deviceVendorId, &deviceRev);
        ...
        // Setup the device identity info
        CSL_SRIO_SetDeviceInfo (hSrio, deviceId, deviceVendorId, deviceRev);
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetDeviceInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16          deviceId,
    Uint16          deviceVendorId,
    Uint32          deviceRev
)
{
    hSrio->RIO_DEV_ID   = (((deviceId) << (0x00000010u)) & (0xFFFF0000u))         |
                          (((deviceVendorId) << (0x00000000u)) & (0x0000FFFFu));
    hSrio->RIO_DEV_INFO = (((deviceRev) << (0x00000000u)) & (0xFFFFFFFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAssemblyInfo
 *
 *   @b Description
 *   @n The function reads the Assembly Identifier information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          asblyId           Assembly Identity populated by this API.
          asblyVendorId     Assembly Vendor Identity populated by this API  
          asblyRev          Assembly Revision populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_ASBLY_ID_ASBLY_ID,SRIO_RIO_ASBLY_ID_ASBLY_VEN_ID,
 *   @n SRIO_RIO_ASBLY_INFO_ASBLY_REV,SRIO_RIO_ASBLY_INFO_EXT_FEAT_PTR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          asblyId;
        Uint16          asblyVendorId;
        Uint16          asblyRev;
        Uint16          extFeaturePtr;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Read the Assembly Identity CAR
        CSL_SRIO_GetAssemblyInfo (hSrio, &asblyId, &asblyVendorId, &asblyRev, &extFeaturePtr);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAssemblyInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16*         asblyId,
    Uint16*         asblyVendorId,
    Uint16*         asblyRev,
    Uint16*         extFeaturePtr
)
{
    Uint32 value;

    /* Read the assembly and vendor identifier */
    value = hSrio->RIO_ASBLY_ID;
    *asblyId       = (((value) & (0xFFFF0000u)) >> (0x00000010u));
    *asblyVendorId = (((value) & (0x0000FFFFu)) >> (0x00000000u));

    /* Read the assembly information and external features */
    value = hSrio->RIO_ASBLY_INFO;
    *asblyRev      = (((value) & (0xFFFF0000u)) >> (0x00000010u));
    *extFeaturePtr = (((value) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetAssemblyInfo
 *
 *   @b Description
 *   @n The function sets up the Assembly Identifier information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          asblyId           Assembly Identity to configure.
          asblyVendorId     Assembly Vendor Identity to configure  
          asblyRev          Assembly Revision to configure
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_ASBLY_ID_ASBLY_ID,SRIO_RIO_ASBLY_ID_ASBLY_VEN_ID,
 *   @n SRIO_RIO_ASBLY_INFO_ASBLY_REV,SRIO_RIO_ASBLY_INFO_EXT_FEAT_PTR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          asblyId;
        Uint16          asblyVendorId;
        Uint16          asblyRev;
        Uint16          extFeaturePtr;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Read the Assembly Identity CAR
        CSL_SRIO_GetAssemblyInfo (hSrio, &asblyId, &asblyVendorId, &asblyRev, &extFeaturePtr);
        ...
        // Sets up the Assembly Identity info
        CSL_SRIO_SetAssemblyInfo (hSrio, asblyId, asblyVendorId, asblyRev, extFeaturePtr);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetAssemblyInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16          asblyId,
    Uint16          asblyVendorId,
    Uint16          asblyRev,
    Uint16          extFeaturePtr
)
{
    hSrio->RIO_ASBLY_ID   = (((asblyId) << (0x00000010u)) & (0xFFFF0000u))         |
                            (((asblyVendorId) << (0x00000000u)) & (0x0000FFFFu));

    hSrio->RIO_ASBLY_INFO = (((asblyRev) << (0x00000010u)) & (0xFFFF0000u))         |
                            (((extFeaturePtr) << (0x00000000u)) & (0x0000FFFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetProcessingElementFeatures
 *
 *   @b Description
 *   @n The function gets the processing element features.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          peFeatures        Processing Element Features to be populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PE_FEAT_BRDG,SRIO_RIO_PE_FEAT_MEM,SRIO_RIO_PE_FEAT_PROC,
 *   @n SRIO_RIO_PE_FEAT_SW,SRIO_RIO_PE_FEAT_MULT_P,SRIO_RIO_PE_FEAT_FLOW_ARB,
 *   @n SRIO_RIO_PE_FEAT_MC,SRIO_RIO_PE_FEAT_ERTC,SRIO_RIO_PE_FEAT_SRTC,
 *   @n SRIO_RIO_PE_FEAT_FLOW_CTRL, SRIO_RIO_PE_FEAT_CRF,
 *   @n SRIO_RIO_PE_FEAT_CTLS,SRIO_RIO_PE_FEAT_EXT_FEA,SRIO_RIO_PE_FEAT_EXT_AS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_PE_FEATURES    peFeatures;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the processing element features.
        CSL_SRIO_GetProcessingElementFeatures (hSrio, &peFeatures);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetProcessingElementFeatures
(
    CSL_SrioHandle      hSrio, 
    SRIO_PE_FEATURES*   ptrPEFeatures
)
{
    Uint32 value = hSrio->RIO_PE_FEAT;

    /* Populate the structure. */
    ptrPEFeatures->isBridge                       = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrPEFeatures->isEndpoint                     = (((value) & (0x40000000u)) >> (0x0000001Eu));
    ptrPEFeatures->isProcessor                    = (((value) & (0x20000000u)) >> (0x0000001Du));
    ptrPEFeatures->isSwitch                       = (((value) & (0x10000000u)) >> (0x0000001Cu));
    ptrPEFeatures->isMultiport                    = (((value) & (0x08000000u)) >> (0x0000001Bu));
    ptrPEFeatures->isFlowArbiterationSupported    = (((value) & (0x00000800u)) >> (0x0000000Bu));
    ptrPEFeatures->isMulticastSupported           = (((value) & (0x00000400u)) >> (0x0000000Au));
    ptrPEFeatures->isExtendedRouteConfigSupported = (((value) & (0x00000200u)) >> (0x00000009u));
    ptrPEFeatures->isStandardRouteConfigSupported = (((value) & (0x00000100u)) >> (0x00000008u));
    ptrPEFeatures->isFlowControlSupported         = (((value) & (0x00000080u)) >> (0x00000007u));
    ptrPEFeatures->isCRFSupported                 = (((value) & (0x00000020u)) >> (0x00000005u));
    ptrPEFeatures->isCTLSSupported                = (((value) & (0x00000010u)) >> (0x00000004u));
    ptrPEFeatures->isExtendedFeaturePtrValid      = (((value) & (0x00000008u)) >> (0x00000003u));
    ptrPEFeatures->numAddressBitSupported         = (((value) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetProcessingElementFeatures
 *
 *   @b Description
 *   @n The function sets the processing element features.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          peFeatures        Processing Element Features to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PE_FEAT_BRDG,SRIO_RIO_PE_FEAT_MEM,SRIO_RIO_PE_FEAT_PROC,
 *   @n SRIO_RIO_PE_FEAT_SW,SRIO_RIO_PE_FEAT_MULT_P,SRIO_RIO_PE_FEAT_FLOW_ARB,
 *   @n SRIO_RIO_PE_FEAT_MC,SRIO_RIO_PE_FEAT_ERTC,SRIO_RIO_PE_FEAT_SRTC,
 *   @n SRIO_RIO_PE_FEAT_FLOW_CTRL, SRIO_RIO_PE_FEAT_CRF,
 *   @n SRIO_RIO_PE_FEAT_CTLS,SRIO_RIO_PE_FEAT_EXT_FEA,SRIO_RIO_PE_FEAT_EXT_AS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_PE_FEATURES    peFeatures;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the processing element features.
        CSL_SRIO_GetProcessingElementFeatures (hSrio, &peFeatures);
        
        // Modify the processing element features and make this a BRIDGE
        peFeatures.isBridge = 1;
        CSL_SRIO_SetProcessingElementFeatures(hSrio, &peFeatures);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetProcessingElementFeatures
(
    CSL_SrioHandle      hSrio, 
    SRIO_PE_FEATURES*   ptrPEFeatures
)
{
    Uint32 value = 0;

    /* Initialize the various fields in the register */ 
    ((value) = ((value) & ~(0x80000000u)) | (((ptrPEFeatures->isBridge) << (0x0000001Fu)) & (0x80000000u)));
    ((value) = ((value) & ~(0x40000000u)) | (((ptrPEFeatures->isEndpoint) << (0x0000001Eu)) & (0x40000000u)));
    ((value) = ((value) & ~(0x20000000u)) | (((ptrPEFeatures->isProcessor) << (0x0000001Du)) & (0x20000000u)));
    ((value) = ((value) & ~(0x10000000u)) | (((ptrPEFeatures->isSwitch) << (0x0000001Cu)) & (0x10000000u)));
    ((value) = ((value) & ~(0x08000000u)) | (((ptrPEFeatures->isMultiport) << (0x0000001Bu)) & (0x08000000u)));
    ((value) = ((value) & ~(0x00000800u)) | (((ptrPEFeatures->isFlowArbiterationSupported) << (0x0000000Bu)) & (0x00000800u)));
    ((value) = ((value) & ~(0x00000400u)) | (((ptrPEFeatures->isMulticastSupported) << (0x0000000Au)) & (0x00000400u)));
    ((value) = ((value) & ~(0x00000200u)) | (((ptrPEFeatures->isExtendedRouteConfigSupported) << (0x00000009u)) & (0x00000200u)));
    ((value) = ((value) & ~(0x00000100u)) | (((ptrPEFeatures->isStandardRouteConfigSupported) << (0x00000008u)) & (0x00000100u)));
    ((value) = ((value) & ~(0x00000080u)) | (((ptrPEFeatures->isFlowControlSupported) << (0x00000007u)) & (0x00000080u)));
    ((value) = ((value) & ~(0x00000020u)) | (((ptrPEFeatures->isCRFSupported) << (0x00000005u)) & (0x00000020u)));
    ((value) = ((value) & ~(0x00000010u)) | (((ptrPEFeatures->isCTLSSupported) << (0x00000004u)) & (0x00000010u)));
    ((value) = ((value) & ~(0x00000008u)) | (((ptrPEFeatures->isExtendedFeaturePtrValid) << (0x00000003u)) & (0x00000008u)));
    ((value) = ((value) & ~(0x00000007u)) | (((ptrPEFeatures->numAddressBitSupported) << (0x00000000u)) & (0x00000007u)));

    hSrio->RIO_PE_FEAT = value;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetSwitchPortInfo
 *
 *   @b Description
 *   @n The function reads the Switch Port information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          numPorts          The total number of ports populated by this API
          portNum           The port number from which the Maintenance read operation
                            accessed this register.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SW_PORT_PORT_TOTAL,SRIO_RIO_SW_PORT_PORT_NUM
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           numPorts;
        Uint8           portNum;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Switch port information
        CSL_SRIO_GetSwitchPortInfo (hSrio, &numPorts, &portNum);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetSwitchPortInfo
(
    CSL_SrioHandle  hSrio, 
    Uint8*          numPorts,
    Uint8*          portNum
)
{
    *numPorts   = (((hSrio->RIO_SW_PORT) & (0x0000FF00u)) >> (0x00000008u));
    *portNum    = (((hSrio->RIO_SW_PORT) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetSourceOperationCAR
 *
 *   @b Description
 *   @n The function reads the Switch Port Capabilities which are all the logical
 *      operations that can be issued by the application.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          ptrSrcOp          Pointer to the Source CAR Structure populated by this 
                            API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SRC_OP_G_READ, SRIO_RIO_SRC_OP_G_IREAD, SRIO_RIO_SRC_OP_G_READ_OWN,
 *   @n SRIO_RIO_SRC_OP_G_DC_INVALIDATE, SRIO_RIO_SRC_OP_G_CASTOUT, SRIO_RIO_SRC_OP_G_DC_FLUSH,
 *   @n SRIO_RIO_SRC_OP_G_IO_READ, SRIO_RIO_SRC_OP_G_IC_INVALIDATE, SRIO_RIO_SRC_OP_G_TLB_INVALIDATE,
 *   @n SRIO_RIO_SRC_OP_G_TLB_SYNC, SRIO_RIO_SRC_OP_DS_TM, SRIO_RIO_SRC_OP_DS, 
 *   @n SRIO_RIO_SRC_OP_IMPLEMENT_DEF, SRIO_RIO_SRC_OP_READ, SRIO_RIO_SRC_OP_WRITE,
 *   @n SRIO_RIO_SRC_OP_STRM_WR, SRIO_RIO_SRC_OP_WR_RES, SRIO_RIO_SRC_OP_D_MSG, SRIO_RIO_SRC_OP_DBELL,
 *   @n SRIO_RIO_SRC_OP_ACSWAP, SRIO_RIO_SRC_OP_ATSWAP, SRIO_RIO_SRC_OP_A_INC, SRIO_RIO_SRC_OP_A_DEC,
 *   @n SRIO_RIO_SRC_OP_A_SET, SRIO_RIO_SRC_OP_A_CLEAR, SRIO_RIO_SRC_OP_A_SWAP, SRIO_RIO_SRC_OP_PORT_WR, 
 *   @n SRIO_RIO_SRC_OP_IMPLEMENT_DEF2
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        SRIO_OP_CAR     srcOPCAR;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Source Operation CAR
        CSL_SRIO_GetSourceOperationCAR (hSrio, &srcOPCAR);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetSourceOperationCAR
(
    CSL_SrioHandle  hSrio, 
    SRIO_OP_CAR*    ptrSrcOp
)
{
    Uint32  value = hSrio->RIO_SRC_OP;

    /* Extract the fields from the Source OP */
    ptrSrcOp->gsmRead                   = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrSrcOp->gsmInstrnRead             = (((value) & (0x40000000u)) >> (0x0000001Eu));
    ptrSrcOp->gsmReadOwn                = (((value) & (0x20000000u)) >> (0x0000001Du));
    ptrSrcOp->gsmDataCacheInvalidate    = (((value) & (0x10000000u)) >> (0x0000001Cu));
    ptrSrcOp->gsmCastout                = (((value) & (0x08000000u)) >> (0x0000001Bu));
    ptrSrcOp->gsmDataCacheFlush         = (((value) & (0x04000000u)) >> (0x0000001Au));
    ptrSrcOp->gsmIORead                 = (((value) & (0x02000000u)) >> (0x00000019u));
    ptrSrcOp->gsmInstrnCacheInvalidate  = (((value) & (0x01000000u)) >> (0x00000018u));
    ptrSrcOp->gsmTLBInvalidate          = (((value) & (0x00800000u)) >> (0x00000017u));
    ptrSrcOp->gsmTLBSync                = (((value) & (0x00400000u)) >> (0x00000016u));
    ptrSrcOp->dataStreamingTM           = (((value) & (0x00080000u)) >> (0x00000013u));
    ptrSrcOp->dataStreamingSupport      = (((value) & (0x00040000u)) >> (0x00000012u));
    ptrSrcOp->implnDefined              = (((value) & (0x00030000u)) >> (0x00000010u));
    ptrSrcOp->readSupport               = (((value) & (0x00008000u)) >> (0x0000000Fu));
    ptrSrcOp->writeSupport              = (((value) & (0x00004000u)) >> (0x0000000Eu));
    ptrSrcOp->streamWriteSupport        = (((value) & (0x00002000u)) >> (0x0000000Du));
    ptrSrcOp->writeResponseSupport      = (((value) & (0x00001000u)) >> (0x0000000Cu));
    ptrSrcOp->dataMessageSupport        = (((value) & (0x00000800u)) >> (0x0000000Bu)); 
    ptrSrcOp->doorbellSupport           = (((value) & (0x00000400u)) >> (0x0000000Au)); 
    ptrSrcOp->atomicCompareSwapSupport  = (((value) & (0x00000200u)) >> (0x00000009u));
    ptrSrcOp->atomicTestSwapSupport     = (((value) & (0x00000100u)) >> (0x00000008u));
    ptrSrcOp->atomicIncSupport          = (((value) & (0x00000080u)) >> (0x00000007u));
    ptrSrcOp->atomicDecSupport          = (((value) & (0x00000040u)) >> (0x00000006u));
    ptrSrcOp->atomicSetSupport          = (((value) & (0x00000020u)) >> (0x00000005u));
    ptrSrcOp->atomicClearSupport        = (((value) & (0x00000010u)) >> (0x00000004u));
    ptrSrcOp->atomicSwapSupport         = (((value) & (0x00000008u)) >> (0x00000003u));
    ptrSrcOp->portWriteOperationSupport = (((value) & (0x00000004u)) >> (0x00000002u));
    ptrSrcOp->implnDefined2             = (((value) & (0x00000003u)) >> (0x00000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetSourceOperationCAR
 *
 *   @b Description
 *   @n The function sets the Switch Port Capabilities which are all the logical
 *      operations that can be issued by the application.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          ptrSrcOp          Pointer to the Source CAR Structure to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SRC_OP_G_READ, SRIO_RIO_SRC_OP_G_IREAD, SRIO_RIO_SRC_OP_G_READ_OWN,
 *   @n SRIO_RIO_SRC_OP_G_DC_INVALIDATE, SRIO_RIO_SRC_OP_G_CASTOUT, SRIO_RIO_SRC_OP_G_DC_FLUSH,
 *   @n SRIO_RIO_SRC_OP_G_IO_READ, SRIO_RIO_SRC_OP_G_IC_INVALIDATE, SRIO_RIO_SRC_OP_G_TLB_INVALIDATE,
 *   @n SRIO_RIO_SRC_OP_G_TLB_SYNC, SRIO_RIO_SRC_OP_DS_TM, SRIO_RIO_SRC_OP_DS, 
 *   @n SRIO_RIO_SRC_OP_IMPLEMENT_DEF, SRIO_RIO_SRC_OP_READ, SRIO_RIO_SRC_OP_WRITE,
 *   @n SRIO_RIO_SRC_OP_STRM_WR, SRIO_RIO_SRC_OP_WR_RES, SRIO_RIO_SRC_OP_D_MSG, SRIO_RIO_SRC_OP_DBELL,
 *   @n SRIO_RIO_SRC_OP_ACSWAP, SRIO_RIO_SRC_OP_ATSWAP, SRIO_RIO_SRC_OP_A_INC, SRIO_RIO_SRC_OP_A_DEC,
 *   @n SRIO_RIO_SRC_OP_A_SET, SRIO_RIO_SRC_OP_A_CLEAR, SRIO_RIO_SRC_OP_A_SWAP, SRIO_RIO_SRC_OP_PORT_WR, 
 *   @n SRIO_RIO_SRC_OP_IMPLEMENT_DEF2
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        SRIO_OP_CAR     srcOPCAR;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Source Operation CAR
        CSL_SRIO_GetSourceOperationCAR (hSrio, &srcOPCAR);

        // Allow Doorbell support.
        srcOPCAR.doorbellSupport = 1;

        // Set the Source Operation CAR
        CSL_SRIO_SetSourceOperationCAR (hSrio, &srcOPCAR);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetSourceOperationCAR
(
    CSL_SrioHandle  hSrio, 
    SRIO_OP_CAR*    ptrSrcOp
)
{
    Uint32  value = 0;

    /* Populate the fields into the Source OP */
    ((value) = ((value) & ~(0x80000000u)) | (((ptrSrcOp->gsmRead) << (0x0000001Fu)) & (0x80000000u)));
    ((value) = ((value) & ~(0x40000000u)) | (((ptrSrcOp->gsmInstrnRead) << (0x0000001Eu)) & (0x40000000u)));
    ((value) = ((value) & ~(0x20000000u)) | (((ptrSrcOp->gsmReadOwn) << (0x0000001Du)) & (0x20000000u)));
    ((value) = ((value) & ~(0x10000000u)) | (((ptrSrcOp->gsmDataCacheInvalidate) << (0x0000001Cu)) & (0x10000000u)));
    ((value) = ((value) & ~(0x08000000u)) | (((ptrSrcOp->gsmCastout) << (0x0000001Bu)) & (0x08000000u)));
    ((value) = ((value) & ~(0x04000000u)) | (((ptrSrcOp->gsmDataCacheFlush) << (0x0000001Au)) & (0x04000000u)));
    ((value) = ((value) & ~(0x02000000u)) | (((ptrSrcOp->gsmIORead) << (0x00000019u)) & (0x02000000u)));
    ((value) = ((value) & ~(0x01000000u)) | (((ptrSrcOp->gsmInstrnCacheInvalidate) << (0x00000018u)) & (0x01000000u)));
    ((value) = ((value) & ~(0x00800000u)) | (((ptrSrcOp->gsmTLBInvalidate) << (0x00000017u)) & (0x00800000u)));
    ((value) = ((value) & ~(0x00400000u)) | (((ptrSrcOp->gsmTLBSync) << (0x00000016u)) & (0x00400000u)));
    ((value) = ((value) & ~(0x00080000u)) | (((ptrSrcOp->dataStreamingTM) << (0x00000013u)) & (0x00080000u)));
    ((value) = ((value) & ~(0x00040000u)) | (((ptrSrcOp->dataStreamingSupport) << (0x00000012u)) & (0x00040000u)));
    ((value) = ((value) & ~(0x00030000u)) | (((ptrSrcOp->implnDefined) << (0x00000010u)) & (0x00030000u)));
    ((value) = ((value) & ~(0x00008000u)) | (((ptrSrcOp->readSupport) << (0x0000000Fu)) & (0x00008000u)));
    ((value) = ((value) & ~(0x00004000u)) | (((ptrSrcOp->writeSupport) << (0x0000000Eu)) & (0x00004000u)));
    ((value) = ((value) & ~(0x00002000u)) | (((ptrSrcOp->streamWriteSupport) << (0x0000000Du)) & (0x00002000u)));
    ((value) = ((value) & ~(0x00001000u)) | (((ptrSrcOp->writeResponseSupport) << (0x0000000Cu)) & (0x00001000u)));
    ((value) = ((value) & ~(0x00000800u)) | (((ptrSrcOp->dataMessageSupport) << (0x0000000Bu)) & (0x00000800u)));
    ((value) = ((value) & ~(0x00000400u)) | (((ptrSrcOp->doorbellSupport) << (0x0000000Au)) & (0x00000400u)));
    ((value) = ((value) & ~(0x00000200u)) | (((ptrSrcOp->atomicCompareSwapSupport) << (0x00000009u)) & (0x00000200u)));
    ((value) = ((value) & ~(0x00000100u)) | (((ptrSrcOp->atomicTestSwapSupport) << (0x00000008u)) & (0x00000100u)));   
    ((value) = ((value) & ~(0x00000080u)) | (((ptrSrcOp->atomicIncSupport) << (0x00000007u)) & (0x00000080u)));
    ((value) = ((value) & ~(0x00000040u)) | (((ptrSrcOp->atomicDecSupport) << (0x00000006u)) & (0x00000040u)));
    ((value) = ((value) & ~(0x00000020u)) | (((ptrSrcOp->atomicSetSupport) << (0x00000005u)) & (0x00000020u)));
    ((value) = ((value) & ~(0x00000010u)) | (((ptrSrcOp->atomicClearSupport) << (0x00000004u)) & (0x00000010u)));
    ((value) = ((value) & ~(0x00000008u)) | (((ptrSrcOp->atomicSwapSupport) << (0x00000003u)) & (0x00000008u)));
    ((value) = ((value) & ~(0x00000004u)) | (((ptrSrcOp->portWriteOperationSupport) << (0x00000002u)) & (0x00000004u)));
    ((value) = ((value) & ~(0x00000003u)) | (((ptrSrcOp->implnDefined2) << (0x00000000u)) & (0x00000003u)));    

    hSrio->RIO_SRC_OP = value;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDestOperationCAR
 *
 *   @b Description
 *   @n The function reads the Switch Port Capabilities which are all the logical
 *      operations that can be issued by the application.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          ptrDstOp          Pointer to the Dest CAR Structure populated by this 
                            API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_DEST_OP_G_READ, SRIO_RIO_DEST_OP_G_IREAD, SRIO_RIO_DEST_OP_G_READ_OWN,
 *   @n SRIO_RIO_DEST_OP_G_DC_INVALIDATE, SRIO_RIO_DEST_OP_G_CASTOUT, SRIO_RIO_DEST_OP_G_DC_FLUSH,
 *   @n SRIO_RIO_DEST_OP_G_IO_READ, SRIO_RIO_DEST_OP_G_IC_INVALIDATE, SRIO_RIO_DEST_OP_G_TLB_INVALIDATE,
 *   @n SRIO_RIO_DEST_OP_G_TLB_SYNC, SRIO_RIO_DEST_OP_DS_TM, SRIO_RIO_DEST_OP_DS,
 *   @n SRIO_RIO_DEST_OP_IMPLEMENT_DEF, SRIO_RIO_DEST_OP_READ, SRIO_RIO_DEST_OP_WRITE, 
 *   @n SRIO_RIO_DEST_OP_STRM_WR, SRIO_RIO_DEST_OP_WR_RES, SRIO_RIO_DEST_OP_D_MSG, SRIO_RIO_DEST_OP_DBELL,
 *   @n SRIO_RIO_DEST_OP_ACSWAP, SRIO_RIO_DEST_OP_ATSWAP, SRIO_RIO_DEST_OP_A_INC, SRIO_RIO_DEST_OP_A_DEC,
 *   @n SRIO_RIO_DEST_OP_A_SET, SRIO_RIO_DEST_OP_A_CLEAR, SRIO_RIO_DEST_OP_A_SWAP, SRIO_RIO_DEST_OP_PORT_WR,
 *   @n SRIO_RIO_DEST_OP_IMPLEMENT_DEF2
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        SRIO_OP_CAR     dstOPCAR;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Destination Operation CAR
        CSL_SRIO_GetDestOperationCAR (hSrio, &dstOPCAR);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDestOperationCAR
(
    CSL_SrioHandle  hSrio, 
    SRIO_OP_CAR*    ptrDstOp
)
{
    Uint32  value = hSrio->RIO_DEST_OP;

    /* Extract the fields from the Destination OP */
    ptrDstOp->gsmRead                   = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrDstOp->gsmInstrnRead             = (((value) & (0x40000000u)) >> (0x0000001Eu));
    ptrDstOp->gsmReadOwn                = (((value) & (0x20000000u)) >> (0x0000001Du));
    ptrDstOp->gsmDataCacheInvalidate    = (((value) & (0x10000000u)) >> (0x0000001Cu));
    ptrDstOp->gsmCastout                = (((value) & (0x08000000u)) >> (0x0000001Bu));
    ptrDstOp->gsmDataCacheFlush         = (((value) & (0x04000000u)) >> (0x0000001Au));
    ptrDstOp->gsmIORead                 = (((value) & (0x02000000u)) >> (0x00000019u));
    ptrDstOp->gsmInstrnCacheInvalidate  = (((value) & (0x01000000u)) >> (0x00000018u));
    ptrDstOp->gsmTLBInvalidate          = (((value) & (0x00800000u)) >> (0x00000017u));
    ptrDstOp->gsmTLBSync                = (((value) & (0x00400000u)) >> (0x00000016u));
    ptrDstOp->dataStreamingTM           = (((value) & (0x00080000u)) >> (0x00000013u));
    ptrDstOp->dataStreamingSupport      = (((value) & (0x00040000u)) >> (0x00000012u));
    ptrDstOp->implnDefined              = (((value) & (0x00030000u)) >> (0x00000010u));
    ptrDstOp->readSupport               = (((value) & (0x00008000u)) >> (0x0000000Fu));
    ptrDstOp->writeSupport              = (((value) & (0x00004000u)) >> (0x0000000Eu));
    ptrDstOp->streamWriteSupport        = (((value) & (0x00002000u)) >> (0x0000000Du));
    ptrDstOp->writeResponseSupport      = (((value) & (0x00001000u)) >> (0x0000000Cu));
    ptrDstOp->dataMessageSupport        = (((value) & (0x00000800u)) >> (0x0000000Bu));
    ptrDstOp->doorbellSupport           = (((value) & (0x00000400u)) >> (0x0000000Au));
    ptrDstOp->atomicCompareSwapSupport  = (((value) & (0x00000200u)) >> (0x00000009u));
    ptrDstOp->atomicTestSwapSupport     = (((value) & (0x00000100u)) >> (0x00000008u));
    ptrDstOp->atomicIncSupport          = (((value) & (0x00000080u)) >> (0x00000007u));
    ptrDstOp->atomicDecSupport          = (((value) & (0x00000040u)) >> (0x00000006u));
    ptrDstOp->atomicSetSupport          = (((value) & (0x00000020u)) >> (0x00000005u));
    ptrDstOp->atomicClearSupport        = (((value) & (0x00000010u)) >> (0x00000004u));
    ptrDstOp->atomicSwapSupport         = (((value) & (0x00000008u)) >> (0x00000003u));
    ptrDstOp->portWriteOperationSupport = (((value) & (0x00000004u)) >> (0x00000002u));
    ptrDstOp->implnDefined2             = (((value) & (0x00000003u)) >> (0x00000000u));    
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetDestOperationCAR
 *
 *   @b Description
 *   @n The function sets the Switch Port Capabilities which are all the logical
 *      operations that can be issued by the application.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          ptrDstOp          Pointer to the Dest CAR Structure to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_DEST_OP_G_READ, SRIO_RIO_DEST_OP_G_IREAD, SRIO_RIO_DEST_OP_G_READ_OWN,
 *   @n SRIO_RIO_DEST_OP_G_DC_INVALIDATE, SRIO_RIO_DEST_OP_G_CASTOUT, SRIO_RIO_DEST_OP_G_DC_FLUSH,
 *   @n SRIO_RIO_DEST_OP_G_IO_READ, SRIO_RIO_DEST_OP_G_IC_INVALIDATE, SRIO_RIO_DEST_OP_G_TLB_INVALIDATE,
 *   @n SRIO_RIO_DEST_OP_G_TLB_SYNC, SRIO_RIO_DEST_OP_DS_TM, SRIO_RIO_DEST_OP_DS,
 *   @n SRIO_RIO_DEST_OP_IMPLEMENT_DEF, SRIO_RIO_DEST_OP_READ, SRIO_RIO_DEST_OP_WRITE, 
 *   @n SRIO_RIO_DEST_OP_STRM_WR, SRIO_RIO_DEST_OP_WR_RES, SRIO_RIO_DEST_OP_D_MSG, SRIO_RIO_DEST_OP_DBELL,
 *   @n SRIO_RIO_DEST_OP_ACSWAP, SRIO_RIO_DEST_OP_ATSWAP, SRIO_RIO_DEST_OP_A_INC, SRIO_RIO_DEST_OP_A_DEC,
 *   @n SRIO_RIO_DEST_OP_A_SET, SRIO_RIO_DEST_OP_A_CLEAR, SRIO_RIO_DEST_OP_A_SWAP, SRIO_RIO_DEST_OP_PORT_WR,
 *   @n SRIO_RIO_DEST_OP_IMPLEMENT_DEF2
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        SRIO_OP_CAR     dstOPCAR;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Dest Operation CAR
        CSL_SRIO_GetDestOperationCAR (hSrio, &dstOPCAR);

        // Allow Doorbell support.
        dstOPCAR.doorbellSupport = 1;

        // Set the Dest Operation CAR
        CSL_SRIO_SetDestOperationCAR (hSrio, &dstOPCAR);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetDestOperationCAR
(
    CSL_SrioHandle  hSrio, 
    SRIO_OP_CAR*    ptrDstOp
)
{
    Uint32  value = 0;

    /* Populate the fields into the Source OP */
    ((value) = ((value) & ~(0x80000000u)) | (((ptrDstOp->gsmRead) << (0x0000001Fu)) & (0x80000000u)));
    ((value) = ((value) & ~(0x40000000u)) | (((ptrDstOp->gsmInstrnRead) << (0x0000001Eu)) & (0x40000000u)));
    ((value) = ((value) & ~(0x20000000u)) | (((ptrDstOp->gsmReadOwn) << (0x0000001Du)) & (0x20000000u)));
    ((value) = ((value) & ~(0x10000000u)) | (((ptrDstOp->gsmDataCacheInvalidate) << (0x0000001Cu)) & (0x10000000u)));
    ((value) = ((value) & ~(0x08000000u)) | (((ptrDstOp->gsmCastout) << (0x0000001Bu)) & (0x08000000u)));
    ((value) = ((value) & ~(0x04000000u)) | (((ptrDstOp->gsmDataCacheFlush) << (0x0000001Au)) & (0x04000000u)));
    ((value) = ((value) & ~(0x02000000u)) | (((ptrDstOp->gsmIORead) << (0x00000019u)) & (0x02000000u)));
    ((value) = ((value) & ~(0x01000000u)) | (((ptrDstOp->gsmInstrnCacheInvalidate) << (0x00000018u)) & (0x01000000u)));
    ((value) = ((value) & ~(0x00800000u)) | (((ptrDstOp->gsmTLBInvalidate) << (0x00000017u)) & (0x00800000u)));
    ((value) = ((value) & ~(0x00400000u)) | (((ptrDstOp->gsmTLBSync) << (0x00000016u)) & (0x00400000u)));
    ((value) = ((value) & ~(0x00080000u)) | (((ptrDstOp->dataStreamingTM) << (0x00000013u)) & (0x00080000u)));
    ((value) = ((value) & ~(0x00040000u)) | (((ptrDstOp->dataStreamingSupport) << (0x00000012u)) & (0x00040000u)));
    ((value) = ((value) & ~(0x00030000u)) | (((ptrDstOp->implnDefined) << (0x00000010u)) & (0x00030000u)));
    ((value) = ((value) & ~(0x00008000u)) | (((ptrDstOp->readSupport) << (0x0000000Fu)) & (0x00008000u)));
    ((value) = ((value) & ~(0x00004000u)) | (((ptrDstOp->writeSupport) << (0x0000000Eu)) & (0x00004000u)));
    ((value) = ((value) & ~(0x00002000u)) | (((ptrDstOp->streamWriteSupport) << (0x0000000Du)) & (0x00002000u)));
    ((value) = ((value) & ~(0x00001000u)) | (((ptrDstOp->writeResponseSupport) << (0x0000000Cu)) & (0x00001000u)));
    ((value) = ((value) & ~(0x00000800u)) | (((ptrDstOp->dataMessageSupport) << (0x0000000Bu)) & (0x00000800u)));
    ((value) = ((value) & ~(0x00000400u)) | (((ptrDstOp->doorbellSupport) << (0x0000000Au)) & (0x00000400u)));
    ((value) = ((value) & ~(0x00000200u)) | (((ptrDstOp->atomicCompareSwapSupport) << (0x00000009u)) & (0x00000200u)));
    ((value) = ((value) & ~(0x00000100u)) | (((ptrDstOp->atomicTestSwapSupport) << (0x00000008u)) & (0x00000100u)));   
    ((value) = ((value) & ~(0x00000080u)) | (((ptrDstOp->atomicIncSupport) << (0x00000007u)) & (0x00000080u)));
    ((value) = ((value) & ~(0x00000040u)) | (((ptrDstOp->atomicDecSupport) << (0x00000006u)) & (0x00000040u)));
    ((value) = ((value) & ~(0x00000020u)) | (((ptrDstOp->atomicSetSupport) << (0x00000005u)) & (0x00000020u)));
    ((value) = ((value) & ~(0x00000010u)) | (((ptrDstOp->atomicClearSupport) << (0x00000004u)) & (0x00000010u)));
    ((value) = ((value) & ~(0x00000008u)) | (((ptrDstOp->atomicSwapSupport) << (0x00000003u)) & (0x00000008u)));
    ((value) = ((value) & ~(0x00000004u)) | (((ptrDstOp->portWriteOperationSupport) << (0x00000002u)) & (0x00000004u)));
    ((value) = ((value) & ~(0x00000003u)) | (((ptrDstOp->implnDefined2) << (0x00000000u)) & (0x00000003u)));    

    hSrio->RIO_DEST_OP = value;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDataStreamingInfo
 *
 *   @b Description
 *   @n The function gets the data streaming information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          maxPDU            Maximum PDU 
          segSupport        Num of segmentation context
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_DS_INFO_MAX_PDU, SRIO_RIO_DS_INFO_SEG_SUPPORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          maxPDU;
        Uint16          segSupport;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Data Streaming Information
        CSL_SRIO_GetDataStreamingInfo (hSrio, &maxPDU, &segSupport);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDataStreamingInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16*         maxPDU,
    Uint16*         segSupport
)
{
    Uint32 value = hSrio->RIO_DS_INFO;

    *maxPDU     = (((value) & (0xFFFF0000u)) >> (0x00000010u));
    *segSupport = (((value) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetDataStreamingInfo
 *
 *   @b Description
 *   @n The function sets the data streaming information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          maxPDU            Maximum PDU 
          segSupport        Num of segmentation context
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_DS_INFO_MAX_PDU, SRIO_RIO_DS_INFO_SEG_SUPPORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          maxPDU;
        Uint16          segSupport;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Data Streaming Information: 64K bytes and 64K Segmentation Context
        CSL_SRIO_SetDataStreamingInfo (hSrio, 0x0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetDataStreamingInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16          maxPDU,
    Uint16          segSupport
)
{
    hSrio->RIO_DS_INFO = (((maxPDU) << (0x00000010u)) & (0xFFFF0000u))             |
                         (((segSupport) << (0x00000000u)) & (0x0000FFFFu));   
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDataStreamingType
 *
 *   @b Description
 *   @n The function gets the data streaming traffic management type 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          type              Data Streaming Type populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_DS_LL_CTL_TM_TYPES
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           type;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Data Streaming Type
        CSL_SRIO_GetDataStreamingType (hSrio, &type);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDataStreamingType
(
    CSL_SrioHandle  hSrio, 
    Uint8*          type
)
{
    *type = (((hSrio->RIO_DS_LL_CTL) & (0xF0000000u)) >> (0x0000001Cu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDataStreamingMode
 *
 *   @b Description
 *   @n The function gets the data streaming traffic management mode of operation
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          mode              Traffic Management Mode populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_DS_LL_CTL_TM_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           mode;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Data Streaming TM Mode
        CSL_SRIO_GetDataStreamingMode (hSrio, &mode);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDataStreamingMode
(
    CSL_SrioHandle  hSrio, 
    Uint8*          mode
)
{
    *mode = (((hSrio->RIO_DS_LL_CTL) & (0x0F000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetDataStreamingMode
 *
 *   @b Description
 *   @n The function sets the data streaming traffic management mode of operation
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          mode              Traffic Management Mode to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_DS_LL_CTL_TM_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           mode;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Data Streaming TM Mode
        CSL_SRIO_SetDataStreamingMode (hSrio, &mode);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetDataStreamingMode
(
    CSL_SrioHandle  hSrio, 
    Uint8           mode
)
{
    ((hSrio->RIO_DS_LL_CTL) = ((hSrio->RIO_DS_LL_CTL) & ~(0x0F000000u)) | (((mode) << (0x00000018u)) & (0x0F000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDataStreamingMTU
 *
 *   @b Description
 *   @n The function gets the data streaming MTU
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          mtu               MTU populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_DS_LL_CTL_MTU
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           mtu;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Data Streaming MTU
        CSL_SRIO_GetDataStreamingMTU (hSrio, &mtu);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDataStreamingMTU
(
    CSL_SrioHandle  hSrio, 
    Uint8*          mtu
)
{
    *mtu = (((hSrio->RIO_DS_LL_CTL) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetDataStreamingMTU
 *
 *   @b Description
 *   @n The function sets the data streaming MTU
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          mtu               MTU to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_DS_LL_CTL_MTU
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Data Streaming MTU
        CSL_SRIO_SetDataStreamingMTU (hSrio, 64);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetDataStreamingMTU
(
    CSL_SrioHandle  hSrio, 
    Uint8           mtu
)
{
    ((hSrio->RIO_DS_LL_CTL) = ((hSrio->RIO_DS_LL_CTL) & ~(0x000000FFu)) | (((mtu) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPEExtendedAddressingControl
 *
 *   @b Description
 *   @n The function sets the processing element extended addressing control 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          controlInfo       Extended Addressing Control Information to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PE_LL_CTL_EXT_ADDR_CTL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Extended Addressing Control Information to operate in 34 bit addresses
        CSL_SRIO_SetPEExtendedAddressingControl (hSrio, 0x1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPEExtendedAddressingControl
(
    CSL_SrioHandle  hSrio, 
    Uint8           controlInfo
)
{
    ((hSrio->RIO_PE_LL_CTL) = ((hSrio->RIO_PE_LL_CTL) & ~(0x00000007u)) | (((controlInfo) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPEExtendedAddressingControl
 *
 *   @b Description
 *   @n The function gets the processing element extended addressing control 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          controlInfo       Extended Addressing Control Information populated
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PE_LL_CTL_EXT_ADDR_CTL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           controlInfo;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Extended Addressing Control Information
        CSL_SRIO_GetPEExtendedAddressingControl (hSrio, &controlInfo);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPEExtendedAddressingControl
(
    CSL_SrioHandle  hSrio, 
    Uint8*          controlInfo
)
{
    *controlInfo = (((hSrio->RIO_PE_LL_CTL) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLocalConfig0SpaceInfo
 *
 *   @b Description
 *   @n The function sets the local configuration space base address0 Information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          baseInfo0         Local Configuration Base Address0 
          baseInfo1         Local Configuration Base Address1
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LCL_CFG_HBAR_LCSBA0,SRIO_RIO_LCL_CFG_HBAR_LCSBA1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Local configuration information
        CSL_SRIO_SetLocalConfig0SpaceInfo (hSrio, 0x100, 0x200);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLocalConfig0SpaceInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16          baseInfo0,
    Uint16          baseInfo1
)
{
    hSrio->RIO_LCL_CFG_HBAR = (((baseInfo1) << (0x0000000Fu)) & (0x7FFF8000u)) |   
                              (((baseInfo0) << (0x00000000u)) & (0x00007FFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLocalConfig0SpaceInfo
 *
 *   @b Description
 *   @n The function gets the local configuration space base address0 information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          baseInfo0         Local Configuration Base Address0 
          baseInfo1         Local Configuration Base Address1
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LCL_CFG_HBAR_LCSBA0,SRIO_RIO_LCL_CFG_HBAR_LCSBA1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          baseInfo0;
        Uint16          baseInfo1;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Local configuration information
        CSL_SRIO_GetLocalConfig0SpaceInfo (hSrio, &baseInfo0, &baseInfo1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLocalConfig0SpaceInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16*         baseInfo0,
    Uint16*         baseInfo1
)
{
    Uint32 value = hSrio->RIO_LCL_CFG_HBAR;
    *baseInfo0 = (((value) & (0x00007FFFu)) >> (0x00000000u));
    *baseInfo1 = (((value) & (0x7FFF8000u)) >> (0x0000000Fu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLocalConfig1SpaceInfo
 *
 *   @b Description
 *   @n The function sets the local configuration space base address1 Information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          baseInfo0         Local Configuration Base Address0 
          baseInfo1         Local Configuration Base Address1
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LCL_CFG_BAR_LCSBA0,SRIO_RIO_LCL_CFG_BAR_LCSBA1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Local configuration1 information
        CSL_SRIO_SetLocalConfig1SpaceInfo (hSrio, 0x100, 0x200);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLocalConfig1SpaceInfo
(
    CSL_SrioHandle  hSrio, 
    Uint8           baseInfo0,
    Uint32          baseInfo1
)
{
    hSrio->RIO_LCL_CFG_BAR = (((baseInfo1) << (0x0000001Fu)) & (0x80000000u)) |   
                             (((baseInfo0) << (0x00000000u)) & (0x7FFFFFFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLocalConfig1SpaceInfo
 *
 *   @b Description
 *   @n The function gets the local configuration space base address1 Information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          baseInfo0         Local Configuration Base Address0 
          baseInfo1         Local Configuration Base Address1
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LCL_CFG_BAR_LCSBA0,SRIO_RIO_LCL_CFG_BAR_LCSBA1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           baseInfo0;
        Uint32          baseInfo1;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Local configuration1 information
        CSL_SRIO_GetLocalConfig1SpaceInfo (hSrio, &baseInfo0, &baseInfo1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLocalConfig1SpaceInfo
(
    CSL_SrioHandle  hSrio, 
    Uint8*          baseInfo0,
    Uint32*         baseInfo1
)
{
    Uint32 value = hSrio->RIO_LCL_CFG_BAR;
    *baseInfo0 = (((value) & (0x7FFFFFFFu)) >> (0x00000000u));
    *baseInfo1 = (((value) & (0x80000000u)) >> (0x0000001Fu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetDeviceIDCSR
 *
 *   @b Description
 *   @n The function sets the 8bit and 16 device ID in the standard CSR
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          baseID8Bit        8bit Device Identifier.
          baseID16Bit       16bit Device Identifier.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_BASE_ID_BASE_ID,SRIO_RIO_BASE_ID_LARGE_BASE_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Device Identifier CSR
        CSL_SRIO_SetDeviceIDCSR (hSrio, 0x0, 0xDEAD);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetDeviceIDCSR
(
    CSL_SrioHandle  hSrio, 
    Uint8           baseID8Bit,
    Uint16          baseID16Bit
)
{
    /* Populate the fields into the Device ID CSR */
    hSrio->RIO_BASE_ID = (((baseID8Bit) << (0x00000010u)) & (0x00FF0000u))       | 
                         (((baseID16Bit) << (0x00000000u)) & (0x0000FFFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDeviceIDCSR
 *
 *   @b Description
 *   @n The function gets the 8bit and 16 device ID in the standard CSR
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          baseID8Bit        8bit Device Identifier populated by this API
          baseID16Bit       16bit Device Identifier populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_BASE_ID_BASE_ID,SRIO_RIO_BASE_ID_LARGE_BASE_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           baseID8Bit;
        Uint16          baseID16Bit;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Device Identifier CSR
        CSL_SRIO_GetDeviceIDCSR (hSrio, &baseID8Bit, &baseID16Bit);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDeviceIDCSR
(
    CSL_SrioHandle  hSrio, 
    Uint8*          baseID8Bit,
    Uint16*         baseID16Bit
)
{
    Uint32 value = hSrio->RIO_BASE_ID;

    *baseID8Bit  = (((value) & (0x00FF0000u)) >> (0x00000010u));
    *baseID16Bit = (((value) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetHostDeviceID
 *
 *   @b Description
 *   @n The function sets the host device identifier which is responsible for 
 *      initializing the processing element.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          identifier        Device Identifier to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_HOST_BASE_ID_LOCK_HOST_BASE_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Host Device Identifier.
        CSL_SRIO_SetHostDeviceID (hSrio, 0xBEEF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetHostDeviceID
(
    CSL_SrioHandle  hSrio, 
    Uint16          identifier
)
{
    /* Populate the fields into the Device ID CSR */
    hSrio->RIO_HOST_BASE_ID_LOCK = (((identifier) << (0x00000000u)) & (0x0000FFFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetHostDeviceID
 *
 *   @b Description
 *   @n The function gets the host device identifier which is responsible for 
 *      initializing the processing element.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          identifier        Device Identifier to be populated by this API.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_HOST_BASE_ID_LOCK_HOST_BASE_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          deviceID;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Host Device Identifier.
        CSL_SRIO_GetHostDeviceID (hSrio, &deviceID);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetHostDeviceID
(
    CSL_SrioHandle  hSrio, 
    Uint16*         identifier
)
{
    *identifier = (((hSrio->RIO_HOST_BASE_ID_LOCK) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetCompTagCSR
 *
 *   @b Description
 *   @n The function sets the component tag CSR
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          ctag          Component Tag to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_COMP_TAG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Component Tag CSR
        CSL_SRIO_SetCompTagCSR (hSrio, 0xBEEF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetCompTagCSR
(
    CSL_SrioHandle  hSrio, 
    Uint32          ctag
)
{
    hSrio->RIO_COMP_TAG = ctag;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetCompTagCSR
 *
 *   @b Description
 *   @n The function gets the component tag CSR
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          ctag          Component Tag to be populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_COMP_TAG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          tag;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the component TAG CSR
        CSL_SRIO_GetCompTagCSR (hSrio, &tag);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetCompTagCSR
(
    CSL_SrioHandle  hSrio, 
    Uint32*         ctag
)
{
    *ctag = hSrio->RIO_COMP_TAG;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetMaintBlockHeaderInfo
 *
 *   @b Description
 *   @n The function gets the maintainance block header information
 *
 *   @b Arguments
     @verbatim
          hSrio          Handle of the SRIO device
          extFeatPtr     Extended Feature Pointer populated by this API
          extFeatID      Extended Feature ID populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_MB_HEAD_EF_PTR,SRIO_RIO_SP_MB_HEAD_EF_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          extFeatPtr;
        Uint16          extFeatID;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the maintainance block header
        CSL_SRIO_GetMaintBlockHeaderInfo (hSrio, &extFeatPtr, &extFeatID);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetMaintBlockHeaderInfo
(
    CSL_SrioHandle  hSrio, 
    Uint16*         extFeatPtr,
    Uint16*         extFeatID
)
{
    Uint32 value = hSrio->RIO_SP_MB_HEAD;
    *extFeatPtr = (((value) & (0xFFFF0000u)) >> (0x00000010u));
    *extFeatID  = (((value) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortLinkTimeoutCSR
 *
 *   @b Description
 *   @n The functions gets the port link timeout. This timeout is for link events
 *      such as sending a packet to receiving the corresponding acknowledge, and 
 *      sending a link-request to receiving the corresponding link-response
 *
 *   @b Arguments
     @verbatim
          hSrio          Handle of the SRIO device
          timeout        Timeout value populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_LT_CTL_TVAL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          timeout;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the port link timeout
        CSL_SRIO_GetPortLinkTimeoutCSR (hSrio, &timeout);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortLinkTimeoutCSR
(
    CSL_SrioHandle  hSrio, 
    Uint32*         timeout
)
{
    *timeout = (((hSrio->RIO_SP_LT_CTL) & (0xFFFFFF00u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPortLinkTimeoutCSR
 *
 *   @b Description
 *   @n The functions sets the port link timeout.
 *
 *   @b Arguments
     @verbatim
          hSrio          Handle of the SRIO device
          timeout        Timeout value to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_LT_CTL_TVAL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          timeout;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the port link timeout
        CSL_SRIO_SetPortLinkTimeoutCSR (hSrio, 10);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPortLinkTimeoutCSR
(
    CSL_SrioHandle  hSrio, 
    Uint32          timeout
)
{
    ((hSrio->RIO_SP_LT_CTL) = ((hSrio->RIO_SP_LT_CTL) & ~(0xFFFFFF00u)) | (((timeout) << (0x00000008u)) & (0xFFFFFF00u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortResponseTimeoutCSR
 *
 *   @b Description
 *   @n The functions gets the port response timeout. This timeout is for 
 *      sending a packet to receiving the corresponding response packet
 *
 *   @b Arguments
     @verbatim
          hSrio          Handle of the SRIO device
          timeout        Timeout value populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_RT_CTL_TVAL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          timeout;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the port response timeout
        CSL_SRIO_GetPortResponseTimeoutCSR (hSrio, &timeout);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortResponseTimeoutCSR
(
    CSL_SrioHandle  hSrio, 
    Uint32*         timeout
)
{
    *timeout = (((hSrio->RIO_SP_RT_CTL) & (0xFFFFFF00u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPortResponseTimeoutCSR
 *
 *   @b Description
 *   @n The functions sets the port response timeout. This timeout is for 
 *      sending a packet to receiving the corresponding response packet
 *
 *   @b Arguments
     @verbatim
          hSrio          Handle of the SRIO device
          timeout        Timeout value to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RT_CTL_TVAL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          timeout;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the port response timeout
        CSL_SRIO_SetPortResponseTimeoutCSR (hSrio, 0xFFFF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPortResponseTimeoutCSR
(
    CSL_SrioHandle  hSrio, 
    Uint32          timeout
)
{
    ((hSrio->RIO_SP_RT_CTL) = ((hSrio->RIO_SP_RT_CTL) & ~(0xFFFFFF00u)) | (((timeout) << (0x00000008u)) & (0xFFFFFF00u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortGeneralCSR
 *
 *   @b Description
 *   @n The functions gets the CSR information for all ports. 
 *
 *   @b Arguments
     @verbatim
          hSrio          Handle of the SRIO device
          hostDev        Host /Agent or Slave Device populated by this API
          masterEn       Master Enable populated by this API
          disc           Discovered flag populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_GEN_CTL_HOST,SRIO_RIO_SP_GEN_CTL_MAST_EN,SRIO_RIO_SP_GEN_CTL_DISC
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle hSrio;
        Uint8          hostDev;
        Uint8          masterEn;
        Uint8          disc;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the port information.
        CSL_SRIO_GetPortGeneralCSR (hSrio, &hostDev, &masterEn, &disc);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortGeneralCSR
(
    CSL_SrioHandle  hSrio, 
    Uint8*          hostDev,
    Uint8*          masterEn,
    Uint8*          disc
)
{
    Uint32 value = hSrio->RIO_SP_GEN_CTL;
    *hostDev  = (((value) & (0x80000000u)) >> (0x0000001Fu));
    *masterEn = (((value) & (0x40000000u)) >> (0x0000001Eu));
    *disc     = (((value) & (0x20000000u)) >> (0x0000001Du));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPortGeneralCSR
 *
 *   @b Description
 *   @n The functions sets the CSR information for all ports. 
 *
 *   @b Arguments
     @verbatim
          hSrio          Handle of the SRIO device
          hostDev        Host /Agent or Slave Device to be configured
          masterEn       Master Enable to be configured
          disc           Discovered flag to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_GEN_CTL_HOST,SRIO_RIO_SP_GEN_CTL_MAST_EN,SRIO_RIO_SP_GEN_CTL_DISC
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the port information.
        CSL_SRIO_SetPortGeneralCSR (hSrio, 1, 1, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPortGeneralCSR
(
    CSL_SrioHandle  hSrio, 
    Uint8           hostDev,
    Uint8           masterEn,
    Uint8           disc
)
{
    hSrio->RIO_SP_GEN_CTL = (((hostDev) << (0x0000001Fu)) & (0x80000000u))      |
                            (((masterEn) << (0x0000001Eu)) & (0x40000000u))  |
                            (((disc) << (0x0000001Du)) & (0x20000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SendPortLinkMaintRequest
 *
 *   @b Description
 *   @n The function sends a port link request control symbol on the specified 
 *      SRIO port.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          cmd               Command to be sent in the link-request control symbol.
                            The following values hold good:-
                                - 0x3 i.e. Reset
                                - 0x4 i.e. Input Status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_LM_REQ_CMD
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Send a maintainance request on port 1 for reset
        CSL_SRIO_SendPortLinkMaintRequest (hSrio, 1, 3);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SendPortLinkMaintRequest
(
    CSL_SrioHandle  hSrio, 
    Uint8           portNum,
    Uint8           cmd
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_LM_REQ) = ((hSrio->RIO_SP[portNum]. RIO_SP_LM_REQ) & ~(0x00000007u)) | (((cmd) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsLinkResponseReceived
 *
 *   @b Description
 *   @n The function checks if a valid link response has been received to the 
 *      previously sent link request. 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_LM_RESP_RESP_VALID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the Link response received or not? 
        if (CSL_SRIO_IsLinkResponseReceived (hSrio, 1) == TRUE)
        {
            // Link Response was received.
        }
        else
        {
            // Link Response was NOT received 
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsLinkResponseReceived
(
    CSL_SrioHandle  hSrio, 
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_LM_RESP) & (0x80000000u)) >> (0x0000001Fu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLinkResponseStatusInfo
 *
 *   @b Description
 *   @n The function gets the status information about the link response.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          ackIdStatus       AckID status field populated by this API
          linkStatus        Link status field populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_LM_RESP_ACK_ID_STAT,SRIO_RIO_SP_LM_RESP_LINK_STAT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           ackIdStatus;
        Uint8           linkStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the Link response received or not? 
        if (CSL_SRIO_IsLinkResponseReceived (hSrio, 1) == TRUE)
        {
            // Link Response was received.
            CSL_SRIO_GetLinkResponseStatusInfo (hSrio, 1, &ackIdStatus, &linkStatus);
        }
        else
        {
            // Link Response was NOT received.
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLinkResponseStatusInfo
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          ackIdStatus,
    Uint8*          linkStatus
)
{
    Uint32 value = hSrio->RIO_SP[portNum].RIO_SP_LM_RESP;
    *ackIdStatus = (((value) & (0x000007E0u)) >> (0x00000005u));
    *linkStatus  = (((value) & (0x0000001Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearOutstandingACK
 *
 *   @b Description
 *   @n The function is used to clear the outstanding acknowledgment ids and is 
 *      used for software assisted ackID realignment.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ACKID_STAT_CLR_OUTSTD_ACKID=1
 *
 *   @b Affects
 *   @n SRIO_RIO_SP_ACKID_STAT_OUTSTD_ACKID=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Clear outstanding ackID for SRIO Port 1
        CSL_SRIO_ClearOutstandingACK (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearOutstandingACK
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ACKID_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ACKID_STAT) & ~(0x80000000u)) | ((((Uint32)1) << (0x0000001Fu)) & (0x80000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetACKStatus
 *
 *   @b Description
 *   @n The function is used to get the ACK status.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          inputAckID        Input port next expected ACK ID 
          outputUnAckID     Output port unacknowledged ackID status
          outputAckID       Output port next transmitted Acknowledge ID value
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ACKID_STAT_INB_ACKID,SRIO_RIO_SP_ACKID_STAT_OUTSTD_ACKID,SRIO_RIO_SP_ACKID_STAT_OUTB_ACKID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           inputAckID;
        Uint8           outputUnAckID;
        Uint8           outputAckID;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the ACK Status for Port 1
        CSL_SRIO_GetACKStatus (hSrio, 1, &inputAckID, &outputUnAckID, &outputAckID);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetACKStatus
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          inputAckID,
    Uint8*          outputUnAckID,
    Uint8*          outputAckID
)
{
    Uint32 value = hSrio->RIO_SP[portNum].RIO_SP_ACKID_STAT;

    *inputAckID     = (((value) & (0x3F000000u)) >> (0x00000018u));
    *outputUnAckID  = (((value) & (0x00001F00u)) >> (0x00000008u));
    *outputAckID    = (((value) & (0x0000003Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetACKStatus
 *
 *   @b Description
 *   @n The function is used to set the ACK status.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          inputAckID        Input port next expected ACK ID 
          outputUnAckID     Output port unacknowledged ackID status
          outputAckID       Output port next transmitted Acknowledge ID value
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ACKID_STAT_INB_ACKID, SRIO_RIO_SP_ACKID_STAT_OUTB_ACKID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the ACK Status for Port 1
        CSL_SRIO_SetACKStatus (hSrio, 1, 100, 205);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetACKStatus
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8           inputAckID,
    Uint8           outputAckID
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ACKID_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ACKID_STAT) & ~(0x3F000000u)) | (((inputAckID) << (0x00000018u)) & (0x3F000000u)));
    ((hSrio->RIO_SP[portNum]. RIO_SP_ACKID_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ACKID_STAT) & ~(0x0000003Fu)) | (((outputAckID) << (0x00000000u)) & (0x0000003Fu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortBaudRate
 *
 *   @b Description
 *   @n The function is used to get the initialized baud rate of the port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          baudSel           Baud Rate Selection populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL2_BAUD_SEL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           baudSel;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port 1 Baud Rate 
        CSL_SRIO_GetPortBaudRate (hSrio, 1, &baudSel);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortBaudRate
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          baudSel
)
{
    *baudSel = (((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & (0xF0000000u)) >> (0x0000001Cu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsAutomaticBaudRateDiscoverySupported
 *
 *   @b Description
 *   @n The function is used to check if automatic baud rate discovery is 
 *      supported or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL2_BAUD_DISC
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is Port1 Automatic Baud Rate Discovery supported
        if (CSL_SRIO_IsAutomaticBaudRateDiscoverySupported (hSrio, 1) == TRUE)
        {
            // Port1 Automatic Baud Rate Discovery supported
        }
        else
        {
            // Port1 Automatic Baud Rate Discovery NOT supported
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsAutomaticBaudRateDiscoverySupported
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & (0x08000000u)) >> (0x0000001Bu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_Is1_25GBaudSupported
 *
 *   @b Description
 *   @n The function is used to check if 1.25 GBaud is supported or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - 1.25GBaud is supported
 *   @n FALSE - 1.25GBaud is not supported
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL2_GB_1P25
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if 1.25Gbaud is supported or not?
        if (CSL_SRIO_Is1_25GBaudSupported (hSrio, 1) == TRUE)
        {
            // 1.25Gbaud is supported
        }
        else
        {
            // 1.25Gbaud is not supported
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_Is1_25GBaudSupported
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & (0x02000000u)) >> (0x00000019u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_Enable1_25GBaud
 *
 *   @b Description
 *   @n The function is used to enable 1.25GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_1P25_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Port1 1.25G Baud
        CSL_SRIO_Enable1_25GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Enable1_25GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x01000000u)) | (((1) << (0x00000018u)) & (0x01000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Disable1_25GBaud
 *
 *   @b Description
 *   @n The function is used to enable 1.25GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_1P25_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable Port1 1.25G Baud
        CSL_SRIO_Disable1_25GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Disable1_25GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x01000000u)) | (((0) << (0x00000018u)) & (0x01000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Is2_5GBaudSupported
 *
 *   @b Description
 *   @n The function is used to check if 2.5GBaud is supported or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - 2.5GBaud is supported
 *   @n FALSE - 2.5GBaud is not supported
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL2_GB_2P5
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if 2.5Gbaud is supported or not?
        if (CSL_SRIO_Is2_5GBaudSupported (hSrio, 1) == TRUE)
        {
            // 2.5Gbaud is supported
        }
        else
        {
            // 2.5Gbaud is not supported
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_Is2_5GBaudSupported
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & (0x00800000u)) >> (0x00000017u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_Enable2_5GBaud
 *
 *   @b Description
 *   @n The function is used to enable 2.5GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_2P5_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Port1 2.5GBaud
        CSL_SRIO_Enable2_5GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Enable2_5GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00400000u)) | (((1) << (0x00000016u)) & (0x00400000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Disable2_5GBaud
 *
 *   @b Description
 *   @n The function is used to disable 2.5GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_2P5_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable Port1 2.5GBaud
        CSL_SRIO_Disable2_5GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Disable2_5GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00400000u)) | (((0) << (0x00000016u)) & (0x00400000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Is3_125GBaudSupported
 *
 *   @b Description
 *   @n The function is used to check if 3.125GBaud is supported or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - 3.125GBaud is supported
 *   @n FALSE - 3.125GBaud is not supported
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL2_GB_3P125
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if 3.125Gbaud is supported or not?
        if (CSL_SRIO_Is3_125GBaudSupported (hSrio, 1) == TRUE)
        {
            // 3.125Gbaud is supported
        }
        else
        {
            // 3.125Gbaud is not supported
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_Is3_125GBaudSupported
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & (0x00200000u)) >> (0x00000015u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_Enable3_125GBaud
 *
 *   @b Description
 *   @n The function is used to enable 3.125GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_3P125_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Port1 3.125GBaud
        CSL_SRIO_Enable3_125GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Enable3_125GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00100000u)) | (((1) << (0x00000014u)) & (0x00100000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Disable3_125GBaud
 *
 *   @b Description
 *   @n The function is used to disable 3.125GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_3P125_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable Port1 3.125GBaud
        CSL_SRIO_Disable3_125GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Disable3_125GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00100000u)) | (((0) << (0x00000014u)) & (0x00100000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Is5GBaudSupported
 *
 *   @b Description
 *   @n The function is used to check if 5GBaud is supported or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - 5GBaud is supported
 *   @n FALSE - 5GBaud is not supported
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL2_GB_5P0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if 5Gbaud is supported or not?
        if (CSL_SRIO_Is5GBaudSupported (hSrio, 1) == TRUE)
        {
            // 5Gbaud is supported
        }
        else
        {
            // 5Gbaud is not supported
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_Is5GBaudSupported
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & (0x00080000u)) >> (0x00000013u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_Enable5GBaud
 *
 *   @b Description
 *   @n The function is used to enable 5GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_5P0_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Port1 5GBaud
        CSL_SRIO_Enable5GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Enable5GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00040000u)) | (((1) << (0x00000012u)) & (0x00040000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Disable5GBaud
 *
 *   @b Description
 *   @n The function is used to disable 5GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_5P0_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable Port1 5GBaud
        CSL_SRIO_Disable5GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Disable5GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00040000u)) | (((0) << (0x00000012u)) & (0x00040000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Is6_25GBaudSupported
 *
 *   @b Description
 *   @n The function is used to check if 6_25GBaud is supported or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - 6_25GBaud is supported
 *   @n FALSE - 6_25GBaud is not supported
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL2_GB_6P25
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if 6_25Gbaud is supported or not?
        if (CSL_SRIO_Is6_25GBaudSupported (hSrio, 1) == TRUE)
        {
            // 6_25Gbaud is supported
        }
        else
        {
            // 6_25Gbaud is not supported
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_Is6_25GBaudSupported
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & (0x00020000u)) >> (0x00000011u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_Enable6_25GBaud
 *
 *   @b Description
 *   @n The function is used to enable 6.25GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_6P25_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Port1 6.25GBaud
        CSL_SRIO_Enable6_25GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Enable6_25GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00010000u)) | (((1) << (0x00000010u)) & (0x00010000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_Disable6_25GBaud
 *
 *   @b Description
 *   @n The function is used to disable 6.25GBaud for the specified port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_GB_6P25_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable Port1 6.25GBaud
        CSL_SRIO_Disable6_25GBaud (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_Disable6_25GBaud
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00010000u)) | (((0) << (0x00000010u)) & (0x00010000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableDataScrambling
 *
 *   @b Description
 *   @n The function is used to enable data scrambling for the specific port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_D_SCRM_DIS=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable Port1 Data Scrambling
        CSL_SRIO_EnableDataScrambling (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableDataScrambling
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00000004u)) | (((1) << (0x00000002u)) & (0x00000004u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableDataScrambling
 *
 *   @b Description
 *   @n The function is used to disable data scrambling for the specific port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL2_D_SCRM_DIS=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable Port1 Data Scrambling
        CSL_SRIO_DisableDataScrambling (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableDataScrambling
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & ~(0x00000004u)) | (((0) << (0x00000002u)) & (0x00000004u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsRemoteTxEmphasisEnabled
 *
 *   @b Description
 *   @n The function is used to check if the remote transmit emphasis is enabled
 *      or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL2_RTEC
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if remote Transmit Emphasis is enabled or not?
        if (CSL_SRIO_IsRemoteTxEmphasisEnabled (hSrio, 1) == TRUE)
        {
            // Remote Transmit Emphasis is enabled
        }
        else
        {
            // Remote Transmit Emphasis is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsRemoteTxEmphasisEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL2) & (0x00000002u)) >> (0x00000001u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsOutputPktDropped
 *
 *   @b Description
 *   @n The function is used to check if the output port has discarded a packet
 *      or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_DROP
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has discarded a packet or not?
        if (CSL_SRIO_IsOutputPktDropped (hSrio, 1) == TRUE)
        {
            // Port1 has discarded the packet
        }
        else
        {
            // Port1 has NOT discarded the packet
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsOutputPktDropped
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x04000000u)) >> (0x0000001Au)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearOutputPktDropped
 *
 *   @b Description
 *   @n The function is used to clear the status of the output port after the 
 *      output port discarded condition has been detected
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_DROP=1
 *
 *   @b Affects
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_DROP=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has discarded a packet or not?
        if (CSL_SRIO_IsOutputPktDropped (hSrio, 1) == TRUE)
        {
            // Port1 has discarded the packet
            ...
            // Clear this error condition
            CSL_SRIO_ClearOutputPktDropped (hSrio, 1);
        }
        else
        {
            // Port1 has NOT discarded the packet
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearOutputPktDropped
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & ~(0x04000000u)) | (((1) << (0x0000001Au)) & (0x04000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsOutputFailed
 *
 *   @b Description
 *   @n The function is used to check if the output port has encountered a failed
 *      condition.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_FAIL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an OUTPUT failed condition?
        if (CSL_SRIO_IsOutputFailed (hSrio, 1) == TRUE)
        {
            // Port1 has detected an OUTPUT failed condition
        }
        else
        {
            // Port1 has NOT detected an OUTPUT failed condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsOutputFailed
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x02000000u)) >> (0x00000019u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearOutputFailed
 *
 *   @b Description
 *   @n The function is used to clear the status of the output port after a
 *   failed condition was detected
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_FAIL=1
 *
 *   @b Affects
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_FAIL=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected a failed condition or not? 
        if (CSL_SRIO_IsOutputFailed (hSrio, 1) == TRUE)
        {
            // Port1 has detected an OUTPUT failed condition
            ...
            // Clear this error condition
            CSL_SRIO_ClearOutputFailed (hSrio, 1);
        }
        else
        {
            // Port1 has NOT detected an OUTPUT failed condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearOutputFailed
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & ~(0x02000000u)) | (((1) << (0x00000019u)) & (0x02000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsOutputDegraded
 *
 *   @b Description
 *   @n The function is used to check if the output port has encountered a degraded
 *      condition or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_DEGR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an OUTPUT degraded condition?
        if (CSL_SRIO_IsOutputDegraded (hSrio, 1) == TRUE)
        {
            // Port1 has detected an OUTPUT degraded condition
        }
        else
        {
            // Port1 has NOT detected an OUTPUT degraded condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsOutputDegraded
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x01000000u)) >> (0x00000018u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearOutputDegrade
 *
 *   @b Description
 *   @n The function is used to clear the status of the output port after a
 *   failed condition was detected
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_DEGR=1
 *
 *   @b Affects
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_DEGR=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an OUTPUT degraded condition?
        if (CSL_SRIO_IsOutputDegraded (hSrio, 1) == TRUE)
        {
            // Port1 has detected an OUTPUT degraded condition
            ...
            // Clear this error condition
            CSL_SRIO_ClearOutputDegrade (hSrio, 1);
        }
        else
        {
            // Port1 has NOT detected an OUTPUT degraded condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearOutputDegrade
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & ~(0x01000000u)) | (((1) << (0x00000018u)) & (0x01000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsOutputRetryStopped
 *
 *   @b Description
 *   @n The function is used to check if the output port has received a packet
 *      retry control symbol.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_RETRY_STOPPED
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an OUTPUT Retry condition?
        if (CSL_SRIO_IsOutputRetryStopped (hSrio, 1) == TRUE)
        {
            // Port1 has detected an OUTPUT Retry condition
        }
        else
        {
            // Port1 has NOT detected an OUTPUT Retry condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsOutputRetryStopped
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x00040000u)) >> (0x00000012u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearOutputRetry
 *
 *   @b Description
 *   @n The function is used to clear the status of the output port after the output
 *      retry condition was detected.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_RETRY=1
 *
 *   @b Affects
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_RETRY_STOPPED=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an OUTPUT Retry condition?
        if (CSL_SRIO_IsOutputRetryStopped (hSrio, 1) == TRUE)
        {
            // Port1 has detected an OUTPUT Retry condition
            ...
            // Clear this error condition
            CSL_SRIO_ClearOutputRetry (hSrio, 1);
        }
        else
        {
            // Port1 has NOT detected an OUTPUT Retry condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearOutputRetry
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & ~(0x00100000u)) | (((1) << (0x00000014u)) & (0x00100000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsOutputErrorStopped
 *
 *   @b Description
 *   @n The function is used to check if the output port has detected an error
 *      and is in the output error stopped state
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_ERR_STOPPED
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an OUTPUT Error stopped condition?
        if (CSL_SRIO_IsOutputErrorStopped (hSrio, 1) == TRUE)
        {
            // Port1 has detected an OUTPUT Error stopped condition
        }
        else
        {
            // Port1 has NOT detected an OUTPUT Error stopped condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsOutputErrorStopped
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x00010000u)) >> (0x00000010u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearOutputErrorStopped
 *
 *   @b Description
 *   @n The function is used to clear the status of the output port after the output
 *      error stopped condition was detected.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_ERR_ENCTR=1
 *
 *   @b Affects
 *   @n SRIO_RIO_SP_ERR_STAT_OUTPUT_ERR_STOPPED=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an OUTPUT Error stopped condition?
        if (CSL_SRIO_IsOutputErrorStopped (hSrio, 1) == TRUE)
        {
            // Port1 has detected an OUTPUT Error stopped condition
            ...
            // Clear this error condition
            CSL_SRIO_ClearOutputErrorStopped (hSrio, 1);
        }
        else
        {
            // Port1 has NOT detected an OUTPUT Error stopped condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearOutputErrorStopped
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & ~(0x00020000u)) | (((1) << (0x00000011u)) & (0x00020000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsInputErrorStopped
 *
 *   @b Description
 *   @n The function is used to check if the port has detected an error
 *      and is in the input error stopped state
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_INPUT_ERR_STOPPED
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an INPUT Error stopped condition?
        if (CSL_SRIO_IsInputErrorStopped (hSrio, 1) == TRUE)
        {
            // Port1 has detected an INPUT Error stopped condition
        }
        else
        {
            // Port1 has NOT detected an INPUT Error stopped condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsInputErrorStopped
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x00000100u)) >> (0x00000008u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearInputErrorStopped
 *
 *   @b Description
 *   @n The function is used to clear the status of the input port after the input
 *      error stopped condition was detected.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_STAT_INPUT_ERR_ENCTR=1
 *
 *   @b Affects
 *   @n SRIO_RIO_SP_ERR_STAT_INPUT_ERR_STOPPED=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected an INPUT Error stopped condition?
        if (CSL_SRIO_IsInputErrorStopped (hSrio, 1) == TRUE)
        {
            // Port1 has detected an INPUT Error stopped condition
            ...
            // Clear this error condition
            CSL_SRIO_ClearInputErrorStopped (hSrio, 1);
        }
        else
        {
            // Port1 has NOT detected an INPUT Error stopped condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearInputErrorStopped
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & ~(0x00000200u)) | (((1) << (0x00000009u)) & (0x00000200u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortWritePending
 *
 *   @b Description
 *   @n The function is used to check if the port has encountered a condition 
 *      which required it to an issue an I/O logical port-write maintainance 
 *      request
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_PORT_WRITE_PEND
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected a port write pending condition?
        if (CSL_SRIO_IsPortWritePending (hSrio, 1) == TRUE)
        {
            // Port1 has detected a port write pending condition
        }
        else
        {
            // Port1 has NOT detected a port write pending condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortWritePending
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x00000010u)) >> (0x00000004u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPortWritePending
 *
 *   @b Description
 *   @n The function is used to clear the port write pending condition
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_STAT_PORT_WRITE_PEND=1
 *
 *   @b Affects
 *   @n SRIO_RIO_SP_ERR_STAT_PORT_WRITE_PEND=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 has detected a port write pending condition?
        if (CSL_SRIO_IsPortWritePending (hSrio, 1) == TRUE)
        {
            // Port1 has detected a port write pending condition
            ...
            // Clear this error condition
            CSL_SRIO_ClearInputErrorStopped (hSrio, 1);
        }
        else
        {
            // Port1 has NOT detected a port write pending condition
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPortWritePending
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) = ((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & ~(0x00000010u)) | (((1) << (0x00000004u)) & (0x00000010u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortAvailable
 *
 *   @b Description
 *   @n The function is used to check if the port is available?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_PORT_UNAVL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 is available or not?
        if (CSL_SRIO_IsPortAvailable (hSrio, 1) == TRUE)
        {
            // Port1 is available
        }
        else
        {
            // Port1 is not available
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortAvailable
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x00000008u)) >> (0x00000003u)) == 0)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortFatalErrorDetected
 *
 *   @b Description
 *   @n The function is used to check if the port has detected an error from which 
 *      the hardware was unable to recover (a fatal error).
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Port Fatal Error detected
 *   @n FALSE - Port Fatal Error not detected
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_PORT_ERR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 fatal error was detected or not?
        if (CSL_SRIO_IsPortFatalErrorDetected (hSrio, 1) == TRUE)
        {
            // Port1 has FATAL Error 
        }
        else
        {
            // Port1 does not have a FATAL Error
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortFatalErrorDetected
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x00000004u)) >> (0x00000002u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortOk
 *
 *   @b Description
 *   @n The function is used to check if the port is initialized and can be 
 *      used for exchanging error free control symbols.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Port is operational
 *   @n FALSE - Port is NOT operational
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_PORT_OK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 is ok and operational
        if (CSL_SRIO_IsPortOk (hSrio, 1) == TRUE)
        {
            // Port1 is OK and can be used
        }
        else
        {
            // Port1 is NOT OK and cannot be used
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortOk
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x00000002u)) >> (0x00000001u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortInitialized
 *
 *   @b Description
 *   @n The function is used to check if the port is initialized or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Port is initialized
 *   @n FALSE - Port is NOT initialized
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_STAT_PORT_UNINIT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if Port1 is initialized or not?
        if (CSL_SRIO_IsPortInitialized (hSrio, 1) == TRUE)
        {
            // Port1 is Initialized
        }
        else
        {
            // Port1 is NOT Initialized
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortInitialized
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_ERR_STAT) & (0x00000001u)) >> (0x00000000u)) == 0)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetSupportedPortWidth
 *
 *   @b Description
 *   @n The function is used to get the supported port width for a specific port
 *      in addition to the 1x mode which is supported by all ports.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          portWidth         Port Width populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_PORT_WIDTH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portWidth;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the supported port width for port1
        CSL_SRIO_GetSupportedPortWidth(hSrio, 1, &portWidth);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetSupportedPortWidth
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          portWidth
)
{
    *portWidth = (((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0xC0000000u)) >> (0x0000001Eu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetInitializedPortWidth
 *
 *   @b Description
 *   @n The function is used to get the width of the port after initialization.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          portWidth         Port Width populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_INIT_PWIDTH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portWidth;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the initialized port width for port1
        CSL_SRIO_GetInitializedPortWidth(hSrio, 1, &portWidth);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetInitializedPortWidth
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          portWidth
)
{
    *portWidth = (((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x38000000u)) >> (0x0000001Bu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetSoftwarePortWidth
 *
 *   @b Description
 *   @n The function is used to get the software port configuration to override
 *      the hardware sizes.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          portWidth         Port Width populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_OVER_PWIDTH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portWidth;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the software port width override
        CSL_SRIO_GetSoftwarePortWidth(hSrio, 1, &portWidth);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetSoftwarePortWidth
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          portWidth
)
{
    *portWidth = (((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x07000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetSoftwarePortWidth
 *
 *   @b Description
 *   @n The function is used to set the software port configuration to override
 *      the hardware sizes.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          portWidth         Port Width to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_OVER_PWIDTH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the software port width override to force 2x mode
        CSL_SRIO_SetSoftwarePortWidth(hSrio, 1, 5);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetSoftwarePortWidth
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8           portWidth
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x07000000u)) | (((portWidth) << (0x00000018u)) & (0x07000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePort
 *
 *   @b Description
 *   @n The function is used to enable the specific port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_PORT_DIS=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable port 1
        CSL_SRIO_EnablePort(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePort
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00800000u)) | (((0) << (0x00000017u)) & (0x00800000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePort
 *
 *   @b Description
 *   @n The function is used to disable the specific port
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_PORT_DIS=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable port 1
        CSL_SRIO_DisablePort(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePort
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00800000u)) | (((1) << (0x00000017u)) & (0x00800000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortEnabled
 *
 *   @b Description
 *   @n The function is used to check if the port is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Port is enabled
 *   @n FALSE - Port is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_PORT_DIS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if port 1 is enabled or not?
        if (CSL_SRIO_IsPortEnabled(hSrio, 1) == TRUE)
        {
            // Port1 is enabled
        }
        else
        {
            // Port1 is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00800000u)) >> (0x00000017u)) == 0)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableOutputPort
 *
 *   @b Description
 *   @n The function is used to enable the output port to issue any packets
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_OTP_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable output port 1
        CSL_SRIO_EnableOutputPort(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableOutputPort
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00400000u)) | (((1) << (0x00000016u)) & (0x00400000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableOutputPort
 *
 *   @b Description
 *   @n The function is used to disable the output port and is unable to issue
 *      any packets except to route or respond to MAINTENANCE packets.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_OTP_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable output port 1
        CSL_SRIO_DisableOutputPort(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableOutputPort
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00400000u)) | (((0) << (0x00000016u)) & (0x00400000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsOutputPortEnabled
 *
 *   @b Description
 *   @n The function is used to check if the output port is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Output Port is enabled
 *   @n FALSE - Output Port is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_OTP_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if output port 1 is enabled or not?
        if (CSL_SRIO_IsOutputPortEnabled(hSrio, 1) == TRUE)
        {
            // Output Port1 is enabled
        }
        else
        {
            // Output Port1 is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsOutputPortEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00400000u)) >> (0x00000016u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableInputPort
 *
 *   @b Description
 *   @n The function is used to enable the input port to issue any packets
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_INP_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable input port 1
        CSL_SRIO_EnableInputPort(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableInputPort
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00200000u)) | (((1) << (0x00000015u)) & (0x00200000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableInputPort
 *
 *   @b Description
 *   @n The function is used to disable the input port to issue any packets
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_INP_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable input port 1
        CSL_SRIO_DisableInputPort(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableInputPort
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00200000u)) | (((0) << (0x00000015u)) & (0x00200000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsInputPortEnabled
 *
 *   @b Description
 *   @n The function is used to check if the input port is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Input Port is enabled
 *   @n FALSE - Input Port is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_INP_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if input port 1 is enabled or not?
        if (CSL_SRIO_IsInputPortEnabled(hSrio, 1) == TRUE)
        {
            // Input Port1 is enabled
        }
        else
        {
            // Input Port1 is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsInputPortEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00200000u)) >> (0x00000015u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePortErrorChecking
 *
 *   @b Description
 *   @n The function is used to enable the error checking
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_ERR_DIS=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable error checking for port 1
        CSL_SRIO_EnablePortErrorChecking(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePortErrorChecking
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00100000u)) | (((0) << (0x00000014u)) & (0x00100000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePortErrorChecking
 *
 *   @b Description
 *   @n The function is used to disable the error checking
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_ERR_DIS=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable error checking for port 1
        CSL_SRIO_DisablePortErrorChecking(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePortErrorChecking
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00100000u)) | (((1) << (0x00000014u)) & (0x00100000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortErrorCheckingEnabled
 *
 *   @b Description
 *   @n The function is used to check if the error checking is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Error Checking is enabled
 *   @n FALSE - Error Checking is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_ERR_DIS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if error checking for port 1 is enabled or not?
        if (CSL_SRIO_IsPortErrorCheckingEnabled(hSrio, 1) == TRUE)
        {
            // Port1 error checking is enabled
        }
        else
        {
            // Port1 error checking is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortErrorCheckingEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00100000u)) >> (0x00000014u)) == 0)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetMulticastEventParticipant
 *
 *   @b Description
 *   @n The function is used to get the Multicast Event Participant status for the
 *      specific port.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          multicastEvent    Multicast Event Participant status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_MULT_CS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           multicastEvent;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Multicast Event Participant status for Port 1
        CSL_SRIO_GetMulticastEventParticipant(hSrio, 1, &multicastEvent);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetMulticastEventParticipant
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          multicastEvent
)
{
    *multicastEvent = (((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00080000u)) >> (0x00000013u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetMulticastEventParticipant
 *
 *   @b Description
 *   @n The function is used to set the Multicast Event Participant status for the
 *      specific port.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          multicastEvent    Multicast Event Participant status to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_MULT_CS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Multicast Event Participant status for Port 1
        CSL_SRIO_SetMulticastEventParticipant(hSrio, 1, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetMulticastEventParticipant
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8           multicastEvent
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00080000u)) | (((multicastEvent) << (0x00000013u)) & (0x00080000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePortFlowControl
 *
 *   @b Description
 *   @n The function is used to enable the port flow control
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_FLOW_CTRL=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable flow control for port 1
        CSL_SRIO_EnablePortFlowControl(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePortFlowControl
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00040000u)) | (((1) << (0x00000012u)) & (0x00040000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePortFlowControl
 *
 *   @b Description
 *   @n The function is used to disable the port flow control
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_FLOW_CTRL=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable flow control for port 1
        CSL_SRIO_DisablePortFlowControl(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePortFlowControl
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00040000u)) | (((0) << (0x00000012u)) & (0x00040000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortFlowControlEnabled
 *
 *   @b Description
 *   @n The function is used to check if the flow control on the specific port 
 *      is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Flow Control is enabled
 *   @n FALSE - Flow Control is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_FLOW_CTRL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if flow control for port 1 is enabled or not?
        if (CSL_SRIO_IsPortFlowControlEnabled(hSrio, 1) == TRUE)
        {
            // Port1 flow control is enabled
        }
        else
        {
            // Port1 flow control is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortFlowControlEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00040000u)) >> (0x00000012u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePortFlowArbiteration
 *
 *   @b Description
 *   @n The function is used to enable the port flow arbiteration
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_FLOW_ARB=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable flow arbiteration for port 1
        CSL_SRIO_EnablePortFlowArbiteration(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePortFlowArbiteration
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00010000u)) | (((1) << (0x00000010u)) & (0x00010000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePortFlowArbiteration
 *
 *   @b Description
 *   @n The function is used to disable the port flow arbiteration
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_FLOW_ARB=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable flow arbiteration for port 1
        CSL_SRIO_DisablePortFlowArbiteration(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePortFlowArbiteration
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00010000u)) | (((0) << (0x00000010u)) & (0x00010000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortFlowArbiterationEnabled
 *
 *   @b Description
 *   @n The function is used to check if the flow arbiteration on the specific port 
 *      is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Flow Arbiteration is enabled
 *   @n FALSE - Flow Arbiteration is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_FLOW_ARB
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if flow arbiteration for port 1 is enabled or not?
        if (CSL_SRIO_IsPortFlowArbiterationEnabled(hSrio, 1) == TRUE)
        {
            // Port1 flow arbiteration is enabled
        }
        else
        {
            // Port1 flow arbiteration is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortFlowArbiterationEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00010000u)) >> (0x00000010u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePortStopFail
 *
 *   @b Description
 *   @n The function is used to enable the port stop fail
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_STOP_FAIL_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable stop fail for port 1
        CSL_SRIO_EnablePortStopFail(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePortStopFail
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00000008u)) | (((1) << (0x00000003u)) & (0x00000008u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePortStopFail
 *
 *   @b Description
 *   @n The function is used to disable the port stop fail
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_STOP_FAIL_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable stop fail for port 1
        CSL_SRIO_DisablePortStopFail(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePortStopFail
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00000008u)) | (((0) << (0x00000003u)) & (0x00000008u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortStopFailEnabled
 *
 *   @b Description
 *   @n The function is used to check if the port stop failed is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Stop flow is enabled
 *   @n FALSE - Stop flow is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_STOP_FAIL_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if stop fail for port 1 is enabled or not?
        if (CSL_SRIO_IsPortStopFailEnabled(hSrio, 1) == TRUE)
        {
            // Port1 stop fail is enabled
        }
        else
        {
            // Port1 stop fail is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortStopFailEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00000008u)) >> (0x00000003u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePortDrop
 *
 *   @b Description
 *   @n The function is used to enable the port drop
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_DROP_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable drop for port 1
        CSL_SRIO_EnablePortDrop(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePortDrop
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00000004u)) | (((1) << (0x00000002u)) & (0x00000004u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePortDrop
 *
 *   @b Description
 *   @n The function is used to disable the port drop
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_DROP_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable drop for port 1
        CSL_SRIO_DisablePortDrop(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePortDrop
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00000004u)) | (((0) << (0x00000002u)) & (0x00000004u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortDropEnabled
 *
 *   @b Description
 *   @n The function is used to check if the port drop is enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Port drop is enabled
 *   @n FALSE - Port drop is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_DROP_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if stop fail for port 1 is enabled or not?
        if (CSL_SRIO_IsPortDropEnabled(hSrio, 1) == TRUE)
        {
            // Port1 drop is enabled
        }
        else
        {
            // Port1 drop is disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortDropEnabled
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00000004u)) >> (0x00000002u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePortLockout
 *
 *   @b Description
 *   @n The function is used to enable the port lockout
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_PORT_LOCKOUT=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable port lockout for port 1
        CSL_SRIO_EnablePortLockout(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePortLockout
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePortLockout
 *
 *   @b Description
 *   @n The function is used to disable the port lockout
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_CTL_PORT_LOCKOUT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable port lockout for port 1
        CSL_SRIO_DisablePortLockout(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePortLockout
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) = ((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & ~(0x00000002u)) | (((0) << (0x00000001u)) & (0x00000002u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPortLockedout
 *
 *   @b Description
 *   @n The function is used to check if the port is locked out or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Port is Locked out
 *   @n FALSE - Port is NOT Locked out
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_PORT_LOCKOUT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if port 1 is locked out or not?
        if (CSL_SRIO_IsPortLockedout(hSrio, 1) == TRUE)
        {
            // Port1 is locked out
        }
        else
        {
            // Port1 is NOT locked out
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPortLockedout
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    if ((((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00000002u)) >> (0x00000001u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortType
 *
 *   @b Description
 *   @n The function is used to get the port type.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          portType          Port Type populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_CTL_PTYP
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portType;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable port lockout for port 1
        CSL_SRIO_GetPortType(hSrio, 1, &portType);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortType
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          portType
)
{
    *portType = (((hSrio->RIO_SP[portNum]. RIO_SP_CTL) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorReportBlockHeader
 *
 *   @b Description
 *   @n The function is used to get the error report block header information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          efPtr             Extended Feature Pointer populated by this API 
          efId              Extended Feature ID populated by this API 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_ERR_RPT_BH_EF_PTR,SRIO_RIO_ERR_RPT_BH_EF_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint16          efPtr;
        Uint16          efId;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Error reporting block header information
        CSL_SRIO_GetErrorReportBlockHeader(hSrio, &efPtr, &efId);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorReportBlockHeader
(
    CSL_SrioHandle  hSrio,
    Uint16*         efPtr,
    Uint16*         efId
)
{
    Uint32 value = hSrio->RIO_ERR_RPT_BH;
    *efPtr = (((value) & (0xFFFF0000u)) >> (0x00000010u));
    *efId  = (((value) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorDetectCSR
 *
 *   @b Description
 *   @n The function is used to get the error detected CSR information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          errDetect         Error Detect Information populated by this API 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_ERR_DET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          errDetect;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the error detect information
        CSL_SRIO_GetErrorDetectCSR(hSrio, &errDetect);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorDetectCSR
(
    CSL_SrioHandle  hSrio,
    Uint32*         errDetect
)
{
    *errDetect = hSrio->RIO_ERR_DET;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetErrorDetectCSR
 *
 *   @b Description
 *   @n The function is used to set the error detected CSR information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          errDetect         Error Detect Information to be cleared
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_ERR_DET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          errDetect;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the error detect information
        CSL_SRIO_GetErrorDetectCSR(hSrio, &errDetect);
        ...
        // Clear the error detect informatio
        CSL_SRIO_SetErrorDetectCSR(hSrio, errDetect);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetErrorDetectCSR
(
    CSL_SrioHandle  hSrio,
    Uint32          errDetect
)
{
    hSrio->RIO_ERR_DET = errDetect;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorEnable
 *
 *   @b Description
 *   @n The function is used to get the error enable status
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          errEnable         Error Enable Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_ERR_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          errEnable;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the error enable status information
        CSL_SRIO_GetErrorEnable(hSrio, &errEnable);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorEnable
(
    CSL_SrioHandle  hSrio,
    Uint32*         errEnable
)
{
    *errEnable = hSrio->RIO_ERR_EN;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetErrorEnable
 *
 *   @b Description
 *   @n The function is used to set the error enable status
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          errEnable         Error Enable Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_ERR_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          errEnable;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the error enable status information
        CSL_SRIO_GetErrorEnable(hSrio, &errEnable);
        
        // Ensure that IO Error response is enabled
        errEnable = errEnable | 0x80000000;
        CSL_SRIO_SetErrorEnable(hSrio, errEnable);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetErrorEnable
(
    CSL_SrioHandle  hSrio,
    Uint32          errEnable
)
{
    hSrio->RIO_ERR_EN = errEnable;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetHighAddressCapture
 *
 *   @b Description
 *   @n The function is used to get the MSB 32 bits of the address which
 *      caused the error
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          hiAddress         High Address populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_H_ADDR_CAPT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          hiAddress;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the high address information
        CSL_SRIO_GetHighAddressCapture(hSrio, &hiAddress);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetHighAddressCapture
(
    CSL_SrioHandle  hSrio,
    Uint32*         hiAddress
)
{
    *hiAddress = hSrio->RIO_H_ADDR_CAPT;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetHighAddressCapture
 *
 *   @b Description
 *   @n The function is used to set the MSB 32 bits of the address which
 *      caused the error
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          hiAddress         High Address to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_H_ADDR_CAPT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Clear the High Address Error Capture 
        CSL_SRIO_SetHighAddressCapture(hSrio, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetHighAddressCapture
(
    CSL_SrioHandle  hSrio,
    Uint32          hiAddress
)
{
    hSrio->RIO_H_ADDR_CAPT = hiAddress;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetAddressCapture
 *
 *   @b Description
 *   @n The function is used to get the LSB 29 bits of the address which
 *      caused the error and also the extended address bits
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          address           Address populated by this API
          xamsbs            Extended Address Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_ADDR_CAPT_ADDR_LOW,SRIO_RIO_ADDR_CAPT_XAMSBS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          address;
        Uint8           xamsbs;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the address information which caused the error
        CSL_SRIO_GetAddressCapture(hSrio, &hiAddress, &xamsbs);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetAddressCapture
(
    CSL_SrioHandle  hSrio,
    Uint32*         address,
    Uint8*          xamsbs
)
{
    *address = (((hSrio->RIO_ADDR_CAPT) & (0xFFFFFFF8u)) >> (0x00000003u));
    *xamsbs  = (((hSrio->RIO_ADDR_CAPT) & (0x00000003u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetAddressCapture
 *
 *   @b Description
 *   @n The function is used to set the LSB 29 bits of the address which
 *      caused the error and also the extended address bits
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          address           Address to be configured
          xamsbs            Extended Address Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_ADDR_CAPT_ADDR_LOW,SRIO_RIO_ADDR_CAPT_XAMSBS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Clear address information which caused the error
        CSL_SRIO_SetAddressCapture(hSrio, 0x0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetAddressCapture
(
    CSL_SrioHandle  hSrio,
    Uint32          address,
    Uint8           xamsbs
)
{
    hSrio->RIO_ADDR_CAPT = (((address) << (0x00000003u)) & (0xFFFFFFF8u))    |
                           (((xamsbs) << (0x00000000u)) & (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetIDCapture
 *
 *   @b Description
 *   @n The function is used to get the source and destination id associated
 *   with the error
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          msbdstId          MSB Destination ID
          lsbdstID          LSB Destination ID
          msbsrcId          MSB Source ID
          lsbsrcId          LSB Source ID          
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_ID_CAPT_MSB_DSTID,  SRIO_RIO_ID_CAPT_DSTID,
 *   @n SRIO_RIO_ID_CAPT_MSB_SRCTID, SRIO_RIO_ID_CAPT_SRCID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           msbdstId;
        Uint8           lsbdstID;
        Uint8           msbsrcId;
        Uint8           lsbsrcId;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the address capture information which caused the error
        CSL_SRIO_GetIDCapture(hSrio, &msbdstId, &lsbdstID, &msbsrcId, &lsbsrcId);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetIDCapture
(
    CSL_SrioHandle  hSrio,
    Uint8*          msbdstId,
    Uint8*          lsbdstId,
    Uint8*          msbsrcId,
    Uint8*          lsbsrcId
)
{
    Uint32 value = hSrio->RIO_ID_CAPT;

    *msbdstId = (((value) & (0xFF000000u)) >> (0x00000018u));
    *lsbdstId = (((value) & (0x00FF0000u)) >> (0x00000010u));
    *msbsrcId = (((value) & (0x0000FF00u)) >> (0x00000008u));
    *lsbsrcId = (((value) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetIDCapture
 *
 *   @b Description
 *   @n The function is used to set the source and destination id associated
 *   with the error
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          msbdstId          MSB Destination ID
          lsbdstID          LSB Destination ID
          msbsrcId          MSB Source ID
          lsbsrcId          LSB Source ID          
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_ID_CAPT_MSB_DSTID,  SRIO_RIO_ID_CAPT_DSTID,
 *   @n SRIO_RIO_ID_CAPT_MSB_SRCTID, SRIO_RIO_ID_CAPT_SRCID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           msbdstId;
        Uint8           lsbdstID;
        Uint8           msbsrcId;
        Uint8           lsbsrcId;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Clear the address capture information
        CSL_SRIO_SetIDCapture(hSrio, 0x0, 0x0, 0x0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetIDCapture
(
    CSL_SrioHandle  hSrio,
    Uint8           msbdstId,
    Uint8           lsbdstId,
    Uint8           msbsrcId,
    Uint8           lsbsrcId
)
{
    hSrio->RIO_ID_CAPT = (((msbdstId) << (0x00000018u)) & (0xFF000000u))    |
                         (((lsbdstId) << (0x00000010u)) & (0x00FF0000u))    |
                         (((msbsrcId) << (0x00000008u)) & (0x0000FF00u))    |
                         (((lsbsrcId) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetControlCapture
 *
 *   @b Description
 *   @n The function is used to get the control information associated with 
 *   the error
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          ftype             FTPYE associated with the error
          ttype             TTPYE associated with the error
          msgInfo           Message Information associated with the error
          implSpecific      Implementation Specific information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_CTRL_CAPT_FTYPE,  SRIO_RIO_CTRL_CAPT_TTYPE,
 *   @n SRIO_RIO_CTRL_CAPT_MSG_INFO, SRIO_RIO_CTRL_CAPT_IMP_SPECIFIC
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           ftype;
        Uint8           ttype;
        Uint8           msgInfo;
        Uint16          implSpecific;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the control capture information which caused the error
        CSL_SRIO_GetControlCapture(hSrio, &ftype, &ttype, &msgInfo, &implSpecific);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetControlCapture
(
    CSL_SrioHandle  hSrio,
    Uint8*          ftype,
    Uint8*          ttype,
    Uint8*          msgInfo,
    Uint16*         implSpecific
)
{
    Uint32 value = hSrio->RIO_CTRL_CAPT;

    *ftype          = (((value) & (0xF0000000u)) >> (0x0000001Cu));
    *ttype          = (((value) & (0x0F000000u)) >> (0x00000018u));
    *msgInfo        = (((value) & (0x00FF0000u)) >> (0x00000010u));
    *implSpecific   = (((value) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetControlCapture
 *
 *   @b Description
 *   @n The function is used to set the control information associated with 
 *   the error
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          ftype             FTPYE associated with the error
          ttype             TTPYE associated with the error
          msgInfo           Message Information associated with the error
          implSpecific      Implementation Specific information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_CTRL_CAPT_FTYPE,  SRIO_RIO_CTRL_CAPT_TTYPE,
 *   @n SRIO_RIO_CTRL_CAPT_MSG_INFO, SRIO_RIO_CTRL_CAPT_IMP_SPECIFIC
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Clear the control capture information which caused the error
        CSL_SRIO_SetControlCapture(hSrio, 0x0, 0x0, 0x0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetControlCapture
(
    CSL_SrioHandle  hSrio,
    Uint8           ftype,
    Uint8           ttype,
    Uint8           msgInfo,
    Uint16          implSpecific
)
{
    hSrio->RIO_CTRL_CAPT = (((ftype) << (0x0000001Cu)) & (0xF0000000u))            |
                           (((ttype) << (0x00000018u)) & (0x0F000000u))            |
                           (((msgInfo) << (0x00000010u)) & (0x00FF0000u))       |
                           (((implSpecific) << (0x00000000u)) & (0x0000FFFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortWriteDeviceId
 *
 *   @b Description
 *   @n The function is used to get the target device ID to be used when a 
 *      device generates a Maintenance Port-Write operation to report errors to 
 *      a system host.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          msbTargetId       Most significant byte of Port-Write Target device ID
          lsbTargetID       Least significant byte of Port-Write Target device ID
          lrgTrans          DeviceID size to use for a port-write
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PW_TGT_ID_DEVICEID_MSB,SRIO_RIO_PW_TGT_ID_DEVICEID,
 *   @n SRIO_RIO_PW_TGT_ID_ID_LARGE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           msbTargetId;
        Uint8           lsbTargetID;
        Uint8           lrgTrans;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port Write Target Device ID information.
        CSL_SRIO_GetPortWriteDeviceId(hSrio, &msbTargetId, &lsbTargetID, &lrgTrans);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortWriteDeviceId
(
    CSL_SrioHandle  hSrio,
    Uint8*          msbTargetId,
    Uint8*          lsbTargetID,
    Uint8*          lrgTrans
)
{
    Uint32 value = hSrio->RIO_PW_TGT_ID;
    *msbTargetId = (((value) & (0xFF000000u)) >> (0x00000018u));
    *lsbTargetID = (((value) & (0x00FF0000u)) >> (0x00000010u));
    *lrgTrans    = (((value) & (0x00008000u)) >> (0x0000000Fu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPortWriteDeviceId
 *
 *   @b Description
 *   @n The function is used to get the target device ID to be used when a 
 *      device generates a Maintenance Port-Write operation to report errors to 
 *      a system host.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          msbTargetId       Most significant byte of Port-Write Target device ID
          lsbTargetID       Least significant byte of Port-Write Target device ID
          lrgTrans          DeviceID size to use for a port-write
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PW_TGT_ID_DEVICEID_MSB,SRIO_RIO_PW_TGT_ID_DEVICEID,
 *   @n SRIO_RIO_PW_TGT_ID_ID_LARGE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Port Write Target Device ID information.
        CSL_SRIO_SetPortWriteDeviceId (hSrio, 0x0, 0x80, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPortWriteDeviceId
(
    CSL_SrioHandle  hSrio,
    Uint8           msbTargetId,
    Uint8           lsbTargetID,
    Uint8           lrgTrans
)
{
    hSrio->RIO_PW_TGT_ID = (((msbTargetId) << (0x00000018u)) & (0xFF000000u)) |
                           (((lsbTargetID) << (0x00000010u)) & (0x00FF0000u)) |
                           (((lrgTrans) << (0x0000000Fu)) & (0x00008000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortError
 *
 *   @b Description
 *   @n The function is used to get the physical layer errors that have been 
 *      detected by the Port hardware
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
          errStatus         Error Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_DET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          errStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port 1 Error Status
        CSL_SRIO_GetPortError(hSrio, 1, &errStatus);
        if (errStatus != 0)
        {
            // Port Errors detected
        }
        else
        {
            // No Port Errors detected
        }        
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint32*         errStatus
)
{
    *errStatus = hSrio->RIO_SP_ERR[portNum].RIO_SP_ERR_DET;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPortError
 *
 *   @b Description
 *   @n The function is used to clear any port errors which were detected by 
 *      the port Physical layer.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_DET=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port 1 Error Status
        CSL_SRIO_GetPortError(hSrio, 1, &errStatus);
        if (errStatus != 0)
        {
            // Port Errors detected
            ...
            // Clear port errors.
            CSL_SRIO_ClearPortError (hSrio, 1);
        }
        else
        {
            // No port errors detected 
        }
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    hSrio->RIO_SP_ERR[portNum].RIO_SP_ERR_DET = 0x0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableImpSpecificPortError
 *
 *   @b Description
 *   @n The function is used to enable the ability for the SRIO port to rate count
 *      implementation specific errors.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_IMP_SPEC_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the Implementation specific Port 1 Rate counting
        CSL_SRIO_EnableImpSpecificPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableImpSpecificPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x80000000u)) | ((((Uint32)1) << (0x0000001Fu)) & (0x80000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableImpSpecificPortError
 *
 *   @b Description
 *   @n The function is used to disable the ability for the SRIO port to rate count
 *      implementation specific errors.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_IMP_SPEC_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the Implementation specific Port 1 Rate counting
        CSL_SRIO_DisableImpSpecificPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableImpSpecificPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x80000000u)) | (((0) << (0x0000001Fu)) & (0x80000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableControlSymBadCRCPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for Received 
 *      Control Symbol with a bad CRC
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_CS_CRC_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the Control Symbol Bad CRC rate counting. 
        CSL_SRIO_EnableControlSymBadCRCPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableControlSymBadCRCPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00400000u)) | (((1) << (0x00000016u)) & (0x00400000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableControlSymBadCRCPortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for Received 
 *      Control Symbol with a bad CRC
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_CS_CRC_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the Control Symbol Bad CRC rate counting. 
        CSL_SRIO_DisableControlSymBadCRCPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableControlSymBadCRCPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00400000u)) | (((0) << (0x00000016u)) & (0x00400000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableUnexpectedAckIDPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for Received 
 *      Control Symbol with an unexpected ACK ID
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_CS_ILL_ID_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the unexpected ACK ID Port Error
        CSL_SRIO_EnableUnexpectedAckIDPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableUnexpectedAckIDPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00200000u)) | (((1) << (0x00000015u)) & (0x00200000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableUnexpectedAckIDPortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for Received 
 *      Control Symbol with an unexpected ACK ID
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_CS_ILL_ID_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the unexpected ACK ID Port Error
        CSL_SRIO_DisableUnexpectedAckIDPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableUnexpectedAckIDPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00200000u)) | (((0) << (0x00000015u)) & (0x00200000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePacketNotAcceptedPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for packet not
 *      accepted control symbol.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_CS_NOT_ACC_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the packet not accepted port error
        CSL_SRIO_EnablePacketNotAcceptedPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePacketNotAcceptedPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00100000u)) | (((1) << (0x00000014u)) & (0x00100000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePacketNotAcceptedPortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for packet not
 *      accepted control symbol.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_CS_NOT_ACC_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the packet not accepted port error
        CSL_SRIO_DisablePacketNotAcceptedPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePacketNotAcceptedPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00100000u)) | (((0) << (0x00000014u)) & (0x00100000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePacketUnexpectedAckIdError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for packets with
 *      unexpected ack id
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_PKT_ILL_ACKID_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the packet with unexpected ack id rate counting
        CSL_SRIO_EnablePacketUnexpectedAckIdError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePacketUnexpectedAckIdError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00080000u)) | (((1) << (0x00000013u)) & (0x00080000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePacketUnexpectedAckIdError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for packets with
 *      unexpected ack id
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_PKT_ILL_ACKID_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the packet with unexpected ack id rate counting
        CSL_SRIO_DisablePacketUnexpectedAckIdError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePacketUnexpectedAckIdError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00080000u)) | (((0) << (0x00000013u)) & (0x00080000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePacketBadCRCError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for packets with
 *      bad CRC
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_PKT_CRC_ERR_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the packet with bad CRC error rate counting
        CSL_SRIO_EnablePacketBadCRCError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePacketBadCRCError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00040000u)) | (((1) << (0x00000012u)) & (0x00040000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePacketBadCRCError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for packets with
 *      bad CRC
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_PKT_CRC_ERR_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the packet with bad CRC error rate counting
        CSL_SRIO_DisablePacketBadCRCError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePacketBadCRCError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00040000u)) | (((0) << (0x00000012u)) & (0x00040000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableIllegalSizePortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for packets with
 *      illegal size
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_PKT_ILL_SIZE_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the rate counting of packets with illegal size error 
        CSL_SRIO_EnableIllegalSizePortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableIllegalSizePortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00020000u)) | (((1) << (0x00000011u)) & (0x00020000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableIllegalSizePortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for packets with
 *      illegal size
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_PKT_ILL_SIZE_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the rate counting of packets with illegal size error 
        CSL_SRIO_DisableIllegalSizePortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableIllegalSizePortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00020000u)) | (((0) << (0x00000011u)) & (0x00020000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableDescramblingLOSPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting of the loss of 
 *      receiver de-scrambler synchronization when control symbol and packet data 
 *      is being scrambled before transmission.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_DSCRAM_LOS_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the error rate counting for the LOS Descrambling
        CSL_SRIO_EnableDescramblingLOSPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableDescramblingLOSPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00004000u)) | (((1) << (0x0000000Eu)) & (0x00004000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableDescramblingLOSPortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting of the loss of 
 *      receiver de-scrambler synchronization when control symbol and packet data 
 *      is being scrambled before transmission.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_DSCRAM_LOS_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the error rate counting for the LOS Descrambling
        CSL_SRIO_DisableDescramblingLOSPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableDescramblingLOSPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00004000u)) | (((0) << (0x0000000Eu)) & (0x00004000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableIllegalAckIDPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for receiving an
 *      ACK ID that is not outstanding. 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_LR_ACKID_ILL_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the error rate counting for the illegal ACK ID.
        CSL_SRIO_EnableIllegalAckIDPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableIllegalAckIDPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000020u)) | (((1) << (0x00000005u)) & (0x00000020u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableIllegalAckIDPortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for receiving an
 *      ACK ID that is not outstanding. 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_LR_ACKID_ILL_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the error rate counting for the illegal ACK ID.
        CSL_SRIO_DisableIllegalAckIDPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableIllegalAckIDPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000020u)) | (((0) << (0x00000005u)) & (0x00000020u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableProtocolPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for protocol 
 *      errors
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_PROT_ERR_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the error rate counting for protocol errors.
        CSL_SRIO_EnableProtocolPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableProtocolPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000010u)) | (((1) << (0x00000004u)) & (0x00000010u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableProtocolPortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for protocol 
 *      errors
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_PROT_ERR_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the error rate counting for protocol errors.
        CSL_SRIO_DisableProtocolPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableProtocolPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000010u)) | (((0) << (0x00000004u)) & (0x00000010u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableDelineationPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for delineation 
 *      errors
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_DELIN_ERR_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the error rate counting for delineation errors.
        CSL_SRIO_EnableDelineationPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableDelineationPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000004u)) | (((1) << (0x00000002u)) & (0x00000004u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableDelineationPortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for delineation 
 *      errors
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_DELIN_ERR_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the error rate counting for delineation errors.
        CSL_SRIO_DisableDelineationPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableDelineationPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000004u)) | (((0) << (0x00000002u)) & (0x00000004u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableIllegalCSPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for illegal control
 *      symbols.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_CS_ACK_ILL_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the error rate counting for illegal control symbols.
        CSL_SRIO_EnableIllegalCSPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableIllegalCSPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableIllegalCSPortError
 *
 *   @b Description
 *   @n The function is used to disable the error rate counting for illegal control
 *      symbols.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_CS_ACK_ILL_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the error rate counting for illegal control symbols.
        CSL_SRIO_DisableIllegalCSPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableIllegalCSPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000002u)) | (((0) << (0x00000001u)) & (0x00000002u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableLinkTimeoutPortError
 *
 *   @b Description
 *   @n The function is used to enable the error rate counting for link responses
 *      not received within the specific timeout.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_RATE_EN_LINK_TO_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the error rate counting for link timeout errors.
        CSL_SRIO_EnableLinkTimeoutPortError (hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableLinkTimeoutPortError
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum
)
{
    ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) = ((hSrio->RIO_SP_ERR[portNum]. RIO_SP_RATE_EN) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorCaptureInfo
 *
 *   @b Description
 *   @n The function is used to get the error capture information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
          infoType          Error Information Type
          errType           Encoded Value of the the captured error bits
          implDep           Implementation Dependent Error Information
          valCapt           Capture Valid Information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_ATTR_CAPT_INFO_TYPE,SRIO_RIO_SP_ERR_ATTR_CAPT_ERR_TYPE,SRIO_RIO_SP_ERR_ATTR_CAPT_IMPL_DEP,SRIO_RIO_SP_ERR_ATTR_CAPT_VAL_CAPT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           infoType;
        Uint8           errType;
        Uint32          implDep;
        Uint8           valCapt;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the error capture information
        CSL_SRIO_GetErrorCaptureInfo (hSrio, 1, &infoType, &errType, &implDep, &valCapt);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorCaptureInfo
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          infoType,
    Uint8*          errType,
    Uint32*         implDep,
    Uint8*          valCapt
)
{
    *infoType = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_ATTR_CAPT) & (0xE0000000u)) >> (0x0000001Du));
    *errType  = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_ATTR_CAPT) & (0x1F000000u)) >> (0x00000018u));
    *implDep  = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_ATTR_CAPT) & (0x00FFFFF0u)) >> (0x00000004u));
    *valCapt  = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_ATTR_CAPT) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorCapture
 *
 *   @b Description
 *   @n The function is used to get the error capture information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
          errCap0           Error 0 Capture Information 
          errCap1           Error 1 Capture Information 
          errCap2           Error 2 Capture Information 
          errCap3           Error 3 Capture Information 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_CAPT_0,SRIO_RIO_SP_ERR_CAPT_1,
 *   @n SRIO_RIO_SP_ERR_CAPT_2,SRIO_RIO_SP_ERR_CAPT_3
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint32          errCap0;
        Uint32          errCap1;
        Uint32          errCap2;
        Uint32          errCap3;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the error capture information
        CSL_SRIO_GetErrorCapture (hSrio, 1, &errCap0, &errCap1, &errCap2, &errCap3);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorCapture
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint32*         errCap0,
    Uint32*         errCap1,
    Uint32*         errCap2,
    Uint32*         errCap3
)
{
    *errCap0 = hSrio->RIO_SP_ERR[portNum].RIO_SP_ERR_CAPT_0;
    *errCap1 = hSrio->RIO_SP_ERR[portNum].RIO_SP_ERR_CAPT_1;
    *errCap2 = hSrio->RIO_SP_ERR[portNum].RIO_SP_ERR_CAPT_2;
    *errCap3 = hSrio->RIO_SP_ERR[portNum].RIO_SP_ERR_CAPT_3;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorRateCSR
 *
 *   @b Description
 *   @n The function is used to get the error rate CSR which is used to monitor
 *      and control the reporting of the Port Physical layer errors.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
          ptrErrorRate      Error Rate configuration.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_RATE_ERR_RB,SRIO_RIO_SP_ERR_RATE_ERR_RR,
 *   @n SRIO_RIO_SP_ERR_RATE_ERR_PEAK,SRIO_RIO_SP_ERR_RATE_ERR_RATE_CNT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        SRIO_ERR_RATE   errorRate;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Error Rate CSR Information.
        CSL_SRIO_GetErrorRateCSR (hSrio, 1, &errorRate);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorRateCSR
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    SRIO_ERR_RATE*  ptrErrorRate
)
{
    ptrErrorRate->errRateBias     = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_RATE) & (0xFF000000u)) >> (0x00000018u)); 
    ptrErrorRate->errRateRecovery = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_RATE) & (0x00030000u)) >> (0x00000010u)); 
    ptrErrorRate->peak            = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_RATE) & (0x0000FF00u)) >> (0x00000008u)); 
    ptrErrorRate->errRateCnt      = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_RATE) & (0x000000FFu)) >> (0x00000000u)); 
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetErrorRateCSR
 *
 *   @b Description
 *   @n The function is used to set the error rate CSR which is used to monitor
 *      and control the reporting of the Port Physical layer errors.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number 
          ptrErrorRate      Error Rate configuration.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_RATE_ERR_RB,SRIO_RIO_SP_ERR_RATE_ERR_RR,
 *   @n SRIO_RIO_SP_ERR_RATE_ERR_PEAK,SRIO_RIO_SP_ERR_RATE_ERR_RATE_CNT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        SRIO_ERR_RATE   errorRate;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Error Rate CSR Information.
        CSL_SRIO_GetErrorRateCSR (hSrio, 1, &errorRate);

        // Modify the configuration to not decrement the error rate counter
        errorRate.errRateBias = 0x0;
        CSL_SRIO_SetErrorRateCSR (hSrio, 1, &errorRate);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetErrorRateCSR
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    SRIO_ERR_RATE*  ptrErrorRate
)
{
    hSrio->RIO_SP_ERR[portNum].RIO_SP_ERR_RATE = 
            (((ptrErrorRate ->errRateBias) << (0x00000018u)) & (0xFF000000u))      |
            (((ptrErrorRate ->errRateRecovery) << (0x00000010u)) & (0x00030000u))  |
            (((ptrErrorRate ->peak) << (0x00000008u)) & (0x0000FF00u))             |
            (((ptrErrorRate ->errRateCnt) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorRateThreshold
 *
 *   @b Description
 *   @n The function is used to get the error rate threshold.
 *
 *   @b Arguments
     @verbatim
          hSrio                     Handle of the SRIO device
          portNum                   SRIO Port Number 
          errRateFailedThreshold    Threshold value for reporting an error condition 
                                    due to possibly broken link
          errRateDegradeThreshold   Threshold value for reporting an error condition 
                                    due to a degrading link.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_ERR_THRESH_ERR_RFT, SRIO_RIO_SP_ERR_THRESH_ERR_RDT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           errRateFailedThreshold;
        Uint8           errRateDegradeThreshold;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Error Rate Threshold Information.
        CSL_SRIO_GetErrorRateThreshold (hSrio, 1, &errRateFailedThreshold, &errRateDegradeThreshold);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorRateThreshold
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8*          errRateFailedThreshold,
    Uint8*          errRateDegradeThreshold
)
{
    *errRateFailedThreshold  = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_THRESH) & (0xFF000000u)) >> (0x00000018u));
    *errRateDegradeThreshold = (((hSrio->RIO_SP_ERR[portNum]. RIO_SP_ERR_THRESH) & (0x00FF0000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetErrorRateThreshold
 *
 *   @b Description
 *   @n The function is used to set the error rate threshold.
 *
 *   @b Arguments
     @verbatim
          hSrio                     Handle of the SRIO device
          portNum                   SRIO Port Number 
          errRateFailedThreshold    Threshold value for reporting an error condition 
                                    due to possibly broken link
          errRateDegradeThreshold   Threshold value for reporting an error condition 
                                    due to a degrading link.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_SP_ERR_THRESH_ERR_RFT, SRIO_RIO_SP_ERR_THRESH_ERR_RDT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Error Rate Threshold Information disabling both failed & 
        // degraded triggers
        CSL_SRIO_SetErrorRateThreshold (hSrio, 1, 0x0, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetErrorRateThreshold
(
    CSL_SrioHandle  hSrio,
    Uint8           portNum,
    Uint8           errRateFailedThreshold,
    Uint8           errRateDegradeThreshold
)
{
    hSrio->RIO_SP_ERR[portNum].RIO_SP_ERR_THRESH = 
            (((errRateFailedThreshold) << (0x00000018u)) & (0xFF000000u)) | 
            (((errRateDegradeThreshold) << (0x00000010u)) & (0x00FF0000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLaneStatus
 *
 *   @b Description
 *   @n The function is used to get the lane status information.
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
          ptrLaneStatus         Pointer to the Lane status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LANE_STAT0_PORT_NUM, SRIO_RIO_LANE_STAT0_LANE_NUM,
 *   @n SRIO_RIO_LANE_STAT0_TX_TYPE, SRIO_RIO_LANE_STAT0_TX_MODE,
 *   @n SRIO_RIO_LANE_STAT0_RX_TYPE, SRIO_RIO_LANE_STAT0_RX_INV,
 *   @n SRIO_RIO_LANE_STAT0_RX_TRN, SRIO_RIO_LANE_STAT0_RX_SYNC, 
 *   @n SRIO_RIO_LANE_STAT0_RX_RDY, SRIO_RIO_LANE_STAT0_ERR_CNT, 
 *   @n SRIO_RIO_LANE_STAT0_CHG_SYNC, SRIO_RIO_LANE_STAT0_CHG_TRN, 
 *   @n SRIO_RIO_LANE_STAT0_STAT1, SRIO_RIO_LANE_STAT0_STAT2_7,
 *   @n SRIO_RIO_LANE_STAT1_IDLE2, SRIO_RIO_LANE_STAT1_INFO_OK,
 *   @n SRIO_RIO_LANE_STAT1_CHG, SRIO_RIO_LANE_STAT1_IMPL_SPEC,
 *   @n SRIO_RIO_LANE_STAT1_LP_RX_TRN, SRIO_RIO_LANE_STAT1_LP_WIDTH,
 *   @n SRIO_RIO_LANE_STAT1_LP_LANE_NUM, SRIO_RIO_LANE_STAT1_LP_TAP_M1,
 *   @n SRIO_RIO_LANE_STAT1_LP_TAP_P1, SRIO_RIO_LANE_STAT1_LP_SCRM
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        SRIO_LANE_STATUS    laneStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Lane Status Information.
        CSL_SRIO_GetLaneStatus (hSrio, 1, &laneStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLaneStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    SRIO_LANE_STATUS*   ptrLaneStatus
)
{
    Uint32  value = hSrio->RIO_LANE[portNum].RIO_LANE_STAT0;

    /* Populate the lane status */
    ptrLaneStatus->portNum = (((value) & (0xFF000000u)) >> (0x00000018u));
    ptrLaneStatus->laneNum = (((value) & (0x00F00000u)) >> (0x00000014u));
    ptrLaneStatus->txType  = (((value) & (0x00080000u)) >> (0x00000013u));
    ptrLaneStatus->txMode  = (((value) & (0x00040000u)) >> (0x00000012u));
    ptrLaneStatus->rxType  = (((value) & (0x00030000u)) >> (0x00000010u));
    ptrLaneStatus->rxInv   = (((value) & (0x00008000u)) >> (0x0000000Fu));
    ptrLaneStatus->rxTrn   = (((value) & (0x00004000u)) >> (0x0000000Eu));
    ptrLaneStatus->rxSync  = (((value) & (0x00002000u)) >> (0x0000000Du));
    ptrLaneStatus->rxReady = (((value) & (0x00001000u)) >> (0x0000000Cu));
    ptrLaneStatus->errCnt  = (((value) & (0x00000F00u)) >> (0x00000008u));
    ptrLaneStatus->chgSync = (((value) & (0x00000080u)) >> (0x00000007u));
    ptrLaneStatus->chgTrn  = (((value) & (0x00000040u)) >> (0x00000006u));
    ptrLaneStatus->stat1   = (((value) & (0x00000008u)) >> (0x00000003u));
    ptrLaneStatus->stat2_7 = (((value) & (0x00000007u)) >> (0x00000000u));

    /* Get the lane status 1 */
    value = hSrio->RIO_LANE[portNum].RIO_LANE_STAT1;

    /* Populate the lane status */
    ptrLaneStatus->idle2        = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrLaneStatus->infoOk       = (((value) & (0x40000000u)) >> (0x0000001Eu));
    ptrLaneStatus->chg          = (((value) & (0x20000000u)) >> (0x0000001Du));
    ptrLaneStatus->implSpecific = (((value) & (0x10000000u)) >> (0x0000001Cu));
    ptrLaneStatus->lpRxTrn      = (((value) & (0x08000000u)) >> (0x0000001Bu));
    ptrLaneStatus->lpWidth      = (((value) & (0x07000000u)) >> (0x00000018u));
    ptrLaneStatus->lpLaneNum    = (((value) & (0x00F00000u)) >> (0x00000014u));
    ptrLaneStatus->lpTapM1      = (((value) & (0x000C0000u)) >> (0x00000012u));
    ptrLaneStatus->lpTapP1      = (((value) & (0x00030000u)) >> (0x00000010u));
    ptrLaneStatus->lpScrm       = (((value) & (0x00008000u)) >> (0x0000000Fu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortPLMImplSpecificControl
 *
 *   @b Description
 *   @n The function is used to get the PLM Implementation Specific control
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
          ptrPLMControl         Pointer to the PLM Implementation specific control
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_PAYL_CAP, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_USE_IDLE2, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_USE_IDLE1, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_DLB_EN, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_FORCE_REINIT, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_SOFT_RST_PORT, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_TX_BYPASS, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_LLB_EN, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_PORT_SELF_RST, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_SELF_RST, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_SWAP_TX, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_SWAP_RX, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_DLT_THRESH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle          hSrio;
        SRIO_PLM_IMPL_CONTROL   implControl;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Implementation specific control
        CSL_SRIO_GetPortPLMImplSpecificControl (hSrio, 1, &implControl);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortPLMImplSpecificControl
(
    CSL_SrioHandle          hSrio,
    Uint8                   portNum,
    SRIO_PLM_IMPL_CONTROL*  ptrPLMControl
)
{
    Uint32  value = hSrio->RIO_PLM[portNum].RIO_PLM_SP_IMP_SPEC_CTL;

    /* Populate the PLM implementation specific control */
    ptrPLMControl->payloadCapture   = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrPLMControl->useIdle2         = (((value) & (0x40000000u)) >> (0x0000001Eu));
    ptrPLMControl->useIdle1         = (((value) & (0x20000000u)) >> (0x0000001Du));
    ptrPLMControl->dlbEn            = (((value) & (0x10000000u)) >> (0x0000001Cu));
    ptrPLMControl->forceReinit      = (((value) & (0x04000000u)) >> (0x0000001Au));
    ptrPLMControl->softRstPort      = (((value) & (0x02000000u)) >> (0x00000019u));
    ptrPLMControl->txBypass         = (((value) & (0x01000000u)) >> (0x00000018u));
    ptrPLMControl->lineLoopbackMode = (((value) & (0x00800000u)) >> (0x00000017u));
    ptrPLMControl->portSelfReset    = (((value) & (0x00200000u)) >> (0x00000015u));
    ptrPLMControl->selfReset        = (((value) & (0x00100000u)) >> (0x00000014u));
    ptrPLMControl->swapTx           = (((value) & (0x000C0000u)) >> (0x00000012u));
    ptrPLMControl->swapRx           = (((value) & (0x00030000u)) >> (0x00000010u));
    ptrPLMControl->dltThresh        = (((value) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortImplSpecificControl
 *
 *   @b Description
 *   @n The function is used to set the PLM Implementation Specific control
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
          ptrPLMControl         Pointer to the PLM Implementation specific control
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_PAYL_CAP, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_USE_IDLE2, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_USE_IDLE1, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_DLB_EN, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_FORCE_REINIT, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_SOFT_RST_PORT, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_TX_BYPASS, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_LLB_EN, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_PORT_SELF_RST, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_SELF_RST, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_SWAP_TX, SRIO_RIO_PLM_SP_IMP_SPEC_CTL_SWAP_RX, 
 *   @n SRIO_RIO_PLM_SP_IMP_SPEC_CTL_DLT_THRESH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle          hSrio;
        SRIO_PLM_IMPL_CONTROL   implControl;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Implementation specific control
        CSL_SRIO_GetPortPLMImplSpecificControl (hSrio, 1, &implControl);

        // Bypass the tx clock crossing the FIFO
        implControl.txBypass = 1;
        CSL_SRIO_SetPLMPortImplSpecificControl (hSrio, 1, &implControl);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortImplSpecificControl
(
    CSL_SrioHandle          hSrio,
    Uint8                   portNum,
    SRIO_PLM_IMPL_CONTROL*  ptrPLMControl
)
{
    Uint32  value = 0;

    /* Populate the PLM implementation specific control */
    ((value) = ((value) & ~(0x80000000u)) | (((ptrPLMControl->payloadCapture) << (0x0000001Fu)) & (0x80000000u)));
    ((value) = ((value) & ~(0x40000000u)) | (((ptrPLMControl->useIdle2) << (0x0000001Eu)) & (0x40000000u)));
    ((value) = ((value) & ~(0x20000000u)) | (((ptrPLMControl->useIdle1) << (0x0000001Du)) & (0x20000000u)));
    ((value) = ((value) & ~(0x10000000u)) | (((ptrPLMControl->dlbEn) << (0x0000001Cu)) & (0x10000000u)));
    ((value) = ((value) & ~(0x04000000u)) | (((ptrPLMControl->forceReinit) << (0x0000001Au)) & (0x04000000u)));
    ((value) = ((value) & ~(0x02000000u)) | (((ptrPLMControl->softRstPort) << (0x00000019u)) & (0x02000000u)));
    ((value) = ((value) & ~(0x01000000u)) | (((ptrPLMControl->txBypass) << (0x00000018u)) & (0x01000000u)));
    ((value) = ((value) & ~(0x00800000u)) | (((ptrPLMControl->lineLoopbackMode) << (0x00000017u)) & (0x00800000u)));
    ((value) = ((value) & ~(0x00200000u)) | (((ptrPLMControl->portSelfReset) << (0x00000015u)) & (0x00200000u)));
    ((value) = ((value) & ~(0x00100000u)) | (((ptrPLMControl->selfReset) << (0x00000014u)) & (0x00100000u)));
    ((value) = ((value) & ~(0x000C0000u)) | (((ptrPLMControl->swapTx) << (0x00000012u)) & (0x000C0000u)));
    ((value) = ((value) & ~(0x00030000u)) | (((ptrPLMControl->swapRx) << (0x00000010u)) & (0x00030000u)));
    ((value) = ((value) & ~(0x0000FFFFu)) | (((ptrPLMControl->dltThresh) << (0x00000000u)) & (0x0000FFFFu)));

    hSrio->RIO_PLM[portNum].RIO_PLM_SP_IMP_SPEC_CTL = value;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortPowerDownControl
 *
 *   @b Description
 *   @n The function is used to get the PLM Port Power Down status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
          powerDownStatus       Power Down Status  
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_PWDN_CTL_PWDN_PORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           powerDownStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Power Down Status
        CSL_SRIO_GetPLMPortPowerDownControl (hSrio, 1, &powerDownStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortPowerDownControl
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              powerDownStatus
)
{
    *powerDownStatus = (((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_PWDN_CTL) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortPowerDownControl
 *
 *   @b Description
 *   @n The function is used to set the PLM Port Power Down status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
          powerDownStatus       Power Down Status  
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_PWDN_CTL_PWDN_PORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PLM Port to be powered down
        CSL_SRIO_SetPLMPortPowerDownControl (hSrio, 1, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortPowerDownControl
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               powerDownStatus
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_PWDN_CTL) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_PWDN_CTL) & ~(0x00000001u)) | (((powerDownStatus) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortMaxDenialErrorSet
 *
 *   @b Description
 *   @n The function is used to check if the PLM Port Max. Denial error set.
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    - Max. Denial Error is set
 *   @n FALSE   - Max. Denial Error is not set
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_STATUS_MAX_DENIAL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the MAX Denial Error set?
        if (CSL_SRIO_IsPLMPortMaxDenialErrorSet (hSrio, 1) == TRUE)
        {
            // MAX Denial error is set
        }
        else
        {
            // MAX Denial error is NOT set
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortMaxDenialErrorSet
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & (0x80000000u)) >> (0x0000001Fu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPLMPortMaxDenialErrorSet
 *
 *   @b Description
 *   @n The function is used to clear the PLM Port Max. Denial error
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_STATUS_MAX_DENIAL=1
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_STATUS_MAX_DENIAL=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the MAX Denial Error set?
        if (CSL_SRIO_IsPLMPortMaxDenialErrorSet (hSrio, 1) == TRUE)
        {
            // MAX Denial error is set
            ...
            // Clear the MAX Denial Error
            CSL_SRIO_ClearPLMPortMaxDenialErrorSet (hSrio, 1);
        }
        else
        {
            // MAX Denial error is NOT set
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPLMPortMaxDenialErrorSet
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & ~(0x80000000u)) | ((((Uint32)1) << (0x0000001Fu)) & (0x80000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortLinkInitialized
 *
 *   @b Description
 *   @n The function is used to check if the PLM Port Link Initialized
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    - Port Link Initialized is set
 *   @n FALSE   - Port Link Initialized is not set
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_STATUS_LINK_INIT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Link Initialized?
        if (CSL_SRIO_IsPLMPortLinkInitialized (hSrio, 1) == TRUE)
        {
            // PLM Port Link is initialized
        }
        else
        {
            // PLM Port Link is NOT initialized
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortLinkInitialized
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & (0x10000000u)) >> (0x0000001Cu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPLMPortLinkInitialized
 *
 *   @b Description
 *   @n The function is used to clear the PLM Port Link Initialization notification
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_STATUS_LINK_INIT=1
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_STATUS_LINK_INIT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Link Initialized?
        if (CSL_SRIO_IsPLMPortLinkInitialized (hSrio, 1) == TRUE)
        {
            // Link is initialized
            ...
            // Clear the Link initialization notification
            CSL_SRIO_ClearPLMPortMaxDenialErrorSet (hSrio, 1);
        }
        else
        {
            // Link is not initialized
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPLMPortLinkInitialized
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & ~(0x10000000u)) | (((1) << (0x0000001Cu)) & (0x10000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortDeadLink
 *
 *   @b Description
 *   @n The function is used to check if the PLM Port has detected that the link
 *      partner has been removed
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    - Link partner has been removed
 *   @n FALSE   - Link partner has not been removed
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_STATUS_DLT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Dead Link detected?
        if (CSL_SRIO_IsPLMPortDeadLink (hSrio, 1) == TRUE)
        {
            // PLM Port Dead Link detected
        }
        else
        {
            // PLM Port Dead Link NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortDeadLink
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & (0x08000000u)) >> (0x0000001Bu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPLMPortDeadLink
 *
 *   @b Description
 *   @n The function is used to clear the PLM Port Dead Link event
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_STATUS_DLT=1
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_STATUS_DLT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Dead Link detected?
        if (CSL_SRIO_IsPLMPortDeadLink (hSrio, 1) == TRUE)
        {
            // PLM Port Dead Link detected
            ...
            // Clear the Dead Link Event
            CSL_SRIO_ClearPLMPortDeadLink (hSrio, 1);
        }
        else
        {
            // PLM Port Dead Link NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPLMPortDeadLink
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & ~(0x08000000u)) | (((1) << (0x0000001Bu)) & (0x08000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortError
 *
 *   @b Description
 *   @n The function is used to check if the PLM Port has detected an error
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    - Link error has been detected
 *   @n FALSE   - Link error has NOT been detected
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_STATUS_PORT_ERR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port error detected?
        if (CSL_SRIO_IsPLMPortError (hSrio, 1) == TRUE)
        {
            // PLM Port error detected
        }
        else
        {
            // PLM Port error NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortError
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & (0x04000000u)) >> (0x0000001Au)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPLMPortError
 *
 *   @b Description
 *   @n The function is used to clear the PLM Port Error
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_STATUS_PORT_ERR=1
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_STATUS_PORT_ERR=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port error detected?
        if (CSL_SRIO_IsPLMPortError (hSrio, 1) == TRUE)
        {
            // PLM Port error detected
            ...
            // Clear the PLM Port Error.
            CSL_SRIO_ClearPLMPortError(hSrio, 1);
        }
        else
        {
            // PLM Port error NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPLMPortError
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & ~(0x04000000u)) | (((1) << (0x0000001Au)) & (0x04000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortOutputFail
 *
 *   @b Description
 *   @n The function is used to check if the PLM Port has detected an output fail
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    - Output fail has been detected
 *   @n FALSE   - Output fail has NOT been detected
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_STATUS_OUTPUT_FAIL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Output fail detected?
        if (CSL_SRIO_IsPLMPortOutputFail (hSrio, 1) == TRUE)
        {
            // PLM Port Output fail detected
        }
        else
        {
            // PLM Port Output fail NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortOutputFail
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & (0x02000000u)) >> (0x00000019u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPLMPortOutputFail
 *
 *   @b Description
 *   @n The function is used to clear the PLM Output Fail Port Error
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_STATUS_OUTPUT_FAIL=1
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_STATUS_OUTPUT_FAIL=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Output fail detected?
        if (CSL_SRIO_IsPLMPortOutputFail (hSrio, 1) == TRUE)
        {
            // PLM Port Output fail detected
            ...
            // Clear the PLM Outport error 
            CSL_SRIO_ClearPLMPortOutputFail (hSrio, 1);
        }
        else
        {
            // PLM Port Output fail NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPLMPortOutputFail
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & ~(0x02000000u)) | (((1) << (0x00000019u)) & (0x02000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortOutputDegrade
 *
 *   @b Description
 *   @n The function is used to check if the PLM Port has detected an output 
 *      degrade
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    - Output degrade has been detected
 *   @n FALSE   - Output degrade has NOT been detected
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_STATUS_OUTPUT_DEGR
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Output degrade detected?
        if (CSL_SRIO_IsPLMPortOutputDegrade (hSrio, 1) == TRUE)
        {
            // PLM Port Output degrade detected
        }
        else
        {
            // PLM Port Output degrade NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortOutputDegrade
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & (0x01000000u)) >> (0x00000018u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPLMPortOutputDegrade
 *
 *   @b Description
 *   @n The function is used to clear the PLM Output Degrade Port Error
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_STATUS_OUTPUT_DEGR=1
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_STATUS_OUTPUT_DEGR=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Output degrade detected?
        if (CSL_SRIO_IsPLMPortOutputDegrade (hSrio, 1) == TRUE)
        {
            // PLM Port Output degrade detected
            ...
            // Clear the PLM Output degrade condition
            CSL_SRIO_ClearPLMPortOutputDegrade (hSrio, 1);
        }
        else
        {
            // PLM Port Output degrade NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPLMPortOutputDegrade
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & ~(0x01000000u)) | (((1) << (0x00000018u)) & (0x01000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortMulticastCSDetected
 *
 *   @b Description
 *   @n The function is used to check if the PLM Port Multicast event control 
 *      symbol detected
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    - Multicast event control symbol has been detected
 *   @n FALSE   - Multicast event control symbol has NOT been detected
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_STATUS_MECS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Multicast Event Control Symbol detected?
        if (CSL_SRIO_IsPLMPortMulticastCSDetected (hSrio, 1) == TRUE)
        {
            // PLM Port Multicast Event Control Symbol detected
        }
        else
        {
            // PLM Port Multicast Event Control Symbol NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortMulticastCSDetected
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & (0x00001000u)) >> (0x0000000Cu)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPLMPortMulticastCS
 *
 *   @b Description
 *   @n The function is used to clear the PLM Port Multicast Control Symbol
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_STATUS_MECS=1
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_STATUS_MECS=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Is the PLM Port Multicast Event Control Symbol detected?
        if (CSL_SRIO_IsPLMPortMulticastCSDetected (hSrio, 1) == TRUE)
        {
            // PLM Port Multicast Event Control Symbol detected
            ...
            // Clear the PLM Port Multicast Event Control Symbol
            CSL_SRIO_ClearPLMPortMulticastCS (hSrio, 1);
        }
        else
        {
            // PLM Port Multicast Event Control Symbol NOT detected
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPLMPortMulticastCS
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_STATUS) & ~(0x00001000u)) | (((1) << (0x0000000Cu)) & (0x00001000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortInterrupts
 *
 *   @b Description
 *   @n The function is used to get the current status of the PLM Port Interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          portNum       SRIO Port Number
          intStatus     Current Interrupt status of the PLM port interrupts
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_INT_ENABLE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           intStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the current interrupt status
        CSL_SRIO_GetPLMPortInterrupts(hSrio, 1, &intStatus);

        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              intStatus
)
{
    *intStatus = hSrio->RIO_PLM[portNum].RIO_PLM_SP_INT_ENABLE;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortInterrupts
 *
 *   @b Description
 *   @n The function is used to set the current status of the PLM Port Interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          portNum       SRIO Port Number
          intStatus     Interrupt status to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_INT_ENABLE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           intStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the current interrupt status
        CSL_SRIO_GetPLMPortInterrupts(hSrio, 1, &intStatus);

        // Enable the Max Denial interrupt.
        intStatus = intStatus | 0x1;
        CSL_SRIO_SetPLMPortInterrupts(hSrio, 1, intStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               intStatus
)
{
    hSrio->RIO_PLM[portNum].RIO_PLM_SP_INT_ENABLE = intStatus;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortWriteEnables
 *
 *   @b Description
 *   @n The function is used to get the current status of the PLM Port Write 
 *      enables. These events will enable a port write notification 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          portWriteStatus   Current port write event status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_PW_ENABLE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portWriteStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the current interrupt status
        CSL_SRIO_GetPLMPortWriteEnables(hSrio, 1, &portWriteStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortWriteEnables
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              portWriteStatus
)
{
    *portWriteStatus = hSrio->RIO_PLM[portNum].RIO_PLM_SP_PW_ENABLE;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortWriteEnables
 *
 *   @b Description
 *   @n The function is used to set the current status of the PLM Port Write 
 *      enables. These events will enable a port write notification 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          portWriteStatus   Port write status to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_PW_ENABLE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portWriteStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the current interrupt status
        CSL_SRIO_GetPLMPortWriteEnables(hSrio, 1, &portWriteStatus);

        // Ensure that Max Denial port write notification is set.
        portWriteStatus = portWriteStatus | 0x1;
        CSL_SRIO_SetPLMPortWriteEnables (hSrio, 1, portWriteStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortWriteEnables
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               portWriteStatus
)
{
    hSrio->RIO_PLM[portNum].RIO_PLM_SP_PW_ENABLE = portWriteStatus;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortEventGenerate
 *
 *   @b Description
 *   @n The function is used to get the current status of the PLM events.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          eventStatus       Current PLM event status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_EVENT_GEN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           eventStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the current PLM event generate 
        CSL_SRIO_GetPLMPortEventGenerate(hSrio, 1, &eventStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortEventGenerate
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              eventStatus
)
{
    *eventStatus = hSrio->RIO_PLM[portNum].RIO_PLM_SP_EVENT_GEN;
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortEventGenerate
 *
 *   @b Description
 *   @n The function is used to set the current status of the PLM events.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          eventStatus       PLM event status to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_EVENT_GEN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           eventStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the current PLM event generate 
        CSL_SRIO_GetPLMPortEventGenerate(hSrio, 1, &eventStatus);

        // Ensure MAX Denial event is set
        eventStatus = eventStatus | 0x1;
        CSL_SRIO_SetPLMPortEventGenerate (hSrio, 1, eventStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortEventGenerate
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               eventStatus
)
{
    hSrio->RIO_PLM[portNum].RIO_PLM_SP_EVENT_GEN = eventStatus;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePLMPortAllInterrupts
 *
 *   @b Description
 *   @n The function is used to enable all interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_ALL_INT_EN_IRQ_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable all PLM Interrupts
        CSL_SRIO_EnablePLMPortAllInterrupts(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePLMPortAllInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_INT_EN) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_INT_EN) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePLMPortAllInterrupts
 *
 *   @b Description
 *   @n The function is used to disable all interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_ALL_INT_EN_IRQ_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable all PLM Interrupts
        CSL_SRIO_DisablePLMPortAllInterrupts(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePLMPortAllInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_INT_EN) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_INT_EN) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortAllInterruptsEnabled
 *
 *   @b Description
 *   @n The function is used to check if the PLM port all interrupts are enabled
 *      or not?
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - PLM Port all interrupts are enabled
 *   @n FALSE - PLM Port all interrupts are disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_ALL_INT_EN_IRQ_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if PLM Interrupts are enabled or not?
        if (CSL_SRIO_IsPLMPortAllInterruptsEnabled(hSrio, 1) == TRUE)
        {
            // PLM Interrupts are enabled.
        }
        else
        {
            // PLM Interrupts are disabled.
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortAllInterruptsEnabled
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_INT_EN) & (0x00000001u)) >> (0x00000000u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnablePLMPortAllPortWrites
 *
 *   @b Description
 *   @n The function is used to enable all port writes
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_ALL_PW_EN_PW_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable all PLM Port Writes
        CSL_SRIO_EnablePLMPortAllPortWrites(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnablePLMPortAllPortWrites
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_PW_EN) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_PW_EN) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisablePLMPortAllPortWrites
 *
 *   @b Description
 *   @n The function is used to disable all port writes
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_ALL_PW_EN_PW_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable all PLM Port Writes
        CSL_SRIO_DisablePLMPortAllPortWrites(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisablePLMPortAllPortWrites
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_PW_EN) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_PW_EN) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsPLMPortAllPortWritesEnabled
 *
 *   @b Description
 *   @n The function is used to disable all port writes
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE - PLM Port all Port Writes are enabled
 *   @n TRUE - PLM Port all Port Writes are disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_ALL_PW_EN_PW_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if all PLM Port Writes are enabled or not?
        if (CSL_SRIO_IsPLMPortAllPortWritesEnabled(hSrio, 1) == TRUE)
        {
            // PLM Port All Port Writes are enabled
        }
        else
        {
            // PLM Port All Port Writes are disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsPLMPortAllPortWritesEnabled
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum
)
{
    if ((((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_ALL_PW_EN) & (0x00000001u)) >> (0x00000000u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortPathControl
 *
 *   @b Description
 *   @n The function is used to get the PLM Port Path control
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          pathID            Identifies the Path in which this port resides.
          pathConfig        Indicates the Paths configuration
          pathMode          The mode of the path
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_PATH_CTL_PATH_ID,SRIO_RIO_PLM_SP_PATH_CTL_PATH_CONFIGURATION,
 *   @n SRIO_RIO_PLM_SP_PATH_CTL_PATH_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           pathID;
        Uint8           pathConfig;
        Uint8           pathMode;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port1 Path Control
        CSL_SRIO_GetPLMPortPathControl(hSrio, 1, &pathID, &pathConfig, &pathMode);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortPathControl
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              pathID,
    Uint8*              pathConfig,
    Uint8*              pathMode
)
{
    Uint32 value = hSrio->RIO_PLM[portNum].RIO_PLM_SP_PATH_CTL;
    *pathID     = (((value) & (0x001F0000u)) >> (0x00000010u));
    *pathConfig = (((value) & (0x00000700u)) >> (0x00000008u));
    *pathMode   = (((value) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortPathControlMode
 *
 *   @b Description
 *   @n The function is used to get the PLM Port Path control mode
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          portNum           SRIO Port Number
          pathMode          The mode of the path
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_PATH_CTL_PATH_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the path mode for PLM Port 1 as 0
        CSL_SRIO_SetPLMPortPathControlMode(hSrio, 1, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortPathControlMode
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               pathMode
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_PATH_CTL) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_PATH_CTL) & ~(0x00000007u)) | (((pathMode) << (0x00000000u)) & (0x00000007u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortDiscoveryTimer
 *
 *   @b Description
 *   @n The function is used to get the PLM Port Discovery timer
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          portDiscoveryTimer    PLM Port Discovery Timer
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_DISCOVERY_TIMER_DISCOVERY_TIMER
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portDiscoveryTimer;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Discovery Timer
        CSL_SRIO_GetPLMPortDiscoveryTimer(hSrio, 1, &portDiscoveryTimer);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortDiscoveryTimer
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              portDiscoveryTimer
)
{
    *portDiscoveryTimer = (((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_DISCOVERY_TIMER) & (0xF0000000u)) >> (0x0000001Cu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortDiscoveryTimer
 *
 *   @b Description
 *   @n The function is used to set the PLM Port Discovery timer
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          portDiscoveryTimer    PLM Port Discovery Timer
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_DISCOVERY_TIMER_DISCOVERY_TIMER
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PLM Discovery Timer
        CSL_SRIO_SetPLMPortDiscoveryTimer(hSrio, 1, 0x5);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortDiscoveryTimer
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               portDiscoveryTimer
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_DISCOVERY_TIMER) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_DISCOVERY_TIMER) & ~(0xF0000000u)) | (((portDiscoveryTimer) << (0x0000001Cu)) & (0xF0000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortSilenceTimer
 *
 *   @b Description
 *   @n The function is used to get the PLM Port Silence timer
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          portSilenceTimer      PLM Port Silence Timer
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_SILENCE_TIMER_SILENCE_TIMER
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portSilenceTimer;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Silence Timer
        CSL_SRIO_GetPLMPortSilenceTimer(hSrio, 1, &portSilenceTimer);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortSilenceTimer
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              portSilenceTimer
)
{
    *portSilenceTimer = (((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_SILENCE_TIMER) & (0xF0000000u)) >> (0x0000001Cu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortSilenceTimer
 *
 *   @b Description
 *   @n The function is used to set up the PLM Port Silence timer value.
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          portSilenceTimer      PLM Port Silence Timer value to configure
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_SILENCE_TIMER_SILENCE_TIMER=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           portSilenceTimer;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Silence Timer
        CSL_SRIO_GetPLMPortSilenceTimer(hSrio, 1, &portSilenceTimer);
        ...
        // Set the PLM Silence Timer
        CSL_SRIO_SetPLMPortSilenceTimer(hSrio, 1, &portSilenceTimer);
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortSilenceTimer
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               portSilenceTimer
)
{
   ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_SILENCE_TIMER) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_SILENCE_TIMER) & ~(0xF0000000u)) | (((portSilenceTimer) << (0x0000001Cu)) & (0xF0000000u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortVMinExponentConfig
 *
 *   @b Description
 *   @n The function is used to get the PLM Port VMin Export configuration
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          ptrVminExponent       PLM Port VMin Exponent configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_VMIN_EXP_VMIN_EXP, SRIO_RIO_PLM_SP_VMIN_EXP_IMAX,
 *   @n SRIO_RIO_PLM_SP_VMIN_EXP_MMAX
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle          hSrio;
        SRIO_PLM_VMIN_EXPONENT  vminExponentConfig;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port VMin Exponent Configuration.
        CSL_SRIO_GetPLMPortVMinExponentConfig(hSrio, 1, &vminExponentConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortVMinExponentConfig
(
    CSL_SrioHandle          hSrio,
    Uint8                   portNum,
    SRIO_PLM_VMIN_EXPONENT* ptrVminExponent
)
{
    Uint32 value = hSrio->RIO_PLM[portNum].RIO_PLM_SP_VMIN_EXP;

    ptrVminExponent->vminExp = (((value) & (0x1F000000u)) >> (0x00000018u));
    ptrVminExponent->imax    = (((value) & (0x000F0000u)) >> (0x00000010u)); 
    ptrVminExponent->mmax    = (((value) & (0x00000F00u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortVMinExponentConfig
 *
 *   @b Description
 *   @n The function is used to set the PLM Port VMin Export configuration
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          ptrVminExponent       PLM Port VMin Exponent configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_VMIN_EXP_VMIN_EXP, SRIO_RIO_PLM_SP_VMIN_EXP_IMAX,
 *   @n SRIO_RIO_PLM_SP_VMIN_EXP_MMAX
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle          hSrio;
        SRIO_PLM_VMIN_EXPONENT  vminExponentConfig;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port VMin Exponent Configuration.
        CSL_SRIO_GetPLMPortVMinExponentConfig(hSrio, 1, &vminExponentConfig);

        vminExponentConfig.imax = 2;
        CSL_SRIO_SetPLMPortVMinExponentConfig(hSrio, 1,  &vminExponentConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortVMinExponentConfig
(
    CSL_SrioHandle          hSrio,
    Uint8                   portNum,
    SRIO_PLM_VMIN_EXPONENT* ptrVminExponent
)
{
    hSrio->RIO_PLM[portNum].RIO_PLM_SP_VMIN_EXP = 
            (((ptrVminExponent->vminExp) << (0x00000018u)) & (0x1F000000u))   |
            (((ptrVminExponent->imax) << (0x00000010u)) & (0x000F0000u))          |
            (((ptrVminExponent->mmax) << (0x00000008u)) & (0x00000F00u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortPolarityControl
 *
 *   @b Description
 *   @n The function is used to get the PLM Port Polarity Control
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          ptrPolarityConfig     PLM Port Polarity configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_POL_CTL_TX3_POL, SRIO_RIO_PLM_SP_POL_CTL_TX2_POL,
 *   @n SRIO_RIO_PLM_SP_POL_CTL_TX1_POL, SRIO_RIO_PLM_SP_POL_CTL_TX0_POL,
 *   @n SRIO_RIO_PLM_SP_POL_CTL_RX3_POL, SRIO_RIO_PLM_SP_POL_CTL_RX2_POL,
 *   @n SRIO_RIO_PLM_SP_POL_CTL_RX1_POL, SRIO_RIO_PLM_SP_POL_CTL_RX0_POL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle              hSrio;
        SRIO_PLM_POLARITY_CONTROL   polarityControlConfig;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port Polarity Control Configuration.
        CSL_SRIO_GetPLMPortPolarityControl(hSrio, 1, &polarityControlConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortPolarityControl
(
    CSL_SrioHandle              hSrio,
    Uint8                       portNum,
    SRIO_PLM_POLARITY_CONTROL*  ptrPolarityConfig
)
{
    Uint32 value = hSrio->RIO_PLM[portNum].RIO_PLM_SP_POL_CTL;

    ptrPolarityConfig->tx3Pol = (((value) & (0x00080000u)) >> (0x00000013u));
    ptrPolarityConfig->tx2Pol = (((value) & (0x00040000u)) >> (0x00000012u));
    ptrPolarityConfig->tx1Pol = (((value) & (0x00020000u)) >> (0x00000011u));
    ptrPolarityConfig->tx0Pol = (((value) & (0x00010000u)) >> (0x00000010u));
    ptrPolarityConfig->rx3Pol = (((value) & (0x00000008u)) >> (0x00000003u));
    ptrPolarityConfig->rx2Pol = (((value) & (0x00000004u)) >> (0x00000002u));
    ptrPolarityConfig->rx1Pol = (((value) & (0x00000002u)) >> (0x00000001u));
    ptrPolarityConfig->rx0Pol = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortPolarityControl
 *
 *   @b Description
 *   @n The function is used to set the PLM Port Polarity Control
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          ptrPolarityConfig     PLM Port Polarity configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_POL_CTL_TX3_POL, SRIO_RIO_PLM_SP_POL_CTL_TX2_POL,
 *   @n SRIO_RIO_PLM_SP_POL_CTL_TX1_POL, SRIO_RIO_PLM_SP_POL_CTL_TX0_POL,
 *   @n SRIO_RIO_PLM_SP_POL_CTL_RX3_POL, SRIO_RIO_PLM_SP_POL_CTL_RX2_POL,
 *   @n SRIO_RIO_PLM_SP_POL_CTL_RX1_POL, SRIO_RIO_PLM_SP_POL_CTL_RX0_POL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle              hSrio;
        SRIO_PLM_POLARITY_CONTROL   polarityControlConfig;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port Polarity Control Configuration.
        CSL_SRIO_GetPLMPortPolarityControl(hSrio, 1, &polarityControlConfig);

        // Make sure that the TX3 Polarity is reversed
        polarityControlConfig.tx3Pol = 1;
        CSL_SRIO_SetPLMPortPolarityControl(hSrio, 1, &polarityControlConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortPolarityControl
(
    CSL_SrioHandle              hSrio,
    Uint8                       portNum,
    SRIO_PLM_POLARITY_CONTROL*  ptrPolarityConfig
)
{
    hSrio->RIO_PLM[portNum].RIO_PLM_SP_POL_CTL = 
        (((ptrPolarityConfig->tx3Pol) << (0x00000013u)) & (0x00080000u)) |
        (((ptrPolarityConfig->tx2Pol) << (0x00000012u)) & (0x00040000u)) |
        (((ptrPolarityConfig->tx1Pol) << (0x00000011u)) & (0x00020000u)) |
        (((ptrPolarityConfig->tx0Pol) << (0x00000010u)) & (0x00010000u)) |
        (((ptrPolarityConfig->rx3Pol) << (0x00000003u)) & (0x00000008u)) |
        (((ptrPolarityConfig->rx2Pol) << (0x00000002u)) & (0x00000004u)) |
        (((ptrPolarityConfig->rx1Pol) << (0x00000001u)) & (0x00000002u)) |
        (((ptrPolarityConfig->rx0Pol) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortPacketDenialControl
 *
 *   @b Description
 *   @n The function is used to get the PLM Port Packet Denial.
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          cntPacketNotAccepted  Controls whether Packet-Not-Accepted control 
                                symbols count toward the packet denial threshold value
          cntRetry              Controls whether Retry control symbols count toward 
                                the packet denial threshold value
          denialThreshold       Sets the threshold for reporting too many consecutive retries
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_DENIAL_CTL_CNT_PNA, SRIO_RIO_PLM_SP_DENIAL_CTL_CNT_RTY,
 *   @n SRIO_RIO_PLM_SP_DENIAL_CTL_DENIAL_THRESH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           cntPacketNotAccepted;
        Uint8           cntRetry;
        Uint8           denialThreshold;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port Packet Denial
        CSL_SRIO_GetPLMPortPacketDenialControl(hSrio, 1, &cntPacketNotAccepted, &cntRetry, &denialThreshold);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortPacketDenialControl
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              cntPacketNotAccepted,
    Uint8*              cntRetry,
    Uint8*              denialThreshold
)
{
    Uint32 value = hSrio->RIO_PLM[portNum].RIO_PLM_SP_DENIAL_CTL;

    *cntPacketNotAccepted = (((value) & (0x20000000u)) >> (0x0000001Du));
    *cntRetry             = (((value) & (0x10000000u)) >> (0x0000001Cu));
    *denialThreshold      = (((value) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortPacketDenialControl
 *
 *   @b Description
 *   @n The function is used to set the PLM Port Packet Denial.
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          cntPacketNotAccepted  Controls whether Packet-Not-Accepted control 
                                symbols count toward the packet denial threshold value
          cntRetry              Controls whether Retry control symbols count toward 
                                the packet denial threshold value
          denialThreshold       Sets the threshold for reporting too many consecutive retries
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_DENIAL_CTL_CNT_PNA, SRIO_RIO_PLM_SP_DENIAL_CTL_CNT_RTY,
 *   @n SRIO_RIO_PLM_SP_DENIAL_CTL_DENIAL_THRESH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PLM Port Packet Denial
        CSL_SRIO_SetPLMPortPacketDenialControl(hSrio, 1, 1, 1, 2);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortPacketDenialControl
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               cntPacketNotAccepted,
    Uint8               cntRetry,
    Uint8               denialThreshold
)
{
    hSrio->RIO_PLM[portNum].RIO_PLM_SP_DENIAL_CTL = 
            (((cntPacketNotAccepted) << (0x0000001Du)) & (0x20000000u))    |
            (((cntRetry) << (0x0000001Cu)) & (0x10000000u))                |
            (((denialThreshold) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortMECSStatus
 *
 *   @b Description
 *   @n The function is used to get the PLM Port MECS status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          cmd                   Indicates which MECS commands have been received.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_RCVD_MECS_CMD_STAT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           cmd;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port MECS Status
        CSL_SRIO_GetPLMPortMECSStatus(hSrio, 1, &cmd);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortMECSStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              cmd
)
{
    *cmd = (((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_RCVD_MECS) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPLMPortMECSStatus
 *
 *   @b Description
 *   @n The function is used to clear the PLM Port MECS status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          cmd                   Indicates which MECS commands need to be cleared.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_RCVD_MECS_CMD_STAT
 *
 *   @b Affects
 *   @n SRIO_RIO_PLM_SP_RCVD_MECS_CMD_STAT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           cmd;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port MECS Status
        CSL_SRIO_GetPLMPortMECSStatus(hSrio, 1, &cmd);
        ...
        // Clear the PLM Port MECS Status.
        CSL_SRIO_ClearPLMPortMECSStatus(hSrio, 1, cmd);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPLMPortMECSStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               cmd
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_RCVD_MECS) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_RCVD_MECS) & ~(0x000000FFu)) | (((cmd) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortMECSForwarding
 *
 *   @b Description
 *   @n The function is used to get the PLM Port MECS Forwarding 
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          subscription          Specifies which MECS cmd values the port 
                                should forward to its link
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_MECS_FWD_SUBSCRIPTION
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;
        Uint8           subscription;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port MECS Forwarding
        CSL_SRIO_GetPLMPortMECSForwarding(hSrio, 1, &subscription);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortMECSForwarding
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              subscription
)
{
    *subscription = (((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_MECS_FWD) & (0x000000FEu)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortMECSForwarding
 *
 *   @b Description
 *   @n The function is used to set the PLM Port MECS Forwarding 
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          subscription          Specifies which MECS cmd values the port 
                                should forward to its link
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_MECS_FWD_SUBSCRIPTION
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle  hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PLM Port MECS Forwarding
        CSL_SRIO_SetPLMPortMECSForwarding(hSrio, 1, 0x1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortMECSForwarding
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               subscription
)
{
    ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_MECS_FWD) = ((hSrio->RIO_PLM[portNum]. RIO_PLM_SP_MECS_FWD) & ~(0x000000FEu)) | (((subscription) << (0x00000001u)) & (0x000000FEu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPLMPortCSTransmit
 *
 *   @b Description
 *   @n The function is used to get the Control Symbol Transmit1
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          ptrCSTransmit         Control Symbol Transmit Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PLM_SP_LONG_CS_TX1_STYPE_0, SRIO_RIO_PLM_SP_LONG_CS_TX1_PAR_0,
 *   @n SRIO_RIO_PLM_SP_LONG_CS_TX1_PAR_1,   SRIO_RIO_PLM_SP_LONG_CS_TX1_CS_EMB,
 *   @n SRIO_RIO_PLM_SP_LONG_CS_TX1_STYPE_1, SRIO_RIO_PLM_SP_LONG_CS_TX1_CMD,
 *   @n SRIO_RIO_PLM_SP_LONG_CS_TX2_STYPE_2, SRIO_RIO_PLM_SP_LONG_CS_TX2_PARM
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle              hSrio;
        SRIO_PLM_CONTROL_SYMBOL     cntlSymbol;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PLM Port Control Symbol Transmit Configuration
        CSL_SRIO_GetPLMPortCSTransmit(hSrio, 1, &cntlSymbol);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPLMPortCSTransmit
(
    CSL_SrioHandle              hSrio,
    Uint8                       portNum,
    SRIO_PLM_CONTROL_SYMBOL*    ptrCSTransmit
)
{
    Uint32 value = hSrio->RIO_PLM[portNum].RIO_PLM_SP_LONG_CS_TX1;

    ptrCSTransmit->stype0   = (((value) & (0x70000000u)) >> (0x0000001Cu)); 
    ptrCSTransmit->par0     = (((value) & (0x03F00000u)) >> (0x00000014u)); 
    ptrCSTransmit->par1     = (((value) & (0x0003F000u)) >> (0x0000000Cu)); 
    ptrCSTransmit->csEmb    = (((value) & (0x00000100u)) >> (0x00000008u)); 
    ptrCSTransmit->stype1   = (((value) & (0x00000070u)) >> (0x00000004u)); 
    ptrCSTransmit->cmd      = (((value) & (0x00000007u)) >> (0x00000000u)); 

    /* Get the value from the Control Symbol Transmit2 register */
    value = hSrio->RIO_PLM[portNum].RIO_PLM_SP_LONG_CS_TX2;
    ptrCSTransmit->stype2   = (((value) & (0x70000000u)) >> (0x0000001Cu));
    ptrCSTransmit->parm     = (((value) & (0x07FF0000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPLMPortCSTransmit
 *
 *   @b Description
 *   @n The function is used to set the Control Symbol Transmit1
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          ptrCSTransmit         Control Symbol Transmit Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PLM_SP_LONG_CS_TX1_STYPE_0, SRIO_RIO_PLM_SP_LONG_CS_TX1_PAR_0,
 *   @n SRIO_RIO_PLM_SP_LONG_CS_TX1_PAR_1,   SRIO_RIO_PLM_SP_LONG_CS_TX1_CS_EMB,
 *   @n SRIO_RIO_PLM_SP_LONG_CS_TX1_STYPE_1, SRIO_RIO_PLM_SP_LONG_CS_TX1_CMD,
 *   @n SRIO_RIO_PLM_SP_LONG_CS_TX2_STYPE_2, SRIO_RIO_PLM_SP_LONG_CS_TX2_PARM
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle              hSrio;
        SRIO_PLM_CONTROL_SYMBOL     cntlSymbol;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PLM Port Control Symbol Transmit Configuration
        CSL_SRIO_SetPLMPortCSTransmit(hSrio, 1, &cntlSymbol);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPLMPortCSTransmit
(
    CSL_SrioHandle              hSrio,
    Uint8                       portNum,
    SRIO_PLM_CONTROL_SYMBOL*    ptrCSTransmit
)
{
    hSrio->RIO_PLM[portNum].RIO_PLM_SP_LONG_CS_TX1 = 
            (((ptrCSTransmit->stype0) << (0x0000001Cu)) & (0x70000000u))    |
            (((ptrCSTransmit->par0) << (0x00000014u)) & (0x03F00000u))      |
            (((ptrCSTransmit->par1) << (0x0000000Cu)) & (0x0003F000u))      |
            (((ptrCSTransmit->csEmb) << (0x00000008u)) & (0x00000100u))     |
            (((ptrCSTransmit->stype1) << (0x00000004u)) & (0x00000070u))    |
            (((ptrCSTransmit->cmd) << (0x00000000u)) & (0x00000007u));

    hSrio->RIO_PLM[portNum].RIO_PLM_SP_LONG_CS_TX2 =
            (((ptrCSTransmit->stype2) << (0x0000001Cu)) & (0x70000000u))    |
            (((ptrCSTransmit->parm) << (0x00000010u)) & (0x07FF0000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTLMPortControl
 *
 *   @b Description
 *   @n The function is used to get the TLM port control
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          ptrTLMControl         TLM Port Control
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_TLM_SP_CONTROL_PORTGROUP_SELECT, SRIO_RIO_TLM_SP_CONTROL_VOQ_SELECT,
 *   @n SRIO_RIO_TLM_SP_CONTROL_TGT_ID_DIS, SRIO_RIO_TLM_SP_CONTROL_MTC_TGT_ID_DIS,
 *   @n SRIO_RIO_TLM_SP_CONTROL_LENGTH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle          hSrio;
        SRIO_TLM_CONTROL        tlmCntlSymbol;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TLM Port Control Configuration
        CSL_SRIO_GetTLMPortControl(hSrio, 1, &tlmCntlSymbol);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTLMPortControl
(
    CSL_SrioHandle              hSrio,
    Uint8                       portNum,
    SRIO_TLM_CONTROL*           ptrTLMControl
)
{
    Uint32 value = hSrio->RIO_TLM[portNum].RIO_TLM_SP_CONTROL;

    ptrTLMControl->portGroupSelect = (((value) & (0x40000000u)) >> (0x0000001Eu));
    ptrTLMControl->voqSelect       = (((value) & (0x30000000u)) >> (0x0000001Cu));
    ptrTLMControl->tgtIDDis        = (((value) & (0x00200000u)) >> (0x00000015u));
    ptrTLMControl->mtcTgtIDDis     = (((value) & (0x00100000u)) >> (0x00000014u));
    ptrTLMControl->length          = (((value) & (0x0000F000u)) >> (0x0000000Cu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTLMPortControl
 *
 *   @b Description
 *   @n The function is used to set the TLM port control
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          ptrTLMControl         TLM Port Control
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TLM_SP_CONTROL_PORTGROUP_SELECT, SRIO_RIO_TLM_SP_CONTROL_VOQ_SELECT,
 *   @n SRIO_RIO_TLM_SP_CONTROL_TGT_ID_DIS, SRIO_RIO_TLM_SP_CONTROL_MTC_TGT_ID_DIS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle          hSrio;
        SRIO_TLM_CONTROL        tlmCntlSymbol;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TLM Port Control Configuration
        CSL_SRIO_GetTLMPortControl(hSrio, 1, &tlmCntlSymbol);

        // Set Promiscuous mode.
        tlmCntlSymbol.tgtIDDis    = 1;
        tlmCntlSymbol.mtcTgtIDDis = 1;
        CSL_SRIO_SetTLMPortControl (hSrio, 1, &tlmCntlSymbol);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTLMPortControl
(
    CSL_SrioHandle              hSrio,
    Uint8                       portNum,
    SRIO_TLM_CONTROL*           ptrTLMControl
)
{
    hSrio->RIO_TLM[portNum].RIO_TLM_SP_CONTROL = 
            (((ptrTLMControl->portGroupSelect) << (0x0000001Eu)) & (0x40000000u))  |
            (((ptrTLMControl->voqSelect) << (0x0000001Cu)) & (0x30000000u))        |
            (((ptrTLMControl->tgtIDDis) << (0x00000015u)) & (0x00200000u))         |
            (((ptrTLMControl->mtcTgtIDDis) << (0x00000014u)) & (0x00100000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTLMPortStatus
 *
 *   @b Description
 *   @n The function is used to get the TLM port status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          igBadVC               Detected an inbound packet with the VC bit set
          igBrrFilter           Discarded an inbound transaction based on the BRR
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_TLM_SP_STATUS_IG_BAD_VC, SRIO_RIO_TLM_SP_STATUS_IG_BRR_FILTER
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igBadVC;
        Uint8               igBrrFilter;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TLM Port Status
        CSL_SRIO_GetTLMPortStatus(hSrio, 1, &igBadVC, &igBrrFilter);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTLMPortStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              igBadVC,
    Uint8*              igBrrFilter
)
{
    Uint32 value = hSrio->RIO_TLM[portNum].RIO_TLM_SP_STATUS;

    *igBadVC     = (((value) & (0x80000000u)) >> (0x0000001Fu));
    *igBrrFilter = (((value) & (0x00100000u)) >> (0x00000014u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearTLMPortStatus
 *
 *   @b Description
 *   @n The function is used to clear the TLM port status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          igBadVC               Detected an inbound packet with the VC bit set
          igBrrFilter           Discarded an inbound transaction based on the BRR
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TLM_SP_STATUS_IG_BAD_VC=1, SRIO_RIO_TLM_SP_STATUS_IG_BRR_FILTER=1
 *
 *   @b Affects
 *   @n SRIO_RIO_TLM_SP_STATUS_IG_BAD_VC=0, SRIO_RIO_TLM_SP_STATUS_IG_BRR_FILTER=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igBadVC;
        Uint8               igBrrFilter;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TLM Port Status
        CSL_SRIO_GetTLMPortStatus(hSrio, 1, &igBadVC, &igBrrFilter);
        ...
        // Clear the TLM Port Status
        CSL_SRIO_ClearTLMPortStatus (hSrio, 1, igBadVC, igBrrFilter);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearTLMPortStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               igBadVC,
    Uint8               igBrrFilter
)
{
    hSrio->RIO_TLM[portNum].RIO_TLM_SP_STATUS = 
            (((igBadVC) << (0x0000001Fu)) & (0x80000000u))        |
            (((igBrrFilter) << (0x00000014u)) & (0x00100000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTLMPortInterrupts
 *
 *   @b Description
 *   @n The function is used to get the TLM port interrupt status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          igBadVC               Detected an inbound packet with the VC bit set
          igBrrFilter           Discarded an inbound transaction based on the BRR
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_TLM_SP_INT_ENABLE_IG_BAD_VC, 
 *   @n SRIO_RIO_TLM_SP_INT_ENABLE_IG_BRR_FILTER
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igBadVC;
        Uint8               igBrrFilter;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TLM Port Interrupt Status
        CSL_SRIO_GetTLMPortInterrupts(hSrio, 1, &igBadVC, &igBrrFilter);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTLMPortInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              igBadVC,
    Uint8*              igBrrFilter
)
{
    Uint32 value = hSrio->RIO_TLM[portNum].RIO_TLM_SP_INT_ENABLE;

    *igBadVC     = (((value) & (0x80000000u)) >> (0x0000001Fu));
    *igBrrFilter = (((value) & (0x00100000u)) >> (0x00000014u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTLMPortInterrupts
 *
 *   @b Description
 *   @n The function is used to set the TLM Port Interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          igBadVC               Detected an inbound packet with the VC bit set
          igBrrFilter           Discarded an inbound transaction based on the BRR
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TLM_SP_INT_ENABLE_IG_BAD_VC, 
 *   @n SRIO_RIO_TLM_SP_INT_ENABLE_IG_BRR_FILTER
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igBadVC;
        Uint8               igBrrFilter;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable BadVC Interrupt & Disable BRR Filter Interrupts 
        CSL_SRIO_SetTLMPortInterrupts(hSrio, 1, 1, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTLMPortInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               igBadVC,
    Uint8               igBrrFilter
)
{
    hSrio->RIO_TLM[portNum].RIO_TLM_SP_INT_ENABLE = 
            (((igBadVC) << (0x0000001Fu)) & (0x80000000u))        |
            (((igBrrFilter) << (0x00000014u)) & (0x00100000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTLMPortWriteEnable
 *
 *   @b Description
 *   @n The function is used to get the TLM port write enable status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          igBadVC               Detected an inbound packet with the VC bit set
          igBrrFilter           Discarded an inbound transaction based on the BRR
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_TLM_SP_PW_ENABLE_IG_BAD_VC, 
 *   @n SRIO_RIO_TLM_SP_PW_ENABLE_IG_BRR_FILTER
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igBadVC;
        Uint8               igBrrFilter;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TLM Port Write Enable status
        CSL_SRIO_GetTLMPortWriteEnable(hSrio, 1, &igBadVC, &igBrrFilter);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTLMPortWriteEnable
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              igBadVC,
    Uint8*              igBrrFilter
)
{
    Uint32 value = hSrio->RIO_TLM[portNum].RIO_TLM_SP_PW_ENABLE;

    *igBadVC     = (((value) & (0x80000000u)) >> (0x0000001Fu));
    *igBrrFilter = (((value) & (0x00100000u)) >> (0x00000014u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTLMPortWriteEnable
 *
 *   @b Description
 *   @n The function is used to set the TLM port write enable status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          igBadVC               Detected an inbound packet with the VC bit set
          igBrrFilter           Discarded an inbound transaction based on the BRR
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TLM_SP_PW_ENABLE_IG_BAD_VC, 
 *   @n SRIO_RIO_TLM_SP_PW_ENABLE_IG_BRR_FILTER
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the TLM Port Write Enable status for BAD VC and NOT for BRR Filter
        CSL_SRIO_SetTLMPortWriteEnable(hSrio, 1, 1, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTLMPortWriteEnable
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               igBadVC,
    Uint8               igBrrFilter
)
{
    hSrio->RIO_TLM[portNum].RIO_TLM_SP_PW_ENABLE = 
            (((igBadVC) << (0x0000001Fu)) & (0x80000000u))          | 
            (((igBrrFilter) << (0x00000014u)) & (0x00100000u)); 
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTLMPortEventGenerate
 *
 *   @b Description
 *   @n The function is used to set the TLM port event generates
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          igBadVC               Detected an inbound packet with the VC bit set
          igBrrFilter           Discarded an inbound transaction based on the BRR
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TLM_SP_EVENT_GEN_IG_BAD_VC, 
 *   @n SRIO_RIO_TLM_SP_EVENT_GEN_IG_BRR_FILTER
 *
 *   @b Affects
 *   @n SRIO_RIO_TLM_SP_STATUS_IG_BAD_VC=1, SRIO_RIO_TLM_SP_STATUS_IG_BRR_FILTER=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igBadVC;
        Uint8               igBrrFilter;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the TLM Port Event Generate Status
        CSL_SRIO_SetTLMPortEventGenerate(hSrio, 1, 1, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTLMPortEventGenerate
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               igBadVC,
    Uint8               igBrrFilter
)
{
    hSrio->RIO_TLM[portNum].RIO_TLM_SP_EVENT_GEN = 
        (((igBadVC) << (0x0000001Fu)) & (0x80000000u))      |
        (((igBrrFilter) << (0x00000014u)) & (0x00100000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTLMPortBaseRoutingInfo
 *
 *   @b Description
 *   @n The function is used to get the TLM Base Routing Information
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          brrNum                BRR Number for which this configuration is applied.
          enableStatus          Status of the BRR for accepting & routing packets
          maintRouting          Maintainance Packet Routing Status
          privateStatus         Status of the BRR to be used by its port or by all
                                ports
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_TLM_SP_BRR_0_CTL_ENABLE, SRIO_RIO_TLM_SP_BRR_0_CTL_ROUTE_MR_TO_LLM,
 *   @n SRIO_RIO_TLM_SP_BRR_0_CTL_PRIVATE;
 *   @n SRIO_RIO_TLM_SP_BRR_1_CTL_ENABLE, SRIO_RIO_TLM_SP_BRR_1_CTL_ROUTE_MR_TO_LLM,
 *   @n SRIO_RIO_TLM_SP_BRR_1_CTL_PRIVATE;
 *   @n SRIO_RIO_TLM_SP_BRR_2_CTL_ENABLE, SRIO_RIO_TLM_SP_BRR_2_CTL_ROUTE_MR_TO_LLM,
 *   @n SRIO_RIO_TLM_SP_BRR_2_CTL_PRIVATE;
 *   @n SRIO_RIO_TLM_SP_BRR_3_CTL_ENABLE, SRIO_RIO_TLM_SP_BRR_3_CTL_ROUTE_MR_TO_LLM,
 *   @n SRIO_RIO_TLM_SP_BRR_3_CTL_PRIVATE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               enableStatus;
        Uint8               maintRouting;
        Uint8               privateStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TLM Port Base routing information.
        CSL_SRIO_GetTLMPortBaseRoutingInfo(hSrio, 1, 0, &enableStatus, &maintRouting, &privateStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTLMPortBaseRoutingInfo
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               brrNum,
    Uint8*              enableStatus,
    Uint8*              maintRouting,
    Uint8*              privateStatus
)
{
    Uint32 value = hSrio->RIO_TLM[portNum].brr[brrNum].RIO_TLM_SP_BRR_CTL;

    *enableStatus   = (((value) & (0x80000000u)) >> (0x0000001Fu));
    *maintRouting   = (((value) & (0x04000000u)) >> (0x0000001Au));
    *privateStatus  = (((value) & (0x01000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTLMPortBaseRoutingInfo
 *
 *   @b Description
 *   @n The function is used to set the TLM Base Routing Information
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          brrNum                BRR Number for which this configuration is applied.
          enableStatus          Status of the BRR for accepting & routing packets
          maintRouting          Maintainance Packet Routing Status
          privateStatus         Status of the BRR to be used by its port or by all
                                ports
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TLM_SP_BRR_0_CTL_ENABLE, SRIO_RIO_TLM_SP_BRR_0_CTL_ROUTE_MR_TO_LLM,
 *   @n SRIO_RIO_TLM_SP_BRR_0_CTL_PRIVATE;
 *   @n SRIO_RIO_TLM_SP_BRR_1_CTL_ENABLE, SRIO_RIO_TLM_SP_BRR_1_CTL_ROUTE_MR_TO_LLM,
 *   @n SRIO_RIO_TLM_SP_BRR_1_CTL_PRIVATE;
 *   @n SRIO_RIO_TLM_SP_BRR_2_CTL_ENABLE, SRIO_RIO_TLM_SP_BRR_2_CTL_ROUTE_MR_TO_LLM,
 *   @n SRIO_RIO_TLM_SP_BRR_2_CTL_PRIVATE;
 *   @n SRIO_RIO_TLM_SP_BRR_3_CTL_ENABLE, SRIO_RIO_TLM_SP_BRR_3_CTL_ROUTE_MR_TO_LLM,
 *   @n SRIO_RIO_TLM_SP_BRR_3_CTL_PRIVATE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the TLM Port Base routing information.
        CSL_SRIO_SetTLMPortBaseRoutingInfo(hSrio, 1, 0, 1, 0, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTLMPortBaseRoutingInfo
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               brrNum,
    Uint8               enableStatus,
    Uint8               maintRouting,
    Uint8               privateStatus
)
{
    hSrio->RIO_TLM[portNum].brr[brrNum].RIO_TLM_SP_BRR_CTL = 
              (((enableStatus) << (0x0000001Fu)) & (0x80000000u))   |
              (((maintRouting) << (0x0000001Au)) & (0x04000000u))   |
              (((privateStatus) << (0x00000018u)) & (0x01000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetTLMPortBaseRoutingPatternMatch
 *
 *   @b Description
 *   @n The function is used to get the TLM Base Routing Pattern Match information
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          brrNum                BRR Number for which this configuration is applied.
          pattern               16 bit ID used for comparison.
          match                 Indicates which of the 16bits should be used
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_TLM_SP_BRR_0_PATTERN_MATCH_PATTERN, SRIO_RIO_TLM_SP_BRR_0_PATTERN_MATCH_MATCH;
 *   @n SRIO_RIO_TLM_SP_BRR_1_PATTERN_MATCH_PATTERN, SRIO_RIO_TLM_SP_BRR_1_PATTERN_MATCH_MATCH;
 *   @n SRIO_RIO_TLM_SP_BRR_2_PATTERN_MATCH_PATTERN, SRIO_RIO_TLM_SP_BRR_2_PATTERN_MATCH_MATCH;
 *   @n SRIO_RIO_TLM_SP_BRR_3_PATTERN_MATCH_PATTERN, SRIO_RIO_TLM_SP_BRR_3_PATTERN_MATCH_MATCH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint16              pattern;
        Uint16              match;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the TLM Port Base routing pattern match information
        CSL_SRIO_GetTLMPortBaseRoutingPatternMatch(hSrio, 1, &pattern, &match);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetTLMPortBaseRoutingPatternMatch
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               brrNum,
    Uint16*             pattern,
    Uint16*             match
)
{
    Uint32 value = hSrio->RIO_TLM[portNum].brr[brrNum].RIO_TLM_SP_BRR_PATTERN_MATCH;

    *pattern = (((value) & (0xFFFF0000u)) >> (0x00000010u));
    *match   = (((value) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetTLMPortBaseRoutingPatternMatch
 *
 *   @b Description
 *   @n The function is used to set the TLM Base Routing Pattern Match information
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          brrNum                BRR Number for which this configuration is applied.
          pattern               16 bit ID used for comparison.
          match                 Indicates which of the 16bits should be used
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_TLM_SP_BRR_0_PATTERN_MATCH_PATTERN, SRIO_RIO_TLM_SP_BRR_0_PATTERN_MATCH_MATCH;
 *   @n SRIO_RIO_TLM_SP_BRR_1_PATTERN_MATCH_PATTERN, SRIO_RIO_TLM_SP_BRR_1_PATTERN_MATCH_MATCH;
 *   @n SRIO_RIO_TLM_SP_BRR_2_PATTERN_MATCH_PATTERN, SRIO_RIO_TLM_SP_BRR_2_PATTERN_MATCH_MATCH;
 *   @n SRIO_RIO_TLM_SP_BRR_3_PATTERN_MATCH_PATTERN, SRIO_RIO_TLM_SP_BRR_3_PATTERN_MATCH_MATCH
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint16              pattern;
        Uint16              match;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the TLM Port Base routing pattern match information
        CSL_SRIO_SetTLMPortBaseRoutingPatternMatch(hSrio, 1, &pattern, &match);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetTLMPortBaseRoutingPatternMatch
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               brrNum,
    Uint16              pattern,
    Uint16              match
)
{
    hSrio->RIO_TLM[portNum].brr[brrNum].RIO_TLM_SP_BRR_PATTERN_MATCH = 
            (((pattern) << (0x00000010u)) & (0xFFFF0000u))      |
            (((match) << (0x00000000u)) & (0x0000FFFFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPBMPortControl
 *
 *   @b Description
 *   @n The function is used to get the PBM Port Control information
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egReorderMode         Reorder Mode
          egReorderStick        Number of repeat times the CRQ is reordered
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PBM_SP_CONTROL_EG_REORDER_MODE, SRIO_RIO_PBM_SP_CONTROL_EG_REORDER_STICK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               egReorderMode;
        Uint8               egReorderStick;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Control Information.
        CSL_SRIO_GetPBMPortControl(hSrio, 1, &egReorderMode, &egReorderStick);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPBMPortControl
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              egReorderMode,
    Uint8*              egReorderStick
)
{
    Uint32 value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_CONTROL;

    *egReorderMode  = (((value) & (0x00000030u)) >> (0x00000004u));
    *egReorderStick = (((value) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPBMPortControl
 *
 *   @b Description
 *   @n The function is used to set the PBM Port Control information
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egReorderMode         Reorder Mode
          egReorderStick        Number of repeat times the CRQ is reordered
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PBM_SP_CONTROL_EG_REORDER_MODE, SRIO_RIO_PBM_SP_CONTROL_EG_REORDER_STICK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PBM Port Control Information.
        CSL_SRIO_GetPBMPortControl(hSrio, 1, 1, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPBMPortControl
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               egReorderMode,
    Uint8               egReorderStick
)
{
    hSrio->RIO_PBM[portNum].RIO_PBM_SP_CONTROL = 
            (((egReorderMode) << (0x00000004u)) & (0x00000030u))    |
            (((egReorderStick) << (0x00000000u)) & (0x00000007u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPBMPortStatus
 *
 *   @b Description
 *   @n The function is used to get the PBM Port Status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          igEmpty               PBMi Queue Status
          egEmpty               PBMe Queue Status
          egDataOverflow        PBMe received a request to enqueue a packet 
                                for which it did not have enough data storage.
          egCRQOverflow         PBMe received a request to enqueue a packet 
                                for which it did not have CRQ Entry.
          egBadChannel          PBMe received a request to enqueue a packet 
                                on a channel enqueue interface which should be 
                                unused for the paths Mode.
          egBabblePacket        PBMe detected a packet that exceeded 276 bytes 
                                on its enqueue interface
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PBM_SP_STATUS_IG_EMPTY, SRIO_RIO_PBM_SP_STATUS_EG_EMPTY,
 *   @n SRIO_RIO_PBM_SP_STATUS_EG_DATA_OVERFLOW, SRIO_RIO_PBM_SP_STATUS_EG_CRQ_OVERFLOW,
 *   @n SRIO_RIO_PBM_SP_STATUS_EG_BAD_CHANNEL, SRIO_RIO_PBM_SP_STATUS_EG_BABBLE_PACKET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igEmpty;
        Uint8               egEmpty;
        Uint8               egDataOverflow;
        Uint8               egCRQOverflow;
        Uint8               egBadChannel;
        Uint8               egBabblePacket;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Status
        CSL_SRIO_GetPBMPortStatus(hSrio, 1, &igEmpty, &egEmpty, 
                                  &egDataOverflow, &egCRQOverflow, &egBadChannel, &egBabblePacket);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPBMPortStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              igEmpty,
    Uint8*              egEmpty,
    Uint8*              egDataOverflow,
    Uint8*              egCRQOverflow,
    Uint8*              egBadChannel,
    Uint8*              egBabblePacket
)
{
    Uint32 value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_STATUS;

    *igEmpty        = (((value) & (0x00010000u)) >> (0x00000010u));
    *egEmpty        = (((value) & (0x00008000u)) >> (0x0000000Fu));
    *egDataOverflow = (((value) & (0x00000010u)) >> (0x00000004u));
    *egCRQOverflow  = (((value) & (0x00000008u)) >> (0x00000003u));
    *egBadChannel   = (((value) & (0x00000002u)) >> (0x00000001u));
    *egBabblePacket = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearPBMPortStatus
 *
 *   @b Description
 *   @n The function is used to clear the PBM Port Status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egDataOverflow        PBMe received a request to enqueue a packet 
                                for which it did not have enough data storage.
          egCRQOverflow         PBMe received a request to enqueue a packet 
                                for which it did not have CRQ Entry.
          egBadChannel          PBMe received a request to enqueue a packet 
                                on a channel enqueue interface which should be 
                                unused for the paths Mode.
          egBabblePacket        PBMe detected a packet that exceeded 276 bytes 
                                on its enqueue interface
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PBM_SP_STATUS_EG_DATA_OVERFLOW=1, SRIO_RIO_PBM_SP_STATUS_EG_CRQ_OVERFLOW=1,
 *   @n SRIO_RIO_PBM_SP_STATUS_EG_BAD_CHANNEL=1, SRIO_RIO_PBM_SP_STATUS_EG_BABBLE_PACKET=1
 *
 *   @b Affects
 *   @n SRIO_RIO_PBM_SP_STATUS_EG_DATA_OVERFLOW=0, SRIO_RIO_PBM_SP_STATUS_EG_CRQ_OVERFLOW=0,
 *   @n SRIO_RIO_PBM_SP_STATUS_EG_BAD_CHANNEL=0, SRIO_RIO_PBM_SP_STATUS_EG_BABBLE_PACKET=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igEmpty;
        Uint8               egEmpty;
        Uint8               egDataOverflow;
        Uint8               egCRQOverflow;
        Uint8               egBadChannel;
        Uint8               egBabblePacket;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Status
        CSL_SRIO_GetPBMPortStatus(hSrio, 1, &igEmpty, &egEmpty, 
                                  &egDataOverflow, &egCRQOverflow, &egBadChannel, &egBabblePacket);
        ...
        // Clear the PBM Port Status
        CSL_SRIO_ClearPBMPortStatus(hSrio, 1, egDataOverflow, egCRQOverflow, egBadChannel, egBabblePacket);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearPBMPortStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               egDataOverflow,
    Uint8               egCRQOverflow,
    Uint8               egBadChannel,
    Uint8               egBabblePacket
)
{
    hSrio->RIO_PBM[portNum].RIO_PBM_SP_STATUS =
            (((egDataOverflow) << (0x00000004u)) & (0x00000010u))     |
            (((egCRQOverflow) << (0x00000003u)) & (0x00000008u))      |
            (((egBadChannel) << (0x00000001u)) & (0x00000002u))       |
            (((egBabblePacket) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPBMPortInterrupts
 *
 *   @b Description
 *   @n The function is used to get the PBM Port Interrupt status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egDataOverflow        PBMe received a request to enqueue a packet 
                                for which it did not have enough data storage.
          egCRQOverflow         PBMe received a request to enqueue a packet 
                                for which it did not have CRQ Entry.
          egBadChannel          PBMe received a request to enqueue a packet 
                                on a channel enqueue interface which should be 
                                unused for the paths Mode.
          egBabblePacket        PBMe detected a packet that exceeded 276 bytes 
                                on its enqueue interface
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PBM_SP_INT_ENABLE_EG_DATA_OVERFLOW, 
 *   @n SRIO_RIO_PBM_SP_INT_ENABLE_EG_CRQ_OVERFLOW,
 *   @n SRIO_RIO_PBM_SP_INT_ENABLE_EG_BAD_CHANNEL,
 *   @n SRIO_RIO_PBM_SP_INT_ENABLE_EG_BABBLE_PACKET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               egDataOverflow;
        Uint8               egCRQOverflow;
        Uint8               egBadChannel;
        Uint8               egBabblePacket;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Interrupts
        CSL_SRIO_GetPBMPortInterrupts(hSrio, 1, &egDataOverflow, &egCRQOverflow, 
                                      &egBadChannel, &egBabblePacket);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPBMPortInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              egDataOverflow,
    Uint8*              egCRQOverflow,
    Uint8*              egBadChannel,
    Uint8*              egBabblePacket
)
{
    Uint32 value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_INT_ENABLE;

    *egDataOverflow = (((value) & (0x00000010u)) >> (0x00000004u));
    *egCRQOverflow  = (((value) & (0x00000008u)) >> (0x00000003u));
    *egBadChannel   = (((value) & (0x00000002u)) >> (0x00000001u));
    *egBabblePacket = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPBMPortInterrupts
 *
 *   @b Description
 *   @n The function is used to set the PBM Port Interrupt status
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egDataOverflow        PBMe received a request to enqueue a packet 
                                for which it did not have enough data storage.
          egCRQOverflow         PBMe received a request to enqueue a packet 
                                for which it did not have CRQ Entry.
          egBadChannel          PBMe received a request to enqueue a packet 
                                on a channel enqueue interface which should be 
                                unused for the paths Mode.
          egBabblePacket        PBMe detected a packet that exceeded 276 bytes 
                                on its enqueue interface
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PBM_SP_INT_ENABLE_EG_DATA_OVERFLOW, 
 *   @n SRIO_RIO_PBM_SP_INT_ENABLE_EG_CRQ_OVERFLOW,
 *   @n SRIO_RIO_PBM_SP_INT_ENABLE_EG_BAD_CHANNEL,
 *   @n SRIO_RIO_PBM_SP_INT_ENABLE_EG_BABBLE_PACKET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PBM Port Interrupts for Data Overflow only
        CSL_SRIO_SetPBMPortInterrupts(hSrio, 1, 1, 0, 0, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPBMPortInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               egDataOverflow,
    Uint8               egCRQOverflow,
    Uint8               egBadChannel,
    Uint8               egBabblePacket
)
{
    hSrio->RIO_PBM[portNum].RIO_PBM_SP_INT_ENABLE = 
        (((egDataOverflow) << (0x00000004u)) & (0x00000010u))     |
        (((egCRQOverflow) << (0x00000003u)) & (0x00000008u))      |
        (((egBadChannel) << (0x00000001u)) & (0x00000002u))       |
        (((egBabblePacket) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPBMPortWriteEnables
 *
 *   @b Description
 *   @n The function is used to get the PBM Port Write Enables
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egDataOverflow        PBMe received a request to enqueue a packet 
                                for which it did not have enough data storage.
          egCRQOverflow         PBMe received a request to enqueue a packet 
                                for which it did not have CRQ Entry.
          egBadChannel          PBMe received a request to enqueue a packet 
                                on a channel enqueue interface which should be 
                                unused for the paths Mode.
          egBabblePacket        PBMe detected a packet that exceeded 276 bytes 
                                on its enqueue interface
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PBM_SP_PW_ENABLE_EG_DATA_OVERFLOW, 
 *   @n SRIO_RIO_PBM_SP_PW_ENABLE_EG_CRQ_OVERFLOW,
 *   @n SRIO_RIO_PBM_SP_PW_ENABLE_EG_BAD_CHANNEL,
 *   @n SRIO_RIO_PBM_SP_PW_ENABLE_EG_BABBLE_PACKET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               egDataOverflow;
        Uint8               egCRQOverflow;
        Uint8               egBadChannel;
        Uint8               egBabblePacket;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Write Enables
        CSL_SRIO_GetPBMPortWriteEnables(hSrio, 1, &egDataOverflow, &egCRQOverflow, 
                                      &egBadChannel, &egBabblePacket);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPBMPortWriteEnables
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              egDataOverflow,
    Uint8*              egCRQOverflow,
    Uint8*              egBadChannel,
    Uint8*              egBabblePacket
)
{
    Uint32 value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_PW_ENABLE;

    *egDataOverflow = (((value) & (0x00000010u)) >> (0x00000004u));
    *egCRQOverflow  = (((value) & (0x00000008u)) >> (0x00000003u));
    *egBadChannel   = (((value) & (0x00000002u)) >> (0x00000001u));
    *egBabblePacket = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPBMPortWriteEnables
 *
 *   @b Description
 *   @n The function is used to set the PBM Port Write Enables
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egDataOverflow        PBMe received a request to enqueue a packet 
                                for which it did not have enough data storage.
          egCRQOverflow         PBMe received a request to enqueue a packet 
                                for which it did not have CRQ Entry.
          egBadChannel          PBMe received a request to enqueue a packet 
                                on a channel enqueue interface which should be 
                                unused for the paths Mode.
          egBabblePacket        PBMe detected a packet that exceeded 276 bytes 
                                on its enqueue interface
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PBM_SP_PW_ENABLE_EG_DATA_OVERFLOW, 
 *   @n SRIO_RIO_PBM_SP_PW_ENABLE_EG_CRQ_OVERFLOW,
 *   @n SRIO_RIO_PBM_SP_PW_ENABLE_EG_BAD_CHANNEL,
 *   @n SRIO_RIO_PBM_SP_PW_ENABLE_EG_BABBLE_PACKET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PBM Port Write Enables for Data Overflow only
        CSL_SRIO_SetPBMPortWriteEnables(hSrio, 1, 1, 0, 0, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPBMPortWriteEnables
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               egDataOverflow,
    Uint8               egCRQOverflow,
    Uint8               egBadChannel,
    Uint8               egBabblePacket
)
{
    hSrio->RIO_PBM[portNum].RIO_PBM_SP_PW_ENABLE = 
            (((egDataOverflow) << (0x00000004u)) & (0x00000010u))    |
            (((egCRQOverflow) << (0x00000003u)) & (0x00000008u))     |
            (((egBadChannel) << (0x00000001u)) & (0x00000002u))      |
            (((egBabblePacket) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPBMPortEventGenerate
 *
 *   @b Description
 *   @n The function is used to get the PBM Port Event generates
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egDataOverflow        PBMe received a request to enqueue a packet 
                                for which it did not have enough data storage.
          egCRQOverflow         PBMe received a request to enqueue a packet 
                                for which it did not have CRQ Entry.
          egBadChannel          PBMe received a request to enqueue a packet 
                                on a channel enqueue interface which should be 
                                unused for the paths Mode.
          egBabblePacket        PBMe detected a packet that exceeded 276 bytes 
                                on its enqueue interface
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PBM_SP_EVENT_GEN_EG_DATA_OVERFLOW, 
 *   @n SRIO_RIO_PBM_SP_EVENT_GEN_EG_CRQ_OVERFLOW,
 *   @n SRIO_RIO_PBM_SP_EVENT_GEN_EG_BAD_CHANNEL,
 *   @n SRIO_RIO_PBM_SP_EVENT_GEN_EG_BABBLE_PACKET
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               egDataOverflow;
        Uint8               egCRQOverflow;
        Uint8               egBadChannel;
        Uint8               egBabblePacket;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Event Generates
        CSL_SRIO_GetPBMPortEventGenerate(hSrio, 1, &egDataOverflow, &egCRQOverflow, 
                                      &egBadChannel, &egBabblePacket);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPBMPortEventGenerate
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8*              egDataOverflow,
    Uint8*              egCRQOverflow,
    Uint8*              egBadChannel,
    Uint8*              egBabblePacket
)
{
    Uint32 value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_EVENT_GEN;

    *egDataOverflow = (((value) & (0x00000010u)) >> (0x00000004u));
    *egCRQOverflow  = (((value) & (0x00000008u)) >> (0x00000003u));
    *egBadChannel   = (((value) & (0x00000002u)) >> (0x00000001u));
    *egBabblePacket = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPBMPortEventGenerate
 *
 *   @b Description
 *   @n The function is used to set the PBM Port Event generates
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          egDataOverflow        PBMe received a request to enqueue a packet 
                                for which it did not have enough data storage.
          egCRQOverflow         PBMe received a request to enqueue a packet 
                                for which it did not have CRQ Entry.
          egBadChannel          PBMe received a request to enqueue a packet 
                                on a channel enqueue interface which should be 
                                unused for the paths Mode.
          egBabblePacket        PBMe detected a packet that exceeded 276 bytes 
                                on its enqueue interface
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PBM_SP_EVENT_GEN_EG_DATA_OVERFLOW, 
 *   @n SRIO_RIO_PBM_SP_EVENT_GEN_EG_CRQ_OVERFLOW,
 *   @n SRIO_RIO_PBM_SP_EVENT_GEN_EG_BAD_CHANNEL,
 *   @n SRIO_RIO_PBM_SP_EVENT_GEN_EG_BABBLE_PACKET
 *
 *   @b Affects
 *   @n SRIO_RIO_PBM_SP_STATUS_EG_DATA_OVERFLOW=1, SRIO_RIO_PBM_SP_STATUS_EG_CRQ_OVERFLOW=1,
 *   @n SRIO_RIO_PBM_SP_STATUS_EG_BAD_CHANNEL=1, SRIO_RIO_PBM_SP_STATUS_EG_BABBLE_PACKET=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PBM Port Event Generates for Data overflow only
        CSL_SRIO_SetPBMPortEventGenerate(hSrio, 1, 1, 0, 0, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPBMPortEventGenerate
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               egDataOverflow,
    Uint8               egCRQOverflow,
    Uint8               egBadChannel,
    Uint8               egBabblePacket
)
{
    hSrio->RIO_PBM[portNum].RIO_PBM_SP_EVENT_GEN = 
            (((egDataOverflow) << (0x00000004u)) & (0x00000010u))     |
            (((egCRQOverflow) << (0x00000003u)) & (0x00000008u))      |
            (((egBadChannel) << (0x00000001u)) & (0x00000002u))       |
            (((egBabblePacket) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPBMPortIngressResources
 *
 *   @b Description
 *   @n The function is used to get the PBM Port Ingress resources
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          dataNodes             Indicates the number of Data Nodes 
                                implemented in the PBMi for packet storage
          tags                  Indicates the number of Tags implemented in 
                                the PBMi for packet storage for the port
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PBM_SP_IG_RESOURCES_DATANODES, 
 *   @n SRIO_RIO_PBM_SP_IG_RESOURCES_TAGS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint16              dataNodes;
        Uint16              tags;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Ingress Resources
        CSL_SRIO_GetPBMPortIngressResources(hSrio, 1, &dataNodes, &tags);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPBMPortIngressResources
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint16*             dataNodes,
    Uint16*             tags
)
{
    Uint32 value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_RESOURCES;

    *dataNodes = (((value) & (0x03FF0000u)) >> (0x00000010u));
    *tags      = (((value) & (0x000003FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPBMPortEgressResources
 *
 *   @b Description
 *   @n The function is used to get the PBM Port Egress resources
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          dataNodes             Indicates the number of Data Nodes 
                                implemented in the PBMe for packet storage
          crqEntries            Indicates the number of CRQ Entries implemented in 
                                the PBMe for packet storage for the port
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PBM_SP_EG_RESOURCES_DATANODES, 
 *   @n SRIO_RIO_PBM_SP_EG_RESOURCES_CRQ_ENTRIES
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint16              dataNodes;
        Uint8               crqEntries;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Egress Resources
        CSL_SRIO_GetPBMPortEgressResources(hSrio, 1, &dataNodes, &crqEntries);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPBMPortEgressResources
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint16*             dataNodes,
    Uint8*              crqEntries
)
{
    Uint32 value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_EG_RESOURCES;

    *dataNodes  = (((value) & (0x03FF0000u)) >> (0x00000010u));
    *crqEntries = (((value) & (0x0000007Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPBMPortIngressPriorityWatermark
 *
 *   @b Description
 *   @n The function is used to get the PBM Port Ingress Priority Watermark
 *      configuration
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          priority              Priority 0,1,2 or 3
          crfWatermark          CRF Watermark
          priWatermark          Priority Watermark
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PBM_SP_IG_WATERMARK0_PRIO0CRF_WM, SRIO_RIO_PBM_SP_IG_WATERMARK0_PRIO0_WM;
 *   @n SRIO_RIO_PBM_SP_IG_WATERMARK1_PRIO1CRF_WM, SRIO_RIO_PBM_SP_IG_WATERMARK1_PRIO1_WM;
 *   @n SRIO_RIO_PBM_SP_IG_WATERMARK2_PRIO2CRF_WM, SRIO_RIO_PBM_SP_IG_WATERMARK2_PRIO2_WM;
 *   @n SRIO_RIO_PBM_SP_IG_WATERMARK3_PRIO3CRF_WM, SRIO_RIO_PBM_SP_IG_WATERMARK3_PRIO3_WM
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint16              crfWatermark;
        Uint16              priWatermark;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the PBM Port Ingress 0 Watermarks
        CSL_SRIO_GetPBMPortIngressPriorityWatermark(hSrio, 1, 0, &crfWatermark, &priWatermark);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPBMPortIngressPriorityWatermark
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               priority,
    Uint16*             crfWatermark,
    Uint16*             priWatermark
)
{
    Uint32 value;

    switch (priority)
    {
        case 0:
        {
            value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_WATERMARK0;

            *crfWatermark  = (((value) & (0x03FF0000u)) >> (0x00000010u));
            *priWatermark  = (((value) & (0x000003FFu)) >> (0x00000000u));                
            break;
        }
        case 1:
        {
            value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_WATERMARK1;

            *crfWatermark  = (((value) & (0x03FF0000u)) >> (0x00000010u));
            *priWatermark  = (((value) & (0x000003FFu)) >> (0x00000000u));
            break;
        }
        case 2:
        {
            value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_WATERMARK2;

            *crfWatermark  = (((value) & (0x03FF0000u)) >> (0x00000010u));
            *priWatermark  = (((value) & (0x000003FFu)) >> (0x00000000u));
            break;
        }
        case 3:
        {
            value = hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_WATERMARK3;

            *crfWatermark  = (((value) & (0x03FF0000u)) >> (0x00000010u));
            *priWatermark  = (((value) & (0x000003FFu)) >> (0x00000000u));
            break;
        }
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPBMPortIngressPriorityWatermark
 *
 *   @b Description
 *   @n The function is used to set the PBM Port Ingress Priority Watermark
 *      configuration
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          portNum               SRIO Port Number
          priority              Priority 0,1,2 or 3
          crfWatermark          CRF Watermark
          priWatermark          Priority Watermark
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PBM_SP_IG_WATERMARK0_PRIO0CRF_WM, SRIO_RIO_PBM_SP_IG_WATERMARK0_PRIO0_WM;
 *   @n SRIO_RIO_PBM_SP_IG_WATERMARK1_PRIO1CRF_WM, SRIO_RIO_PBM_SP_IG_WATERMARK1_PRIO1_WM;
 *   @n SRIO_RIO_PBM_SP_IG_WATERMARK2_PRIO2CRF_WM, SRIO_RIO_PBM_SP_IG_WATERMARK2_PRIO2_WM;
 *   @n SRIO_RIO_PBM_SP_IG_WATERMARK3_PRIO3CRF_WM, SRIO_RIO_PBM_SP_IG_WATERMARK3_PRIO3_WM
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the PBM Port Ingress 0 Watermarks
        CSL_SRIO_SetPBMPortIngressPriorityWatermark(hSrio, 1, 0, 10, 12);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPBMPortIngressPriorityWatermark
(
    CSL_SrioHandle      hSrio,
    Uint8               portNum,
    Uint8               priority,
    Uint16              crfWatermark,
    Uint16              priWatermark
)
{
    switch (priority)
    {
        case 0:
        {
            hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_WATERMARK0 = 
                (((crfWatermark) << (0x00000010u)) & (0x03FF0000u))   |
                (((priWatermark) << (0x00000000u)) & (0x000003FFu));                
            break;
        }
        case 1:
        {
            hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_WATERMARK1 = 
                (((crfWatermark) << (0x00000010u)) & (0x03FF0000u))   |
                (((priWatermark) << (0x00000000u)) & (0x000003FFu));
            break;
        }
        case 2:
        {
            hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_WATERMARK2 = 
                (((crfWatermark) << (0x00000010u)) & (0x03FF0000u))   |
                (((priWatermark) << (0x00000000u)) & (0x000003FFu));
            break;
        }
        case 3:
        {
            hSrio->RIO_PBM[portNum].RIO_PBM_SP_IG_WATERMARK3 = 
                (((crfWatermark) << (0x00000010u)) & (0x03FF0000u))   |
                (((priWatermark) << (0x00000000u)) & (0x000003FFu));
            break;
        }
    }
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtInterruptStatus
 *
 *   @b Description
 *   @n The function is used to get the Event Management Interrupt Status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          intStatus     Event Management Interrupt Status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_INT_STAT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint32              intStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Interrupt Status
        CSL_SRIO_GetEventMgmtInterruptStatus(hSrio, &intStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtInterruptStatus
(
    CSL_SrioHandle      hSrio,
    Uint32*             intStatus
)
{
    *intStatus = hSrio->RIO_EM_INT_STAT;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtInterrupts
 *
 *   @b Description
 *   @n The function is used to get the Event Management Interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          log           When set, this field enables a logical layer event 
                        detected in the User Core to cause an interrupt
          mecs          When set, this field enables an interrupt to be raised 
                        upon reception of an MECS with a command value that is 
                        enabled
          pwRx          When set, this field enables the reception of a port-write 
                        to cause an interrupt
          localLog      When set, this field enables an implementation-specific
                        Logical/Transport Layer Error to cause an interrupt
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_INT_ENABLE_LOG,   SRIO_RIO_EM_INT_ENABLE_MECS, 
 *   @n SRIO_RIO_EM_INT_ENABLE_PW_RX, SRIO_RIO_EM_INT_ENABLE_LOCALOG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               log;
        Uint8               mecs;
        Uint8               pwRx;
        Uint8               localLog;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Interrupts 
        CSL_SRIO_GetEventMgmtInterrupts(hSrio, &log, &mecs, &pwRx, &localLog);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8*              log,
    Uint8*              mecs,
    Uint8*              pwRx,
    Uint8*              localLog
)
{
    Uint32  value = hSrio->RIO_EM_INT_ENABLE;

    *log        = (((value) & (0x10000000u)) >> (0x0000001Cu));
    *mecs       = (((value) & (0x04000000u)) >> (0x0000001Au));
    *pwRx       = (((value) & (0x00010000u)) >> (0x00000010u));
    *localLog   = (((value) & (0x00000100u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtInterrupts
 *
 *   @b Description
 *   @n The function is used to set the Event Management Interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          log           When set, this field enables a logical layer event 
                        detected in the User Core to cause an interrupt
          mecs          When set, this field enables an interrupt to be raised 
                        upon reception of an MECS with a command value that is 
                        enabled
          pwRx          When set, this field enables the reception of a port-write 
                        to cause an interrupt
          localLog      When set, this field enables an implementation-specific
                        Logical/Transport Layer Error to cause an interrupt
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_INT_ENABLE_LOG,   SRIO_RIO_EM_INT_ENABLE_MECS, 
 *   @n SRIO_RIO_EM_INT_ENABLE_PW_RX, SRIO_RIO_EM_INT_ENABLE_LOCALOG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Event Management Interrupts for logical layer events only
        CSL_SRIO_SetEventMgmtInterrupts(hSrio, 1, 0, 0, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtInterrupts
(
    CSL_SrioHandle      hSrio,
    Uint8               log,
    Uint8               mecs,
    Uint8               pwRx,
    Uint8               localLog
)
{
    hSrio->RIO_EM_INT_ENABLE = 
        (((log) << (0x0000001Cu)) & (0x10000000u))           |
        (((mecs) << (0x0000001Au)) & (0x04000000u))         |
        (((pwRx) << (0x00000010u)) & (0x00010000u))        |
        (((localLog) << (0x00000008u)) & (0x00000100u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtInterruptPortStatus
 *
 *   @b Description
 *   @n The function is used to get the Event Management Interrupt port status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          irqPending    Per-port interrupt pending status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_INT_PORT_STAT_IRQ_PENDING
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               irqPending;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Port Interrupt Status
        CSL_SRIO_GetEventMgmtInterruptPortStatus(hSrio, &irqPending);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtInterruptPortStatus
(
    CSL_SrioHandle      hSrio,
    Uint8*              irqPending
)
{
    *irqPending = (((hSrio->RIO_EM_INT_PORT_STAT) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtPortWriteStatus
 *
 *   @b Description
 *   @n The function is used to get the Event Management Port Write Status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          port          When set, a port-specific event has been detected
          log           An enabled logical layer event has been detected
          rcs           A reset request has been detected by a port
          multiportErr  Indicates that multiple ports have detected errors 
                        which use port-write notification
          localLog      Implementation-specific local Logical/Transport Layer Error
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_PW_STAT_PORT,   SRIO_RIO_EM_PW_STAT_LOG, 
 *   @n SRIO_RIO_EM_PW_STAT_RCS,    SRIO_RIO_EM_PW_STAT_MULTIPORT_ERR,
 *   @n SRIO_RIO_EM_PW_STAT_LOCALOG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               port;
        Uint8               log;
        Uint8               rcs;
        Uint8               multiportErr;
        Uint8               localLog;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Port Status 
        CSL_SRIO_GetEventMgmtPortWriteStatus(hSrio, &port, &log, &rcs, &multiportErr, &localLog);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtPortWriteStatus
(
    CSL_SrioHandle      hSrio,
    Uint8*              port,
    Uint8*              log,
    Uint8*              rcs,
    Uint8*              multiportErr,
    Uint8*              localLog
)
{
    Uint32  value = hSrio->RIO_EM_PW_STAT;

    *port           = (((value) & (0x20000000u)) >> (0x0000001Du));
    *log            = (((value) & (0x10000000u)) >> (0x0000001Cu));
    *rcs            = (((value) & (0x08000000u)) >> (0x0000001Bu));
    *multiportErr   = (((value) & (0x00000200u)) >> (0x00000009u));
    *localLog       = (((value) & (0x00000100u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtPortWriteEnable
 *
 *   @b Description
 *   @n The function is used to get the Event Management Port Write Enable
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          log           When set, this field enables a logical layer event 
                        to cause a port-write to be sent.
          localLog      When set, this field enables an implementation-specific
                        Logical/Transport Layer Error to cause a port-write 
                        to be sent
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_PW_EN_LOG, SRIO_RIO_EM_PW_EN_LOCALOG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               log;
        Uint8               localLog;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Port Enable 
        CSL_SRIO_GetEventMgmtPortWriteEnable(hSrio, &log, &localLog);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtPortWriteEnable
(
    CSL_SrioHandle      hSrio,
    Uint8*              log,
    Uint8*              localLog
)
{
    Uint32  value = hSrio->RIO_EM_PW_EN;

    *log            = (((value) & (0x10000000u)) >> (0x0000001Cu));
    *localLog       = (((value) & (0x00000100u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtPortWriteEnable
 *
 *   @b Description
 *   @n The function is used to set the Event Management Port Write Enable
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          log           When set, this field enables a logical layer event 
                        to cause a port-write to be sent.
          localLog      When set, this field enables an implementation-specific
                        Logical/Transport Layer Error to cause a port-write 
                        to be sent
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_PW_EN_LOG, SRIO_RIO_EM_PW_EN_LOCALOG
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Event Management Port Enable for Log only events
        CSL_SRIO_SetEventMgmtPortWriteEnable(hSrio, 1, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtPortWriteEnable
(
    CSL_SrioHandle      hSrio,
    Uint8               log,
    Uint8               localLog
)
{
    hSrio->RIO_EM_PW_EN = 
            (((log) << (0x0000001Cu)) & (0x10000000u))    |
            (((localLog) << (0x00000008u)) & (0x00000100u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtPortWritePendingStatus
 *
 *   @b Description
 *   @n The function is used to get the Event Management Port Write Status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          pwPending     Per-port Port Write pending status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_PW_PORT_STAT_PW_PENDING
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               pwPending;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Port Write status
        CSL_SRIO_GetEventMgmtPortWritePendingStatus(hSrio, &pwPending);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtPortWritePendingStatus
(
    CSL_SrioHandle      hSrio,
    Uint8*              pwPending
)
{
    *pwPending = (((hSrio->RIO_EM_PW_PORT_STAT) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableEventMgmtInterrupts
 *
 *   @b Description
 *   @n The function is used to enable the Event Management Interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_DEV_INT_EN_INT_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the Event Management Interrupts
        CSL_SRIO_EnableEventMgmtInterrupts(hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableEventMgmtInterrupts
(
    CSL_SrioHandle      hSrio
)
{
    ((hSrio->RIO_EM_DEV_INT_EN) = ((hSrio->RIO_EM_DEV_INT_EN) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableEventMgmtInterrupts
 *
 *   @b Description
 *   @n The function is used to disable the Event Management Interrupts
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_DEV_INT_EN_INT_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the Event Management Interrupts
        CSL_SRIO_DisableEventMgmtInterrupts(hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableEventMgmtInterrupts
(
    CSL_SrioHandle      hSrio
)
{
    ((hSrio->RIO_EM_DEV_INT_EN) = ((hSrio->RIO_EM_DEV_INT_EN) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsEventMgmtInterruptsEnabled
 *
 *   @b Description
 *   @n The function is used to check if the Event Management Interrupts are 
 *      enabled or disabled?
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    - Event Management Interrupts are enabled
 *   @n FALSE   - Event Management Interrupts are disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_DEV_INT_EN_INT_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the Event Management Interrupts
        if (CSL_SRIO_IsEventMgmtInterruptsEnabled(hSrio) == TRUE)
        {
            // Event Management Interrupts Enabled
        }
        else
        {
            // Event Management Interrupts Disabled        
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsEventMgmtInterruptsEnabled
(
    CSL_SrioHandle      hSrio
)
{
    if ((((hSrio->RIO_EM_DEV_INT_EN) & (0x00000001u)) >> (0x00000000u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_EnableEventMgmtPortWrite
 *
 *   @b Description
 *   @n The function is used to enable the Event Management Port Write
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_DEV_PW_EN_PW_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Enable the Event Management Port Writes
        CSL_SRIO_EnableEventMgmtPortWrite(hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_EnableEventMgmtPortWrite
(
    CSL_SrioHandle      hSrio
)
{
    ((hSrio->RIO_EM_DEV_PW_EN) = ((hSrio->RIO_EM_DEV_PW_EN) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_DisableEventMgmtPortWrite
 *
 *   @b Description
 *   @n The function is used to disable the Event Management Port Write
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_DEV_PW_EN_PW_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Disable the Event Management Port Writes
        CSL_SRIO_DisableEventMgmtPortWrite(hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_DisableEventMgmtPortWrite
(
    CSL_SrioHandle      hSrio
)
{
    ((hSrio->RIO_EM_DEV_PW_EN) = ((hSrio->RIO_EM_DEV_PW_EN) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_IsEventMgmtPortWriteEnabled
 *
 *   @b Description
 *   @n The function is used to check if the Event Management Port Write is 
 *      enabled or not?
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_DEV_PW_EN_PW_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Check if the Event Management Port Writes are enabled or not?
        if (CSL_SRIO_IsEventMgmtPortWriteEnabled(hSrio) == TRUE)
        {
            // Event Management Port Writes are enabled
        }
        else
        {
            // Event Management Port Writes are disabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_SRIO_IsEventMgmtPortWriteEnabled
(
    CSL_SrioHandle      hSrio
)
{
    if ((((hSrio->RIO_EM_DEV_PW_EN) & (0x00000001u)) >> (0x00000000u)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtMECSStatus
 *
 *   @b Description
 *   @n The function is used to get the event management MECS status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          mecsStatus    MECS Command received by any SRIO port
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_MECS_STAT_CMD_STAT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               mecsStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Status
        CSL_SRIO_GetEventMgmtMECSStatus(hSrio, &mecsStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtMECSStatus
(
    CSL_SrioHandle      hSrio,
    Uint8*              mecsStatus
)
{
    *mecsStatus = (((hSrio->RIO_EM_MECS_STAT) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearEventMgmtMECSStatus
 *
 *   @b Description
 *   @n The function is used to clear the event management MECS status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          mecsStatus    MECS Command received by any SRIO port
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_MECS_STAT_CMD_STAT
 *
 *   @b Affects
 *   @n SRIO_RIO_EM_MECS_STAT_CMD_STAT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               mecsStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Status
        CSL_SRIO_GetEventMgmtMECSStatus(hSrio, &mecsStatus);
        if (mecsStatus != 0)
        {
            // MECS with a command has been received.
            ...
            // Clear the MECS Event Management Status
            CSL_SRIO_ClearEventMgmtMECSStatus (hSrio, mecsStatus);
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearEventMgmtMECSStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               mecsStatus
)
{
    ((hSrio->RIO_EM_MECS_STAT) = ((hSrio->RIO_EM_MECS_STAT) & ~(0x000000FFu)) | (((mecsStatus) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtMECSInterrupt
 *
 *   @b Description
 *   @n The function is used to get the event management MECS interrupt enable
 *      status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          mecsStatus    Enables MECS with set cmd to raise an interrupt request
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_MECS_INT_EN_CMD_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               mecsStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Interrupt status
        CSL_SRIO_GetEventMgmtMECSInterrupt(hSrio, &mecsStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtMECSInterrupt
(
    CSL_SrioHandle      hSrio,
    Uint8*              mecsStatus
)
{
    *mecsStatus = (((hSrio->RIO_EM_MECS_INT_EN) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtMECSInterrupt
 *
 *   @b Description
 *   @n The function is used to set the event management MECS interrupt enable
 *      status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          mecsStatus    Enables MECS with set cmd to raise an interrupt request
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_MECS_INT_EN_CMD_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Event Management MECS Interrupt status for all cmds
        CSL_SRIO_SetEventMgmtMECSInterrupt(hSrio, 0xFF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtMECSInterrupt
(
    CSL_SrioHandle      hSrio,
    Uint8               mecsStatus
)
{
    ((hSrio->RIO_EM_MECS_INT_EN) = ((hSrio->RIO_EM_MECS_INT_EN) & ~(0x000000FFu)) | (((mecsStatus) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtMECSCaptureOut
 *
 *   @b Description
 *   @n The function is used to get the event management MECS capture out 
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          cmdEn         Enables the associated bit to toggle
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_MECS_CAP_EN_CMD_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               cmdEn;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Capture out
        CSL_SRIO_GetEventMgmtMECSCaptureOut(hSrio, &cmdEn);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtMECSCaptureOut
(
    CSL_SrioHandle      hSrio,
    Uint8*              cmdEn
)
{
    *cmdEn = (((hSrio->RIO_EM_MECS_CAP_EN) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtMECSCaptureOut
 *
 *   @b Description
 *   @n The function is used to set the event management MECS capture out 
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          cmdEn         Enables the associated bit to toggle
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_MECS_CAP_EN_CMD_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Event Management MECS Capture out for all commands
        CSL_SRIO_SetEventMgmtMECSCaptureOut(hSrio, 0xFF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtMECSCaptureOut
(
    CSL_SrioHandle      hSrio,
    Uint8               cmdEn
)
{
    ((hSrio->RIO_EM_MECS_CAP_EN) = ((hSrio->RIO_EM_MECS_CAP_EN) & ~(0x000000FFu)) | (((cmdEn) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtMECSTriggerIn
 *
 *   @b Description
 *   @n The function is used to get the event management MECS Trigger In
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          cmdStat       Bit is set whenever an edge is detected on corresponding
          cmdEn         Enables the associated bit to trigger a MECS command
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_MECS_TRIG_EN_CMD_STAT, SRIO_RIO_EM_MECS_TRIG_EN_CMD_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               cmdEn;
        Uint8               cmdStat;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Trigger In
        CSL_SRIO_GetEventMgmtMECSTriggerIn(hSrio, &cmdStat, &cmdEn);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtMECSTriggerIn
(
    CSL_SrioHandle      hSrio,
    Uint8*              cmdStat,
    Uint8*              cmdEn
)
{
    Uint32 value = hSrio->RIO_EM_MECS_TRIG_EN;
    *cmdStat = (((value) & (0x0000FF00u)) >> (0x00000008u));
    *cmdEn   = (((value) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtMECSTriggerIn
 *
 *   @b Description
 *   @n The function is used to set the event management MECS Trigger In
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          cmdStat       Bit is set whenever an edge is detected on corresponding
          cmdEn         Enables the associated bit to trigger a MECS command
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_MECS_TRIG_EN_CMD_STAT, SRIO_RIO_EM_MECS_TRIG_EN_CMD_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               cmdEn;
        Uint8               cmdStat;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Trigger In
        CSL_SRIO_GetEventMgmtMECSTriggerIn(hSrio, &cmdStat, &cmdEn);
        ...
        // Set the Event Management MECS Trigger In to enable all MECS cmds
        CSL_SRIO_SetEventMgmtMECSTriggerIn(hSrio, cmdStat, 0xFF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtMECSTriggerIn
(
    CSL_SrioHandle      hSrio,
    Uint8               cmdStat,
    Uint8               cmdEn
)
{
    hSrio->RIO_EM_MECS_TRIG_EN = 
        (((cmdStat) << (0x00000008u)) & (0x0000FF00u))    |
        (((cmdEn) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtMECSRequest
 *
 *   @b Description
 *   @n The function is used to get the event management MECS Request
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          sendStatus    Send Status 
          cmd           MECS command to be sent
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_MECS_REQ_SEND, SRIO_RIO_EM_MECS_REQ_CMD
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               sendStatus;
        Uint8               cmd;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Trigger In
        CSL_SRIO_GetEventMgmtMECSRequest(hSrio, &cmdStat, &cmdEn);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtMECSRequest
(
    CSL_SrioHandle      hSrio,
    Uint8*              sendStatus,
    Uint8*              cmd
)
{
    Uint32 value = hSrio->RIO_EM_MECS_REQ;
    *sendStatus = (((value) & (0x00000100u)) >> (0x00000008u));
    *cmd        = (((value) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtMECSRequest
 *
 *   @b Description
 *   @n The function is used to set the event management MECS Request
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          sendStatus    Send Status 
          cmd           MECS command to be sent
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_MECS_REQ_SEND, SRIO_RIO_EM_MECS_REQ_CMD
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               sendStatus;
        Uint8               cmd;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Send the MECS Command 2.
        CSL_SRIO_SetEventMgmtMECSRequest(hSrio, 0x1, 0x2);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtMECSRequest
(
    CSL_SrioHandle      hSrio,
    Uint8               sendStatus,
    Uint8               cmd
)
{
    hSrio->RIO_EM_MECS_REQ = 
            (((sendStatus) << (0x00000008u)) & (0x00000100u))     |
            (((cmd) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtMECSPortStatus
 *
 *   @b Description
 *   @n The function is used to get the event management MECS Port Status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          port          MECS Received Status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_MECS_PORT_STAT_PORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               port;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Port Status
        CSL_SRIO_GetEventMgmtMECSPortStatus(hSrio, &port);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtMECSPortStatus
(
    CSL_SrioHandle      hSrio,
    Uint8*              port
)
{
    *port = (((hSrio->RIO_EM_MECS_PORT_STAT) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtMECSPortStatus
 *
 *   @b Description
 *   @n The function is used to set the event management MECS Port Status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          port          MECS Received Status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_MECS_PORT_STAT_PORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               port;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Port Status
        CSL_SRIO_GetEventMgmtMECSPortStatus(hSrio, &port);
        ...
        // Clear the Event Management MECS Port Status
        CSL_SRIO_SetEventMgmtMECSPortStatus (hSrio, port);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtMECSPortStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               port
)
{
    ((hSrio->RIO_EM_MECS_PORT_STAT) = ((hSrio->RIO_EM_MECS_PORT_STAT) & ~(0x0000000Fu)) | (((port) << (0x00000000u)) & (0x0000000Fu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtCmdStatus
 *
 *   @b Description
 *   @n The function is used to get the event management command status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          cmdStat       MECS Command which were received 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_RST_PORT_STAT_RST_REQ
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               cmdStat;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Command Status
        CSL_SRIO_GetEventMgmtCmdStatus(hSrio, &cmdStat);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtCmdStatus
(
    CSL_SrioHandle      hSrio,
    Uint8*              cmdStat
)
{
    *cmdStat = (((hSrio->RIO_EM_MECS_STAT) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtCmdStatus
 *
 *   @b Description
 *   @n The function is used to set the event management command status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          cmdStat       MECS Command to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_MECS_STAT_CMD_STAT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               cmdStat;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Command Status
        CSL_SRIO_GetEventMgmtCmdStatus(hSrio, &cmdStat);
        ...
        // Clear the Event Management Command Status
        CSL_SRIO_SetEventMgmtCmdStatus(hSrio, cmdStat);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtCmdStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               cmdStat
)
{
    ((hSrio->RIO_EM_MECS_STAT) = ((hSrio->RIO_EM_MECS_STAT) & ~(0x000000FFu)) | (((cmdStat) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtResetRequest
 *
 *   @b Description
 *   @n The function is used to get the event management reset request
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          rstReq        Per-port Reset Control Symbol event received status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_RST_PORT_STAT_RST_REQ
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               rstReq;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management Reset Request Status
        CSL_SRIO_GetEventMgmtResetRequest(hSrio, &rstReq);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtResetRequest
(
    CSL_SrioHandle      hSrio,
    Uint8*              rstReq
)
{
    *rstReq = (((hSrio->RIO_EM_RST_PORT_STAT) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtResetRequest
 *
 *   @b Description
 *   @n The function is used to set the event management reset request
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          rstReq        Per-port Reset Control Symbol event received status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_RST_PORT_STAT_RST_REQ
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               rstReq;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Event Management Reset Request Status 
        // and clear all the reset events
        CSL_SRIO_SetEventMgmtResetRequest(hSrio, 0xFF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtResetRequest
(
    CSL_SrioHandle      hSrio,
    Uint8               rstReq
)
{
    ((hSrio->RIO_EM_RST_PORT_STAT) = ((hSrio->RIO_EM_RST_PORT_STAT) & ~(0x000000FFu)) | (((rstReq) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtResetRequestInterrupt
 *
 *   @b Description
 *   @n The function is used to get the event management reset request interrupt
 *      enable status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          rstIntEn      Per-port Reset Request event interrupt enable
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_RST_INT_EN_RST_INT_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               rstReq;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Reset Request Status
        CSL_SRIO_GetEventMgmtResetRequestInterrupt(hSrio, &rstReq);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtResetRequestInterrupt
(
    CSL_SrioHandle      hSrio,
    Uint8*              rstIntEn
)
{
    *rstIntEn = (((hSrio->RIO_EM_RST_INT_EN) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtResetRequestInterrupt
 *
 *   @b Description
 *   @n The function is used to set the event management reset request interrupt
 *      enable status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          rstIntEn      Per-port Reset Request event interrupt enable
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_RST_INT_EN_RST_INT_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Event Management Reset Request Interrupt Enable for all ports
        CSL_SRIO_SetEventMgmtResetRequestInterrupt(hSrio, 0xF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtResetRequestInterrupt
(
    CSL_SrioHandle      hSrio,
    Uint8               rstIntEn
)
{
    ((hSrio->RIO_EM_RST_INT_EN) = ((hSrio->RIO_EM_RST_INT_EN) & ~(0x0000000Fu)) | (((rstIntEn) << (0x00000000u)) & (0x0000000Fu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetEventMgmtResetRequestPortWrite
 *
 *   @b Description
 *   @n The function is used to get the event management reset request port write
 *      enable status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          rstPwEn       Per-port Reset Request port-write enable
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_EM_RST_PW_EN_RST_PW_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               rstReq;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Event Management MECS Reset Request Port Write Status
        CSL_SRIO_GetEventMgmtResetRequestPortWrite(hSrio, &rstReq);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetEventMgmtResetRequestPortWrite
(
    CSL_SrioHandle      hSrio,
    Uint8*              rstPwEn
)
{
    *rstPwEn = (((hSrio->RIO_EM_RST_PW_EN) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetEventMgmtResetRequestPortWrite
 *
 *   @b Description
 *   @n The function is used to set the event management reset request port write
 *      enable status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          rstPwEn       Per-port Reset Request port-write enable
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_EM_RST_PW_EN_RST_PW_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               rstReq;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Event Management MECS Reset Request Port Write Status to
        // enable sending port write for reset request on all ports
        CSL_SRIO_SetEventMgmtResetRequestPortWrite(hSrio, 0xF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetEventMgmtResetRequestPortWrite
(
    CSL_SrioHandle      hSrio,
    Uint8               rstPwEn
)
{
    ((hSrio->RIO_EM_RST_PW_EN) = ((hSrio->RIO_EM_RST_PW_EN) & ~(0x0000000Fu)) | (((rstPwEn) << (0x00000000u)) & (0x0000000Fu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortWriteControl
 *
 *   @b Description
 *   @n The function is used to get the port write control information
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          pwTimer       Port Write Timer
          pwcMode       Port Write Capture Mode
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PW_CTL_PW_TIMER, SRIO_RIO_PW_CTL_PWC_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               pwTimer;
        Uint8               pwcMode;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port Write Control
        CSL_SRIO_GetPortWriteControl(hSrio, &pwTimer, &pwcMode);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortWriteControl
(
    CSL_SrioHandle      hSrio,
    Uint8*              pwTimer,
    Uint8*              pwcMode
)
{
    *pwTimer = (((hSrio->RIO_PW_CTL) & (0xF0000000u)) >> (0x0000001Cu));
    *pwcMode = (((hSrio->RIO_PW_CTL) & (0x01000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPortWriteControl
 *
 *   @b Description
 *   @n The function is used to set the port write control information
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          pwTimer       Port Write Timer
          pwcMode       Port Write Capture Mode
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PW_CTL_PW_TIMER, SRIO_RIO_PW_CTL_PWC_MODE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Port Write Control to disable port write timer and to enable
        // continuous port capture 
        CSL_SRIO_SetPortWriteControl(hSrio, 0, 0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPortWriteControl
(
    CSL_SrioHandle      hSrio,
    Uint8               pwTimer,
    Uint8               pwcMode
)
{
    hSrio->RIO_PW_CTL = 
            (((pwTimer) << (0x0000001Cu)) & (0xF0000000u))     |
            (((pwcMode) << (0x00000018u)) & (0x01000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortWriteRouting
 *
 *   @b Description
 *   @n The function is used to get the port write routing
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          port          Indicates if a port-write should be sent to this port.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PW_ROUTE_PORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               port;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port Write Control
        CSL_SRIO_GetPortWriteRouting(hSrio, &port);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortWriteRouting
(
    CSL_SrioHandle      hSrio,
    Uint8*              port
)
{
    *port = (((hSrio->RIO_PW_ROUTE) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPortWriteRouting
 *
 *   @b Description
 *   @n The function is used to set the port write routing
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          port          Indicates if a port-write should be sent to this port.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PW_ROUTE_PORT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               port;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Port Write Routing to ensure port writes are sent on all ports
        CSL_SRIO_SetPortWriteRouting(hSrio, 0xF);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPortWriteRouting
(
    CSL_SrioHandle      hSrio,
    Uint8               port
)
{
    ((hSrio->RIO_PW_ROUTE) = ((hSrio->RIO_PW_ROUTE) & ~(0x0000000Fu)) | (((port) << (0x00000000u)) & (0x0000000Fu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortWriteReceptionStatus
 *
 *   @b Description
 *   @n The function is used to get the port write reception status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          wrSize        WRSIZE, in combination with WDPTR, are used to 
                        determine the maximum size of the port-write which has 
                        been received
          wdPtr         WDPTR, in combination with WRSIZE, are used to 
                        determine the maximum size of the port-write which has 
                        been received
          pwDisc        Port-write was discarded
          pwVal         Port-write data registers contain valid data
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PW_RX_STAT_WR_SIZE,  SRIO_RIO_PW_RX_STAT_WDPTR,
 *   @n SRIO_RIO_PW_RX_STAT_PW_DISC, SRIO_RIO_PW_RX_STAT_PW_VAL,
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               wrSize;
        Uint8               wdPtr;
        Uint8               pwDisc;
        Uint8               pwVal;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port Write Reception Status
        CSL_SRIO_GetPortWriteReceptionStatus(hSrio, &wrSize, &wdPtr, &pwDisc, &pwVal);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortWriteReceptionStatus
(
    CSL_SrioHandle      hSrio,
    Uint8*              wrSize,
    Uint8*              wdPtr,
    Uint8*              pwDisc,
    Uint8*              pwVal
)
{
    Uint32 value = hSrio->RIO_PW_RX_STAT;
    *wrSize = (((value) & (0x0000F000u)) >> (0x0000000Cu));
    *wdPtr  = (((value) & (0x00000100u)) >> (0x00000008u));
    *pwDisc = (((value) & (0x00000002u)) >> (0x00000001u));
    *pwVal  = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortWriteEventGenerate
 *
 *   @b Description
 *   @n The function is used to get the port write reception status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          pwDisc        Port-write discard event generate status
          pwVal         Port-write data event generate status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PW_RX_EVENT_GEN_PW_DISC, SRIO_RIO_PW_RX_EVENT_GEN_PW_VAL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               pwDisc;
        Uint8               pwVal;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port Write Event Generate Status
        CSL_SRIO_GetPortWriteEventGenerate(hSrio, &pwDisc, &pwVal);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortWriteEventGenerate
(
    CSL_SrioHandle      hSrio,
    Uint8*              pwDisc,
    Uint8*              pwVal
)
{
    Uint32 value = hSrio->RIO_PW_RX_EVENT_GEN;
    *pwDisc = (((value) & (0x00000002u)) >> (0x00000001u));
    *pwVal  = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPortWriteEventGenerate
 *
 *   @b Description
 *   @n The function is used to set the port write reception status
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          pwDisc        Port-write discard event generate status
          pwVal         Port-write data event generate status
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PW_RX_EVENT_GEN_PW_DISC, SRIO_RIO_PW_RX_EVENT_GEN_PW_VAL
 *   
 *   @b Affects
 *   @n SRIO_RIO_PW_RX_STAT_PW_DISC=1, SRIO_RIO_PW_RX_STAT_PW_VAL=1
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Port Write Event Generate Status
        CSL_SRIO_SetPortWriteEventGenerate(hSrio, 1, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPortWriteEventGenerate
(
    CSL_SrioHandle      hSrio,
    Uint8               pwDisc,
    Uint8               pwVal
)
{
    hSrio->RIO_PW_RX_EVENT_GEN = (((pwDisc) << (0x00000001u)) & (0x00000002u)) |
                                 (((pwVal) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortWriteReceptionCapture
 *
 *   @b Description
 *   @n The function is used to get the port write reception capture
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          cap0          Reception Capture 0
          cap1          Reception Capture 1
          cap2          Reception Capture 2
          cap3          Reception Capture 3
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PW_RX_CAPT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint32              cap0;
        Uint32              cap1;
        Uint32              cap2;
        Uint32              cap3;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port Write Reception Capture
        CSL_SRIO_GetPortWriteReceptionCapture(hSrio, &cap0, &cap1, &cap2, &cap3);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortWriteReceptionCapture
(
    CSL_SrioHandle      hSrio,
    Uint32*             cap0,
    Uint32*             cap1,
    Uint32*             cap2,
    Uint32*             cap3
)
{
    *cap0 = hSrio->RIO_PW_RX_CAPT[0];
    *cap1 = hSrio->RIO_PW_RX_CAPT[1];
    *cap2 = hSrio->RIO_PW_RX_CAPT[2];
    *cap3 = hSrio->RIO_PW_RX_CAPT[3];
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetPortWriteReceptionCapture
 *
 *   @b Description
 *   @n The function is used to set the port write reception capture
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          port          Port number for which the write reception capture needs
                        to be configured.
          cap           Reception Capture value
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Affects
 *   @n SRIO_RIO_PW_RX_CAPT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint32              cap0;
        Uint32              cap1;
        Uint32              cap2;
        Uint32              cap3;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port Write Reception Capture
        CSL_SRIO_GetPortWriteReceptionCapture(hSrio, &cap0, &cap1, &cap2, &cap3);
        ...
        // Set the Port Write Reception Capture for port 0
        CSL_SRIO_SetPortWriteReceptionCapture(hSrio, 0, cap0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetPortWriteReceptionCapture
(
    CSL_SrioHandle      hSrio,
    Uint8               port,
    Uint32              cap
)
{
    ((hSrio->RIO_PW_RX_CAPT[port]) = ((hSrio->RIO_PW_RX_CAPT[port]) & ~(0xFFFFFFFFu)) | (((cap) << (0x00000000u)) & (0xFFFFFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetPortNumberInfo
 *
 *   @b Description
 *   @n The function is used to get the port number information
 *
 *   @b Arguments
     @verbatim
          hSrio         Handle of the SRIO device
          portNum       Port Number
          totalPort     Total number of ports
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PORT_NUMBER_PORT_NUM,SRIO_RIO_PORT_NUMBER_PORT_TOTAL
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               portNum;
        Uint8               totalPort;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Port Information
        CSL_SRIO_GetPortNumberInfo(hSrio, &portNum, &totalPort);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetPortNumberInfo
(
    CSL_SrioHandle      hSrio,
    Uint8*              portNum,
    Uint8*              totalPort
)
{
    Uint32 value = hSrio->RIO_PORT_NUMBER;
    *portNum   = (((value) & (0x000000FFu)) >> (0x00000000u));
    *totalPort = (((value) & (0x0000FF00u)) >> (0x00000008u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLLMPortIPPrescalar
 *
 *   @b Description
 *   @n The function is used to get the LLM Port IP Prescalar
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          prescalarClock    Prescalar clock
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_PRESCALAR_SRV_CLK_PRESCALAR_SRV_CLK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               prescalarClock;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the LLM Port IP Prescalar Clock.
        CSL_SRIO_GetLLMPortIPPrescalar(hSrio, &prescalarClock);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLLMPortIPPrescalar
(
    CSL_SrioHandle      hSrio,
    Uint8*              prescalarClock
)
{
    *prescalarClock = (((hSrio->RIO_PRESCALAR_SRV_CLK) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLLMPortIPPrescalar
 *
 *   @b Description
 *   @n The function is used to set the LLM Port IP Prescalar
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          prescalarClock    Prescalar clock
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_PRESCALAR_SRV_CLK_PRESCALAR_SRV_CLK
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               prescalarClock;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the LLM Port IP Prescalar Clock to the default value
        CSL_SRIO_SetLLMPortIPPrescalar(hSrio, 31);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLLMPortIPPrescalar
(
    CSL_SrioHandle      hSrio,
    Uint8               prescalarClock
)
{
    ((hSrio->RIO_PRESCALAR_SRV_CLK) = ((hSrio->RIO_PRESCALAR_SRV_CLK) & ~(0x000000FFu)) | (((prescalarClock) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLLMResetControl
 *
 *   @b Description
 *   @n The function is used to get the LLM Reset Control CSR
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          clearSticky       Allows the SELF_RST and PWDN_PORT resets to 
                            clear sticky register bits in addition to the 
                            normal configuration registers
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_REG_RST_CTL_CLEAR_STICKY
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               clearSticky;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the LLM Port Reset Control CSR
        CSL_SRIO_GetLLMResetControl(hSrio, &clearSticky);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLLMResetControl
(
    CSL_SrioHandle      hSrio,
    Uint8*              clearSticky
)
{
    *clearSticky = (((hSrio->RIO_REG_RST_CTL) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetLLMResetControl
 *
 *   @b Description
 *   @n The function is used to set the LLM Reset Control CSR
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          clearSticky       Allows the SELF_RST and PWDN_PORT resets to 
                            clear sticky register bits in addition to the 
                            normal configuration registers
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_REG_RST_CTL_CLEAR_STICKY
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the LLM Port Reset Control CSR
        CSL_SRIO_SetLLMResetControl(hSrio, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetLLMResetControl
(
    CSL_SrioHandle      hSrio,
    Uint8               clearSticky
)
{
    ((hSrio->RIO_REG_RST_CTL) = ((hSrio->RIO_REG_RST_CTL) & ~(0x00000001u)) | (((clearSticky) << (0x00000000u)) & (0x00000001u)));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorDetect
 *
 *   @b Description
 *   @n The function is used to get the error detect CSR
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          illID             Illegal transaction target error
          illType           Unsupported Transaction
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LOCAL_ERR_DET_ILL_ID, SRIO_RIO_LOCAL_ERR_DET_ILL_TYPE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               illID;
        Uint8               illType;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Error Detect CSR Information
        CSL_SRIO_GetErrorDetect(hSrio, &illID, &illType);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorDetect
(
    CSL_SrioHandle      hSrio,
    Uint8*              illID,
    Uint8*              illType
)
{
    Uint32 value = hSrio->RIO_LOCAL_ERR_DET;

    *illID   = (((value) & (0x04000000u)) >> (0x0000001Au));
    *illType = (((value) & (0x00400000u)) >> (0x00000016u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetErrorDetect
 *
 *   @b Description
 *   @n The function is used to set the error detect CSR. 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          illID             Illegal transaction target error
          illType           Unsupported Transaction
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LOCAL_ERR_DET_ILL_ID, SRIO_RIO_LOCAL_ERR_DET_ILL_TYPE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
 
        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Error Detect CSR Information for illegal type
        CSL_SRIO_SetErrorDetect(hSrio, 0, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetErrorDetect
(
    CSL_SrioHandle      hSrio,
    Uint8               illID,
    Uint8               illType
)
{
    hSrio->RIO_LOCAL_ERR_DET = 
            (((illID) << (0x0000001Au)) & (0x04000000u))      |
            (((illType) << (0x00000016u)) & (0x00400000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetErrorDetectEnable
 *
 *   @b Description
 *   @n The function is used to get the error detect enable CSR
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          illID             Illegal transaction target error
          illType           Unsupported Transaction
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LOCAL_ERR_EN_ILL_ID_EN, SRIO_RIO_LOCAL_ERR_EN_ILL_TYPE_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               illID;
        Uint8               illType;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Error Detect Enable CSR Information
        CSL_SRIO_GetErrorDetectEnable(hSrio, &illID, &illType);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetErrorDetectEnable
(
    CSL_SrioHandle      hSrio,
    Uint8*              illID,
    Uint8*              illType
)
{
    Uint32 value = hSrio->RIO_LOCAL_ERR_EN;

    *illID   = (((value) & (0x04000000u)) >> (0x0000001Au));
    *illType = (((value) & (0x00400000u)) >> (0x00000016u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_SetErrorDetectEnable
 *
 *   @b Description
 *   @n The function is used to set the error detect enable CSR
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          illID             Illegal transaction target error
          illType           Unsupported Transaction
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LOCAL_ERR_EN_ILL_ID_EN, SRIO_RIO_LOCAL_ERR_EN_ILL_TYPE_EN
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Set the Error Detect Enable CSR Information for both illegal id and type
        CSL_SRIO_SetErrorDetectEnable(hSrio, 1, 1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_SetErrorDetectEnable
(
    CSL_SrioHandle      hSrio,
    Uint8               illID,
    Uint8               illType
)
{
    hSrio->RIO_LOCAL_ERR_EN = 
            (((illID) << (0x0000001Au)) & (0x04000000u))    |
            (((illType) << (0x00000016u)) & (0x00400000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetHiAddressCapture
 *
 *   @b Description
 *   @n The function is used to get the High Address capture CSR information. 
 *      The contents of this register are only valid when the device is using 
 *      50- or 66-bit addressing
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          address           Address Capture information
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LOCAL_H_ADDR_CAPT
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint32              address;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Address Capture Information
        CSL_SRIO_GetHiAddressCapture(hSrio, &address);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetHiAddressCapture
(
    CSL_SrioHandle      hSrio,
    Uint32*             address
)
{
    *address   = hSrio->RIO_LOCAL_H_ADDR_CAPT;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLoAddressCapture
 *
 *   @b Description
 *   @n The function is used to get the Low Address capture CSR information. 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          address           Address Capture information
          xambs             Extended address bits of the address associated 
                            with the error
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LOCAL_ADDR_CAPT_ADDR, SRIO_RIO_LOCAL_ADDR_CAPT_XAMSBS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint32              address;
        Uint8               xambs;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Address Capture Information
        CSL_SRIO_GetLoAddressCapture(hSrio, &address, &xambs);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLoAddressCapture
(
    CSL_SrioHandle      hSrio,
    Uint32*             address,
    Uint8*              xambs
)
{
    Uint32 value = hSrio->RIO_LOCAL_ADDR_CAPT;
    *address = (((value) & (0xFFFFFFF8u)) >> (0x00000003u));
    *xambs   = (((value) & (0x00000003u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearLoAddressCapture
 *
 *   @b Description
 *   @n The function is used to clear the Low Address capture CSR information. 
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LOCAL_ADDR_CAPT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint32              address;
        Uint8               xambs;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Address Capture Information
        CSL_SRIO_GetLoAddressCapture(hSrio, &address, &xambs);
        ...
        // Clear the Address capture information
        CSL_SRIO_ClearLoAddressCapture(hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearLoAddressCapture
(
    CSL_SrioHandle      hSrio
)
{
    hSrio->RIO_LOCAL_ADDR_CAPT = 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetDeviceIDCapture
 *
 *   @b Description
 *   @n The function is used to get the Device ID capture CSR information.
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          msbDstID          MSB Destination ID
          lsbDstID          LSB Destination ID
          msbSrcID          MSB Source ID
          lsbSrcID          LSB Source ID
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LOCAL_ID_CAPT_MSB_DEST_ID, SRIO_RIO_LOCAL_ID_CAPT_DEST_ID,SRIO_RIO_LOCAL_ID_CAPT_MSB_SRC_ID, SRIO_RIO_LOCAL_ID_CAPT_SRC_ID
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               msbDstID;
        Uint8               lsbDstID;
        Uint8               msbSrcID;
        Uint8               lsbSrcID;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Device ID Capture information
        CSL_SRIO_GetDeviceIDCapture(hSrio, &msbDstID, &lsbDstID, &msbSrcID, &lsbSrcID);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetDeviceIDCapture
(
    CSL_SrioHandle      hSrio,
    Uint8*              msbDstID,
    Uint8*              lsbDstID,
    Uint8*              msbSrcID,
    Uint8*              lsbSrcID
)
{
    Uint32 value = hSrio->RIO_LOCAL_ID_CAPT;

    *msbDstID  = (((value) & (0xFF000000u)) >> (0x00000018u));
    *lsbDstID  = (((value) & (0x00FF0000u)) >> (0x00000010u));
    *msbSrcID  = (((value) & (0x0000FF00u)) >> (0x00000008u));
    *lsbSrcID  = (((value) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearDeviceIDCapture
 *
 *   @b Description
 *   @n The function is used to clear the Device ID capture CSR information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LOCAL_ID_CAPT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               msbDstID;
        Uint8               lsbDstID;
        Uint8               msbSrcID;
        Uint8               lsbSrcID;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Device ID Capture information
        CSL_SRIO_GetDeviceIDCapture(hSrio, &msbDstID, &lsbDstID, &msbSrcID, &lsbSrcID);
        ...
        // Clear the Address capture information
        CSL_SRIO_ClearDeviceIDCapture(hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearDeviceIDCapture
(
    CSL_SrioHandle      hSrio
)
{
    hSrio->RIO_LOCAL_ID_CAPT = 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetLocalControlCapture
 *
 *   @b Description
 *   @n The function is used to get the Local Control capture CSR information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
          ftype             FTYPE associated with the error.
          ttype             TTYPE associated with the error.
          msgInfo           Messages are not generated by SRIO-TEV2 and message
                            information is not logged
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_LOCAL_CTRL_CAPT_FTYPE,SRIO_RIO_LOCAL_CTRL_CAPT_TTYPE,
 *   @n SRIO_RIO_LOCAL_CTRL_CAPT_MESSAGE_INFO
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               ftype;
        Uint8               ttype;
        Uint8               msgInfo;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Device ID Capture information
        CSL_SRIO_GetLocalControlCapture(hSrio, &ftype, &ttype, &msgInfo);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetLocalControlCapture
(
    CSL_SrioHandle      hSrio,
    Uint8*              ftype,
    Uint8*              ttype,
    Uint8*              msgInfo
)
{
    Uint32 value = hSrio->RIO_LOCAL_CTRL_CAPT;

    *ftype   = (((value) & (0xF0000000u)) >> (0x0000001Cu));
    *ttype   = (((value) & (0x0F000000u)) >> (0x00000018u));
    *msgInfo = (((value) & (0x00FF0000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_SRIO_ClearLocalControlCapture
 *
 *   @b Description
 *   @n The function is used to clear the Local Control capture CSR information
 *
 *   @b Arguments
     @verbatim
          hSrio             Handle of the SRIO device
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n SRIO_RIO_LOCAL_CTRL_CAPT=0
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               ftype;
        Uint8               ttype;
        Uint8               msgInfo;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Local control Capture information
        CSL_SRIO_GetLocalControlCapture(hSrio, &ftype, &ttype, &msgInfo);
        ...
        // Clear the local control capture
        CSL_SRIO_ClearLocalControlCapture(hSrio);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_ClearLocalControlCapture
(
    CSL_SrioHandle      hSrio
)
{
    hSrio->RIO_LOCAL_CTRL_CAPT = 0;
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetFabricControlStatus
 *
 *   @b Description
 *   @n The function is used to get the Fabric control status information.
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          igLLMBackPressure     Ingress LLM backpressure indication
          igUCBackPressure      Ingress User Core backpressure indication
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_FABRIC_CSR_IG_LLM_BACKPRESSURE,SRIO_RIO_FABRIC_CSR_IG_UC_BACKPRESSURE
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igLLMBackPressure;
        Uint8               igUCBackPressure;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Fabric Control Status
        CSL_SRIO_GetFabricControlStatus(hSrio, &igLLMBackPressure, &igUCBackPressure);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetFabricControlStatus
(
    CSL_SrioHandle      hSrio,
    Uint8*              igLLMBackPressure,
    Uint8*              igUCBackPressure
)
{
    Uint32 value = hSrio->RIO_FABRIC_CSR;

    *igLLMBackPressure  = (((value) & (0x08000000u)) >> (0x0000001Bu));
    *igUCBackPressure   = (((value) & (0x04000000u)) >> (0x0000001Au));
}

/** ============================================================================
 *   @n@b CSL_SRIO_GetFabricControlPortStatus
 *
 *   @b Description
 *   @n The function is used to get the Fabric control port status information.
 *
 *   @b Arguments
     @verbatim
          hSrio                 Handle of the SRIO device
          port                  SRIO port number
          igPktEnableStatus     PBMi Packet Enable Indication
          egPktEnableStatus     PBMe Packet Enable Indication
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_SRIO_Open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n SRIO_RIO_SP_FABRIC_STATUS_IG_PKT_ENABLE_STATUS,
 *   @n SRIO_RIO_SP_FABRIC_STATUS_EG_PKT_ENABLE_STATUS
 *
 *   @b Example
 *   @verbatim
        CSL_SrioHandle      hSrio;
        Uint8               igPktEnableStatus;
        Uint8               egPktEnableStatus;

        // Open the CSL SRIO Module 0
        hSrio = CSL_SRIO_Open (0);

        // Get the Fabric Control Port Status
        CSL_SRIO_GetFabricControlPortStatus(hSrio, 1, &igPktEnableStatus, &egPktEnableStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_SRIO_GetFabricControlPortStatus
(
    CSL_SrioHandle      hSrio,
    Uint8               port,
    Uint8*              igPktEnableStatus,
    Uint8*              egPktEnableStatus
)
{
    Uint32 value = hSrio->RIO_SP_FABRIC_STATUS[port];

    *igPktEnableStatus  = (((value) & (0x00F00000u)) >> (0x00000014u));
    *egPktEnableStatus  = (((value) & (0x000F0000u)) >> (0x00000010u));
}

/**
@}
*/





/* CSL BootCfg Module */

/* CSL Chip Functional Layer */
/* ============================================================================
 * Copyright (c) Texas Instruments Incorporated 2008, 2009
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** 
 * @file csl_chipAux.h
 *
 * @brief 
 *  API Auxilary header file for CHIP CSL to read/write from the C64x+ CPU
 *  Control Register File.
 * 
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 *  @n   Use of this software is controlled by the terms and conditions found 
 *  @n   in the license agreement under which this software has been supplied.
 *  ===========================================================================
 *  \par  
 */




/** @addtogroup CSL_CHIP_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_chipReadAMR
 *
 *   @b Description
 *   @n This API reads the Addressing Mode (AMR) control register and returns its
 *      contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n AMR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 amrVal;
        amrVal = CSL_chipReadAMR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadAMR()
{
    /** Addressing Mode Register */
    return AMR;            
}

/** ============================================================================
 *   @n@b CSL_chipReadCSR
 *
 *   @b Description
 *   @n This API reads the Control Status (CSR) register and returns its
 *      contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CSR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 csrVal;
        csrVal = CSL_chipReadCSR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadCSR()
{
    /** Control Status Register */                
    return CSR;    
}

/** ============================================================================
 *   @n@b CSL_chipReadIFR
 *
 *   @b Description
 *   @n This API reads the Interrrupt Flag register (IFR) and returns its
 *      contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>   Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n IFR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 ifrVal;
        ifrVal = CSL_chipReadIFR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadIFR()
{
    /** Interrupt Flag Register */
    return IFR;      
}

/** ============================================================================
 *   @n@b CSL_chipReadIER
 *
 *   @b Description
 *   @n This API reads the Interrrupt Enable register (IER) and returns its
 *      contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n IER
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 ierVal;
        ierVal = CSL_chipReadIER ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadIER()
{
    /** Interrupt Enable Register */
    return IER;              
}

/** ============================================================================
 *   @n@b CSL_chipReadISTP
 *
 *   @b Description
 *   @n This API reads the Interrrupt Service Table Pointer register (ISTP) and 
 *      returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value   </b> Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n ISTP
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 istpVal;
        istpVal = CSL_chipReadISTP ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadISTP()
{
    /** Interrupt Service Table Pointer Register */
    return ISTP;
}

/** ============================================================================
 *   @n@b CSL_chipReadIRP
 *
 *   @b Description
 *   @n This API reads the Interrrupt Return Pointer register (IRP) and 
 *      returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n IRP
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 irpVal;
        irpVal = CSL_chipReadIRP ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadIRP()
{
    /** Interrupt Return Pointer Register */                
    return IRP;           
}

/** ============================================================================
 *   @n@b CSL_chipReadNRP
 *
 *   @b Description
 *   @n This API reads the Nonmaskable Interrupt Return Pointer register (NRP) 
 *      and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n NRP
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 nrpVal;
        nrpVal = CSL_chipReadNRP ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadNRP()
{
    /** Nonmaskable Interrupt (NMI) Registers */                
    return NRP;               
}

/** ============================================================================
 *   @n@b CSL_chipReadERP
 *
 *   @b Description
 *   @n This API reads the Exception Return Pointer register (ERP) and returns 
 *      its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n NRP
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 erpVal;
        erpVal = CSL_chipReadERP ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadERP()
{
    /** Exception Return Pointer Registers */                
    return NRP;              
}

/** ============================================================================
 *   @n@b CSL_chipReadTSCL
 *
 *   @b Description
 *   @n This API reads the Time Stamp Counter Lower Order 32-bits (TSCL) register
 *      and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_chipWriteTSCL() must be called with any arbitrary value to
 *      enable the TSC first before this API is called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n TSCL
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 tsclVal;
        tsclVal = CSL_chipReadTSCL ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadTSCL()
{
    /** Time Stamp Counter Register - Low */
    return TSCL;
}

/** ============================================================================
 *   @n@b CSL_chipReadTSCH
 *
 *   @b Description
 *   @n This API reads the Time Stamp Counter Higher Order 32-bits (TSCH) register
 *      and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value   </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n @a CSL_chipWriteTSCL() must be called with any arbitrary value to
 *      enable the TSC first before this API is called.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n TSCH
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 tschVal;
        tschVal = CSL_chipReadTSCH ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadTSCH()
{
    /** Time Stamp Counter Registers - High */
    return TSCH;
}

/** ============================================================================
 *   @n@b CSL_chipReadARP
 *
 *   @b Description
 *   @n This API reads the Analysis Return Pointer (ARP) register
 *      and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n ARP
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 arpVal;
        arpVal = CSL_chipReadARP ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadARP()
{
    /** Analysis Return Pointer */
    return ARP;
}

/** ============================================================================
 *   @n@b CSL_chipReadILC
 *
 *   @b Description
 *   @n This API reads the Inner Loop SPL Buffer Count (ILC) register
 *      and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n ILC
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 ilcVal;
        ilcVal = CSL_chipReadILC ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadILC()
{
    /** SPLOOP Inner Loop Count Register */
    return ILC;               
}


/** ============================================================================
 *   @n@b CSL_chipReadRILC
 *
 *   @b Description
 *   @n This API reads the Reload Inner Loop SPL Buffer Count (RILC) register
 *      and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n RILC
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 rilcVal;
        rilcVal = CSL_chipReadRILC ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadRILC()
{
    /** SPLOOP Reload Inner Loop Count Register */                
    return RILC;             
}


/** ============================================================================
 *   @n@b CSL_chipReadREP
 *
 *   @b Description
 *   @n This API reads the Restricted Entry Point Address (REP) register
 *      and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n REP
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 repVal;
        repVal = CSL_chipReadREP ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadREP()
{
    /** Restricted Entry Point Address Register */
    return REP;             
}

/** ============================================================================
 *   @n@b CSL_chipReadPCE1
 *
 *   @b Description
 *   @n This API reads the Program Counter, E1 Phase (PCE1) register and returns 
 *      its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PCE1
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 pce1Val;
        pce1Val = CSL_chipReadPCE1 ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadPCE1()
{
    /** E1 Phase Program Counter */
    return PCE1;                
}


/** ============================================================================
 *   @n@b CSL_chipReadDNUM
 *
 *   @b Description
 *   @n This API reads the DSP Core Number (DSPNUM) register and returns 
 *      its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n DNUM
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 dnumVal;
        dnumVal = CSL_chipReadDNUM ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadDNUM()
{
    /** DSP Core Number Register */
    return DNUM;              
}

/** ============================================================================
 *   @n@b CSL_chipReadSSR
 *
 *   @b Description
 *   @n This API reads the Saturation Status Register (SSR) and returns 
 *      its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n SSR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 ssrVal;
        ssrVal = CSL_chipReadSSR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadSSR()
{
    /** Saturation Status Register */
    return SSR;               
}

/** ============================================================================
 *   @n@b CSL_chipReadGPLYA
 *
 *   @b Description
 *   @n This API reads the GMPY A-side polynomial Register (GPLYA) and returns 
 *      its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n GPLYA
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 gplyaVal;
        gplyaVal = CSL_chipReadGPLYA ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadGPLYA()
{
    /** GMPY Polynomial.A Side Register */
    return GPLYA;              
}

/** ============================================================================
 *   @n@b CSL_chipReadGPLYB
 *
 *   @b Description
 *   @n This API reads the GMPY B-side polynomial Register (GPLYB) and returns 
 *      its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n GPLYB
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 gplybVal;
        gplybVal = CSL_chipReadGPLYB ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadGPLYB()
{
    /** GMPY Polynomial.B Side Register */
    return GPLYB;                
}


/** ============================================================================
 *   @n@b CSL_chipReadGFPGFR
 *
 *   @b Description
 *   @n This API reads the Galios Field Multiply Control Register (GFPGFR) and 
 *      returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n GFPGFR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 gfpgfrVal;
        gfpgfrVal = CSL_chipReadGFPGFR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadGFPGFR()
{
    /** Galois Field Polynomial Generator Function Register */
    return GFPGFR;             
}


/** ============================================================================
 *   @n@b CSL_chipReadDIER
 *
 *   @b Description
 *   @n This API reads the Debug Interrupt Enable Register (DIER) and returns its 
 *      contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value   </b> Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n DIER
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 dierVal;
        dierVal = CSL_chipReadDIER ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadDIER()
{
    /** Debug Interrupt Enable Register */
    return DIER;               
}


/** ============================================================================
 *   @n@b CSL_chipReadTSR
 *
 *   @b Description
 *   @n This API reads the Task State Register (TSR) and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value   </b> Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n TSR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 tsrVal;
        tsrVal = CSL_chipReadTSR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadTSR()
{
    /** Task State Register */
    return TSR;               
}


/** ============================================================================
 *   @n@b CSL_chipReadITSR
 *
 *   @b Description
 *   @n This API reads the Interrupt Task State Register (ITSR) and returns its 
 *      contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b> Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n ITSR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 itsrVal;
        itsrVal = CSL_chipReadITSR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadITSR()
{
    /** Interrupt Task State Register */
    return ITSR;                
}

/** ============================================================================
 *   @n@b CSL_chipReadNTSR
 *
 *   @b Description
 *   @n This API reads the NMI/Exception Task State Register (NTSR) and returns its 
 *      contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n NTSR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 ntsrVal;
        ntsrVal = CSL_chipReadNTSR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadNTSR()
{
    /** NMI/Exception Task State Register */
    return NTSR;              
}


/** ============================================================================
 *   @n@b CSL_chipReadEFR
 *
 *   @b Description
 *   @n This API reads the Exception Flag Register (EFR) and returns its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b> Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n EFR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 efrVal;
        efrVal = CSL_chipReadEFR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadEFR()
{
    /** Exception Flag Register */
    return EFR;                
}


/** ============================================================================
 *   @n@b CSL_chipReadIERR
 *
 *   @b Description
 *   @n This API reads the Internal Exception Report Register (IERR) and returns 
 *      its contents.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value  </b>  Uint32
 *   @li            The control register value read
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n IERR
 *
 *  <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 ierrVal;
        ierrVal = CSL_chipReadIERR ();

    @endverbatim
 * ===========================================================================
 */        
static inline Uint32  CSL_chipReadIERR()
{
    /** Internal Exception Report Register */
    return IERR;
}


/** ============================================================================
 *   @n@b CSL_chipWriteAMR
 *
 *   @b Description
 *   @n This API configures the Addressing Mode Register (AMR) with the specified 
 *      new value 'val'. This API returns the old AMR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *
 *   <b> Return Value   </b>  Uint32
 *      @li         New programmed value
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The AMR control register is written with the value passed
 *
 *   @b Writes
 *   @n AMR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldamr;
        oldamr = CSL_chipWriteAMR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteAMR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Addressing Mode Register */
    oldVal  = AMR;
    AMR     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteCSR
 *
 *   @b Description
 *   @n This API configures the Control Status Register (CSR) with the specified 
 *      new value 'val'. This API returns the old CSR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b> Uint32
 *      @li         New programmed value
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The CSR control register is written with the value passed
 *
 *   @b Writes
 *   @n CSR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldcsr;
        oldcsr = CSL_chipWriteCSR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteCSR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Control Status Register */                
    oldVal  = CSR;
    CSR     = val;

    return oldVal;            
}

/** ============================================================================
 *   @n@b CSL_chipWriteISR
 *
 *   @b Description
 *   @n This API configures the Interrupt Set Register (ISR) with the specified 
 *      new value 'val'. This API returns the old ISR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b> Uint32
 *      @li         New programmed value
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The ISR control register is written with the value passed
 *
 *   @b Writes
 *   @n ISR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldISR;
        oldISR = CSL_chipWriteISR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteISR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Read Interrupt Flag Register and write to the Interrupt Set Register */
    oldVal  = IFR;
    ISR     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteICR
 *
 *   @b Description
 *   @n This API writes to the Interrupt Clear Register (ICR) with the specified 
 *      new value 'val' to clear the maskable interrupts configured in the IFR
 *      register. This API returns the old interrupt state from IFR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from IFR
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The ICR control register is written with the value passed
 *
 *   @b Writes
 *   @n ICR
 *
 *   @b Affects
 *   @n IFR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldIFR;
        oldIFR = CSL_chipWriteICR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteICR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /* Reads the old interrupt set status from the Interrupt Flag Register and 
     * clears the interrupts specified by writing to Interrupt Clear Register 
     */
    oldVal  = IFR;
    ICR     = val;

    return oldVal;
}

/** ============================================================================
 *   @n@b CSL_chipWriteIER
 *
 *   @b Description
 *   @n This API writes to the Interrupt Enable Register (IER) with the specified 
 *      new value 'val' to enable/disable individual interrupts in the system. 
 *      This API returns the old interrupt enable state from IER value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from IER
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The IER control register is written with the value passed
 *
 *   @b Writes
 *   @n IER
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldIER;
        oldIER = CSL_chipWriteIER (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteIER(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Interrupt Enable Register */
    oldVal  = IER;
    IER     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteISTP
 *
 *   @b Description
 *   @n This API writes to the Interrupt Service Table Pointer Register (ISTP) 
 *      with the specified value 'val' to setup a ISR base address for a given 
 *      interrupt in the ISTB. This API returns the old ISTP value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b> Uint32
 *      @li         New programmed value from ISTP
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The ISTP control register is written with the value passed
 *
 *   @b Writes
 *   @n ISTP
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldISTP;
        oldISTP = CSL_chipWriteISTP (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteISTP(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Interrupt Service Table Pointer Register */
    oldVal  = ISTP;
    ISTP    = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteIRP
 *
 *   @b Description
 *   @n This API writes to the Interrupt Return Pointer Register (IRP) 
 *      with the specified value 'val' to setup a return point in the program to
 *      continue execution after a maskable interrupt is executed. This API 
 *      returns the old IRP value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b> Uint32
 *      @li         New programmed value from IRP
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The IRP control register is written with the value passed
 *
 *   @b Writes
 *   @n IRP
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldIRP;
        oldIRP = CSL_chipWriteIRP (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteIRP(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Interrupt Return Pointer Register */                
    oldVal  = IRP;
    IRP     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteNRP
 *
 *   @b Description
 *   @n This API writes to the NMI Return Pointer Register (NRP) with the specified 
 *      value 'val' to setup a return point in the program to continue execution after 
 *      an NMI has occured. This API returns the old NRP value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from NRP
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The NRP control register is written with the value passed
 *
 *   @b Writes
 *   @n NRP
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldNRP;
        oldNRP = CSL_chipWriteNRP (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteNRP(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Nonmaskable Interrupt (NMI) Registers */                
    oldVal  = NRP;
    NRP     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteERP
 *
 *   @b Description
 *   @n This API writes to the Exception Return Pointer Register (ERP) with the specified 
 *      value 'val' to setup a return point in the program to continue execution after 
 *      an exception has occured. This API returns the old ERP value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b> Uint32
 *      @li         New programmed value from NRP register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The NRP control register is written with the value passed
 *
 *   @b Writes
 *   @n NRP
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldERP;
        oldERP = CSL_chipWriteERP (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteERP(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Exception Return Point (ERP) Registers */                
    oldVal  = NRP;
    NRP     = val;              

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteTSCL
 *
 *   @b Description
 *   @n This API writes to the Time-Stamp Counter (low order 32 bits) Register (TSCL) 
 *      with the specified value 'val' to enable the TSC. This API returns the 
 *      old TSCL value on return. The actual value written "val" to TSCL has no effect on
 *      the Time stamp counter. The value is simply ignored by the hardware, and a write to
 *      TSCL is used only to enable the Time Stamp Counter.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from TSCL register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The TSCL control register is written with the value passed
 *
 *   @b Writes
 *   @n TSCL
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldTSCL;
        oldTSCL = CSL_chipWriteTSCL (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteTSCL(CSL_Reg32  val)
{
    Uint32  oldVal;
    
    /** Time Stamp Counter Register - Low */
    oldVal  = TSCL;
    TSCL    = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteARP
 *
 *   @b Description
 *   @n This API writes to the Analysis Return Pointer (ARP) with the 
 *      specified value 'val'. This API returns the old ARP value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from ARP register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The ARP control register is written with the value passed
 *
 *   @b Writes
 *   @n ARP
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldARP;
        oldARP = CSL_chipWriteARP (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteARP(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Analysis Return Point Register */
    oldVal  = ARP;
    ARP     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteILC
 *
 *   @b Description
 *   @n This API writes to the SPLOOP Inner Loop Count Register (ILC) with the 
 *      specified value 'val'. This API returns the old ILC value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from ILC register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The ILC control register is written with the value passed
 *
 *   @b Writes
 *   @n ILC
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldILC;
        oldILC = CSL_chipWriteILC (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteILC(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** SPLOOP Inner Loop Count Register */
    oldVal  = ILC;
    ILC     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteRILC
 *
 *   @b Description
 *   @n This API writes to the SPLOOP Reload Inner Loop Count Register (RILC) with 
 *      the specified value 'val'. This API returns the old RILC value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from RILC register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The RILC control register is written with the value passed
 *
 *   @b Writes
 *   @n RILC
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldRILC;
        oldRILC = CSL_chipWriteRILC (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteRILC(CSL_Reg32  val)
{
    Uint32  oldVal;
    
    /** SPLOOP Reload Inner Loop Count Register */                
    oldVal  = RILC;
    RILC    = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteREP
 *
 *   @b Description
 *   @n This API writes to the Restricted Entry-Point Register (REP) with 
 *      the specified value 'val'. This API returns the old REP value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from REP register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The REP control register is written with the value passed
 *
 *   @b Writes
 *   @n REP
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldREP;
        oldREP = CSL_chipWriteREP (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteREP(CSL_Reg32  val)
{
    Uint32  oldVal;
    
    /** Restricted Entry Point Address Register */
    oldVal  = REP;
    REP     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteSSR
 *
 *   @b Description
 *   @n This API writes to the Saturation Status Register (SSR) with 
 *      the specified value 'val'. This API returns the old SSR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from SSR register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The SSR control register is written with the value passed
 *
 *   @b Writes
 *   @n SSR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldSSR;
        oldSSR = CSL_chipWriteSSR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteSSR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Saturation Status Register */
    oldVal  = SSR;
    SSR     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteGPLYA
 *
 *   @b Description
 *   @n This API writes to the GMPY Polynomial-A side Register (GPLYA) with 
 *      the specified value 'val'. This API returns the old GPLYA value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from GPLYA register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The GPLYA control register is written with the value passed
 *
 *   @b Writes
 *   @n GPLYA
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldGPLYA;
        oldGPLYA = CSL_chipWriteGPLYA (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteGPLYA(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** GMPY Polynomial.A Side Register */
    oldVal  = GPLYA;
    GPLYA   = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteGPLYB
 *
 *   @b Description
 *   @n This API writes to the GMPY Polynomial-B side Register (GPLYB) with 
 *      the specified value 'val'. This API returns the old GPLYB value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from GPLYB register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The GPLYB control register is written with the value passed
 *
 *   @b Writes
 *   @n GPLYB
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldGPLYB;
        oldGPLYB = CSL_chipWriteGPLYB (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteGPLYB(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** GMPY Polynomial.B Side Register */
    oldVal  = GPLYB;
    GPLYB   = val;

    return oldVal;
}

/** ============================================================================
 *   @n@b CSL_chipWriteGFPGFR
 *
 *   @b Description
 *   @n This API writes to the Galios Field Polynomial Generator Function Register 
 *      (GFPGFR) with the specified value 'val'. This API returns the old GFPGFR value 
 *      on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from GFPGFR register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The GFPGFR control register is written with the value passed
 *
 *   @b Writes
 *   @n GFPGFR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldGFPGFR;
        oldGFPGFR = CSL_chipWriteGFPGFR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteGFPGFR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Galois Field Polynomial Generator Function Register */
    oldVal  = GFPGFR;
    GFPGFR  = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteDIER
 *
 *   @b Description
 *   @n This API writes to the Debug Interrupt Enable Register (DIER) with the 
 *      specified value 'val'. This API returns the old DIER value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from DIER register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The DIER control register is written with the value passed
 *
 *   @b Writes
 *   @n DIER
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldDIER;
        oldDIER = CSL_chipWriteDIER (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteDIER(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Debug Interrupt Enable Register */
    oldVal  = DIER;
    DIER     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteTSR
 *
 *   @b Description
 *   @n This API writes to the Task State Register (TSR) with the specified value 
 *      'val'. This API returns the old TSR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from TSR register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The TSR control register is written with the value passed
 *
 *   @b Writes
 *   @n TSR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldTSR;
        oldTSR = CSL_chipWriteTSR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteTSR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Task State Register */
    oldVal  = TSR;
    TSR     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteITSR
 *
 *   @b Description
 *   @n This API writes to the Interrupt Task State Register (ITSR) with the 
 *      specified value 'val'. This API returns the old ITSR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from ITSR register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The ITSR control register is written with the value passed
 *
 *   @b Writes
 *   @n ITSR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldITSR;
        oldITSR = CSL_chipWriteITSR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteITSR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Interrupt Task State Register */
    oldVal  = ITSR;
    ITSR    = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteNTSR
 *
 *   @b Description
 *   @n This API writes to the NMI/Exception Task State Register (NTSR) with the 
 *      specified value 'val'. This API returns the old NTSR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from NTSR register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The NTSR control register is written with the value passed
 *
 *   @b Writes
 *   @n NTSR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldNTSR;
        oldNTSR = CSL_chipWriteNTSR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteNTSR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** NMI/Exception Task State Register */
    oldVal  = NTSR;
    NTSR    = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteECR
 *
 *   @b Description
 *   @n This API writes to the Exception Clear Register (ECR) with the specified 
 *      value 'val' to clear the corresponding bits in the EFR. This API returns 
 *      the old EFR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b> Uint32
 *      @li         New programmed value from EFR register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The ECR control register is written with the value passed and the 
 *       corresponding exception bits in the EFR register are cleared.
 *
 *   @b Writes
 *   @n EFR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldEFR;
        oldEFR = CSL_chipWriteECR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteECR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Return the old value from Exception Flag Register
     * and set the Clear Register 
     */
    oldVal  = EFR;
    ECR     = val;

    return oldVal;
}


/** ============================================================================
 *   @n@b CSL_chipWriteIERR
 *
 *   @b Description
 *   @n This API writes to the Internal Exception Report Register (IERR) with the 
 *      specified value 'val'. This API returns the old IERR value on return.
 *
 *   @b Arguments
 *   @verbatim      
        val         Value to be written.
     @endverbatim
 *
 *   <b> Return Value  </b>  Uint32
 *      @li         New programmed value from IERR register
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  The IERR control register is written with the value passed.
 *
 *   @b Writes
 *   @n IERR
 *
 * <b> Usage Constraints: </b>
 *  @n Please refer to the C64x+ user guide for constraints while accessing 
 *     registers in different privilege levels.
 *
 *   @b Example
 *   @verbatim
 
        Uint32 oldIERR;
        oldIERR = CSL_chipWriteIERR (56);

    @endverbatim
 * ===========================================================================
 */
static inline Uint32  CSL_chipWriteIERR(CSL_Reg32  val)
{
    Uint32  oldVal;

    /** Internal Exception Report Register */
    oldVal  = IERR;
    IERR    = val;

    return oldVal;
}



/* @} */


/* CSL PSC Module */
/**
 *   @file  csl_pscAux.h
 *
 *   @brief API Auxilary header file for PSC CSL
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2002-2010 Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/**
 *   @file  csl_psc.h
 *
 *   @brief
 *      This is the main Header File for the PSC Module which defines all
 *      the data structures and exported API.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, 2010 Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/** @defgroup CSL_PSC_API PSC
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 * 
 * The Power and Sleep Controller (PSC) is intended to be used on chips 
 * that require granular power control to all the on-chip modules such as 
 * peripherals, CPU, and controllers for power savings. 
 *
 * @subsection References
 *   -# PSC User Guide. 
 *
 * @subsection Assumptions
 *    The abbreviations PSC, psc and Psc have been used throughout this
 *    document to refer to Power and Sleep Controller.
 */


/********************************************************************
* Copyright (C) 2002-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 PID;
    volatile Uint8 RSVD0[16];
    volatile Uint32 VCNTLID;
    volatile Uint8 RSVD1[264];
    volatile Uint32 PTCMD;
    volatile Uint8 RSVD2[4];
    volatile Uint32 PTSTAT;
    volatile Uint8 RSVD3[212];
    volatile Uint32 PDSTAT[32];
    volatile Uint8 RSVD4[128];
    volatile Uint32 PDCTL[32];
    volatile Uint8 RSVD5[1152];
    volatile Uint32 MDSTAT[32];
    volatile Uint8 RSVD6[384];
    volatile Uint32 MDCTL[32];
} CSL_PscRegs;


/*************************************************************************** Overlay structure typedef definition
\**************************************************************************/
typedef volatile CSL_PscRegs             *CSL_PscRegsOvly;


/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* PID */










/* VCNTLID */



/* PTCMD */


/*----GO Tokens----*/


/* PTSTAT */


/*----GOSTAT Tokens----*/


/* PDSTAT */


/*----STATE Tokens----*/


/* PDCTL */


/*----NEXT Tokens----*/


/* MDSTAT */


/*----MCKOUT Tokens----*/

/*----MRSTDONE Tokens----*/

/*----MRST Tokens----*/

/*----LRSTDONE Tokens----*/

/*----LRST Tokens----*/

/*----STATE Tokens----*/


/* MDCTL */
/*----LRST Tokens----*/

/*----LRST Tokens----*/


/*----NEXT Tokens----*/



/**
@defgroup CSL_PSC_SYMBOL  PSC Symbols Defined
@ingroup CSL_PSC_API
*/
/**
@defgroup CSL_PSC_DATASTRUCT  PSC Data Structures
@ingroup CSL_PSC_API
*/
/**
@defgroup CSL_PSC_FUNCTION  PSC Functions
@ingroup CSL_PSC_API
*/
/**
@defgroup CSL_PSC_ENUM PSC Enumerated Data Types
@ingroup CSL_PSC_API
*/

/**
@addtogroup CSL_PSC_SYMBOL
@{
*/

/**
@}
*/

/** @addtogroup CSL_PSC_DATASTRUCT
 @{ */

/** Constants for passing parameters to the functions.
 */
/** @brief Pointer to the PSC overlay registers */

/** @brief      
 *
 *  Possible PSC Power domain states
 */        
typedef enum {
    /** Power domain is Off */        
    PSC_PDSTATE_OFF = 0,

    /** Power domain is On */        
    PSC_PDSTATE_ON = 1
} CSL_PSC_PDSTATE;

/** @brief      
 *
 *  Possible PSC Module states
 */        
typedef enum {
    /** Module is in Reset state. Clock is off. */        
    PSC_MODSTATE_SWRSTDISABLE = 0,

    /** Module is in Sync Reset state. */        
    PSC_MODSTATE_SYNCRST = 1,

    /** Module is in disable state. */        
    PSC_MODSTATE_DISABLE = 2,

    /** Module is in enable state. */        
    PSC_MODSTATE_ENABLE = 3,

    /** Module is in Auto sleep state */        
    PSC_MODSTATE_AUTOSLP = 4,

    /** Module is in Auto wake state */        
    PSC_MODSTATE_AUTOWK = 5
} CSL_PSC_MODSTATE;

/** @brief      
 *
 *  Possible module local reset status
 */        
typedef enum {
    /** Module local reset asserted */        
    PSC_MDLRST_ASSERTED = 0,

    /** Module local reset deasserted */        
    PSC_MDLRST_DEASSERTED = 1
} CSL_PSC_MDLRST;

/** @brief      
 *
 *  Possible module reset status
 */        
typedef enum {
    /** Module reset asserted */        
    PSC_MDRST_ASSERTED = 0,

    /** Module reset deasserted */        
    PSC_MDRST_DEASSERTED = 1
} CSL_PSC_MDRST;






/** @addtogroup CSL_PSC_FUNCTION
 @{ */


/** ============================================================================
 *   @n@b CSL_PSC_getVersionInfo
 *
 *   @b Description
 *   @n This function retrieves the PSC peripheral identification register
 *      contents.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  Uint32  - version value
 *	 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PSC_PID
 *
 *   @b Example
 *   @verbatim
        Uint32      versionInfo;

        versionInfo =   CSL_PSC_getVersionInfo ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_PSC_getVersionInfo (void)
{

    return ((CSL_PscRegs *) ((0x02350000)))->PID;
}


/** ============================================================================
 *   @n@b CSL_PSC_getVoltageControl
 *
 *   @b Description
 *   @n This function retrieves the Smart reflex bits from the voltage
 *      control identification register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>  Uint8
 *	 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PSC_VCNTLID_VCNTL
 *
 *   @b Example
 *   @verbatim
        Uint32      vcntlInfo;

        vcntlInfo =   CSL_PSC_getVoltageControl ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_PSC_getVoltageControl (void)
{

    return (((((CSL_PscRegs *) ((0x02350000)))->VCNTLID) & (0x003F0000u)) >> (0x00000010u));
}
        

/** ============================================================================
 *   @n@b CSL_PSC_setModuleNextState
 *
 *   @b Description
 *   @n This function sets up the "Next" state the module should be 
 *      transitioned for a given module.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       LPSC Module for which the next state must be configured.
        state           Next state to which the module must be transitioned.
     @endverbatim
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None 
 *
 *   <b> Post Condition </b>
 *   @n  Module is moved to configured next state after transition is triggered
 *       using @a CSL_PSC_startStateTransition () API.
 *
 *   @b  Writes
 *   @n  PSC_MDCTL_NEXT
 *
 *   @b  Example
 *   @verbatim
        ...
        // Enable Module 1's clock.
        CSL_PSC_setModuleNextState (1, PSC_MODSTATE_ENABLE);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_PSC_setModuleNextState (
    Uint32                  moduleNum,
    CSL_PSC_MODSTATE        state
)
{
    ((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum]) = ((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum]) & ~(0x0000001Fu)) | (((state) << (0x00000000u)) & (0x0000001Fu)));
    
    return;
}

/** ===========================================================================
 *   @n@b CSL_PSC_getModuleNextState
 *
 *   @b Description
 *   @n This function returns the next state configured for a given module.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the state must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_PSC_MODSTATE 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n PSC_MDCTL_NEXT
 *
 *   @b Example
 *   @verbatim
        ...
        // Check Module 2's next state configured
        if (CSL_PSC_getModuleNextState (2) == PSC_MODSTATE_ENABLE)
        {
            ...
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline CSL_PSC_MODSTATE CSL_PSC_getModuleNextState  (
    Uint32                  moduleNum
)
{
    return (CSL_PSC_MODSTATE) (((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum]) & (0x0000001Fu)) >> (0x00000000u));
}

/** ===========================================================================
 *   @n@b CSL_PSC_setModuleLocalReset
 *
 *   @b Description
 *   @n This function configures the Module local reset control. 
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the status must be retrieved.
        resetState      Assert/Deassert module local reset.
     @endverbatim
 *
 *   <b> Return Value </b>  None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Writes
 *   @n PSC_MDCTL_LRST
 *
 *   @b Example
 *   @verbatim
        ...
        // Assert Module 2's local reset 
        CSL_PSC_setModuleLocalReset (2, PSC_MDLRST_ASSERTED);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_PSC_setModuleLocalReset  (
    Uint32                  moduleNum,
    CSL_PSC_MDLRST          resetState
)
{
    ((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum]) = ((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum]) & ~(0x00000100u)) | (((resetState) << (0x00000008u)) & (0x00000100u)));

    return;
}

/** ===========================================================================
 *   @n@b CSL_PSC_getModuleLocalReset
 *
 *   @b Description
 *   @n This function reads the Module local reset control configured.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the status must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_PSC_MDLRST 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n PSC_MDCTL_LRST
 *
 *   @b Example
 *   @verbatim
 *      Uint32  resetState;
 
        ...
        // Check Module 2's local reset bit
        resetState = CSL_PSC_getModuleLocalReset (2);
        ...
     @endverbatim
 * ============================================================================
 */
static inline CSL_PSC_MDLRST CSL_PSC_getModuleLocalReset  (
    Uint32                  moduleNum
)
{
    return (CSL_PSC_MDLRST) (((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum]) & (0x00000100u)) >> (0x00000008u));
}


/** ===========================================================================
 *   @n@b CSL_PSC_enableModuleResetIsolation
 *
 *   @b Description
 *   @n This function enables the Module reset isolation control.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the configuration must be done.
     @endverbatim
 *
 *   <b> Return Value </b>  None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Writes
 *   @n PSC_MDCTL_RSTISO=1
 *
 *   @b Example
 *   @verbatim
        ...
        // Enable Module 2's reset isolation
        CSL_PSC_enableModuleResetIsolation (2);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_PSC_enableModuleResetIsolation  (
    Uint32                  moduleNum
)
{
    (((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum])) = (((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum])) & ~(0x00001000u)) | ((((0x00000001u)) << (0x0000000Cu)) & (0x00001000u)));

    return;
}


/** ===========================================================================
 *   @n@b CSL_PSC_disableModuleResetIsolation
 *
 *   @b Description
 *   @n This function disables the Module reset isolation control.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the configuration must be done.
     @endverbatim
 *
 *   <b> Return Value </b>  None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Writes
 *   @n PSC_MDCTL_RSTISO=0
 *
 *   @b Example
 *   @verbatim
        ...
        // Disable Module 2's reset isolation
        CSL_PSC_disableModuleResetIsolation (2);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_PSC_disableModuleResetIsolation  (
    Uint32                  moduleNum
)
{
    (((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum])) = (((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum])) & ~(0x00001000u)) | ((((0x00000000u)) << (0x0000000Cu)) & (0x00001000u)));

    return;
}


/** ===========================================================================
 *   @n@b CSL_PSC_isModuleResetIsolationEnabled
 *
 *   @b Description
 *   @n This function reads the Module reset isolation control bit.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the status must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  Bool 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n PSC_MDCTL_RSTISO
 *
 *   @b Example
 *   @verbatim
        ...
        // Check Module 2's reset isolation configuration
        if (CSL_PSC_isModuleResetIsolationEnabled (2) == TRUE)
        {
            // Module 2 reset isolation enabled
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline Bool CSL_PSC_isModuleResetIsolationEnabled  (
    Uint32                  moduleNum
)
{
    return (((((CSL_PscRegs *) ((0x02350000)))->MDCTL[moduleNum]) & (0x00001000u)) >> (0x0000000Cu));
}


/** ===========================================================================
 *   @n@b CSL_PSC_getModuleState
 *
 *   @b Description
 *   @n This function returns the current state of a given module.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the state must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_PSC_MODSTATE 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n Power Domain status is returned
 *
 *   @b Reads
 *   @n PSC_MDSTAT_STATE
 *
 *   @b Example
 *   @verbatim
        ...
        // Check if Module 2's clock is enabled.
        if (CSL_PSC_getModuleState (2) == PSC_MODSTATE_ENABLE)
        {
            // Module 2's clock is enabled.
            ...
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline CSL_PSC_MODSTATE CSL_PSC_getModuleState  (
    Uint32                  moduleNum
)
{
    return (CSL_PSC_MODSTATE) (((((CSL_PscRegs *) ((0x02350000)))->MDSTAT[moduleNum]) & (0x0000003Fu)) >> (0x00000000u));
}


/** ===========================================================================
 *   @n@b CSL_PSC_getModuleLocalResetStatus
 *
 *   @b Description
 *   @n This function returns the Module local reset actual status. 
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the status must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_PSC_MDLRST 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n PSC_MDSTAT_LRST
 *
 *   @b Example
 *   @verbatim
        ...
        // Check Module 2's local reset status
        if (CSL_PSC_getModuleLocalResetStatus (2) == PSC_MDLRST_ASSERTED)
        {
            // Module 2's local reset asserted.
            ...
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline CSL_PSC_MDLRST CSL_PSC_getModuleLocalResetStatus  (
    Uint32                  moduleNum
)
{
    return (CSL_PSC_MDLRST) (((((CSL_PscRegs *) ((0x02350000)))->MDSTAT[moduleNum]) & (0x00000100u)) >> (0x00000008u));
}


/** ===========================================================================
 *   @n@b CSL_PSC_isModuleLocalResetDone
 *
 *   @b Description
 *   @n This function returns the Module local reset initialization done status.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the status must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  Bool 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n PSC_MDSTAT_LRSTDONE
 *
 *   @b Example
 *   @verbatim
        ...
        // Check Module 2's local reset initialization done status
        if (CSL_PSC_isModuleLocalResetDone (2))
        {
            // Module 2's local reset init done.
            ...
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline Bool CSL_PSC_isModuleLocalResetDone  (
    Uint32                  moduleNum
)
{
    return (Bool) (((((CSL_PscRegs *) ((0x02350000)))->MDSTAT[moduleNum]) & (0x00000200u)) >> (0x00000009u));
}


/** ===========================================================================
 *   @n@b CSL_PSC_getModuleResetStatus
 *
 *   @b Description
 *   @n This function returns the Module reset actual status. 
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the status must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_PSC_MDRST 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n PSC_MDSTAT_MRST
 *
 *   @b Example
 *   @verbatim
        ...
        // Check Module 2's reset status
        if (CSL_PSC_getModuleResetStatus (2) == PSC_MDRST_ASSERTED)
        {
            // Module 2's reset asserted.
            ...
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline CSL_PSC_MDRST CSL_PSC_getModuleResetStatus  (
    Uint32                  moduleNum
)
{
    return (CSL_PSC_MDRST) (((((CSL_PscRegs *) ((0x02350000)))->MDSTAT[moduleNum]) & (0x00000400u)) >> (0x0000000Au));
}


/** ===========================================================================
 *   @n@b CSL_PSC_isModuleResetDone
 *
 *   @b Description
 *   @n This function returns the Module reset initialization done status.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the status must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  Bool 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n PSC_MDSTAT_MRSTDONE
 *
 *   @b Example
 *   @verbatim
        ...
        // Check Module 2's reset initialization done status
        if (CSL_PSC_isModuleResetDone (2))
        {
            // Module 2's reset init done.
            ...
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline Bool CSL_PSC_isModuleResetDone  (
    Uint32                  moduleNum
)
{
    return (Bool) (((((CSL_PscRegs *) ((0x02350000)))->MDSTAT[moduleNum]) & (0x00000800u)) >> (0x0000000Bu));
}


/** ===========================================================================
 *   @n@b CSL_PSC_isModuleClockOn
 *
 *   @b Description
 *   @n This function returns the actual modclk output to module.
 *
 *   @b Arguments
 *   @verbatim
        moduleNum       Module number for which the clock status must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  Bool 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n None
 *
 *   @b Reads
 *   @n PSC_MDSTAT_MCKOUT
 *
 *   @b Example
 *   @verbatim
        ...
        // Check Module 2's modclk status
        if (CSL_PSC_isModuleClockOn (2))
        {
            // Module 2's modclk on.
            ...
        }
        else
        {
            // Module 2's modclk gated.
            ...
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline Bool CSL_PSC_isModuleClockOn  (
    Uint32                  moduleNum
)
{
    return (Bool) (((((CSL_PscRegs *) ((0x02350000)))->MDSTAT[moduleNum]) & (0x00001000u)) >> (0x0000000Cu));
}


/** ============================================================================
 *   @n@b CSL_PSC_enablePowerDomain
 *
 *   @b Description
 *   @n This function enables the specified power domain.
 *
 *   @b Arguments
 *   @verbatim
        pwrDmnNum       Power domain number that needs to be enabled.
     @endverbatim
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None 
 *
 *   <b> Post Condition </b>
 *   @n  Power domain is enabled.
 *
 *   @b  Writes
 *   @n  PSC_PDCTL_NEXT=1
 *
 *   @b  Example
 *   @verbatim
        ...
        // On the power domain 2
        CSL_PSC_enablePowerDomain (2);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_PSC_enablePowerDomain (
    Uint32                  pwrDmnNum
)
{
    (((((CSL_PscRegs *) ((0x02350000)))->PDCTL[pwrDmnNum])) = (((((CSL_PscRegs *) ((0x02350000)))->PDCTL[pwrDmnNum])) & ~(0x00000001u)) | ((((0x00000001u)) << (0x00000000u)) & (0x00000001u)));
    
    return;
}


/** ============================================================================
 *   @n@b CSL_PSC_disablePowerDomain
 *
 *   @b Description
 *   @n This function turns off the specified power domain.
 *
 *   @b Arguments
 *   @verbatim
        pwrDmnNum       Power domain number that needs to be disabled.
     @endverbatim
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None 
 *
 *   <b> Post Condition </b>
 *   @n  Power domain is disabled.
 *
 *   @b  Writes
 *   @n  PSC_PDCTL_NEXT=0
 *
 *   @b  Example
 *   @verbatim
        ...
        // Off the power domain 2
        CSL_PSC_disablePowerDomain (2);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_PSC_disablePowerDomain (
    Uint32                  pwrDmnNum
)
{
    (((((CSL_PscRegs *) ((0x02350000)))->PDCTL[pwrDmnNum])) = (((((CSL_PscRegs *) ((0x02350000)))->PDCTL[pwrDmnNum])) & ~(0x00000001u)) | ((((0x00000000u)) << (0x00000000u)) & (0x00000001u)));
    
    return;
}



/** ===========================================================================
 *   @n@b CSL_PSC_getPowerDomainState
 *
 *   @b Description
 *   @n This function returns the current state of a given power domain.
 *
 *   @b Arguments
 *   @verbatim
        pwrDmnNum       Power domain number for which the state must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  CSL_PSC_PDSTATE 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n Power Domain status is returned
 *
 *   @b Reads
 *   @n PSC_PDSTAT_STATE
 *
 *   @b Example
 *   @verbatim
        ...
        // Check if Power domain is On.
        if (CSL_PSC_getPowerDomainState(2) == PSC_PDSTATE_ON)
        {
            // Power domain 2 is on
            ...
        }
        else
        {
            // Power domain 2 is off
        }
        ...
     @endverbatim
 * ============================================================================
 */
static inline CSL_PSC_PDSTATE CSL_PSC_getPowerDomainState  (
    Uint32                  pwrDmnNum
)
{
    return (CSL_PSC_PDSTATE) (((((CSL_PscRegs *) ((0x02350000)))->PDSTAT[pwrDmnNum]) & (0x00000003u)) >> (0x00000000u));
}



/** ============================================================================
 *   @n@b CSL_PSC_startStateTransition
 *
 *   @b Description
 *   @n This function sets the 'GO' bit in the PSC Command register. All state
 *      transitions marked for a specified power domain and all its modules are
 *      initiated by the hardware.
 *
 *      This function starts a given Power domain and all its modules state 
 *      transition.
 *
 *   @b Arguments       
 *   @verbatim
        pwrDmnNum       Power domain number for which the state transition 
                        must be initiated.
     @endverbatim
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None 
 *
 *   <b> Post Condition </b>
 *   @n  Power domain and modules are moved to a new "Next" state as marked
 *       earlier using APIs: @a CSL_PSC_setModuleNextState  (),
 *       @a CSL_PSC_enablePowerDomain (), @a CSL_PSC_disablePowerDomain ().
 *
 *   @b  Writes
 *   @n  PSC_PTCMD
 *
 *   @b  Example
 *   @verbatim
        ...
        // To Enable Power domain 2 and modules 3, 4
        CSL_PSC_enablePowerDomain (2);
        CSL_PSC_setModuleNextState  (3, PSC_MODSTATE_ENABLE);
        CSL_PSC_setModuleNextState (4, PSC_MODSTATE_ENABLE);
        CSL_PSC_startStateTransition (2);
        ...
     @endverbatim
 * ============================================================================
 */
static inline void CSL_PSC_startStateTransition (
    Uint32                  pwrDmnNum
)
{
    ((CSL_PscRegs *) ((0x02350000)))->PTCMD =   (1 << pwrDmnNum);
    
    return;
}

/** ===========================================================================
 *   @n@b CSL_PSC_isStateTransitionDone
 *
 *   @b Description
 *   @n This function gets the transition status of the power domain. This function
 *      returns 0 to indicate that the state transition initiated earlier using
 *      @a CSL_PSC_startStateTransition () API for the specified power domain has not
 *      yet been completed, and is in progress still. This function returns 1
 *      to indicate when this transition is completed in the hardware.
 *
 *   @b Arguments
 *   @verbatim
        pwrDmnNum       Power domain number for which the state transition status 
                        must be retrieved.
     @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *    @n Power domain transition status value is read
 *
 *   @b Reads
 *   @n PSC_PTSTAT
 *
 *   @b Example
 *   @verbatim
        ...
        // Ensure no transition in progress for Power domain 2 
        // before we start a new one.
        while (!CSL_PSC_isStateTransitionDone (2));

        // To Enable Power domain 2 and modules 3, 4
        CSL_PSC_enablePowerDomain (2);
        CSL_PSC_setModuleNextState (3, PSC_MODSTATE_ENABLE);
        CSL_PSC_setModuleNextState (4, PSC_MODSTATE_ENABLE);
        CSL_PSC_startStateTransition (2);

        // Wait until the transition process is completed.
        while (!CSL_PSC_isStateTransitionDone (2));
        ...
     @endverbatim
 * ============================================================================
 */
static inline Uint32 CSL_PSC_isStateTransitionDone (
    Uint32                  pwrDmnNum
)
{
    Uint32  pdTransStatus;

    pdTransStatus =   (((((CSL_PscRegs *) ((0x02350000)))->PTSTAT) >> (pwrDmnNum)) & ((1 << ((pwrDmnNum) - (pwrDmnNum) + 1)) - 1));

    if (pdTransStatus)
    {
        /* Power domain transition is in progress. Return 0 to indicate not yet done. */            
        return 0;
    }
    else
    {
        /* Power domain transition is done. */            
        return 1;
    }
}

/**
@}
*/




/* QMSS Include */

/*****************************************************************************/
/* string.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*  C6X.H v7.3.4                                                             */
/*                                                                           */
/* Copyright (c) 1996-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/*                                                                           */
/* NOTICE TO THOSE WHO USE INTRINSICS AND PACKED DATA                        */
/*                                                                           */
/* This note contains information on a new __float2_t type.                  */
/* It also contains recommendations on the use of the "double" type.         */
/*                                                                           */
/* In order to better support packed data compiler optimizations in the      */
/* future, the use of the type "double" for packed data is now discouraged   */
/* and its support may be discontinued in the future.                        */
/*                                                                           */
/* There are several recommendations and changes as a result.  Note that     */
/* these changes do NOT break compatibility with older code (source files    */
/* or object files).                                                         */
/*                                                                           */
/* (1) long long should be used for 64-bit packed integer data.  The double  */
/*     type should be used only for double-precision floating point values.  */
/*                                                                           */
/* (2) There is a new type, __float2_t, that holds two floats and should     */
/*     be used instead of double for holding two floats.  For now, this new  */
/*     type is typedef'ed to double in c6x.h, but could be changed in the    */
/*     future to a structure or vector type to allow better optimization of  */
/*     packed data floats.  We recommend the use of __float2_t for any       */
/*     float x2 data instead of double.                                      */
/*                                                                           */
/* (3) There are new __float2_t manipulation intrinsics (see below) that     */
/*     should be used to create and manipulate objects of type __float2_t.   */
/*                                                                           */
/* (4) C66 intrinsics that deal with packed float data are now declared      */
/*     using __float2_t instead of double.  (Those intrinsics are declared   */
/*     in this file, c6x.h.)                                                 */
/*                                                                           */
/* (5) When using any intrinsic that involves __float2_t, c6x.h must be      */
/*     included.                                                             */
/*                                                                           */
/* (6) Certain intrinsics that used double to store fixed-point packed       */
/*     data have been deprecated.  They will still be supported in the       */
/*     near future, but their descriptions will be removed from the          */
/*     compiler user's guide (spru187).  Deprecated: _mpy2, _mpyhi, _mpyli,  */
/*     _mpysu4, _mpyu4, and _smpy2.  Use the long long versions instead.     */
/*                                                                           */
/* Please see                                                                */
/* http://processors.wiki.ti.com/index.php/C6000_Intrinsics_and_Type_Double  */
/* and the C6000 Compiler User's Guide (v7.2), spru187, for more             */
/* information.                                                              */
/*                                                                           */
/*****************************************************************************/
/* If not using host intrinsics, define __float2_t items. */

unsigned  _extu	   (unsigned, unsigned, unsigned);
int       _ext	   (int,      unsigned, unsigned);
unsigned  _set	   (unsigned, unsigned, unsigned);
unsigned  _clr	   (unsigned, unsigned, unsigned);
unsigned  _extur   (unsigned, int);
int       _extr	   (int,      int);
unsigned  _setr	   (unsigned, int);
unsigned  _clrr	   (unsigned, int);
int       _sadd	   (int,      int);
int	  _ssub	   (int,      int);
int       _sshl	   (int,      unsigned);
int	  _add2	   (int,      int);
int	  _sub2	   (int,      int);
unsigned  _subc	   (unsigned, unsigned);
unsigned  _lmbd	   (unsigned, unsigned);
int       _abs	   (int);
__int40_t _labs	   (__int40_t);
unsigned  _norm	   (int);
int	  _smpy	   (int,      int);
int	  _smpyhl  (int,      int);
int	  _smpylh  (int,      int);
int	  _smpyh   (int,      int);
int	  _mpy	   (int,      int);
int	  _mpyus   (unsigned, int);
int	  _mpysu   (int,      unsigned);
unsigned  _mpyu	   (unsigned, unsigned);
int	  _mpyhl   (int,      int);
int	  _mpyhuls (unsigned, int);
int	  _mpyhslu (int,      unsigned);
unsigned  _mpyhlu  (unsigned, unsigned);
int	  _mpylh   (int,      int);
int	  _mpyluhs (unsigned, int);
int	  _mpylshu (int,      unsigned);
unsigned  _mpylhu  (unsigned, unsigned);
int	  _mpyh	   (int,      int);
int	  _mpyhus  (unsigned, int);
int	  _mpyhsu  (int,      unsigned);
unsigned  _mpyhu   (unsigned, unsigned);

__int40_t _lsadd   (int, __int40_t);
__int40_t _lssub   (int, __int40_t);
int       _sat	   (__int40_t);
unsigned  _lnorm   (__int40_t);

double    _fabs    (double);
float     _fabsf   (float);
long long _mpyidll (int,      int);
int    	  _spint   (float);
int    	  _dpint   (double);
float  	  _rcpsp   (float);
double 	  _rcpdp   (double);
float  	  _rsqrsp  (float);
double 	  _rsqrdp  (double);

/*double    _mpyid   (int,      int);  Deprecated.  Use _mpyidll instead. */

unsigned  _hi(double);      /* Return the hi 32 bits of a double as an int    */
float     _hif(double);     /* Return the hi 32 bits of a double as a float   */
unsigned  _hill(long long); /* Return the hi 32 bits of a long long as an int */
unsigned  _lo(double);      /* Return the lo 32 bits of a double as an int    */
float     _lof(double);     /* Return the lo 32 bits of a double as a float   */
unsigned  _loll(long long); /* Return the lo 32 bits of a long long as an int */
  
double 	  _itod(unsigned, unsigned);  /* Create a double from 2 ints    */
double 	  _ftod(float,    float);     /* Create a double from 2 floats  */
long long _itoll(unsigned, unsigned); /* Create a long long from 2 ints */
float  	  _itof(unsigned);            /* Reinterpret int as float.      */
unsigned  _ftoi(float);               /* Reinterpret float as int.      */

__int40_t _dtol(double);              /* Reinterpret double as 40-bit type    */
double    _ltod(__int40_t);           /* Reinterpret 40-bit type as double    */
long long _dtoll(double);             /* Reinterpret double as long long      */
double    _lltod(long long);          /* Reinterpret long long as double      */

int       _add4      (int,      int);
int       _avg2      (int,      int);
unsigned  _avgu4     (unsigned, unsigned);
int       _cmpeq2    (int,      int);
int       _cmpeq4    (int,      int);
int       _cmpgt2    (int,      int);
unsigned  _cmpgtu4   (unsigned, unsigned);
int       _dotp2     (int,      int);
int       _dotpn2    (int,      int);
int       _dotpnrsu2 (int,      unsigned);
int       _dotprsu2  (int,      unsigned);
int       _dotpsu4   (int,      unsigned);
unsigned  _dotpu4    (unsigned, unsigned);
int       _gmpy4     (int,      int);
__int40_t _ldotp2    (int,      int);
int       _max2      (int,      int);
unsigned  _maxu4     (unsigned, unsigned);
int       _min2      (int,      int);
unsigned  _minu4     (unsigned, unsigned);
long long _mpy2ll    (int,      int);
long long _mpyhill   (int,      int);
int       _mpyhir    (int,      int);
long long _mpylill   (int,      int);
int       _mpylir    (int,      int);
long long _mpysu4ll  (int,      unsigned);
long long _mpyu4ll   (unsigned, unsigned);
unsigned  _pack2     (unsigned, unsigned);
unsigned  _packh2    (unsigned, unsigned);
unsigned  _packh4    (unsigned, unsigned);
unsigned  _packhl2   (unsigned, unsigned);
unsigned  _packl4    (unsigned, unsigned);
unsigned  _packlh2   (unsigned, unsigned);
unsigned  _rotl      (unsigned, unsigned);
int       _sadd2     (int,      int);
unsigned  _saddu4    (unsigned, unsigned);
int       _saddus2   (unsigned, int);
unsigned  _shlmb     (unsigned, unsigned);
int       _shr2      (int,      unsigned);
unsigned  _shrmb     (unsigned, unsigned);
unsigned  _shru2     (unsigned, unsigned);
long long _smpy2ll   (int,      int);
int       _spack2    (int,      int);
unsigned  _spacku4   (int,      int);
int       _sshvl     (int,      int);
int       _sshvr     (int,      int);
int       _sub4      (int,      int);
int       _subabs4   (int,      int);
     
int       _abs2      (int);
unsigned  _bitc4     (unsigned);
unsigned  _bitr      (unsigned);
unsigned  _deal      (unsigned);
int       _mvd       (int);
unsigned  _shfl      (unsigned);
unsigned  _swap4     (unsigned);
unsigned  _unpkhu4   (unsigned);
unsigned  _unpklu4   (unsigned);
unsigned  _xpnd2     (unsigned);
unsigned  _xpnd4     (unsigned);

/*double  _mpy2      (int,      int);  Deprecated: use _mpy2ll instead */
/*double  _mpyhi     (int,      int);  Deprecated: use _mpyhill instead */
/*double  _mpysu4    (int,      unsigned);  Deprecated: use _mpysu4ll instead */
/*double  _mpyu4     (unsigned, unsigned);  Deprecated: use _mpyu4ll instead */
/*double  _smpy2     (int,      int);  Deprecated: use _smpy2ll instead */


long long _addsub    (int,       int);
long long _addsub2   (unsigned,  unsigned);
long long _cmpy      (unsigned,  unsigned);
unsigned  _cmpyr     (unsigned,  unsigned);
unsigned  _cmpyr1    (unsigned,  unsigned);
long long _ddotph2   (long long, unsigned);
unsigned  _ddotph2r  (long long, unsigned);
long long _ddotpl2   (long long, unsigned);
unsigned  _ddotpl2r  (long long, unsigned);
long long _ddotp4    (unsigned,  unsigned);
long long _dpack2    (unsigned,  unsigned);
long long _dpackx2   (unsigned,  unsigned);
long long _dmv       (unsigned,  unsigned);
double    _fdmv      (float,     float);
unsigned  _gmpy      (unsigned,  unsigned);
long long _mpy32ll   (int,       int);
int       _mpy32     (int,       int);
long long _mpy32su   (int,       unsigned);
long long _mpy32us   (unsigned,  int);
long long _mpy32u    (unsigned,  unsigned);
long long _mpy2ir    (unsigned,  int);
unsigned  _rpack2    (unsigned,  unsigned);
long long _saddsub   (int,       int);
long long _saddsub2  (unsigned,  unsigned);
long long _shfl3     (unsigned,  unsigned);
int       _smpy32    (int,       int);
int       _ssub2     (int,       int);
unsigned  _xormpy    (unsigned,  unsigned);

long long  _dcmpyr1    (long long, long long);
long long  _dccmpyr1   (long long, long long);
long long  _cmpy32r1   (long long, long long);
long long  _ccmpy32r1  (long long, long long);
long long  _mpyu2      (unsigned,  unsigned);
int        _dotp4h     (long long, long long);
long long  _dotp4hll   (long long, long long);
int        _dotpsu4h   (long long, long long);
long long  _dotpsu4hll (long long, long long);
long long  _dadd       (long long, long long);
long long  _dadd_c     (int,       long long);
long long  _dsadd      (long long, long long);
long long  _dadd2      (long long, long long);
long long  _dsadd2     (long long, long long);
long long  _dsub       (long long, long long);
long long  _dssub      (long long, long long);
long long  _dssub2     (long long, long long);
long long  _dapys2     (long long, long long);
long long  _dshr       (long long, unsigned);
long long  _dshru      (long long, unsigned);
long long  _dshl       (long long, unsigned);
long long  _dshr2      (long long, unsigned);
long long  _dshru2     (long long, unsigned);
unsigned   _shl2       (unsigned , unsigned);
long long  _dshl2      (long long, unsigned);
long long  _dxpnd4     (unsigned);
long long  _dxpnd2     (unsigned);
int        _crot90     (int);
long long  _dcrot90    (long long);
int        _crot270    (int);
long long  _dcrot270   (long long);
long long  _dmax2      (long long, long long);
long long  _dmin2      (long long, long long);
long long  _dmaxu4     (long long, long long);
long long  _dminu4     (long long, long long);
unsigned   _dcmpgt2    (long long, long long);
unsigned   _dcmpeq2    (long long, long long);
unsigned   _dcmpgtu4   (long long, long long);
unsigned   _dcmpeq4    (long long, long long);
long long  _davg2      (long long, long long);
long long  _davgu4     (long long, long long);
long long  _davgnr2    (long long, long long);
long long  _davgnru4   (long long, long long);
long long  _unpkbu4    (unsigned);
long long  _unpkh2     (unsigned);
long long  _unpkhu2    (unsigned);
long long  _dpackl2    (long long, long long);
long long  _dpackh2    (long long, long long);
long long  _dpackhl2   (long long, long long);
long long  _dpacklh4   (unsigned,  unsigned);
long long  _dpackl4    (long long, long long);
long long  _dpackh4    (long long, long long);
long long  _dspacku4   (long long, long long);
void       _mfence     ();
__float2_t _dmpysp     (__float2_t, __float2_t);
__float2_t _daddsp     (__float2_t, __float2_t);
__float2_t _dsubsp     (__float2_t, __float2_t);
__float2_t _dinthsp    (unsigned);
__float2_t _dinthspu   (unsigned);
__float2_t _dintsp     (long long);
__float2_t _dintspu    (long long);
unsigned   _dspinth    (__float2_t);
long long  _dspint     (__float2_t);

int        _land       (int, int);
int        _landn      (int, int);
int        _lor        (int, int);

long long  _dmvd       (int,       int);
double     _fdmvd      (float,     float);

double     _complex_mpysp           (double, double); /* CMPYSP then DADDSP */
double     _complex_conjugate_mpysp (double, double); /* CMPYSP then DSUBSP */

long long  _xorll_c    (int, long long);

__x128_t   __attribute__((builtin)) _dcmpy      (long long, long long);
__x128_t   __attribute__((builtin)) _dccmpy     (long long, long long);
long long  __attribute__((builtin)) _cmatmpyr1  (long long, __x128_t);
long long  __attribute__((builtin)) _ccmatmpyr1 (long long, __x128_t);
__x128_t   __attribute__((builtin)) _cmatmpy    (long long, __x128_t);
__x128_t   __attribute__((builtin)) _ccmatmpy   (long long, __x128_t);
__x128_t   __attribute__((builtin)) _qsmpy32r1  (__x128_t,  __x128_t);
__x128_t   __attribute__((builtin)) _qmpy32     (__x128_t,  __x128_t);
__x128_t   __attribute__((builtin)) _dsmpy2     (long long, long long);
__x128_t   __attribute__((builtin)) _dmpy2      (long long, long long);
__x128_t   __attribute__((builtin)) _dmpyu2     (long long, long long);
__x128_t   __attribute__((builtin)) _dmpysu4    (long long, long long);
__x128_t   __attribute__((builtin)) _dmpyu4     (long long, long long);
__x128_t   __attribute__((builtin)) _cmpysp     (__float2_t, __float2_t);
__x128_t   __attribute__((builtin)) _qmpysp     (__x128_t,  __x128_t);
long long  __attribute__((builtin)) _ddotp4h    (__x128_t,  __x128_t);
long long  __attribute__((builtin)) _ddotpsu4h  (__x128_t,  __x128_t);

__x128_t   __attribute__((builtin)) _ito128  (unsigned,  unsigned, unsigned, unsigned);
__x128_t   __attribute__((builtin)) _fto128  (float,     float,    float,    float);
__x128_t   __attribute__((builtin)) _llto128 (long long, long long);
__x128_t   __attribute__((builtin)) _dto128  (double,    double);

long long  __attribute__((builtin)) _hi128   (__x128_t);
double     __attribute__((builtin)) _hid128  (__x128_t);
long long  __attribute__((builtin)) _lo128   (__x128_t);
double     __attribute__((builtin)) _lod128  (__x128_t);

unsigned  __attribute__((builtin)) _get32_128  (__x128_t, __attribute__((constrange((0), (3)))) unsigned);
float     __attribute__((builtin)) _get32f_128 (__x128_t, __attribute__((constrange((0), (3)))) unsigned);

__x128_t  __attribute__((builtin)) _dup32_128 (unsigned);


extern __cregister volatile unsigned int AMR;
extern __cregister volatile unsigned int CSR;
extern __cregister volatile unsigned int IFR;
extern __cregister volatile unsigned int ISR;
extern __cregister volatile unsigned int ICR;
extern __cregister volatile unsigned int IER;
extern __cregister volatile unsigned int ISTP;
extern __cregister volatile unsigned int IRP;
extern __cregister volatile unsigned int NRP;

extern __cregister volatile unsigned int GFPGFR;
extern __cregister volatile unsigned int DIER;

extern __cregister volatile unsigned int FADCR;
extern __cregister volatile unsigned int FAUCR;
extern __cregister volatile unsigned int FMCR;

extern __cregister volatile unsigned int DESR;
extern __cregister volatile unsigned int DETR;

extern __cregister volatile unsigned int REP;
extern __cregister volatile unsigned int TSCL;
extern __cregister volatile unsigned int TSCH;
extern __cregister volatile unsigned int ARP;
extern __cregister volatile unsigned int ILC;
extern __cregister volatile unsigned int RILC;
extern __cregister volatile unsigned int PCE1;
extern __cregister volatile unsigned int DNUM;
extern __cregister volatile unsigned int SSR;
extern __cregister volatile unsigned int GPLYA;
extern __cregister volatile unsigned int GPLYB;
extern __cregister volatile unsigned int TSR;
extern __cregister volatile unsigned int ITSR;
extern __cregister volatile unsigned int NTSR;
extern __cregister volatile unsigned int ECR;
extern __cregister volatile unsigned int EFR;
extern __cregister volatile unsigned int IERR;

extern __cregister volatile unsigned int DMSG;
extern __cregister volatile unsigned int CMSG;
extern __cregister volatile unsigned int DT_DMA_ADDR;
extern __cregister volatile unsigned int DT_DMA_DATA;
extern __cregister volatile unsigned int DT_DMA_CNTL;
extern __cregister volatile unsigned int TCU_CNTL;
extern __cregister volatile unsigned int RTDX_REC_CNTL;
extern __cregister volatile unsigned int RTDX_XMT_CNTL;
extern __cregister volatile unsigned int RTDX_CFG;
extern __cregister volatile unsigned int RTDX_RDATA;
extern __cregister volatile unsigned int RTDX_WDATA;
extern __cregister volatile unsigned int RTDX_RADDR;
extern __cregister volatile unsigned int RTDX_WADDR;
extern __cregister volatile unsigned int MFREG0;
extern __cregister volatile unsigned int DBG_STAT;
extern __cregister volatile unsigned int BRK_EN;
extern __cregister volatile unsigned int HWBP0_CNT;
extern __cregister volatile unsigned int HWBP0;
extern __cregister volatile unsigned int HWBP1;
extern __cregister volatile unsigned int HWBP2;
extern __cregister volatile unsigned int HWBP3;
extern __cregister volatile unsigned int OVERLAY;
extern __cregister volatile unsigned int PC_PROF;
extern __cregister volatile unsigned int ATSR;
extern __cregister volatile unsigned int TRR;
extern __cregister volatile unsigned int TCRR;


/*****************************************************************************/
/* DATA_IS_ALIGNED_2, DATA_IS_ALIGNED_4, DATA_IS_ALIGNED_8 -                 */
/*     Tell the compiler that data is already aligned to a 2-byte, 4-byte    */
/*     or 8-byte boundary.  Note: this macro does not change the             */
/*     alignment of data.  Use DATA_ALIGN to change alignment.               */
/*****************************************************************************/


/*****************************************************************************/
/* SAVE_AMR -                                                                */
/*     Define a local 'volatile unsigned int' variable in your interrupt     */
/*     routine.                                                              */
/*     When invoking this macro, pass that local variable to save the AMR.   */
/*                                                                           */
/*     If you interrupted an assembly coded routine that may be using        */
/*     circular addressing, and you interrupt into a C coded interrupt       */
/*     service routine, you need to set the AMR to 0 for the C code and save */
/*     off the AMR register, so that it will have the correct value upon     */
/*     leaving the C interrupt service routine and returning to the assembly */
/*     code.                                                                 */
/*                                                                           */
/*     Add this routine immediately after your local variable definitions    */
/*     and before the start of your C interrupt code.                        */
/*****************************************************************************/

/*****************************************************************************/
/* RESTORE_AMR -                                                             */
/*    When invoking this macro, pass the same local variable that was passed */
/*    to the SAVE_AMR macro.  This macro will restore the AMR to the value   */
/*    it had when interrupted out of the hand assembly routine.              */
/*                                                                           */
/*    Add this macro immediately before exiting the C interrupt service      */
/*    routine.                                                               */ 
/*****************************************************************************/

/*****************************************************************************/
/* SAVE_SAT -                                                                */
/*     Define a local 'volatile unsigned int' variable in your interrupt     */
/*     routine.                                                              */
/*     When invoking this macro, pass that local variable to save the SAT    */
/*     bit.                                                                  */
/*                                                                           */
/*     If you interrupted a routine that was performing saturated arithmetic */
/*     and the interrupt service routine is also performing saturated        */
/*     arithmetic, then you must save and restore the SAT bit in your        */
/*     interrupt service routine.                                            */
/*                                                                           */
/*     Add this routine immediately after your local variable definitions    */
/*     and before the start of your C interrupt code.                        */
/*****************************************************************************/

/*****************************************************************************/
/* RESTORE_SAT -                                                             */
/*    When invoking this macro, pass the same local variable that was passed */
/*    to the SAVE_SAT macro.  This macro will restore the SAT bit to the     */
/*    value it had when your application was interrupted.                    */
/*                                                                           */
/*    Add this macro immediately before exiting the C interrupt service      */
/*    routine.                                                               */ 
/*****************************************************************************/
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) ti.sysbios; 2, 0, 0, 0,566; 3-20-2012 14:01:20; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */





/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== module ti.sysbios.heaps.HeapBuf ========
 */

typedef struct ti_sysbios_heaps_HeapBuf_ExtendedStats ti_sysbios_heaps_HeapBuf_ExtendedStats;
typedef struct ti_sysbios_heaps_HeapBuf_Module_State ti_sysbios_heaps_HeapBuf_Module_State;
typedef struct ti_sysbios_heaps_HeapBuf_Fxns__ ti_sysbios_heaps_HeapBuf_Fxns__;
typedef const ti_sysbios_heaps_HeapBuf_Fxns__* ti_sysbios_heaps_HeapBuf_Module;
typedef struct ti_sysbios_heaps_HeapBuf_Params ti_sysbios_heaps_HeapBuf_Params;
typedef struct ti_sysbios_heaps_HeapBuf_Object ti_sysbios_heaps_HeapBuf_Object;
typedef struct ti_sysbios_heaps_HeapBuf_Struct ti_sysbios_heaps_HeapBuf_Struct;
typedef ti_sysbios_heaps_HeapBuf_Object* ti_sysbios_heaps_HeapBuf_Handle;
typedef struct ti_sysbios_heaps_HeapBuf_Object__ ti_sysbios_heaps_HeapBuf_Instance_State;
typedef ti_sysbios_heaps_HeapBuf_Object* ti_sysbios_heaps_HeapBuf_Instance;

/*
 * ======== module ti.sysbios.heaps.HeapMem ========
 */

typedef struct ti_sysbios_heaps_HeapMem_ExtendedStats ti_sysbios_heaps_HeapMem_ExtendedStats;
typedef struct ti_sysbios_heaps_HeapMem_Header ti_sysbios_heaps_HeapMem_Header;
typedef struct ti_sysbios_heaps_HeapMem_Fxns__ ti_sysbios_heaps_HeapMem_Fxns__;
typedef const ti_sysbios_heaps_HeapMem_Fxns__* ti_sysbios_heaps_HeapMem_Module;
typedef struct ti_sysbios_heaps_HeapMem_Params ti_sysbios_heaps_HeapMem_Params;
typedef struct ti_sysbios_heaps_HeapMem_Object ti_sysbios_heaps_HeapMem_Object;
typedef struct ti_sysbios_heaps_HeapMem_Struct ti_sysbios_heaps_HeapMem_Struct;
typedef ti_sysbios_heaps_HeapMem_Object* ti_sysbios_heaps_HeapMem_Handle;
typedef struct ti_sysbios_heaps_HeapMem_Object__ ti_sysbios_heaps_HeapMem_Instance_State;
typedef ti_sysbios_heaps_HeapMem_Object* ti_sysbios_heaps_HeapMem_Instance;

/*
 * ======== module ti.sysbios.heaps.HeapMultiBuf ========
 */

typedef struct ti_sysbios_heaps_HeapMultiBuf_AddrPair ti_sysbios_heaps_HeapMultiBuf_AddrPair;
typedef struct ti_sysbios_heaps_HeapMultiBuf_Fxns__ ti_sysbios_heaps_HeapMultiBuf_Fxns__;
typedef const ti_sysbios_heaps_HeapMultiBuf_Fxns__* ti_sysbios_heaps_HeapMultiBuf_Module;
typedef struct ti_sysbios_heaps_HeapMultiBuf_Params ti_sysbios_heaps_HeapMultiBuf_Params;
typedef struct ti_sysbios_heaps_HeapMultiBuf_Object ti_sysbios_heaps_HeapMultiBuf_Object;
typedef struct ti_sysbios_heaps_HeapMultiBuf_Struct ti_sysbios_heaps_HeapMultiBuf_Struct;
typedef ti_sysbios_heaps_HeapMultiBuf_Object* ti_sysbios_heaps_HeapMultiBuf_Handle;
typedef struct ti_sysbios_heaps_HeapMultiBuf_Object__ ti_sysbios_heaps_HeapMultiBuf_Instance_State;
typedef ti_sysbios_heaps_HeapMultiBuf_Object* ti_sysbios_heaps_HeapMultiBuf_Instance;

/*
 * ======== module ti.sysbios.heaps.HeapNull ========
 */

typedef struct ti_sysbios_heaps_HeapNull_Fxns__ ti_sysbios_heaps_HeapNull_Fxns__;
typedef const ti_sysbios_heaps_HeapNull_Fxns__* ti_sysbios_heaps_HeapNull_Module;
typedef struct ti_sysbios_heaps_HeapNull_Params ti_sysbios_heaps_HeapNull_Params;
typedef struct ti_sysbios_heaps_HeapNull_Object ti_sysbios_heaps_HeapNull_Object;
typedef struct ti_sysbios_heaps_HeapNull_Struct ti_sysbios_heaps_HeapNull_Struct;
typedef ti_sysbios_heaps_HeapNull_Object* ti_sysbios_heaps_HeapNull_Handle;
typedef struct ti_sysbios_heaps_HeapNull_Object__ ti_sysbios_heaps_HeapNull_Instance_State;
typedef ti_sysbios_heaps_HeapNull_Object* ti_sysbios_heaps_HeapNull_Instance;

/*
 * ======== module ti.sysbios.heaps.HeapMem_Module_GateProxy ========
 */

typedef struct ti_sysbios_heaps_HeapMem_Module_GateProxy_Fxns__ ti_sysbios_heaps_HeapMem_Module_GateProxy_Fxns__;
typedef const ti_sysbios_heaps_HeapMem_Module_GateProxy_Fxns__* ti_sysbios_heaps_HeapMem_Module_GateProxy_Module;
typedef struct ti_sysbios_heaps_HeapMem_Module_GateProxy_Params ti_sysbios_heaps_HeapMem_Module_GateProxy_Params;
typedef struct xdc_runtime_IGateProvider___Object *ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle;



/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* ExtendedStats */
struct ti_sysbios_heaps_HeapBuf_ExtendedStats {
    xdc_UInt maxAllocatedBlocks;
    xdc_UInt numAllocatedBlocks;
};


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* Instance_State */
typedef xdc_Char __T1_ti_sysbios_heaps_HeapBuf_Instance_State__buf;
typedef xdc_Char *__ARRAY1_ti_sysbios_heaps_HeapBuf_Instance_State__buf;
typedef __ARRAY1_ti_sysbios_heaps_HeapBuf_Instance_State__buf __TA_ti_sysbios_heaps_HeapBuf_Instance_State__buf;

/* Module_State */
typedef ti_sysbios_heaps_HeapBuf_Handle __T1_ti_sysbios_heaps_HeapBuf_Module_State__constructedHeaps;
typedef ti_sysbios_heaps_HeapBuf_Handle *__ARRAY1_ti_sysbios_heaps_HeapBuf_Module_State__constructedHeaps;
typedef __ARRAY1_ti_sysbios_heaps_HeapBuf_Module_State__constructedHeaps __TA_ti_sysbios_heaps_HeapBuf_Module_State__constructedHeaps;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_heaps_HeapBuf_Module__diagsEnabled;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__diagsEnabled ti_sysbios_heaps_HeapBuf_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_heaps_HeapBuf_Module__diagsIncluded;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__diagsIncluded ti_sysbios_heaps_HeapBuf_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_heaps_HeapBuf_Module__diagsMask;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__diagsMask ti_sysbios_heaps_HeapBuf_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapBuf_Module__gateObj;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__gateObj ti_sysbios_heaps_HeapBuf_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapBuf_Module__gatePrms;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__gatePrms ti_sysbios_heaps_HeapBuf_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_heaps_HeapBuf_Module__id;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__id ti_sysbios_heaps_HeapBuf_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_heaps_HeapBuf_Module__loggerDefined;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__loggerDefined ti_sysbios_heaps_HeapBuf_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapBuf_Module__loggerObj;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__loggerObj ti_sysbios_heaps_HeapBuf_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn0;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn0 ti_sysbios_heaps_HeapBuf_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn1;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn1 ti_sysbios_heaps_HeapBuf_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn2;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn2 ti_sysbios_heaps_HeapBuf_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn4;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn4 ti_sysbios_heaps_HeapBuf_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn8;
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__loggerFxn8 ti_sysbios_heaps_HeapBuf_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_heaps_HeapBuf_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_heaps_HeapBuf_Module__startupDoneFxn ti_sysbios_heaps_HeapBuf_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_heaps_HeapBuf_Object__count;
extern far const CT__ti_sysbios_heaps_HeapBuf_Object__count ti_sysbios_heaps_HeapBuf_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_heaps_HeapBuf_Object__heap;
extern far const CT__ti_sysbios_heaps_HeapBuf_Object__heap ti_sysbios_heaps_HeapBuf_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_heaps_HeapBuf_Object__sizeof;
extern far const CT__ti_sysbios_heaps_HeapBuf_Object__sizeof ti_sysbios_heaps_HeapBuf_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapBuf_Object__table;
extern far const CT__ti_sysbios_heaps_HeapBuf_Object__table ti_sysbios_heaps_HeapBuf_Object__table__C;

/* A_nullBuf */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_nullBuf;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_nullBuf ti_sysbios_heaps_HeapBuf_A_nullBuf__C;

/* A_bufAlign */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_bufAlign;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_bufAlign ti_sysbios_heaps_HeapBuf_A_bufAlign__C;

/* A_invalidAlign */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_invalidAlign;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_invalidAlign ti_sysbios_heaps_HeapBuf_A_invalidAlign__C;

/* A_zeroBlockSize */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_zeroBlockSize;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_zeroBlockSize ti_sysbios_heaps_HeapBuf_A_zeroBlockSize__C;

/* A_zeroBlocks */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_zeroBlocks;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_zeroBlocks ti_sysbios_heaps_HeapBuf_A_zeroBlocks__C;

/* A_zeroBufSize */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_zeroBufSize;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_zeroBufSize ti_sysbios_heaps_HeapBuf_A_zeroBufSize__C;

/* A_invalidBufSize */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_invalidBufSize;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_invalidBufSize ti_sysbios_heaps_HeapBuf_A_invalidBufSize__C;

/* A_noBlocksToFree */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_noBlocksToFree;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_noBlocksToFree ti_sysbios_heaps_HeapBuf_A_noBlocksToFree__C;

/* A_invalidFree */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapBuf_A_invalidFree;
extern far const CT__ti_sysbios_heaps_HeapBuf_A_invalidFree ti_sysbios_heaps_HeapBuf_A_invalidFree__C;

/* E_size */
typedef xdc_runtime_Error_Id CT__ti_sysbios_heaps_HeapBuf_E_size;
extern far const CT__ti_sysbios_heaps_HeapBuf_E_size ti_sysbios_heaps_HeapBuf_E_size__C;

/* trackMaxAllocs */
typedef xdc_Bool CT__ti_sysbios_heaps_HeapBuf_trackMaxAllocs;
extern far const CT__ti_sysbios_heaps_HeapBuf_trackMaxAllocs ti_sysbios_heaps_HeapBuf_trackMaxAllocs__C;

/* numConstructedHeaps */
typedef xdc_UInt CT__ti_sysbios_heaps_HeapBuf_numConstructedHeaps;
extern far const CT__ti_sysbios_heaps_HeapBuf_numConstructedHeaps ti_sysbios_heaps_HeapBuf_numConstructedHeaps__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_heaps_HeapBuf_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_SizeT align;
    xdc_UInt numBlocks;
    xdc_SizeT blockSize;
    xdc_runtime_Memory_Size bufSize;
    xdc_Ptr buf;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_heaps_HeapBuf_Struct {
    const ti_sysbios_heaps_HeapBuf_Fxns__* __fxns;
    xdc_SizeT __f0;
    xdc_SizeT __f1;
    xdc_UInt __f2;
    xdc_runtime_Memory_Size __f3;
    __TA_ti_sysbios_heaps_HeapBuf_Instance_State__buf __f4;
    xdc_UInt __f5;
    xdc_UInt __f6;
    ti_sysbios_knl_Queue_Struct __f7;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_heaps_HeapBuf_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Ptr (*alloc)(ti_sysbios_heaps_HeapBuf_Handle, xdc_SizeT, xdc_SizeT, xdc_runtime_Error_Block*);
    void (*free)(ti_sysbios_heaps_HeapBuf_Handle, xdc_Ptr, xdc_SizeT);
    xdc_Bool (*isBlocking)(ti_sysbios_heaps_HeapBuf_Handle);
    void (*getStats)(ti_sysbios_heaps_HeapBuf_Handle, xdc_runtime_Memory_Stats*);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_heaps_HeapBuf_Fxns__ ti_sysbios_heaps_HeapBuf_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_heaps_HeapBuf_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_heaps_HeapBuf_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_heaps_HeapBuf_Module_startup__R( xdc_Int state );

/* Instance_init__F */

extern int ti_sysbios_heaps_HeapBuf_Instance_init__F( ti_sysbios_heaps_HeapBuf_Object*, const ti_sysbios_heaps_HeapBuf_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__F */

extern void ti_sysbios_heaps_HeapBuf_Instance_finalize__F( ti_sysbios_heaps_HeapBuf_Object* , int );

/* Instance_init__R */

extern int ti_sysbios_heaps_HeapBuf_Instance_init__R( ti_sysbios_heaps_HeapBuf_Object*, const ti_sysbios_heaps_HeapBuf_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__R */

extern void ti_sysbios_heaps_HeapBuf_Instance_finalize__R( ti_sysbios_heaps_HeapBuf_Object* , int );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_heaps_HeapBuf_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_heaps_HeapBuf_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_heaps_HeapBuf_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_heaps_HeapBuf_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_heaps_HeapBuf_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_heaps_HeapBuf_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_heaps_HeapBuf_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_heaps_HeapBuf_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_heaps_HeapBuf_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* free__E */

extern void ti_sysbios_heaps_HeapBuf_free__E( ti_sysbios_heaps_HeapBuf_Handle __inst, xdc_Ptr block, xdc_SizeT size );

extern void ti_sysbios_heaps_HeapBuf_free__F( ti_sysbios_heaps_HeapBuf_Object* __inst, xdc_Ptr block, xdc_SizeT size );
extern void ti_sysbios_heaps_HeapBuf_free__R( ti_sysbios_heaps_HeapBuf_Handle __inst, xdc_Ptr block, xdc_SizeT size );

/* getStats__E */

extern void ti_sysbios_heaps_HeapBuf_getStats__E( ti_sysbios_heaps_HeapBuf_Handle __inst, xdc_runtime_Memory_Stats* stats );

extern void ti_sysbios_heaps_HeapBuf_getStats__F( ti_sysbios_heaps_HeapBuf_Object* __inst, xdc_runtime_Memory_Stats* stats );
extern void ti_sysbios_heaps_HeapBuf_getStats__R( ti_sysbios_heaps_HeapBuf_Handle __inst, xdc_runtime_Memory_Stats* stats );

/* alloc__E */

extern xdc_Ptr ti_sysbios_heaps_HeapBuf_alloc__E( ti_sysbios_heaps_HeapBuf_Handle __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

extern xdc_Ptr ti_sysbios_heaps_HeapBuf_alloc__F( ti_sysbios_heaps_HeapBuf_Object* __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );
extern xdc_Ptr ti_sysbios_heaps_HeapBuf_alloc__R( ti_sysbios_heaps_HeapBuf_Handle __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

/* isBlocking__E */

extern xdc_Bool ti_sysbios_heaps_HeapBuf_isBlocking__E( ti_sysbios_heaps_HeapBuf_Handle __inst );

extern xdc_Bool ti_sysbios_heaps_HeapBuf_isBlocking__F( ti_sysbios_heaps_HeapBuf_Object* __inst );
extern xdc_Bool ti_sysbios_heaps_HeapBuf_isBlocking__R( ti_sysbios_heaps_HeapBuf_Handle __inst );

/* getBlockSize__E */

extern xdc_SizeT ti_sysbios_heaps_HeapBuf_getBlockSize__E( ti_sysbios_heaps_HeapBuf_Handle __inst );

extern xdc_SizeT ti_sysbios_heaps_HeapBuf_getBlockSize__F( ti_sysbios_heaps_HeapBuf_Object* __inst );
extern xdc_SizeT ti_sysbios_heaps_HeapBuf_getBlockSize__R( ti_sysbios_heaps_HeapBuf_Handle __inst );

/* getAlign__E */

extern xdc_SizeT ti_sysbios_heaps_HeapBuf_getAlign__E( ti_sysbios_heaps_HeapBuf_Handle __inst );

extern xdc_SizeT ti_sysbios_heaps_HeapBuf_getAlign__F( ti_sysbios_heaps_HeapBuf_Object* __inst );
extern xdc_SizeT ti_sysbios_heaps_HeapBuf_getAlign__R( ti_sysbios_heaps_HeapBuf_Handle __inst );

/* getEndAddr__E */

extern xdc_Ptr ti_sysbios_heaps_HeapBuf_getEndAddr__E( ti_sysbios_heaps_HeapBuf_Handle __inst );

extern xdc_Ptr ti_sysbios_heaps_HeapBuf_getEndAddr__F( ti_sysbios_heaps_HeapBuf_Object* __inst );
extern xdc_Ptr ti_sysbios_heaps_HeapBuf_getEndAddr__R( ti_sysbios_heaps_HeapBuf_Handle __inst );

/* getExtendedStats__E */

extern void ti_sysbios_heaps_HeapBuf_getExtendedStats__E( ti_sysbios_heaps_HeapBuf_Handle __inst, ti_sysbios_heaps_HeapBuf_ExtendedStats* stats );

extern void ti_sysbios_heaps_HeapBuf_getExtendedStats__F( ti_sysbios_heaps_HeapBuf_Object* __inst, ti_sysbios_heaps_HeapBuf_ExtendedStats* stats );
extern void ti_sysbios_heaps_HeapBuf_getExtendedStats__R( ti_sysbios_heaps_HeapBuf_Handle __inst, ti_sysbios_heaps_HeapBuf_ExtendedStats* stats );

/* mergeHeapBufs__E */

extern void ti_sysbios_heaps_HeapBuf_mergeHeapBufs__E( ti_sysbios_heaps_HeapBuf_Handle __inst, ti_sysbios_heaps_HeapBuf_Handle heapBuf2 );

extern void ti_sysbios_heaps_HeapBuf_mergeHeapBufs__F( ti_sysbios_heaps_HeapBuf_Object* __inst, ti_sysbios_heaps_HeapBuf_Handle heapBuf2 );
extern void ti_sysbios_heaps_HeapBuf_mergeHeapBufs__R( ti_sysbios_heaps_HeapBuf_Handle __inst, ti_sysbios_heaps_HeapBuf_Handle heapBuf2 );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* free_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapBuf_free_FxnT)(void*, xdc_Ptr, xdc_SizeT);
static inline ti_sysbios_heaps_HeapBuf_free_FxnT ti_sysbios_heaps_HeapBuf_free_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_free_FxnT)ti_sysbios_heaps_HeapBuf_free__E; 
}

/* getStats_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapBuf_getStats_FxnT)(void*, xdc_runtime_Memory_Stats*);
static inline ti_sysbios_heaps_HeapBuf_getStats_FxnT ti_sysbios_heaps_HeapBuf_getStats_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_getStats_FxnT)ti_sysbios_heaps_HeapBuf_getStats__E; 
}

/* alloc_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_heaps_HeapBuf_alloc_FxnT)(void*, xdc_SizeT, xdc_SizeT, xdc_runtime_Error_Block*);
static inline ti_sysbios_heaps_HeapBuf_alloc_FxnT ti_sysbios_heaps_HeapBuf_alloc_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_alloc_FxnT)ti_sysbios_heaps_HeapBuf_alloc__E; 
}

/* isBlocking_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_heaps_HeapBuf_isBlocking_FxnT)(void*);
static inline ti_sysbios_heaps_HeapBuf_isBlocking_FxnT ti_sysbios_heaps_HeapBuf_isBlocking_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_isBlocking_FxnT)ti_sysbios_heaps_HeapBuf_isBlocking__E; 
}

/* getBlockSize_{FxnT,fxnP} */
typedef xdc_SizeT (*ti_sysbios_heaps_HeapBuf_getBlockSize_FxnT)(void*);
static inline ti_sysbios_heaps_HeapBuf_getBlockSize_FxnT ti_sysbios_heaps_HeapBuf_getBlockSize_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_getBlockSize_FxnT)ti_sysbios_heaps_HeapBuf_getBlockSize__E; 
}

/* getAlign_{FxnT,fxnP} */
typedef xdc_SizeT (*ti_sysbios_heaps_HeapBuf_getAlign_FxnT)(void*);
static inline ti_sysbios_heaps_HeapBuf_getAlign_FxnT ti_sysbios_heaps_HeapBuf_getAlign_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_getAlign_FxnT)ti_sysbios_heaps_HeapBuf_getAlign__E; 
}

/* getEndAddr_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_heaps_HeapBuf_getEndAddr_FxnT)(void*);
static inline ti_sysbios_heaps_HeapBuf_getEndAddr_FxnT ti_sysbios_heaps_HeapBuf_getEndAddr_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_getEndAddr_FxnT)ti_sysbios_heaps_HeapBuf_getEndAddr__E; 
}

/* getExtendedStats_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapBuf_getExtendedStats_FxnT)(void*, ti_sysbios_heaps_HeapBuf_ExtendedStats*);
static inline ti_sysbios_heaps_HeapBuf_getExtendedStats_FxnT ti_sysbios_heaps_HeapBuf_getExtendedStats_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_getExtendedStats_FxnT)ti_sysbios_heaps_HeapBuf_getExtendedStats__E; 
}

/* mergeHeapBufs_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapBuf_mergeHeapBufs_FxnT)(void*, ti_sysbios_heaps_HeapBuf_Handle);
static inline ti_sysbios_heaps_HeapBuf_mergeHeapBufs_FxnT ti_sysbios_heaps_HeapBuf_mergeHeapBufs_fxnP( void )
{
    return (ti_sysbios_heaps_HeapBuf_mergeHeapBufs_FxnT)ti_sysbios_heaps_HeapBuf_mergeHeapBufs__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IHeap_Module ti_sysbios_heaps_HeapBuf_Module_upCast( void )
{
    return (xdc_runtime_IHeap_Module)&ti_sysbios_heaps_HeapBuf_Module__FXNS__C;
}

/* Module_to_xdc_runtime_IHeap */

/* Handle_upCast */
static inline xdc_runtime_IHeap_Handle ti_sysbios_heaps_HeapBuf_Handle_upCast( ti_sysbios_heaps_HeapBuf_Handle i )
{
    return (xdc_runtime_IHeap_Handle)i;
}

/* Handle_to_xdc_runtime_IHeap */

/* Handle_downCast */
static inline ti_sysbios_heaps_HeapBuf_Handle ti_sysbios_heaps_HeapBuf_Handle_downCast( xdc_runtime_IHeap_Handle i )
{
    xdc_runtime_IHeap_Handle i2 = (xdc_runtime_IHeap_Handle)i;
    return (void*)i2->__fxns == (void*)&ti_sysbios_heaps_HeapBuf_Module__FXNS__C ? (ti_sysbios_heaps_HeapBuf_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IHeap */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_heaps_HeapBuf_Module__id ti_sysbios_heaps_HeapBuf_Module_id( void ) 
{
    return ti_sysbios_heaps_HeapBuf_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_heaps_HeapBuf_Module_hasMask( void ) 
{
    return ti_sysbios_heaps_HeapBuf_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_heaps_HeapBuf_Module_getMask( void ) 
{
    return ti_sysbios_heaps_HeapBuf_Module__diagsMask__C != 0 ? *ti_sysbios_heaps_HeapBuf_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_heaps_HeapBuf_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_heaps_HeapBuf_Module__diagsMask__C != 0) *ti_sysbios_heaps_HeapBuf_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_heaps_HeapBuf_Params_init( ti_sysbios_heaps_HeapBuf_Params* prms ) 
{
    if (prms) {
        ti_sysbios_heaps_HeapBuf_Params__init__S(prms, 0, sizeof(ti_sysbios_heaps_HeapBuf_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_heaps_HeapBuf_Params_copy( ti_sysbios_heaps_HeapBuf_Params* dst, const ti_sysbios_heaps_HeapBuf_Params* src ) 
{
    if (dst) {
        ti_sysbios_heaps_HeapBuf_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_heaps_HeapBuf_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_heaps_HeapBuf_Handle ti_sysbios_heaps_HeapBuf_Object_get( ti_sysbios_heaps_HeapBuf_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_heaps_HeapBuf_Handle)ti_sysbios_heaps_HeapBuf_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_heaps_HeapBuf_Handle ti_sysbios_heaps_HeapBuf_Object_first( void )
{
    return (ti_sysbios_heaps_HeapBuf_Handle)ti_sysbios_heaps_HeapBuf_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_heaps_HeapBuf_Handle ti_sysbios_heaps_HeapBuf_Object_next( ti_sysbios_heaps_HeapBuf_Object* obj )
{
    return (ti_sysbios_heaps_HeapBuf_Handle)ti_sysbios_heaps_HeapBuf_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_heaps_HeapBuf_Handle_label( ti_sysbios_heaps_HeapBuf_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_heaps_HeapBuf_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_heaps_HeapBuf_Handle_name( ti_sysbios_heaps_HeapBuf_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_heaps_HeapBuf_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_heaps_HeapBuf_Handle ti_sysbios_heaps_HeapBuf_create( const ti_sysbios_heaps_HeapBuf_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (ti_sysbios_heaps_HeapBuf_Handle)ti_sysbios_heaps_HeapBuf_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_heaps_HeapBuf_Params), __eb);
}

/* construct */
static inline void ti_sysbios_heaps_HeapBuf_construct( ti_sysbios_heaps_HeapBuf_Struct* __obj, const ti_sysbios_heaps_HeapBuf_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_heaps_HeapBuf_Object__create__S(__obj, sizeof (ti_sysbios_heaps_HeapBuf_Struct), 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_heaps_HeapBuf_Params), __eb);
}

/* delete */
static inline void ti_sysbios_heaps_HeapBuf_delete( ti_sysbios_heaps_HeapBuf_Handle* instp )
{
    ti_sysbios_heaps_HeapBuf_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_heaps_HeapBuf_destruct( ti_sysbios_heaps_HeapBuf_Struct* obj )
{
    ti_sysbios_heaps_HeapBuf_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_heaps_HeapBuf_Handle ti_sysbios_heaps_HeapBuf_handle( ti_sysbios_heaps_HeapBuf_Struct* str )
{
    return (ti_sysbios_heaps_HeapBuf_Handle)str;
}

/* struct */
static inline ti_sysbios_heaps_HeapBuf_Struct* ti_sysbios_heaps_HeapBuf_struct( ti_sysbios_heaps_HeapBuf_Handle inst )
{
    return (ti_sysbios_heaps_HeapBuf_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) ti.sysbios.heaps; 2, 0, 0, 0,545; 3-20-2012 14:03:23; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Q_BLOCKING */

/* Q_PREEMPTING */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsEnabled;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsEnabled ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsIncluded;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsIncluded ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsMask;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsMask ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__gateObj;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__gateObj ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__gatePrms;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__gatePrms ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__id;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__id ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerDefined;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerDefined ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerObj;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerObj ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn0;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn0 ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn1;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn1 ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn2;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn2 ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn4;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn4 ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn8;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn8 ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__startupDoneFxn ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__count;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__count ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__heap;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__heap ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__sizeof;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__sizeof ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__table;
extern far const CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__table ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_heaps_HeapMem_Module_GateProxy_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_heaps_HeapMem_Module_GateProxy_Struct {
    const ti_sysbios_heaps_HeapMem_Module_GateProxy_Fxns__* __fxns;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_heaps_HeapMem_Module_GateProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*query)(xdc_Int);
    xdc_IArg (*enter)(ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle);
    void (*leave)(ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle, xdc_IArg);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_heaps_HeapMem_Module_GateProxy_Fxns__ ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_heaps_HeapMem_Module_GateProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool ti_sysbios_heaps_HeapMem_Module_GateProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Module_GateProxy_Proxy__delegate__S( void );

/* query__E */

extern xdc_Bool ti_sysbios_heaps_HeapMem_Module_GateProxy_query__E( xdc_Int qual );

extern xdc_Bool ti_sysbios_heaps_HeapMem_Module_GateProxy_query__R( xdc_Int qual );

/* enter__E */

extern xdc_IArg ti_sysbios_heaps_HeapMem_Module_GateProxy_enter__E( ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle __inst );

extern xdc_IArg ti_sysbios_heaps_HeapMem_Module_GateProxy_enter__R( ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle __inst );

/* leave__E */

extern void ti_sysbios_heaps_HeapMem_Module_GateProxy_leave__E( ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle __inst, xdc_IArg key );

extern void ti_sysbios_heaps_HeapMem_Module_GateProxy_leave__R( ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle __inst, xdc_IArg key );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enter_{FxnT,fxnP} */
typedef xdc_IArg (*ti_sysbios_heaps_HeapMem_Module_GateProxy_enter_FxnT)(void*);
static inline ti_sysbios_heaps_HeapMem_Module_GateProxy_enter_FxnT ti_sysbios_heaps_HeapMem_Module_GateProxy_enter_fxnP( void )
{
    return (ti_sysbios_heaps_HeapMem_Module_GateProxy_enter_FxnT)ti_sysbios_heaps_HeapMem_Module_GateProxy_enter__E; 
}

/* leave_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapMem_Module_GateProxy_leave_FxnT)(void*, xdc_IArg);
static inline ti_sysbios_heaps_HeapMem_Module_GateProxy_leave_FxnT ti_sysbios_heaps_HeapMem_Module_GateProxy_leave_fxnP( void )
{
    return (ti_sysbios_heaps_HeapMem_Module_GateProxy_leave_FxnT)ti_sysbios_heaps_HeapMem_Module_GateProxy_leave__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IGateProvider_Module ti_sysbios_heaps_HeapMem_Module_GateProxy_Module_upCast( void )
{
    return (xdc_runtime_IGateProvider_Module)ti_sysbios_heaps_HeapMem_Module_GateProxy_Proxy__delegate__S();
}

/* Module_to_xdc_runtime_IGateProvider */

/* Handle_upCast */
static inline xdc_runtime_IGateProvider_Handle ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle_upCast( ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle i )
{
    return (xdc_runtime_IGateProvider_Handle)i;
}

/* Handle_to_xdc_runtime_IGateProvider */

/* Handle_downCast */
static inline ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle_downCast( xdc_runtime_IGateProvider_Handle i )
{
    xdc_runtime_IGateProvider_Handle i2 = (xdc_runtime_IGateProvider_Handle)i;
if (ti_sysbios_heaps_HeapMem_Module_GateProxy_Proxy__abstract__S()) return (ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle)i;
    return (void*)i2->__fxns == (void*)ti_sysbios_heaps_HeapMem_Module_GateProxy_Proxy__delegate__S() ? (ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IGateProvider */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__id ti_sysbios_heaps_HeapMem_Module_GateProxy_Module_id( void ) 
{
    return ti_sysbios_heaps_HeapMem_Module_GateProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */

/* Params_init */
static inline void ti_sysbios_heaps_HeapMem_Module_GateProxy_Params_init( ti_sysbios_heaps_HeapMem_Module_GateProxy_Params* prms ) 
{
    if (prms) {
        ti_sysbios_heaps_HeapMem_Module_GateProxy_Params__init__S(prms, 0, sizeof(ti_sysbios_heaps_HeapMem_Module_GateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_heaps_HeapMem_Module_GateProxy_Params_copy( ti_sysbios_heaps_HeapMem_Module_GateProxy_Params* dst, const ti_sysbios_heaps_HeapMem_Module_GateProxy_Params* src ) 
{
    if (dst) {
        ti_sysbios_heaps_HeapMem_Module_GateProxy_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_heaps_HeapMem_Module_GateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* create */
static inline ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle ti_sysbios_heaps_HeapMem_Module_GateProxy_create( const ti_sysbios_heaps_HeapMem_Module_GateProxy_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle)ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_heaps_HeapMem_Module_GateProxy_Params), __eb);
}

/* delete */
static inline void ti_sysbios_heaps_HeapMem_Module_GateProxy_delete( ti_sysbios_heaps_HeapMem_Module_GateProxy_Handle* instp )
{
    ti_sysbios_heaps_HeapMem_Module_GateProxy_Object__delete__S(instp);
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* ExtendedStats */
struct ti_sysbios_heaps_HeapMem_ExtendedStats {
    xdc_Ptr buf;
    xdc_SizeT size;
};


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* Header */
struct ti_sysbios_heaps_HeapMem_Header {
    ti_sysbios_heaps_HeapMem_Header* next;
    xdc_runtime_Memory_Size size;
};

/* Instance_State */
typedef xdc_Char __T1_ti_sysbios_heaps_HeapMem_Instance_State__buf;
typedef xdc_Char *__ARRAY1_ti_sysbios_heaps_HeapMem_Instance_State__buf;
typedef __ARRAY1_ti_sysbios_heaps_HeapMem_Instance_State__buf __TA_ti_sysbios_heaps_HeapMem_Instance_State__buf;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_heaps_HeapMem_Module__diagsEnabled;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__diagsEnabled ti_sysbios_heaps_HeapMem_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_heaps_HeapMem_Module__diagsIncluded;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__diagsIncluded ti_sysbios_heaps_HeapMem_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_heaps_HeapMem_Module__diagsMask;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__diagsMask ti_sysbios_heaps_HeapMem_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapMem_Module__gateObj;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__gateObj ti_sysbios_heaps_HeapMem_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapMem_Module__gatePrms;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__gatePrms ti_sysbios_heaps_HeapMem_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_heaps_HeapMem_Module__id;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__id ti_sysbios_heaps_HeapMem_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_heaps_HeapMem_Module__loggerDefined;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__loggerDefined ti_sysbios_heaps_HeapMem_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapMem_Module__loggerObj;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__loggerObj ti_sysbios_heaps_HeapMem_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn0;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn0 ti_sysbios_heaps_HeapMem_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn1;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn1 ti_sysbios_heaps_HeapMem_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn2;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn2 ti_sysbios_heaps_HeapMem_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn4;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn4 ti_sysbios_heaps_HeapMem_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn8;
extern far const CT__ti_sysbios_heaps_HeapMem_Module__loggerFxn8 ti_sysbios_heaps_HeapMem_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_heaps_HeapMem_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_heaps_HeapMem_Module__startupDoneFxn ti_sysbios_heaps_HeapMem_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_heaps_HeapMem_Object__count;
extern far const CT__ti_sysbios_heaps_HeapMem_Object__count ti_sysbios_heaps_HeapMem_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_heaps_HeapMem_Object__heap;
extern far const CT__ti_sysbios_heaps_HeapMem_Object__heap ti_sysbios_heaps_HeapMem_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_heaps_HeapMem_Object__sizeof;
extern far const CT__ti_sysbios_heaps_HeapMem_Object__sizeof ti_sysbios_heaps_HeapMem_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_heaps_HeapMem_Object__table;
extern far const CT__ti_sysbios_heaps_HeapMem_Object__table ti_sysbios_heaps_HeapMem_Object__table__C;

/* A_zeroBlock */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapMem_A_zeroBlock;
extern far const CT__ti_sysbios_heaps_HeapMem_A_zeroBlock ti_sysbios_heaps_HeapMem_A_zeroBlock__C;

/* A_heapSize */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapMem_A_heapSize;
extern far const CT__ti_sysbios_heaps_HeapMem_A_heapSize ti_sysbios_heaps_HeapMem_A_heapSize__C;

/* A_align */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapMem_A_align;
extern far const CT__ti_sysbios_heaps_HeapMem_A_align ti_sysbios_heaps_HeapMem_A_align__C;

/* E_memory */
typedef xdc_runtime_Error_Id CT__ti_sysbios_heaps_HeapMem_E_memory;
extern far const CT__ti_sysbios_heaps_HeapMem_E_memory ti_sysbios_heaps_HeapMem_E_memory__C;

/* A_invalidFree */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_heaps_HeapMem_A_invalidFree;
extern far const CT__ti_sysbios_heaps_HeapMem_A_invalidFree ti_sysbios_heaps_HeapMem_A_invalidFree__C;

/* reqAlign */
typedef xdc_Int CT__ti_sysbios_heaps_HeapMem_reqAlign;
extern far const CT__ti_sysbios_heaps_HeapMem_reqAlign ti_sysbios_heaps_HeapMem_reqAlign__C;

/* reqAlignMask */
typedef xdc_Int CT__ti_sysbios_heaps_HeapMem_reqAlignMask;
extern far const CT__ti_sysbios_heaps_HeapMem_reqAlignMask ti_sysbios_heaps_HeapMem_reqAlignMask__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_heaps_HeapMem_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_Ptr buf;
    xdc_runtime_Memory_Size size;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_heaps_HeapMem_Struct {
    const ti_sysbios_heaps_HeapMem_Fxns__* __fxns;
    xdc_runtime_Memory_Size __f0;
    __TA_ti_sysbios_heaps_HeapMem_Instance_State__buf __f1;
    ti_sysbios_heaps_HeapMem_Header __f2;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_heaps_HeapMem_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Ptr (*alloc)(ti_sysbios_heaps_HeapMem_Handle, xdc_SizeT, xdc_SizeT, xdc_runtime_Error_Block*);
    void (*free)(ti_sysbios_heaps_HeapMem_Handle, xdc_Ptr, xdc_SizeT);
    xdc_Bool (*isBlocking)(ti_sysbios_heaps_HeapMem_Handle);
    void (*getStats)(ti_sysbios_heaps_HeapMem_Handle, xdc_runtime_Memory_Stats*);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_heaps_HeapMem_Fxns__ ti_sysbios_heaps_HeapMem_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Instance_init__F */

extern void ti_sysbios_heaps_HeapMem_Instance_init__F( ti_sysbios_heaps_HeapMem_Object*, const ti_sysbios_heaps_HeapMem_Params* );

/* Instance_init__R */

extern void ti_sysbios_heaps_HeapMem_Instance_init__R( ti_sysbios_heaps_HeapMem_Object*, const ti_sysbios_heaps_HeapMem_Params* );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_heaps_HeapMem_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_heaps_HeapMem_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_heaps_HeapMem_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_heaps_HeapMem_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_heaps_HeapMem_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* enter__E */

extern xdc_IArg ti_sysbios_heaps_HeapMem_enter__E( void );

extern xdc_IArg ti_sysbios_heaps_HeapMem_enter__F( void );
extern xdc_IArg ti_sysbios_heaps_HeapMem_enter__R( void );

/* leave__E */

extern void ti_sysbios_heaps_HeapMem_leave__E( xdc_IArg key );

extern void ti_sysbios_heaps_HeapMem_leave__F( xdc_IArg key );
extern void ti_sysbios_heaps_HeapMem_leave__R( xdc_IArg key );

/* alloc__E */

extern xdc_Ptr ti_sysbios_heaps_HeapMem_alloc__E( ti_sysbios_heaps_HeapMem_Handle __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

extern xdc_Ptr ti_sysbios_heaps_HeapMem_alloc__F( ti_sysbios_heaps_HeapMem_Object* __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );
extern xdc_Ptr ti_sysbios_heaps_HeapMem_alloc__R( ti_sysbios_heaps_HeapMem_Handle __inst, xdc_SizeT size, xdc_SizeT align, xdc_runtime_Error_Block* eb );

/* free__E */

extern void ti_sysbios_heaps_HeapMem_free__E( ti_sysbios_heaps_HeapMem_Handle __inst, xdc_Ptr block, xdc_SizeT size );

extern void ti_sysbios_heaps_HeapMem_free__F( ti_sysbios_heaps_HeapMem_Object* __inst, xdc_Ptr block, xdc_SizeT size );
extern void ti_sysbios_heaps_HeapMem_free__R( ti_sysbios_heaps_HeapMem_Handle __inst, xdc_Ptr block, xdc_SizeT size );

/* isBlocking__E */

extern xdc_Bool ti_sysbios_heaps_HeapMem_isBlocking__E( ti_sysbios_heaps_HeapMem_Handle __inst );

extern xdc_Bool ti_sysbios_heaps_HeapMem_isBlocking__F( ti_sysbios_heaps_HeapMem_Object* __inst );
extern xdc_Bool ti_sysbios_heaps_HeapMem_isBlocking__R( ti_sysbios_heaps_HeapMem_Handle __inst );

/* getStats__E */

extern void ti_sysbios_heaps_HeapMem_getStats__E( ti_sysbios_heaps_HeapMem_Handle __inst, xdc_runtime_Memory_Stats* stats );

extern void ti_sysbios_heaps_HeapMem_getStats__F( ti_sysbios_heaps_HeapMem_Object* __inst, xdc_runtime_Memory_Stats* stats );
extern void ti_sysbios_heaps_HeapMem_getStats__R( ti_sysbios_heaps_HeapMem_Handle __inst, xdc_runtime_Memory_Stats* stats );

/* restore__E */

extern void ti_sysbios_heaps_HeapMem_restore__E( ti_sysbios_heaps_HeapMem_Handle __inst );

extern void ti_sysbios_heaps_HeapMem_restore__F( ti_sysbios_heaps_HeapMem_Object* __inst );
extern void ti_sysbios_heaps_HeapMem_restore__R( ti_sysbios_heaps_HeapMem_Handle __inst );

/* getExtendedStats__E */

extern void ti_sysbios_heaps_HeapMem_getExtendedStats__E( ti_sysbios_heaps_HeapMem_Handle __inst, ti_sysbios_heaps_HeapMem_ExtendedStats* stats );

extern void ti_sysbios_heaps_HeapMem_getExtendedStats__F( ti_sysbios_heaps_HeapMem_Object* __inst, ti_sysbios_heaps_HeapMem_ExtendedStats* stats );
extern void ti_sysbios_heaps_HeapMem_getExtendedStats__R( ti_sysbios_heaps_HeapMem_Handle __inst, ti_sysbios_heaps_HeapMem_ExtendedStats* stats );

/* init__I */

extern void ti_sysbios_heaps_HeapMem_init__I( void );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* alloc_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_heaps_HeapMem_alloc_FxnT)(void*, xdc_SizeT, xdc_SizeT, xdc_runtime_Error_Block*);
static inline ti_sysbios_heaps_HeapMem_alloc_FxnT ti_sysbios_heaps_HeapMem_alloc_fxnP( void )
{
    return (ti_sysbios_heaps_HeapMem_alloc_FxnT)ti_sysbios_heaps_HeapMem_alloc__E; 
}

/* free_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapMem_free_FxnT)(void*, xdc_Ptr, xdc_SizeT);
static inline ti_sysbios_heaps_HeapMem_free_FxnT ti_sysbios_heaps_HeapMem_free_fxnP( void )
{
    return (ti_sysbios_heaps_HeapMem_free_FxnT)ti_sysbios_heaps_HeapMem_free__E; 
}

/* isBlocking_{FxnT,fxnP} */
typedef xdc_Bool (*ti_sysbios_heaps_HeapMem_isBlocking_FxnT)(void*);
static inline ti_sysbios_heaps_HeapMem_isBlocking_FxnT ti_sysbios_heaps_HeapMem_isBlocking_fxnP( void )
{
    return (ti_sysbios_heaps_HeapMem_isBlocking_FxnT)ti_sysbios_heaps_HeapMem_isBlocking__E; 
}

/* getStats_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapMem_getStats_FxnT)(void*, xdc_runtime_Memory_Stats*);
static inline ti_sysbios_heaps_HeapMem_getStats_FxnT ti_sysbios_heaps_HeapMem_getStats_fxnP( void )
{
    return (ti_sysbios_heaps_HeapMem_getStats_FxnT)ti_sysbios_heaps_HeapMem_getStats__E; 
}

/* restore_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapMem_restore_FxnT)(void*);
static inline ti_sysbios_heaps_HeapMem_restore_FxnT ti_sysbios_heaps_HeapMem_restore_fxnP( void )
{
    return (ti_sysbios_heaps_HeapMem_restore_FxnT)ti_sysbios_heaps_HeapMem_restore__E; 
}

/* getExtendedStats_{FxnT,fxnP} */
typedef void (*ti_sysbios_heaps_HeapMem_getExtendedStats_FxnT)(void*, ti_sysbios_heaps_HeapMem_ExtendedStats*);
static inline ti_sysbios_heaps_HeapMem_getExtendedStats_FxnT ti_sysbios_heaps_HeapMem_getExtendedStats_fxnP( void )
{
    return (ti_sysbios_heaps_HeapMem_getExtendedStats_FxnT)ti_sysbios_heaps_HeapMem_getExtendedStats__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IHeap_Module ti_sysbios_heaps_HeapMem_Module_upCast( void )
{
    return (xdc_runtime_IHeap_Module)&ti_sysbios_heaps_HeapMem_Module__FXNS__C;
}

/* Module_to_xdc_runtime_IHeap */

/* Handle_upCast */
static inline xdc_runtime_IHeap_Handle ti_sysbios_heaps_HeapMem_Handle_upCast( ti_sysbios_heaps_HeapMem_Handle i )
{
    return (xdc_runtime_IHeap_Handle)i;
}

/* Handle_to_xdc_runtime_IHeap */

/* Handle_downCast */
static inline ti_sysbios_heaps_HeapMem_Handle ti_sysbios_heaps_HeapMem_Handle_downCast( xdc_runtime_IHeap_Handle i )
{
    xdc_runtime_IHeap_Handle i2 = (xdc_runtime_IHeap_Handle)i;
    return (void*)i2->__fxns == (void*)&ti_sysbios_heaps_HeapMem_Module__FXNS__C ? (ti_sysbios_heaps_HeapMem_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IHeap */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_heaps_HeapMem_Module__id ti_sysbios_heaps_HeapMem_Module_id( void ) 
{
    return ti_sysbios_heaps_HeapMem_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_heaps_HeapMem_Module_hasMask( void ) 
{
    return ti_sysbios_heaps_HeapMem_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_heaps_HeapMem_Module_getMask( void ) 
{
    return ti_sysbios_heaps_HeapMem_Module__diagsMask__C != 0 ? *ti_sysbios_heaps_HeapMem_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_heaps_HeapMem_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_heaps_HeapMem_Module__diagsMask__C != 0) *ti_sysbios_heaps_HeapMem_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_heaps_HeapMem_Params_init( ti_sysbios_heaps_HeapMem_Params* prms ) 
{
    if (prms) {
        ti_sysbios_heaps_HeapMem_Params__init__S(prms, 0, sizeof(ti_sysbios_heaps_HeapMem_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_heaps_HeapMem_Params_copy( ti_sysbios_heaps_HeapMem_Params* dst, const ti_sysbios_heaps_HeapMem_Params* src ) 
{
    if (dst) {
        ti_sysbios_heaps_HeapMem_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_heaps_HeapMem_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_heaps_HeapMem_Handle ti_sysbios_heaps_HeapMem_Object_get( ti_sysbios_heaps_HeapMem_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_heaps_HeapMem_Handle)ti_sysbios_heaps_HeapMem_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_heaps_HeapMem_Handle ti_sysbios_heaps_HeapMem_Object_first( void )
{
    return (ti_sysbios_heaps_HeapMem_Handle)ti_sysbios_heaps_HeapMem_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_heaps_HeapMem_Handle ti_sysbios_heaps_HeapMem_Object_next( ti_sysbios_heaps_HeapMem_Object* obj )
{
    return (ti_sysbios_heaps_HeapMem_Handle)ti_sysbios_heaps_HeapMem_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_heaps_HeapMem_Handle_label( ti_sysbios_heaps_HeapMem_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_heaps_HeapMem_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_heaps_HeapMem_Handle_name( ti_sysbios_heaps_HeapMem_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_heaps_HeapMem_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_heaps_HeapMem_Handle ti_sysbios_heaps_HeapMem_create( const ti_sysbios_heaps_HeapMem_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (ti_sysbios_heaps_HeapMem_Handle)ti_sysbios_heaps_HeapMem_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_heaps_HeapMem_Params), __eb);
}

/* construct */
static inline void ti_sysbios_heaps_HeapMem_construct( ti_sysbios_heaps_HeapMem_Struct* __obj, const ti_sysbios_heaps_HeapMem_Params* __prms )
{
    ti_sysbios_heaps_HeapMem_Object__create__S(__obj, sizeof (ti_sysbios_heaps_HeapMem_Struct), 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_heaps_HeapMem_Params), 0);
}

/* delete */
static inline void ti_sysbios_heaps_HeapMem_delete( ti_sysbios_heaps_HeapMem_Handle* instp )
{
    ti_sysbios_heaps_HeapMem_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_heaps_HeapMem_destruct( ti_sysbios_heaps_HeapMem_Struct* obj )
{
    ti_sysbios_heaps_HeapMem_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_heaps_HeapMem_Handle ti_sysbios_heaps_HeapMem_handle( ti_sysbios_heaps_HeapMem_Struct* str )
{
    return (ti_sysbios_heaps_HeapMem_Handle)str;
}

/* struct */
static inline ti_sysbios_heaps_HeapMem_Struct* ti_sysbios_heaps_HeapMem_struct( ti_sysbios_heaps_HeapMem_Handle inst )
{
    return (ti_sysbios_heaps_HeapMem_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/*
 *  @(#) ti.sysbios.heaps; 2, 0, 0, 0,545; 3-20-2012 14:03:23; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
/*
 *  @(#) ti.sysbios.family.c64p; 2, 0, 0, 0,548; 3-20-2012 14:02:31; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== module ti.sysbios.family.c64p.EventCombiner ========
 */

typedef struct ti_sysbios_family_c64p_EventCombiner_DispatchTabElem ti_sysbios_family_c64p_EventCombiner_DispatchTabElem;
typedef struct ti_sysbios_family_c64p_EventCombiner_Module_State ti_sysbios_family_c64p_EventCombiner_Module_State;

/*
 * ======== module ti.sysbios.family.c64p.Exception ========
 */

typedef struct ti_sysbios_family_c64p_Exception_Context ti_sysbios_family_c64p_Exception_Context;
typedef struct ti_sysbios_family_c64p_Exception_Status ti_sysbios_family_c64p_Exception_Status;
typedef struct ti_sysbios_family_c64p_Exception_Module_State ti_sysbios_family_c64p_Exception_Module_State;

/*
 * ======== module ti.sysbios.family.c64p.Hwi ========
 */

typedef struct ti_sysbios_family_c64p_Hwi_Module_State ti_sysbios_family_c64p_Hwi_Module_State;
typedef struct ti_sysbios_family_c64p_Hwi_Fxns__ ti_sysbios_family_c64p_Hwi_Fxns__;
typedef const ti_sysbios_family_c64p_Hwi_Fxns__* ti_sysbios_family_c64p_Hwi_Module;
typedef struct ti_sysbios_family_c64p_Hwi_Params ti_sysbios_family_c64p_Hwi_Params;
typedef struct ti_sysbios_family_c64p_Hwi_Object ti_sysbios_family_c64p_Hwi_Object;
typedef struct ti_sysbios_family_c64p_Hwi_Struct ti_sysbios_family_c64p_Hwi_Struct;
typedef ti_sysbios_family_c64p_Hwi_Object* ti_sysbios_family_c64p_Hwi_Handle;
typedef struct ti_sysbios_family_c64p_Hwi_Object__ ti_sysbios_family_c64p_Hwi_Instance_State;
typedef ti_sysbios_family_c64p_Hwi_Object* ti_sysbios_family_c64p_Hwi_Instance;

/*
 * ======== module ti.sysbios.family.c64p.TimestampProvider ========
 */

typedef struct ti_sysbios_family_c64p_TimestampProvider_Fxns__ ti_sysbios_family_c64p_TimestampProvider_Fxns__;
typedef const ti_sysbios_family_c64p_TimestampProvider_Fxns__* ti_sysbios_family_c64p_TimestampProvider_Module;

/*
 * ======== module ti.sysbios.family.c64p.MemoryProtect ========
 */

typedef struct ti_sysbios_family_c64p_MemoryProtect_BitRange ti_sysbios_family_c64p_MemoryProtect_BitRange;
typedef struct ti_sysbios_family_c64p_MemoryProtect_Lock ti_sysbios_family_c64p_MemoryProtect_Lock;
typedef struct ti_sysbios_family_c64p_MemoryProtect_Fault ti_sysbios_family_c64p_MemoryProtect_Fault;
typedef struct ti_sysbios_family_c64p_MemoryProtect_Key ti_sysbios_family_c64p_MemoryProtect_Key;
typedef struct ti_sysbios_family_c64p_MemoryProtect_Controller ti_sysbios_family_c64p_MemoryProtect_Controller;
typedef struct ti_sysbios_family_c64p_MemoryProtect_Module_State ti_sysbios_family_c64p_MemoryProtect_Module_State;

/*
 * ======== module ti.sysbios.family.c64p.Clobber ========
 */


/*
 * ======== module ti.sysbios.family.c64p.Cache ========
 */

typedef struct ti_sysbios_family_c64p_Cache_Size ti_sysbios_family_c64p_Cache_Size;
typedef struct ti_sysbios_family_c64p_Cache_Module_State ti_sysbios_family_c64p_Cache_Module_State;
typedef struct ti_sysbios_family_c64p_Cache_Fxns__ ti_sysbios_family_c64p_Cache_Fxns__;
typedef const ti_sysbios_family_c64p_Cache_Fxns__* ti_sysbios_family_c64p_Cache_Module;



/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.interfaces; 2, 0, 0, 0,545; 3-20-2012 14:03:22; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_family_c64p_Hwi_FuncPtr;

/* Irp */
typedef ti_sysbios_interfaces_IHwi_Irp ti_sysbios_family_c64p_Hwi_Irp;

/* HookSet */
typedef ti_sysbios_interfaces_IHwi_HookSet ti_sysbios_family_c64p_Hwi_HookSet;

/* MaskingOption */
typedef ti_sysbios_interfaces_IHwi_MaskingOption ti_sysbios_family_c64p_Hwi_MaskingOption;

/* StackInfo */
typedef ti_sysbios_interfaces_IHwi_StackInfo ti_sysbios_family_c64p_Hwi_StackInfo;

/* NUM_INTERRUPTS */

/* PlugFuncPtr */
typedef void (*ti_sysbios_family_c64p_Hwi_PlugFuncPtr)(void);

/* MaskingOption_NONE */

/* MaskingOption_ALL */

/* MaskingOption_SELF */

/* MaskingOption_BITMASK */

/* MaskingOption_LOWER */


/*
 * ======== CREATE ARGS ========
 */

/* Args__create */
typedef struct ti_sysbios_family_c64p_Hwi_Args__create {
    xdc_Int intNum;
    ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn;
} ti_sysbios_family_c64p_Hwi_Args__create;


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* Instance_State */
typedef xdc_Ptr __T1_ti_sysbios_family_c64p_Hwi_Instance_State__hookEnv;
typedef xdc_Ptr *__ARRAY1_ti_sysbios_family_c64p_Hwi_Instance_State__hookEnv;
typedef __ARRAY1_ti_sysbios_family_c64p_Hwi_Instance_State__hookEnv __TA_ti_sysbios_family_c64p_Hwi_Instance_State__hookEnv;

/* Module_State */
typedef xdc_Char __T1_ti_sysbios_family_c64p_Hwi_Module_State__intEvents;
typedef xdc_Char __ARRAY1_ti_sysbios_family_c64p_Hwi_Module_State__intEvents[12];
typedef __ARRAY1_ti_sysbios_family_c64p_Hwi_Module_State__intEvents __TA_ti_sysbios_family_c64p_Hwi_Module_State__intEvents;
typedef ti_sysbios_family_c64p_Hwi_Handle __T1_ti_sysbios_family_c64p_Hwi_Module_State__dispatchTable;
typedef ti_sysbios_family_c64p_Hwi_Handle __ARRAY1_ti_sysbios_family_c64p_Hwi_Module_State__dispatchTable[16];
typedef __ARRAY1_ti_sysbios_family_c64p_Hwi_Module_State__dispatchTable __TA_ti_sysbios_family_c64p_Hwi_Module_State__dispatchTable;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_family_c64p_Hwi_Module__diagsEnabled;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__diagsEnabled ti_sysbios_family_c64p_Hwi_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_family_c64p_Hwi_Module__diagsIncluded;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__diagsIncluded ti_sysbios_family_c64p_Hwi_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_family_c64p_Hwi_Module__diagsMask;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__diagsMask ti_sysbios_family_c64p_Hwi_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_family_c64p_Hwi_Module__gateObj;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__gateObj ti_sysbios_family_c64p_Hwi_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_family_c64p_Hwi_Module__gatePrms;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__gatePrms ti_sysbios_family_c64p_Hwi_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_family_c64p_Hwi_Module__id;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__id ti_sysbios_family_c64p_Hwi_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_family_c64p_Hwi_Module__loggerDefined;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__loggerDefined ti_sysbios_family_c64p_Hwi_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_family_c64p_Hwi_Module__loggerObj;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__loggerObj ti_sysbios_family_c64p_Hwi_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn0;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn0 ti_sysbios_family_c64p_Hwi_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn1;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn1 ti_sysbios_family_c64p_Hwi_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn2;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn2 ti_sysbios_family_c64p_Hwi_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn4;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn4 ti_sysbios_family_c64p_Hwi_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn8;
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__loggerFxn8 ti_sysbios_family_c64p_Hwi_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_family_c64p_Hwi_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_family_c64p_Hwi_Module__startupDoneFxn ti_sysbios_family_c64p_Hwi_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_family_c64p_Hwi_Object__count;
extern far const CT__ti_sysbios_family_c64p_Hwi_Object__count ti_sysbios_family_c64p_Hwi_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_family_c64p_Hwi_Object__heap;
extern far const CT__ti_sysbios_family_c64p_Hwi_Object__heap ti_sysbios_family_c64p_Hwi_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_family_c64p_Hwi_Object__sizeof;
extern far const CT__ti_sysbios_family_c64p_Hwi_Object__sizeof ti_sysbios_family_c64p_Hwi_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_family_c64p_Hwi_Object__table;
extern far const CT__ti_sysbios_family_c64p_Hwi_Object__table ti_sysbios_family_c64p_Hwi_Object__table__C;

/* dispatcherAutoNestingSupport */
typedef xdc_Bool CT__ti_sysbios_family_c64p_Hwi_dispatcherAutoNestingSupport;
extern far const CT__ti_sysbios_family_c64p_Hwi_dispatcherAutoNestingSupport ti_sysbios_family_c64p_Hwi_dispatcherAutoNestingSupport__C;

/* dispatcherSwiSupport */
typedef xdc_Bool CT__ti_sysbios_family_c64p_Hwi_dispatcherSwiSupport;
extern far const CT__ti_sysbios_family_c64p_Hwi_dispatcherSwiSupport ti_sysbios_family_c64p_Hwi_dispatcherSwiSupport__C;

/* dispatcherTaskSupport */
typedef xdc_Bool CT__ti_sysbios_family_c64p_Hwi_dispatcherTaskSupport;
extern far const CT__ti_sysbios_family_c64p_Hwi_dispatcherTaskSupport ti_sysbios_family_c64p_Hwi_dispatcherTaskSupport__C;

/* dispatcherIrpTrackingSupport */
typedef xdc_Bool CT__ti_sysbios_family_c64p_Hwi_dispatcherIrpTrackingSupport;
extern far const CT__ti_sysbios_family_c64p_Hwi_dispatcherIrpTrackingSupport ti_sysbios_family_c64p_Hwi_dispatcherIrpTrackingSupport__C;

/* E_alreadyDefined */
typedef xdc_runtime_Error_Id CT__ti_sysbios_family_c64p_Hwi_E_alreadyDefined;
extern far const CT__ti_sysbios_family_c64p_Hwi_E_alreadyDefined ti_sysbios_family_c64p_Hwi_E_alreadyDefined__C;

/* LM_begin */
typedef xdc_runtime_Log_Event CT__ti_sysbios_family_c64p_Hwi_LM_begin;
extern far const CT__ti_sysbios_family_c64p_Hwi_LM_begin ti_sysbios_family_c64p_Hwi_LM_begin__C;

/* LD_end */
typedef xdc_runtime_Log_Event CT__ti_sysbios_family_c64p_Hwi_LD_end;
extern far const CT__ti_sysbios_family_c64p_Hwi_LD_end ti_sysbios_family_c64p_Hwi_LD_end__C;

/* enableException */
typedef xdc_Bool CT__ti_sysbios_family_c64p_Hwi_enableException;
extern far const CT__ti_sysbios_family_c64p_Hwi_enableException ti_sysbios_family_c64p_Hwi_enableException__C;

/* swiDisable */
typedef xdc_UInt (*CT__ti_sysbios_family_c64p_Hwi_swiDisable)(void);
extern far const CT__ti_sysbios_family_c64p_Hwi_swiDisable ti_sysbios_family_c64p_Hwi_swiDisable__C;

/* swiRestoreHwi */
typedef void (*CT__ti_sysbios_family_c64p_Hwi_swiRestoreHwi)(xdc_UInt);
extern far const CT__ti_sysbios_family_c64p_Hwi_swiRestoreHwi ti_sysbios_family_c64p_Hwi_swiRestoreHwi__C;

/* taskDisable */
typedef xdc_UInt (*CT__ti_sysbios_family_c64p_Hwi_taskDisable)(void);
extern far const CT__ti_sysbios_family_c64p_Hwi_taskDisable ti_sysbios_family_c64p_Hwi_taskDisable__C;

/* taskRestoreHwi */
typedef void (*CT__ti_sysbios_family_c64p_Hwi_taskRestoreHwi)(xdc_UInt);
extern far const CT__ti_sysbios_family_c64p_Hwi_taskRestoreHwi ti_sysbios_family_c64p_Hwi_taskRestoreHwi__C;

/* hooks */
typedef ti_sysbios_family_c64p_Hwi_HookSet __T1_ti_sysbios_family_c64p_Hwi_hooks;
typedef struct { int length; ti_sysbios_family_c64p_Hwi_HookSet *elem; } __ARRAY1_ti_sysbios_family_c64p_Hwi_hooks;
typedef __ARRAY1_ti_sysbios_family_c64p_Hwi_hooks __TA_ti_sysbios_family_c64p_Hwi_hooks;
typedef __TA_ti_sysbios_family_c64p_Hwi_hooks CT__ti_sysbios_family_c64p_Hwi_hooks;
extern far const CT__ti_sysbios_family_c64p_Hwi_hooks ti_sysbios_family_c64p_Hwi_hooks__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_family_c64p_Hwi_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    ti_sysbios_interfaces_IHwi_MaskingOption maskSetting;
    xdc_UArg arg;
    xdc_Bool enableInt;
    xdc_Int eventId;
    xdc_Int priority;
    xdc_Bits16 disableMask;
    xdc_Bits16 restoreMask;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_family_c64p_Hwi_Struct {
    const ti_sysbios_family_c64p_Hwi_Fxns__* __fxns;
    xdc_Bits16 __f0;
    xdc_Bits16 __f1;
    xdc_UArg __f2;
    ti_sysbios_family_c64p_Hwi_FuncPtr __f3;
    ti_sysbios_family_c64p_Hwi_Irp __f4;
    __TA_ti_sysbios_family_c64p_Hwi_Instance_State__hookEnv __f5;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_family_c64p_Hwi_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*getStackInfo)(ti_sysbios_interfaces_IHwi_StackInfo*, xdc_Bool);
    void (*startup)(void);
    xdc_UInt (*disable)(void);
    xdc_UInt (*enable)(void);
    void (*restore)(xdc_UInt);
    void (*switchFromBootStack)(void);
    void (*post)(xdc_UInt);
    xdc_Char* (*getTaskSP)(void);
    xdc_UInt (*disableInterrupt)(xdc_UInt);
    xdc_UInt (*enableInterrupt)(xdc_UInt);
    void (*restoreInterrupt)(xdc_UInt, xdc_UInt);
    void (*clearInterrupt)(xdc_UInt);
    ti_sysbios_interfaces_IHwi_FuncPtr (*getFunc)(ti_sysbios_family_c64p_Hwi_Handle, xdc_UArg*);
    void (*setFunc)(ti_sysbios_family_c64p_Hwi_Handle, ti_sysbios_interfaces_IHwi_FuncPtr, xdc_UArg);
    xdc_Ptr (*getHookContext)(ti_sysbios_family_c64p_Hwi_Handle, xdc_Int);
    void (*setHookContext)(ti_sysbios_family_c64p_Hwi_Handle, xdc_Int, xdc_Ptr);
    ti_sysbios_interfaces_IHwi_Irp (*getIrp)(ti_sysbios_family_c64p_Hwi_Handle);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_family_c64p_Hwi_Fxns__ ti_sysbios_family_c64p_Hwi_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_family_c64p_Hwi_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_family_c64p_Hwi_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_family_c64p_Hwi_Module_startup__R( xdc_Int state );

/* Instance_init__F */

extern int ti_sysbios_family_c64p_Hwi_Instance_init__F( ti_sysbios_family_c64p_Hwi_Object*, xdc_Int intNum, ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn, const ti_sysbios_family_c64p_Hwi_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__F */

extern void ti_sysbios_family_c64p_Hwi_Instance_finalize__F( ti_sysbios_family_c64p_Hwi_Object* , int );

/* Instance_init__R */

extern int ti_sysbios_family_c64p_Hwi_Instance_init__R( ti_sysbios_family_c64p_Hwi_Object*, xdc_Int intNum, ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn, const ti_sysbios_family_c64p_Hwi_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__R */

extern void ti_sysbios_family_c64p_Hwi_Instance_finalize__R( ti_sysbios_family_c64p_Hwi_Object* , int );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_family_c64p_Hwi_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_family_c64p_Hwi_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_family_c64p_Hwi_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_family_c64p_Hwi_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_family_c64p_Hwi_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_family_c64p_Hwi_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_family_c64p_Hwi_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_family_c64p_Hwi_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_family_c64p_Hwi_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* getStackInfo__E */

extern xdc_Bool ti_sysbios_family_c64p_Hwi_getStackInfo__E( ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth );

extern xdc_Bool ti_sysbios_family_c64p_Hwi_getStackInfo__F( ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth );
extern xdc_Bool ti_sysbios_family_c64p_Hwi_getStackInfo__R( ti_sysbios_interfaces_IHwi_StackInfo* stkInfo, xdc_Bool computeStackDepth );

/* startup__E */

extern void ti_sysbios_family_c64p_Hwi_startup__E( void );

extern void ti_sysbios_family_c64p_Hwi_startup__F( void );
extern void ti_sysbios_family_c64p_Hwi_startup__R( void );

/* switchFromBootStack__E */

extern void ti_sysbios_family_c64p_Hwi_switchFromBootStack__E( void );

extern void ti_sysbios_family_c64p_Hwi_switchFromBootStack__F( void );
extern void ti_sysbios_family_c64p_Hwi_switchFromBootStack__R( void );

/* post__E */

extern void ti_sysbios_family_c64p_Hwi_post__E( xdc_UInt intNum );

extern void ti_sysbios_family_c64p_Hwi_post__F( xdc_UInt intNum );
extern void ti_sysbios_family_c64p_Hwi_post__R( xdc_UInt intNum );

/* getTaskSP__E */

extern xdc_Char* ti_sysbios_family_c64p_Hwi_getTaskSP__E( void );

extern xdc_Char* ti_sysbios_family_c64p_Hwi_getTaskSP__F( void );
extern xdc_Char* ti_sysbios_family_c64p_Hwi_getTaskSP__R( void );

/* disableInterrupt__E */

extern xdc_UInt ti_sysbios_family_c64p_Hwi_disableInterrupt__E( xdc_UInt intNum );

extern xdc_UInt ti_sysbios_family_c64p_Hwi_disableInterrupt__F( xdc_UInt intNum );
extern xdc_UInt ti_sysbios_family_c64p_Hwi_disableInterrupt__R( xdc_UInt intNum );

/* enableInterrupt__E */

extern xdc_UInt ti_sysbios_family_c64p_Hwi_enableInterrupt__E( xdc_UInt intNum );

extern xdc_UInt ti_sysbios_family_c64p_Hwi_enableInterrupt__F( xdc_UInt intNum );
extern xdc_UInt ti_sysbios_family_c64p_Hwi_enableInterrupt__R( xdc_UInt intNum );

/* restoreInterrupt__E */

extern void ti_sysbios_family_c64p_Hwi_restoreInterrupt__E( xdc_UInt intNum, xdc_UInt key );

extern void ti_sysbios_family_c64p_Hwi_restoreInterrupt__F( xdc_UInt intNum, xdc_UInt key );
extern void ti_sysbios_family_c64p_Hwi_restoreInterrupt__R( xdc_UInt intNum, xdc_UInt key );

/* clearInterrupt__E */

extern void ti_sysbios_family_c64p_Hwi_clearInterrupt__E( xdc_UInt intNum );

extern void ti_sysbios_family_c64p_Hwi_clearInterrupt__F( xdc_UInt intNum );
extern void ti_sysbios_family_c64p_Hwi_clearInterrupt__R( xdc_UInt intNum );

/* getFunc__E */

extern ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_family_c64p_Hwi_getFunc__E( ti_sysbios_family_c64p_Hwi_Handle __inst, xdc_UArg* arg );

extern ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_family_c64p_Hwi_getFunc__F( ti_sysbios_family_c64p_Hwi_Object* __inst, xdc_UArg* arg );
extern ti_sysbios_interfaces_IHwi_FuncPtr ti_sysbios_family_c64p_Hwi_getFunc__R( ti_sysbios_family_c64p_Hwi_Handle __inst, xdc_UArg* arg );

/* setFunc__E */

extern void ti_sysbios_family_c64p_Hwi_setFunc__E( ti_sysbios_family_c64p_Hwi_Handle __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg );

extern void ti_sysbios_family_c64p_Hwi_setFunc__F( ti_sysbios_family_c64p_Hwi_Object* __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg );
extern void ti_sysbios_family_c64p_Hwi_setFunc__R( ti_sysbios_family_c64p_Hwi_Handle __inst, ti_sysbios_interfaces_IHwi_FuncPtr fxn, xdc_UArg arg );

/* getHookContext__E */

extern xdc_Ptr ti_sysbios_family_c64p_Hwi_getHookContext__E( ti_sysbios_family_c64p_Hwi_Handle __inst, xdc_Int id );

extern xdc_Ptr ti_sysbios_family_c64p_Hwi_getHookContext__F( ti_sysbios_family_c64p_Hwi_Object* __inst, xdc_Int id );
extern xdc_Ptr ti_sysbios_family_c64p_Hwi_getHookContext__R( ti_sysbios_family_c64p_Hwi_Handle __inst, xdc_Int id );

/* setHookContext__E */

extern void ti_sysbios_family_c64p_Hwi_setHookContext__E( ti_sysbios_family_c64p_Hwi_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

extern void ti_sysbios_family_c64p_Hwi_setHookContext__F( ti_sysbios_family_c64p_Hwi_Object* __inst, xdc_Int id, xdc_Ptr hookContext );
extern void ti_sysbios_family_c64p_Hwi_setHookContext__R( ti_sysbios_family_c64p_Hwi_Handle __inst, xdc_Int id, xdc_Ptr hookContext );

/* getIrp__E */

extern ti_sysbios_interfaces_IHwi_Irp ti_sysbios_family_c64p_Hwi_getIrp__E( ti_sysbios_family_c64p_Hwi_Handle __inst );

extern ti_sysbios_interfaces_IHwi_Irp ti_sysbios_family_c64p_Hwi_getIrp__F( ti_sysbios_family_c64p_Hwi_Object* __inst );
extern ti_sysbios_interfaces_IHwi_Irp ti_sysbios_family_c64p_Hwi_getIrp__R( ti_sysbios_family_c64p_Hwi_Handle __inst );

/* eventMap__E */

extern void ti_sysbios_family_c64p_Hwi_eventMap__E( xdc_Int intNum, xdc_Int eventId );

extern void ti_sysbios_family_c64p_Hwi_eventMap__F( xdc_Int intNum, xdc_Int eventId );
extern void ti_sysbios_family_c64p_Hwi_eventMap__R( xdc_Int intNum, xdc_Int eventId );

/* plug__E */

extern void ti_sysbios_family_c64p_Hwi_plug__E( xdc_UInt intNum, ti_sysbios_family_c64p_Hwi_PlugFuncPtr fxn );

extern void ti_sysbios_family_c64p_Hwi_plug__F( xdc_UInt intNum, ti_sysbios_family_c64p_Hwi_PlugFuncPtr fxn );
extern void ti_sysbios_family_c64p_Hwi_plug__R( xdc_UInt intNum, ti_sysbios_family_c64p_Hwi_PlugFuncPtr fxn );

/* getHandle__E */

extern ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_getHandle__E( xdc_UInt intNum );

extern ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_getHandle__F( xdc_UInt intNum );
extern ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_getHandle__R( xdc_UInt intNum );

/* disableIER__E */

extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_disableIER__E( xdc_Bits16 mask );

extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_disableIER__F( xdc_Bits16 mask );
extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_disableIER__R( xdc_Bits16 mask );

/* enableIER__E */

extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_enableIER__E( xdc_Bits16 mask );

extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_enableIER__F( xdc_Bits16 mask );
extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_enableIER__R( xdc_Bits16 mask );

/* restoreIER__E */

extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_restoreIER__E( xdc_Bits16 mask );

extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_restoreIER__F( xdc_Bits16 mask );
extern xdc_Bits16 ti_sysbios_family_c64p_Hwi_restoreIER__R( xdc_Bits16 mask );

/* reconfig__E */

extern void ti_sysbios_family_c64p_Hwi_reconfig__E( ti_sysbios_family_c64p_Hwi_Handle __inst, ti_sysbios_family_c64p_Hwi_FuncPtr fxn, const ti_sysbios_family_c64p_Hwi_Params* params );

extern void ti_sysbios_family_c64p_Hwi_reconfig__F( ti_sysbios_family_c64p_Hwi_Object* __inst, ti_sysbios_family_c64p_Hwi_FuncPtr fxn, const ti_sysbios_family_c64p_Hwi_Params* params );
extern void ti_sysbios_family_c64p_Hwi_reconfig__R( ti_sysbios_family_c64p_Hwi_Handle __inst, ti_sysbios_family_c64p_Hwi_FuncPtr fxn, const ti_sysbios_family_c64p_Hwi_Params* params );

/* getIsrStackAddress__I */

extern xdc_Char* ti_sysbios_family_c64p_Hwi_getIsrStackAddress__I( void );

/* getEvent__I */

extern xdc_UInt ti_sysbios_family_c64p_Hwi_getEvent__I( xdc_UInt intNum );

/* dispatchC__I */

extern void ti_sysbios_family_c64p_Hwi_dispatchC__I( xdc_Int intNum );

/* unPluggedInterrupt__I */

extern void ti_sysbios_family_c64p_Hwi_unPluggedInterrupt__I( void );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* getFunc_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_IHwi_FuncPtr (*ti_sysbios_family_c64p_Hwi_getFunc_FxnT)(void*, xdc_UArg*);
static inline ti_sysbios_family_c64p_Hwi_getFunc_FxnT ti_sysbios_family_c64p_Hwi_getFunc_fxnP( void )
{
    return (ti_sysbios_family_c64p_Hwi_getFunc_FxnT)ti_sysbios_family_c64p_Hwi_getFunc__E; 
}

/* setFunc_{FxnT,fxnP} */
typedef void (*ti_sysbios_family_c64p_Hwi_setFunc_FxnT)(void*, ti_sysbios_interfaces_IHwi_FuncPtr, xdc_UArg);
static inline ti_sysbios_family_c64p_Hwi_setFunc_FxnT ti_sysbios_family_c64p_Hwi_setFunc_fxnP( void )
{
    return (ti_sysbios_family_c64p_Hwi_setFunc_FxnT)ti_sysbios_family_c64p_Hwi_setFunc__E; 
}

/* getHookContext_{FxnT,fxnP} */
typedef xdc_Ptr (*ti_sysbios_family_c64p_Hwi_getHookContext_FxnT)(void*, xdc_Int);
static inline ti_sysbios_family_c64p_Hwi_getHookContext_FxnT ti_sysbios_family_c64p_Hwi_getHookContext_fxnP( void )
{
    return (ti_sysbios_family_c64p_Hwi_getHookContext_FxnT)ti_sysbios_family_c64p_Hwi_getHookContext__E; 
}

/* setHookContext_{FxnT,fxnP} */
typedef void (*ti_sysbios_family_c64p_Hwi_setHookContext_FxnT)(void*, xdc_Int, xdc_Ptr);
static inline ti_sysbios_family_c64p_Hwi_setHookContext_FxnT ti_sysbios_family_c64p_Hwi_setHookContext_fxnP( void )
{
    return (ti_sysbios_family_c64p_Hwi_setHookContext_FxnT)ti_sysbios_family_c64p_Hwi_setHookContext__E; 
}

/* getIrp_{FxnT,fxnP} */
typedef ti_sysbios_interfaces_IHwi_Irp (*ti_sysbios_family_c64p_Hwi_getIrp_FxnT)(void*);
static inline ti_sysbios_family_c64p_Hwi_getIrp_FxnT ti_sysbios_family_c64p_Hwi_getIrp_fxnP( void )
{
    return (ti_sysbios_family_c64p_Hwi_getIrp_FxnT)ti_sysbios_family_c64p_Hwi_getIrp__E; 
}

/* reconfig_{FxnT,fxnP} */
typedef void (*ti_sysbios_family_c64p_Hwi_reconfig_FxnT)(void*, ti_sysbios_family_c64p_Hwi_FuncPtr, const ti_sysbios_family_c64p_Hwi_Params*);
static inline ti_sysbios_family_c64p_Hwi_reconfig_FxnT ti_sysbios_family_c64p_Hwi_reconfig_fxnP( void )
{
    return (ti_sysbios_family_c64p_Hwi_reconfig_FxnT)ti_sysbios_family_c64p_Hwi_reconfig__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline ti_sysbios_interfaces_IHwi_Module ti_sysbios_family_c64p_Hwi_Module_upCast( void )
{
    return (ti_sysbios_interfaces_IHwi_Module)&ti_sysbios_family_c64p_Hwi_Module__FXNS__C;
}

/* Module_to_ti_sysbios_interfaces_IHwi */

/* Handle_upCast */
static inline ti_sysbios_interfaces_IHwi_Handle ti_sysbios_family_c64p_Hwi_Handle_upCast( ti_sysbios_family_c64p_Hwi_Handle i )
{
    return (ti_sysbios_interfaces_IHwi_Handle)i;
}

/* Handle_to_ti_sysbios_interfaces_IHwi */

/* Handle_downCast */
static inline ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_Handle_downCast( ti_sysbios_interfaces_IHwi_Handle i )
{
    ti_sysbios_interfaces_IHwi_Handle i2 = (ti_sysbios_interfaces_IHwi_Handle)i;
    return (void*)i2->__fxns == (void*)&ti_sysbios_family_c64p_Hwi_Module__FXNS__C ? (ti_sysbios_family_c64p_Hwi_Handle)i : 0;
}

/* Handle_from_ti_sysbios_interfaces_IHwi */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_family_c64p_Hwi_Module__id ti_sysbios_family_c64p_Hwi_Module_id( void ) 
{
    return ti_sysbios_family_c64p_Hwi_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_family_c64p_Hwi_Module_hasMask( void ) 
{
    return ti_sysbios_family_c64p_Hwi_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_family_c64p_Hwi_Module_getMask( void ) 
{
    return ti_sysbios_family_c64p_Hwi_Module__diagsMask__C != 0 ? *ti_sysbios_family_c64p_Hwi_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_family_c64p_Hwi_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_family_c64p_Hwi_Module__diagsMask__C != 0) *ti_sysbios_family_c64p_Hwi_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_family_c64p_Hwi_Params_init( ti_sysbios_family_c64p_Hwi_Params* prms ) 
{
    if (prms) {
        ti_sysbios_family_c64p_Hwi_Params__init__S(prms, 0, sizeof(ti_sysbios_family_c64p_Hwi_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_family_c64p_Hwi_Params_copy( ti_sysbios_family_c64p_Hwi_Params* dst, const ti_sysbios_family_c64p_Hwi_Params* src ) 
{
    if (dst) {
        ti_sysbios_family_c64p_Hwi_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_family_c64p_Hwi_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_Object_get( ti_sysbios_family_c64p_Hwi_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_family_c64p_Hwi_Handle)ti_sysbios_family_c64p_Hwi_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_Object_first( void )
{
    return (ti_sysbios_family_c64p_Hwi_Handle)ti_sysbios_family_c64p_Hwi_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_Object_next( ti_sysbios_family_c64p_Hwi_Object* obj )
{
    return (ti_sysbios_family_c64p_Hwi_Handle)ti_sysbios_family_c64p_Hwi_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_family_c64p_Hwi_Handle_label( ti_sysbios_family_c64p_Hwi_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_family_c64p_Hwi_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_family_c64p_Hwi_Handle_name( ti_sysbios_family_c64p_Hwi_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_family_c64p_Hwi_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_create( xdc_Int intNum, ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn, const ti_sysbios_family_c64p_Hwi_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_family_c64p_Hwi_Args__create __args;
    __args.intNum = intNum;
    __args.hwiFxn = hwiFxn;
    return (ti_sysbios_family_c64p_Hwi_Handle)ti_sysbios_family_c64p_Hwi_Object__create__S(0, 0, &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_family_c64p_Hwi_Params), __eb);
}

/* construct */
static inline void ti_sysbios_family_c64p_Hwi_construct( ti_sysbios_family_c64p_Hwi_Struct* __obj, xdc_Int intNum, ti_sysbios_interfaces_IHwi_FuncPtr hwiFxn, const ti_sysbios_family_c64p_Hwi_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    ti_sysbios_family_c64p_Hwi_Args__create __args;
    __args.intNum = intNum;
    __args.hwiFxn = hwiFxn;
    ti_sysbios_family_c64p_Hwi_Object__create__S(__obj, sizeof (ti_sysbios_family_c64p_Hwi_Struct), &__args, (const xdc_UChar*)__prms, sizeof(ti_sysbios_family_c64p_Hwi_Params), __eb);
}

/* delete */
static inline void ti_sysbios_family_c64p_Hwi_delete( ti_sysbios_family_c64p_Hwi_Handle* instp )
{
    ti_sysbios_family_c64p_Hwi_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_family_c64p_Hwi_destruct( ti_sysbios_family_c64p_Hwi_Struct* obj )
{
    ti_sysbios_family_c64p_Hwi_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_family_c64p_Hwi_Handle ti_sysbios_family_c64p_Hwi_handle( ti_sysbios_family_c64p_Hwi_Struct* str )
{
    return (ti_sysbios_family_c64p_Hwi_Handle)str;
}

/* struct */
static inline ti_sysbios_family_c64p_Hwi_Struct* ti_sysbios_family_c64p_Hwi_struct( ti_sysbios_family_c64p_Hwi_Handle inst )
{
    return (ti_sysbios_family_c64p_Hwi_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */

/* 
 * Copyright (c) 2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */

/*
 *  ======== Hwi_disable ========
 */

/*
 *  ======== Hwi_enable ========
 */

/*
 *  ======== Hwi_restore ========
 */
/*
 *  @(#) ti.sysbios.family.c64p; 2, 0, 0, 0,548; 3-20-2012 14:02:31; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */





/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) ti.sysbios.family.c64p; 2, 0, 0, 0,548; 3-20-2012 14:02:31; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* NUM_EVENTS */

/* FuncPtr */
typedef void (*ti_sysbios_family_c64p_EventCombiner_FuncPtr)(xdc_UArg);


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* DispatchTabElem */
struct ti_sysbios_family_c64p_EventCombiner_DispatchTabElem {
    ti_sysbios_family_c64p_EventCombiner_FuncPtr fxn;
    xdc_UArg arg;
};

/* Module_State */
typedef ti_sysbios_family_c64p_EventCombiner_DispatchTabElem __T1_ti_sysbios_family_c64p_EventCombiner_Module_State__dispatchTab;
typedef ti_sysbios_family_c64p_EventCombiner_DispatchTabElem __ARRAY1_ti_sysbios_family_c64p_EventCombiner_Module_State__dispatchTab[128];
typedef __ARRAY1_ti_sysbios_family_c64p_EventCombiner_Module_State__dispatchTab __TA_ti_sysbios_family_c64p_EventCombiner_Module_State__dispatchTab;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_family_c64p_EventCombiner_Module__diagsEnabled;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__diagsEnabled ti_sysbios_family_c64p_EventCombiner_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_family_c64p_EventCombiner_Module__diagsIncluded;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__diagsIncluded ti_sysbios_family_c64p_EventCombiner_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_family_c64p_EventCombiner_Module__diagsMask;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__diagsMask ti_sysbios_family_c64p_EventCombiner_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_family_c64p_EventCombiner_Module__gateObj;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__gateObj ti_sysbios_family_c64p_EventCombiner_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_family_c64p_EventCombiner_Module__gatePrms;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__gatePrms ti_sysbios_family_c64p_EventCombiner_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_family_c64p_EventCombiner_Module__id;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__id ti_sysbios_family_c64p_EventCombiner_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerDefined;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerDefined ti_sysbios_family_c64p_EventCombiner_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerObj;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerObj ti_sysbios_family_c64p_EventCombiner_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn0;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn0 ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn1;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn1 ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn2;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn2 ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn4;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn4 ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn8;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn8 ti_sysbios_family_c64p_EventCombiner_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_family_c64p_EventCombiner_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Module__startupDoneFxn ti_sysbios_family_c64p_EventCombiner_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_family_c64p_EventCombiner_Object__count;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Object__count ti_sysbios_family_c64p_EventCombiner_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_family_c64p_EventCombiner_Object__heap;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Object__heap ti_sysbios_family_c64p_EventCombiner_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_family_c64p_EventCombiner_Object__sizeof;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Object__sizeof ti_sysbios_family_c64p_EventCombiner_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_family_c64p_EventCombiner_Object__table;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_Object__table ti_sysbios_family_c64p_EventCombiner_Object__table__C;

/* E_unpluggedEvent */
typedef xdc_runtime_Error_Id CT__ti_sysbios_family_c64p_EventCombiner_E_unpluggedEvent;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_E_unpluggedEvent ti_sysbios_family_c64p_EventCombiner_E_unpluggedEvent__C;

/* EVTMASK */
typedef xdc_Bits32 __T1_ti_sysbios_family_c64p_EventCombiner_EVTMASK;
typedef xdc_Bits32 __ARRAY1_ti_sysbios_family_c64p_EventCombiner_EVTMASK[4];
typedef __ARRAY1_ti_sysbios_family_c64p_EventCombiner_EVTMASK __TA_ti_sysbios_family_c64p_EventCombiner_EVTMASK;
typedef __TA_ti_sysbios_family_c64p_EventCombiner_EVTMASK CT__ti_sysbios_family_c64p_EventCombiner_EVTMASK;
extern far const CT__ti_sysbios_family_c64p_EventCombiner_EVTMASK ti_sysbios_family_c64p_EventCombiner_EVTMASK__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int ti_sysbios_family_c64p_EventCombiner_Module_startup__E( xdc_Int state );

extern xdc_Int ti_sysbios_family_c64p_EventCombiner_Module_startup__F( xdc_Int state );

extern xdc_Int ti_sysbios_family_c64p_EventCombiner_Module_startup__R( xdc_Int state );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_family_c64p_EventCombiner_Module__startupDone__S( void );

/* disableEvent__E */

extern void ti_sysbios_family_c64p_EventCombiner_disableEvent__E( xdc_UInt evt );

extern void ti_sysbios_family_c64p_EventCombiner_disableEvent__F( xdc_UInt evt );
extern void ti_sysbios_family_c64p_EventCombiner_disableEvent__R( xdc_UInt evt );

/* enableEvent__E */

extern void ti_sysbios_family_c64p_EventCombiner_enableEvent__E( xdc_UInt evt );

extern void ti_sysbios_family_c64p_EventCombiner_enableEvent__F( xdc_UInt evt );
extern void ti_sysbios_family_c64p_EventCombiner_enableEvent__R( xdc_UInt evt );

/* dispatch__E */

extern void ti_sysbios_family_c64p_EventCombiner_dispatch__E( xdc_UInt evt );

extern void ti_sysbios_family_c64p_EventCombiner_dispatch__F( xdc_UInt evt );
extern void ti_sysbios_family_c64p_EventCombiner_dispatch__R( xdc_UInt evt );

/* dispatchPlug__E */

extern void ti_sysbios_family_c64p_EventCombiner_dispatchPlug__E( xdc_UInt evt, ti_sysbios_family_c64p_EventCombiner_FuncPtr fxn, xdc_UArg arg, xdc_Bool unmask );

extern void ti_sysbios_family_c64p_EventCombiner_dispatchPlug__F( xdc_UInt evt, ti_sysbios_family_c64p_EventCombiner_FuncPtr fxn, xdc_UArg arg, xdc_Bool unmask );
extern void ti_sysbios_family_c64p_EventCombiner_dispatchPlug__R( xdc_UInt evt, ti_sysbios_family_c64p_EventCombiner_FuncPtr fxn, xdc_UArg arg, xdc_Bool unmask );

/* unused__E */

extern void ti_sysbios_family_c64p_EventCombiner_unused__E( xdc_UArg arg );

extern void ti_sysbios_family_c64p_EventCombiner_unused__F( xdc_UArg arg );
extern void ti_sysbios_family_c64p_EventCombiner_unused__R( xdc_UArg arg );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_family_c64p_EventCombiner_Module__id ti_sysbios_family_c64p_EventCombiner_Module_id( void ) 
{
    return ti_sysbios_family_c64p_EventCombiner_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_family_c64p_EventCombiner_Module_hasMask( void ) 
{
    return ti_sysbios_family_c64p_EventCombiner_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_family_c64p_EventCombiner_Module_getMask( void ) 
{
    return ti_sysbios_family_c64p_EventCombiner_Module__diagsMask__C != 0 ? *ti_sysbios_family_c64p_EventCombiner_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_family_c64p_EventCombiner_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_family_c64p_EventCombiner_Module__diagsMask__C != 0) *ti_sysbios_family_c64p_EventCombiner_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) ti.sysbios.family.c64p; 2, 0, 0, 0,548; 3-20-2012 14:02:31; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) ti.sysbios.family.c66.tci66xx; 2, 0, 0, 0,153; 3-20-2012 14:02:46; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */


/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:32; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */


/* IPC includes */
//#include <ti/ipc/GateMP.h>
//#include <ti/ipc/Ipc.h>
//#include <ti/ipc/ListMP.h>
//#include <ti/ipc/SharedRegion.h>
//#include <ti/ipc/MultiProc.h>

/* 
 *  Copyright (c) 2008 Texas Instruments and others.
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 * 
 *  Contributors:
 *      Texas Instruments - initial implementation
 * 
 * */
/*
 *  ======== global.h ========
 *  This header is used by C/C++ sources that want to "portably" include a
 *  configuration-specific generated header (which contains extern
 *  declarations of configuration specified global variables).
 *
 *  To use this header you must define the symbol xdc_cfg__header__ to be
 *  the package-qualified name of the configuration header.
 *
 *  For example, to compile sources that reference config values
 *  for a TI C6x target with a generated
 *  configuration header named "package/cfg/mycfg_x62.h" in a package
 *  named "local.examples" the following command line is sufficient:
 *
 *      cl6x -Dxdc_cfg__header__=local/examples/package/cfg/mycfg_x62.h ...
 */


/* support old compiler option for naming config include file */

/* if specified, include configuration generated header */

/*
 *  @(#) xdc.cfg; 1, 0, 2, 0,376; 4-27-2012 14:30:17; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/* SRIO Driver Include File. */
/**
 *   @file  srio_drv.h
 *
 *   @brief
 *      Header file for the SRIO Driver. The file exposes the data structures
 *      and exported API which are available for use by the driver users.
 *
 *  \par
 *  NOTE:
 *      (C) Copyright 2009-2012 Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/

/** @defgroup SRIO_LLD_API SRIO LLD
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *  The SRIO Low Level driver provides a well defined standard interface
 *  which allows application developers to send and receive messages via
 *  the Serial RapidIO peripheral. 
 */


/* CPPI Include Files. */
/**
 *   @file  cppi_drv.h
 *
 *   @brief   
 *      This is the CPPI Low Level Driver include file.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/


/** @defgroup CPPI_LLD_API CPPI
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 *
 * @subsection References
 *   -# CPPI Functional Specification 
 *
 * @subsection Assumptions
 *    
 */


/* CSL RL includes */
/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 REVISION_REG;
    volatile Uint32 PERF_CONTROL_REG;
    volatile Uint32 EMULATION_CONTROL_REG;
    volatile Uint32 PRIORITY_CONTROL_REG;
    volatile Uint32 QM_BASE_ADDRESS_REG[4];
} CSL_Cppidma_global_configRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* REVISION_REG */









/* PERF_CONTROL_REG */




/* EMULATION_CONTROL_REG */





/* PRIORITY_CONTROL_REG */




/* QM_BASE_ADDRESS_REG */




/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for RX_CHANNEL_GLOBAL_CONFIG
\**************************************************************************/
typedef struct  {
    volatile Uint32 RX_CHANNEL_GLOBAL_CONFIG_REG;
    volatile Uint8 RSVD0[28];
} CSL_Cppidma_rx_channel_configRx_channel_global_configRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    CSL_Cppidma_rx_channel_configRx_channel_global_configRegs RX_CHANNEL_GLOBAL_CONFIG[129];
} CSL_Cppidma_rx_channel_configRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* RX_CHANNEL_GLOBAL_CONFIG_REG */





/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for RX_FLOW_CONFIG
\**************************************************************************/
typedef struct  {
    volatile Uint32 RX_FLOW_CONFIG_REG_A;
    volatile Uint32 RX_FLOW_CONFIG_REG_B;
    volatile Uint32 RX_FLOW_CONFIG_REG_C;
    volatile Uint32 RX_FLOW_CONFIG_REG_D;
    volatile Uint32 RX_FLOW_CONFIG_REG_E;
    volatile Uint32 RX_FLOW_CONFIG_REG_F;
    volatile Uint32 RX_FLOW_CONFIG_REG_G;
    volatile Uint32 RX_FLOW_CONFIG_REG_H;
} CSL_Cppidma_rx_flow_configRx_flow_configRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    CSL_Cppidma_rx_flow_configRx_flow_configRegs RX_FLOW_CONFIG[129];
} CSL_Cppidma_rx_flow_configRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* RX_FLOW_CONFIG_REG_A */










/* RX_FLOW_CONFIG_REG_B */






/* RX_FLOW_CONFIG_REG_C */







/* RX_FLOW_CONFIG_REG_D */






/* RX_FLOW_CONFIG_REG_E */






/* RX_FLOW_CONFIG_REG_F */




/* RX_FLOW_CONFIG_REG_G */





/* RX_FLOW_CONFIG_REG_H */






/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for TX_CHANNEL_GLOBAL_CONFIG
\**************************************************************************/
typedef struct  {
    volatile Uint32 TX_CHANNEL_GLOBAL_CONFIG_REG_A;
    volatile Uint32 TX_CHANNEL_GLOBAL_CONFIG_REG_B;
    volatile Uint8 RSVD0[24];
} CSL_Cppidma_tx_channel_configTx_channel_global_configRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    CSL_Cppidma_tx_channel_configTx_channel_global_configRegs TX_CHANNEL_GLOBAL_CONFIG[129];
} CSL_Cppidma_tx_channel_configRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* TX_CHANNEL_GLOBAL_CONFIG_REG_A */





/* TX_CHANNEL_GLOBAL_CONFIG_REG_B */






/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 TX_CHANNEL_SCHEDULER_CONFIG_REG[129];
} CSL_Cppidma_tx_scheduler_configRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* TX_CHANNEL_SCHEDULER_CONFIG_REG */



/*  ============================================================================
 *   Copyright (c) Texas Instruments Incorporated 2010
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** 
 *   @file  csl_cppi.h
 *
 *   @brief  
 *      This is the CPPI device specific include file. This file defines various queue 
 *      types
 * 
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2010, Texas Instruments, Inc.
 *  @n   Use of this software is controlled by the terms and conditions found 
 *  @n   in the license agreement under which this software has been supplied.
 *  ===========================================================================
 *  \par
 */

/** @defgroup CSL_CPPI_API CPPI
 *
 */



/**
@addtogroup CPPI_LLD_SYMBOL
@{
*/

/** CPPI maximum number of CPDMAs */

/**
@}
*/

/**
@addtogroup CPPI_LLD_ENUM
@{
*/

/** 
 * @brief CPPI CPDMA types
 */
typedef enum
{
    /** SRIO */
    Cppi_CpDma_SRIO_CPDMA = 0,
    /** PASS */
    Cppi_CpDma_PASS_CPDMA,
    /** QMSS */
    Cppi_CpDma_QMSS_CPDMA
}Cppi_CpDma;

/**
@}
*/






/* ============================================================= */
/**
 *   @file  cppiver.h
 *
 *   path  ti/drv/cppi/cppiver.h
 *
 *   @brief  CPPI sub-system LLD Version Definitions
 *
 *  ============================================================
 *  Copyright (c) Texas Instruments Incorporated 2009-2011
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/**
 * @brief   This is the CPPI LLD Version. Versions numbers are encoded in the following 
 * format:
 *  0xAABBCCDD -> Arch (AA); API Changes (BB); Major (CC); Minor (DD)
 */

/**
 * @brief   This is the version string which describes the CPPI LLD along with the
 * date and build information.
 */


  


/**
@defgroup CPPI_LLD_SYMBOL  CPPI Low Level Driver Symbols Defined
@ingroup CPPI_LLD_API
*/
/**
@defgroup CPPI_LLD_ENUM  CPPI Low Level Driver Enums
@ingroup CPPI_LLD_API
*/
/**
@defgroup CPPI_LLD_DATASTRUCT  CPPI Low Level Driver Data Structures
@ingroup CPPI_LLD_API
*/
/**
@defgroup CPPI_LLD_FUNCTION  CPPI Low Level Driver Functions
@ingroup CPPI_LLD_API
*/
/**
@defgroup CPPI_LLD_OSAL  CPPI Low Level Driver OSAL Functions
@ingroup CPPI_LLD_API
*/

/**
@addtogroup CPPI_LLD_SYMBOL
@{
*/

/** Used as input parameter when queue number is 
 * not known and not specified */

/** CPPI Low level Driver return and Error Codes */
/** CPPI successful return code */
/** CPPI Error Base */       
/** CPPI CPDMA not yet initialized */
/** CPPI invalid parameter */
/** CPPI Rx/Tx channel not yet enabled */
/** CPPI Rx flow not yet enabled */
/** CPPI Tx channels are still open. 
 * All Tx channels should be closed 
 * before calling CPPI_close */
/** CPPI Rx channels are still open. 
 * All Rx channels should be closed 
 * before calling CPPI_close */
/** CPPI Rx flows are still open. 
 * All Rx flows should be closed 
 * before calling CPPI_close */

/** Queue Manager subsystem memory region not enabled */
/** Queue open error */
/** CPPI extended packet information block not present in descriptor */
/** CPPI protocol specific data not present in descriptor */
/** CPPI CPDMA instances are still open. 
 * All CPDMA instances should be closed 
 * before calling CPPI_exit */
/** CPPI resource initialization permission denied */
/** CPPI resource usage permission denied */

/**
@}
*/

/**
@addtogroup CPPI_LLD_ENUM
@{
*/

/** 
 * @brief CPPI Channel type 
 */
typedef enum
{
    /** Receive Channel */
    Cppi_ChType_RX_CHANNEL = 0,
    /** Transmit Channel */
    Cppi_ChType_TX_CHANNEL
}Cppi_ChType;

/** 
 * @brief CPPI Channel Enable
 */
typedef enum
{
    /** Disable Channel */
    Cppi_ChState_CHANNEL_DISABLE = 0,
    /** Enable Channel */
    Cppi_ChState_CHANNEL_ENABLE 
}Cppi_ChState;

/** 
 * @brief CPPI Wait after Channel Teardown
 */
typedef enum
{
    /** No wait */
    Cppi_Wait_NO_WAIT = 0,
    /** Wait */
    Cppi_Wait_WAIT
}Cppi_Wait;


/**
@}
*/

/** @addtogroup CPPI_LLD_DATASTRUCT
@{ 
*/

/** 
 * @brief CPPI global configuration structure
 */
typedef struct
{
    /** CPDMA this configuration belongs to */
    Cppi_CpDma      dmaNum;
    /** Maximum supported Rx Channels */
    uint32_t          maxRxCh;
    /** Maximum supported Tx Channels */
    uint32_t          maxTxCh;
    /** Maximum supported Rx Flows */
    uint32_t          maxRxFlow;
    /** Priority for all Rx transactions of this CPDMA */
    uint8_t           rxPriority;
    /** Priority for all Tx transactions of this CPDMA */
    uint8_t           txPriority;

    /** Base address for the CPDMA overlay registers */

    /** Global Config registers */
    CSL_Cppidma_global_configRegs       *gblCfgRegs;
    /** Tx Channel Config registers */
    CSL_Cppidma_tx_channel_configRegs   *txChRegs;
    /** Rx Channel Config registers */
    CSL_Cppidma_rx_channel_configRegs   *rxChRegs;
    /** Tx Channel Scheduler registers */
    CSL_Cppidma_tx_scheduler_configRegs *txSchedRegs;
    /** Rx Flow Config registers */
    CSL_Cppidma_rx_flow_configRegs      *rxFlowRegs;
}Cppi_GlobalConfigParams;

/** 
 * @brief CPPI heap configuration structure (optional)
 */
typedef struct
{
    /** Optional static heap.  In order to prevent the use of Cppi_osalMalloc,
     * the size should be at least the size returned by @ref Cppi_getHeapReq.
     * Otherwise, Cppi_osalMalloc will be used when the static heap is used.
     * A value of NULL disables the static heap */
    void                        *staticHeapBase;

    /** Optional static heap size in bytes.  Only used when staticHeapBase != NULL */
    uint32_t                     staticHeapSize;

    /** Heap alignment: power of 2 to align front and back of heap.  This
     * applies to both static and dynamic heaps.  A value of 0 means use
     * platform default which is 128 bytes (2^7).  The minimum for correct
     * functionality without shared memory is 3 (2^3 = 8).  */
    uint32_t                     heapAlignPow2;

    /** Dynamic heap block size in bytes.  This is the amount requested from
     * Cppi_osalMalloc, whenever more memory is needed.  Up to @ref heapAlignPow2
     * can be lost at both beginning and end due to alignment, so it is recommended
     * to make this value at least 4*(2^heapAlignPow2) or a minimum of 256 bytes,
     * whichever is larger.  A value of 0 will cause a system default (1024) to
     * be used.  A value < 0 will disable dynamic allocation */
    int32_t                      dynamicHeapBlockSize;
} Cppi_HeapParams;

/** 
 * @brief CPPI CPDMA configuration structure
 */
typedef struct
{
    /** CPDMA configuring control registers */
    Cppi_CpDma                  dmaNum;

    /** This field sets the depth of the write arbitration FIFO which stores write transaction information
     * between the command arbiter and write data arbiters in the Bus Interface Unit. Setting this field to smaller 
     * values will cause prevent the CDMAHP from having an excess of write transactions outstanding whose data is 
     * still waiting to be transferred.
     * System performance can suffer if write commands are allowed to be issued long before the corresponding 
     * write data will be transferred.  This field allows the command count to be optimized based on system dynamics
     *
     * Valid range is 1 to 32. If writeFifoDepth field is set to 0, this field will not be configured. The reset/default value is 20.
     */
    uint8_t                     writeFifoDepth;
    /** This field sets the timeout duration in clock cycles.  This field controls the minimum 
     * amount of time that an Rx channel will be required to wait when it encounters a buffer starvation 
     * condition and the Rx error handling bit is set to 1 (packet is to be preserved - no discard).  
     * If the Rx error handling bit in the flow table is cleared, this field will have no effect on the Rx operation.  
     * When this field is set to 0, the Rx engine will not force an Rx channel to wait after encountering a starvation 
     * event (the feature is disabled).  When this field is set to a value other than 0, the Rx engine will force any 
     * channel whose associated flow had the Rx error handling bit asserted and which encounters starvation to wait for 
     * at least the specified # of clock cycles before coming into context again to retry the access to the QM
     */ 
    uint16_t                    timeoutCount;
    /** The QM N Queues Region Base Address Register is used to provide a programmable 
     * pointer to the base address of the queues region in Queue Manager N in the system 
     */

    /** Queue Manager 0 base address register */
    volatile uint32_t            qm0BaseAddress;
    /** Queue Manager 1 base address register */
    volatile uint32_t            qm1BaseAddress;
    /** Queue Manager 2 base address register */
    volatile uint32_t            qm2BaseAddress;
    /** Queue Manager 3 base address register */
    volatile uint32_t            qm3BaseAddress;
}Cppi_CpDmaInitCfg;

/** 
 * @brief CPPI transmit channel configuration structure
 */
typedef struct
{
    /** Channel number */
    /** If channelNum is set to CPPI_PARAM_NOT_SPECIFIED then the next 
     * available channel will be allocated */
    int32_t           channelNum;
    /** Enable Tx Channel on creation. If not set use CPPI_channelEnable() API to enable it later */
    Cppi_ChState    txEnable;
    /** Tx scheduling priority for channelNum */
    uint8_t           priority;
    /** Tx Filter Software Info.  This field controls whether or not the DMA controller will pass the 
     * extended packet information fields (if present) from the descriptor to the back end application.
     * 0 - DMA controller will pass extended packet info fields if they are present in the descriptor
     * 1 - DMA controller will filter extended packet info fields
     */
    uint16_t             filterEPIB;
    /** Filter Protocol Specific Words. This field controls whether or not the DMA controller will 
     * pass the protocol specific words (if present) from the descriptor to the back end application.
     * 0 - DMA controller will pass PS words if present in descriptor
     * 1 - DMA controller will filter PS words
     */
    uint16_t             filterPS;
    /**
     * AIF Specific Monolithic Packet Mode. This field when set indicates that all monolithic packets 
     * which will be transferred on this channel will be formatted in an optimal configuration as needed 
     * by the Antenna Interface Peripheral.  The AIF configuration uses a fixed descriptor format which 
     * includes the 3 mandatory descriptor info words, a single Protocol Specific Word and data 
     * immediately following (data offset = 16).
     */
    uint16_t             aifMonoMode;
}Cppi_TxChInitCfg;

/** 
 * @brief CPPI receive channel configuration structure
 */
typedef struct
{
    /** Channel number */
    /** If channelNum is set to CPPI_PARAM_NOT_SPECIFIED then the next 
     * available channel will be allocated */
    int32_t           channelNum;
    /** Enable Rx Channel on creation. If not set use CPPI_channelEnable() API to enable it later */
    Cppi_ChState    rxEnable;
}Cppi_RxChInitCfg;

/** 
 * @brief CPPI receive flow configuration structure
 */
typedef struct 
{
    /** Rx flow configuration register A */

    /** flow ID number */
    /** If flowIdNum is set to CPPI_PARAM_NOT_SPECIFIED then the next available flow ID will be allocated */
    int16_t           flowIdNum;
    /** This field indicates the default receive queue that this channel should use */
    uint16_t          rx_dest_qnum;
    /** This field indicates the default receive queue manager that this channel should use */
    uint16_t          rx_dest_qmgr;
    /** This field specifies the number of bytes that are to be skipped in the SOP buffer before beginning 
     * to write the payload or protocol specific bytes(if they are in the sop buffer).  This value must
     * be less than the minimum size of a buffer in the system */
    uint16_t          rx_sop_offset;
    /** This field controls where the Protocol Specific words will be placed in the Host Mode CPPI data structure 
     * 0 - protocol specific information is located in descriptor 
     * 1 - protocol specific information is located in SOP buffer */
    uint16_t             rx_ps_location;
    /** This field indicates the descriptor type to use 1 = Host, 2 = Monolithic */
    uint8_t           rx_desc_type;
    /** This field controls the error handling mode for the flow and is only used when channel errors occurs 
     * 0 = Starvation errors result in dropping packet and reclaiming any used descriptor or buffer resources 
     * back to the original queues/pools they were allocated to
     * 1 = Starvation errors result in subsequent re-try of the descriptor allocation operation.  
     */
    uint16_t             rx_error_handling;
    /** This field controls whether or not the Protocol Specific words will be present in the Rx Packet Descriptor 
     * 0 - The port DMA will set the PS word count to 0 in the PD and will drop any PS words that are presented 
     * from the back end application.
     * 1 - The port DMA will set the PS word count to the value given by the back end application and will copy 
     * the PS words from the back end application to the location 
     */
    uint16_t             rx_psinfo_present;
    /** This field controls whether or not the Extended Packet Info Block will be present in the Rx Packet Descriptor.  
     * 0 - The port DMA will clear the Extended Packet Info Block Present bit in the PD and will drop any extended 
     * packet info words that are presented from the back end application. 
     * 1 - The port DMA will set the Extended Packet Info Block Present bit in the PD and will copy any extended packet
     * info words that are presented across the Rx streaming interface into the extended packet info words in the descriptor.
     * If no extended packet info words are presented from the back end application, the port DMA will overwrite the fields with zeroes.
     */
    uint16_t             rx_einfo_present;

    /** Rx flow configuration register B */

    /** This is the value to insert into bits 7:0 of the destination tag if the rx_dest_tag_lo_sel is set to 1 */
    uint8_t           rx_dest_tag_lo;
    /** This is the value to insert into bits 15:8 of the destination tag if the rx_dest_tag_hi_sel is set to 1 */
    uint8_t           rx_dest_tag_hi;
    /** This is the value to insert into bits 7:0 of the source tag if the rx_src_tag_lo_sel is set to 1 */
    uint8_t           rx_src_tag_lo;
    /** This is the value to insert into bits 15:8 of the source tag if the rx_src_tag_hi_sel is set to 1 */
    uint8_t           rx_src_tag_hi;    

    /** Rx flow configuration register C */
    /** This bits control whether or not the flow will compare the packet size received from the back end application 
     * against the rx_size_thresh0 fields to determine which FDQ to allocate the SOP buffer from.  
     * The bits in this field is encoded as follows:
     * 0 = Do not use the threshold.
     * 1 = Use the thresholds to select SOP FDQ rx_fdq0_sz0_qnum/rx_fdq0_sz0_qmgr.
     */
    uint8_t             rx_size_thresh0_en;
    /** This bits control whether or not the flow will compare the packet size received from the back end application 
     * against the rx_size_thresh1 fields to determine which FDQ to allocate the SOP buffer from.  
     * The bits in this field is encoded as follows:
     * 0 = Do not use the threshold.
     * 1 = Use the thresholds to select SOP FDQ rx_fdq0_sz1_qnum/rx_fdq0_sz1_qmgr.
     */
    uint8_t             rx_size_thresh1_en;
        /** This bits control whether or not the flow will compare the packet size received from the back end application 
     * against the rx_size_thresh2 fields to determine which FDQ to allocate the SOP buffer from.  
     * The bits in this field is encoded as follows:
     * 0 = Do not use the threshold.
     * 1 = Use the thresholds to select SOP FDQ rx_fdq0_sz2_qnum/rx_fdq0_sz2_qmgr.
     */
    uint8_t             rx_size_thresh2_en;

    /** This field specifies the source for bits 7:0 of the source tag field in word 1 of the output PD.
     * This field is encoded as follows:
     * 0 = do not overwrite
     * 1 = overwrite with value given in rx_dest_tag_lo
     * 2 = overwrite with flow_id[7:0] from back end application
     * 3 = RESERVED
     * 4 = overwrite with dest_tag[7:0] from back end application
     * 5 = overwrite with dest_tag[15:8] from back end application
     * 6-7 = RESERVED
     */    
    uint8_t           rx_dest_tag_lo_sel;
    /** This field specifies the source for bits 15:8 of the source tag field in the word 1 of the output PD.
     * This field is encoded as follows:
     * 0 = do not overwrite
     * 1 = overwrite with value given in rx_dest_tag_hi
     * 2 = overwrite with flow_id[7:0] from back end application
     * 3 = RESERVED
     * 4 = overwrite with dest_tag[7:0] from back end application
     * 5 = overwrite with dest_tag[15:8] from back end application
     * 6-7 = RESERVED
     */
    uint8_t           rx_dest_tag_hi_sel;
    /** This field specifies the source for bits 7:0 of the source tag field in the output packet descriptor.
     * This field is encoded as follows:
     * 0 = do not overwrite
     * 1 = overwrite with value given in rx_src_tag_lo
     * 2 = overwrite with flow_id[7:0] from back end application
     * 3 = RESERVED
     * 4 = overwrite with src_tag[7:0] from back end application
     * 5 = RESERVED
     * 6-7 = RESERVED
     */
    uint8_t           rx_src_tag_lo_sel;
    /** This field specifies the source for bits 15:8 of the source tag field in the output packet descriptor.
     * This field is encoded as follows:
     * 0 = do not overwrite
     * 1 = overwrite with value given in rx_src_tag_hi
     * 2 = overwrite with flow_id[7:0] from back end application
     * 3 = RESERVED
     * 4 = overwrite with src_tag[7:0] from back end application
     * 5 = RESERVED
     * 6-7 = RESERVED
     */
    uint8_t           rx_src_tag_hi_sel;    
 
    /** Rx flow configuration register D */

    /** This field specifies which Free Descriptor Queue should be used for the 2nd Rx buffer in a host type packet */
    uint16_t          rx_fdq1_qnum;
    /** This field specifies which Queue Manager should be used for the 2nd Rx buffer in a host type packet */
    uint16_t          rx_fdq1_qmgr;
    /** This field specifies which Free Descriptor Queue should be used for the 1st Rx buffer in a packet whose 
     * size is less than or equal to the rx_size0 value */
    uint16_t          rx_fdq0_sz0_qnum;
    /** This field specifies which Queue Manager should be used for the 1st Rx buffer in a packet whose size 
     * is less than or equal to the rx_size0 value */
    uint16_t          rx_fdq0_sz0_qmgr;

    /** Rx flow configuration register E */

    /** This field specifies which Free Descriptor Queue should be used for the 4th or later Rx
     *  buffers in a host type packet */
    uint16_t          rx_fdq3_qnum;
    /** This field specifies which Queue Manager should be used for the 4th or later Rx buffers 
     * in a host type packet */
    uint16_t          rx_fdq3_qmgr;
    /** This field specifies which Free Descriptor Queue should be used for the 3rd Rx buffer in a host type packet */
    uint16_t          rx_fdq2_qnum;
    /** This field specifies which Queue Manager should be used for the 3rd Rx buffer in a host type packet */
    uint16_t          rx_fdq2_qmgr;

    /** Rx flow configuration register F */

    /** This value is left shifted by 5 bits and compared against the packet size to determine which free descriptor 
     * queue should be used for the SOP buffer in the packet.  If the  packet size is greater than the rx_size_thresh0 
     * but is less than or equal to the value given in this threshold, the DMA controller in the port will allocate the 
     * SOP buffer from the queue given by the rx_fdq0_sz1_qmgr and rx_fdq0_sz1_qnum fields. 
     * If enabled, this value must be greater than the value given in the rx_size_thresh0 field. This field is optional.
     */
    uint16_t          rx_size_thresh1;
    /** This value is left shifted by 5 bits and compared against the packet size to determine which free descriptor 
     * queue should be used for the SOP buffer in the packet.  If the packet size is less than or equal to the value 
     * given in this threshold, the DMA controller in the port will allocate the SOP buffer from the queue given by 
     * the rx_fdq0_sz0_qmgr and rx_fdq0_sz0_qnum fields. This field is optional.
     */
    uint16_t          rx_size_thresh0;
    
    /** Rx flow configuration register G */

    /** This field specifies which Queue should be used for the 1st Rx buffer in a packet whose size is 
     * less than or equal to the rx_size0 value */
    uint16_t          rx_fdq0_sz1_qnum;
    /** This field specifies which Queue Manager should be used for the 1st Rx buffer in a packet whose size 
     * is less than or equal to the rx_size0 value */
    uint16_t          rx_fdq0_sz1_qmgr;
    /** This value is left shifted by 5 bits and compared against the packet size to determine which free descriptor 
     * queue should be used for the SOP buffer in the packet.  If the  packet size is less than or equal to the value
     * given in this threshold, the DMA controller in the port will allocate the SOP buffer from the queue given by the 
     * rx_fdq0_sz2_qmgr and rx_fdq0_sz2_qnum fields.
     * If enabled, this value must be greater than the value given in the rx_size_thresh1 field. This field is optional.
     */
    uint16_t  		rx_size_thresh2;

    /** Rx flow configuration register H */

    /** This field specifies which Free Descriptor Queue should be used for the 1st Rx buffer in a
     * packet whose size is less than or equal to the rx_size3 value */
    uint16_t          rx_fdq0_sz3_qnum;
    /** This field specifies which Free Descriptor Queue Manager should be used for the 1st Rx buffer in a 
     * packet whose size is less than or equal to the rx_size3 value */
    uint16_t          rx_fdq0_sz3_qmgr;
    /** This field specifies which Free Descriptor Queue should be used for the 1st Rx buffer in a packet 
     * whose size is less than or equal to the rx_size2 value */
    uint16_t          rx_fdq0_sz2_qnum;
    /** This field specifies which Free Descriptor Queue Manager should be used for the 1st Rx buffer in a packet 
     * whose size is less than or equal to the rx_size2 value */
    uint16_t          rx_fdq0_sz2_qmgr;
}Cppi_RxFlowCfg;

/** 
 * @brief CPPI RM Handle
 */
typedef void *  Cppi_RmHnd;

/** 
 * @brief CPPI start configuration structure
 */
typedef struct
{
    /** Provide a handle to the Resource Manager instance */
    Cppi_RmHnd rmHandle;
} Cppi_StartCfg;

/** 
 * @brief CPPI init configuration structure
 */
typedef struct
{
    /** dynamic heap configuration parameters */
    Cppi_HeapParams heapParams;
} Cppi_InitCfg;

/** 
 * @brief CPPI return result
 */
typedef int32_t   Cppi_Result;

/** 
 * @brief CPPI handle
 */
typedef uint32_t  *Cppi_Handle;

/** 
 * @brief CPPI channel handle
 */
typedef uint32_t  *Cppi_ChHnd;

/** 
 * @brief CPPI receive flow handle
 */
typedef uint32_t  *Cppi_FlowHnd;

/** 
@} 
*/

/* Exported functions */
extern Cppi_Result Cppi_initCfg (Cppi_GlobalConfigParams *cppiGblCfgParams, Cppi_InitCfg *initCfg);
extern Cppi_Result Cppi_init (Cppi_GlobalConfigParams *cppiGblCfgParams);
extern Cppi_Result Cppi_getHeapReq (Cppi_GlobalConfigParams *cppiGblCfgParams, uint32_t *size);
extern void Cppi_startCfg (Cppi_StartCfg *startCfg);
extern Cppi_Result Cppi_exit (void);
extern Cppi_Handle Cppi_open (Cppi_CpDmaInitCfg *initCfg);
extern Cppi_Result Cppi_close (Cppi_Handle hnd);
extern Cppi_ChHnd Cppi_txChannelOpen (Cppi_Handle hnd, Cppi_TxChInitCfg *cfg, uint8_t *isAllocated);
extern Cppi_ChHnd Cppi_rxChannelOpen (Cppi_Handle hnd, Cppi_RxChInitCfg *cfg, uint8_t *isAllocated);
extern Cppi_Result Cppi_channelEnable (Cppi_ChHnd hnd);
extern Cppi_Result Cppi_channelDisable (Cppi_ChHnd hnd);
extern Cppi_Result Cppi_channelTeardown (Cppi_ChHnd hnd, Cppi_Wait wait);
extern Cppi_Result Cppi_channelClose (Cppi_ChHnd hnd);
extern Cppi_Result Cppi_channelPause (Cppi_ChHnd hnd);
extern Cppi_Result Cppi_channelStatus (Cppi_ChHnd hnd);
extern Cppi_FlowHnd Cppi_configureRxFlow (Cppi_Handle hnd, Cppi_RxFlowCfg *cfg, uint8_t *isAllocated);
extern Cppi_Result Cppi_closeRxFlow (Cppi_FlowHnd hnd);
extern uint32_t Cppi_getChannelNumber (Cppi_ChHnd hnd);
extern uint32_t Cppi_getFlowId (Cppi_FlowHnd hnd);
extern Cppi_Result Cppi_setCpdmaLoopback (Cppi_Handle hnd, uint8_t loopback);
extern Cppi_Result Cppi_getCpdmaLoopback (Cppi_Handle hnd);
extern uint32_t Cppi_getVersion (void);
extern const char* Cppi_getVersionStr (void);



/**
 *   @file  cppi_desc.h
 *
 *   @brief   
 *      This is the CPPI Descriptor Management include file.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009-2011, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/


/** 
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 *
 * @subsection References
 *   -# CPPI Functional Specification 
 *   -# Queue Manager Subsystem Specification 
 *
 * @subsection Assumptions
 *    
 */


/* 
 * Shut off: remark #880-D: parameter "descType" was never referenced
 *
 * This is better than removing the argument since removal would break
 * backwards compatibility
 */
#pragma diag_suppress 880
#pragma diag_suppress 681

/* QMSS LLD includes */
/**
 *   @file  qmss_drv.h
 *
 *   @brief   
 *      This is the Queue Manager Sub System Low Level Driver include file.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/


/** @defgroup QMSS_LLD_API QMSS
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 *
 * @subsection References
 *   -# QMSS Functional Specification 
 *
 * @subsection Assumptions
 *    
 */


/* QMSS includes */


/* ============================================================= */
/**
 *   @file  qmssver.h
 *
 *   path  ti/drv/qmss/qmssver.h
 *
 *   @brief  QMSS sub-system LLD Version Definitions
 *
 *  ============================================================
 *  Copyright (c) Texas Instruments Incorporated 2009-2011
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/**
 * @brief   This is the QMSS LLD Version. Versions numbers are encoded in the following 
 * format:
 *  0xAABBCCDD -> Arch (AA); API Changes (BB); Major (CC); Minor (DD)
 */

/**
 * @brief   This is the version string which describes the QMSS LLD along with the
 * date and build information.
 */


  

/**
 *   @file  qmss_qm.h
 *
 *   @brief   
 *      This is the Queue Manager module include file.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/


/** @defgroup QMSS_LLD_API QMSS
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 *
 * @subsection References
 *   -# QMSS Functional Specification 
 *
 * @subsection Assumptions
 *    
 */


/* QM device specific include file */
//#include <ti/drv/qmss/device/qmss_device.h>
        
/* CSL RL includes */
/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Added register overlay for the QUEUE STATUS which has now been moved
 *         out of the QM_CONFIG Regs to a new location. 
 *      b) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct CSL_Qm_Queue_Status
{
    volatile Uint32 QUEUE_THRESHOLD_STATUS_REG[256];
}CSL_Qm_Queue_Status;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 REVISION_REG;
    volatile Uint8 RSVD0[4];
    volatile Uint32 QUEUE_DIVERSION_REG;
    volatile Uint32 LINKING_RAM_REGION_0_BASE_ADDRESS_REG;
    volatile Uint32 LINKING_RAM_REGION_0_SIZE_REG;
    volatile Uint32 LINKING_RAM_REGION_1_BASE_ADDRESS_REG;
    volatile Uint8 RSVD1[8];
    volatile Uint32 FREE_DESCRIPTOR_STARVE_COUNT_REG[16];
} CSL_Qm_configRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* REVISION_REG */








/* QUEUE_DIVERSION_REG */





/* LINKING_RAM_REGION_0_BASE_ADDRESS_REG */



/* LINKING_RAM_REGION_0_SIZE_REG */



/* LINKING_RAM_REGION_1_BASE_ADDRESS_REG */



/* FREE_DESCRIPTOR_STARVE_COUNT_REG */






/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for MEMORY_REGION_BASE_ADDRESS_GROUP
\**************************************************************************/
typedef struct  {
    volatile Uint32 MEMORY_REGION_BASE_ADDRESS_REG;
    volatile Uint32 MEMORY_REGION_START_INDEX_REG;
    volatile Uint32 MEMORY_REGION_DESCRIPTOR_SETUP_REG;
    volatile Uint8 RSVD0[4];
} CSL_Qm_descriptor_region_configMemory_region_base_address_groupRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    CSL_Qm_descriptor_region_configMemory_region_base_address_groupRegs MEMORY_REGION_BASE_ADDRESS_GROUP[20];
} CSL_Qm_descriptor_region_configRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* MEMORY_REGION_BASE_ADDRESS_REG */



/* MEMORY_REGION_START_INDEX_REG */



/* MEMORY_REGION_DESCRIPTOR_SETUP_REG */




/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for QUEUE_MGMT_GROUP
\**************************************************************************/
typedef struct  {
    volatile Uint32 QUEUE_REG_A;
    volatile Uint32 QUEUE_REG_B;
    volatile Uint32 QUEUE_REG_C;
    volatile Uint32 QUEUE_REG_D;
} CSL_Qm_queue_managementQueue_mgmt_groupRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    CSL_Qm_queue_managementQueue_mgmt_groupRegs QUEUE_MGMT_GROUP[8192];
} CSL_Qm_queue_managementRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* QUEUE_REG_A */



/* QUEUE_REG_B */



/* QUEUE_REG_C */




/* QUEUE_REG_D */




/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for QUEUE_STATUS_CONFIG_GROUP
\**************************************************************************/
typedef struct  {
    volatile Uint32 QUEUE_STATUS_CONFIG_REG_A;
    volatile Uint32 QUEUE_STATUS_CONFIG_REG_B;
    volatile Uint32 QUEUE_STATUS_CONFIG_REG_C;
    volatile Uint32 QUEUE_STATUS_CONFIG_REG_D;
} CSL_Qm_queue_status_configQueue_status_config_groupRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    CSL_Qm_queue_status_configQueue_status_config_groupRegs QUEUE_STATUS_CONFIG_GROUP[8192];
} CSL_Qm_queue_status_configRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* QUEUE_STATUS_CONFIG_REG_A */



/* QUEUE_STATUS_CONFIG_REG_B */



/* QUEUE_STATUS_CONFIG_REG_C */



/* QUEUE_STATUS_CONFIG_REG_D */




/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 PDSP_CONTROL_REG;
    volatile Uint32 PDSP_STATUS_REG;
    volatile Uint32 PDSP_WAKEUP_ENABLE_REG;
    volatile Uint32 PDSP_CYCLE_COUNT_REG;
    volatile Uint32 PDSP_STALL_COUNT_REG;
    volatile Uint8 RSVD0[12];
    volatile Uint32 PDSP_CONSTANT_TABLE_BLOCK_INDEX_REG_0;
    volatile Uint32 PDSP_CONSTANT_TABLE_BLOCK_INDEX_REG_1;
    volatile Uint32 PDSP_CONSTANT_TABLE_PROG_PTR_REG_0;
    volatile Uint32 PDSP_CONSTANT_TABLE_PROG_PTR_REG_1;
} CSL_PdspRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* PDSP_CONTROL_REG */










/* PDSP_STATUS_REG */



/* PDSP_WAKEUP_ENABLE_REG */



/* PDSP_CYCLE_COUNT_REG */



/* PDSP_STALL_COUNT_REG */



/* PDSP_CONSTANT_TABLE_BLOCK_INDEX_REG_0 */




/* PDSP_CONSTANT_TABLE_BLOCK_INDEX_REG_1 */




/* PDSP_CONSTANT_TABLE_PROG_PTR_REG_0 */




/* PDSP_CONSTANT_TABLE_PROG_PTR_REG_1 */




/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 REVISION_REG;
    volatile Uint8 RSVD0[12];
    volatile Uint32 EOI_REG;
    volatile Uint32 INTR_VECTOR_REG;
    volatile Uint8 RSVD1[488];
    volatile Uint32 STATUS_REG0;
    volatile Uint32 STATUS_REG1;
    volatile Uint32 STATUS_REG2;
    volatile Uint32 STATUS_REG3;
    volatile Uint32 STATUS_REG4;
    volatile Uint8 RSVD2[108];
    volatile Uint32 STATUS_CLR_REG0;
    volatile Uint32 STATUS_CLR_REG1;
    volatile Uint8 RSVD3[8];
    volatile Uint32 STATUS_CLR_REG4;
    volatile Uint8 RSVD4[108];
    volatile Uint32 INTCNT_REG[50];
    volatile Uint8 RSVD5[184];
    volatile Uint32 INTR_VECTOR_REG_HOST;
} CSL_Qm_intdRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* REVISION_REG */








/* EOI_REG */



/* INTR_VECTOR_REG */



/* STATUS_REG0 */



/* STATUS_REG1 */



/* STATUS_REG2 */



/* STATUS_REG3 */



/* STATUS_REG4 */




/* STATUS_CLR_REG0 */



/* STATUS_CLR_REG1 */



/* STATUS_CLR_REG4 */




/* INTCNT_REG */



/* INTR_VECTOR_REG_HOST */



/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for MCDMA_CHANNEL_CONFIG_GROUP
\**************************************************************************/
typedef struct  {
    volatile Uint32 SRC_ADDR_REG;
    volatile Uint32 DST_ADDR_REG;
    volatile Uint32 XFER_CTRL_REG;
    volatile Uint8 RSVD0[52];
} CSL_McdmaMcdma_channel_config_groupRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    CSL_McdmaMcdma_channel_config_groupRegs MCDMA_CHANNEL_CONFIG_GROUP[4];
} CSL_McdmaRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* SRC_ADDR_REG */



/* DST_ADDR_REG */



/* XFER_CTRL_REG */









/********************************************************************
* Copyright (C) 2003-2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 TIMER_CNTRL_REG;
    volatile Uint32 TIMER_LOAD_REG;
    volatile Uint32 TIMER_VALUE_REG;
    volatile Uint32 TIMER_IRQ_REG;
} CSL_Cp_timer16Regs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* TIMER_CNTRL_REG */






/* TIMER_LOAD_REG */



/* TIMER_VALUE_REG */



/* TIMER_IRQ_REG */



/*  ============================================================================
 *   Copyright (c) Texas Instruments Incorporated 2010
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** 
 *   @file  csl_qm_queue.h
 *
 *   @brief  
 *      This is the Queue Manager device specific include file. This file defines various queue 
 *      types
 * 
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2010, Texas Instruments, Inc.
 *  @n   Use of this software is controlled by the terms and conditions found 
 *  @n   in the license agreement under which this software has been supplied.
 *  ===========================================================================
 *  \par
 */

/** @defgroup CSL_QMSS_API QMSS
 *
 */



/** 
 * @brief Queue start number and maximum number of each type of queue supported.
 */

/** 
 * @brief Queue Type. Specifies different queue classifications
 */
typedef enum
{
    /** Low priority queue */
    Qmss_QueueType_LOW_PRIORITY_QUEUE = 0,
    /** PASS queue */
    Qmss_QueueType_PASS_QUEUE,
    /** INTC pending queue */
    Qmss_QueueType_INTC_QUEUE,
    /** SRIO queue */
    Qmss_QueueType_SRIO_QUEUE,
    /** High priority queue */
    Qmss_QueueType_HIGH_PRIORITY_QUEUE,
    /** starvation counter queue */
    Qmss_QueueType_STARVATION_COUNTER_QUEUE,
    /** Infrastructure queue */
    Qmss_QueueType_INFRASTRUCTURE_QUEUE,
    /** Traffic shaping queue */
    Qmss_QueueType_TRAFFIC_SHAPING_QUEUE,
    /** General purpose queue */
    Qmss_QueueType_GENERAL_PURPOSE_QUEUE
}Qmss_QueueType;




/**
@defgroup QMSS_LLD_SYMBOL  QMSS Low Level Driver Symbols Defined
@ingroup QMSS_LLD_API
*/
/**
@defgroup QMSS_LLD_ENUM  QMSS Low Level Driver Enums
@ingroup QMSS_LLD_API
*/
/**
@defgroup QMSS_LLD_DATASTRUCT  QMSS Low Level Driver Data Structures
@ingroup QMSS_LLD_API
*/
/**
@defgroup QMSS_LLD_FUNCTION  QMSS Low Level Driver Functions
@ingroup QMSS_LLD_API
*/
/**
@defgroup QMSS_LLD_OSAL  QMSS Low Level Driver OSAL Functions
@ingroup QMSS_LLD_API
*/

/**
@addtogroup QMSS_LLD_SYMBOL
@{
*/

/** Internal Linking RAM offset */
/** Internal Linking RAM default size */

/** Used as input parameter when queue number is 
 * not known and not specified */

/** Used to indicate that QMSS HW Initialization is complete */

/** QMSS Low level Driver return and Error Codes */
/** QMSS successful return code */
/** QMSS Error Base */       
/** QMSS LLD invalid parameter */
/** QMSS LLD not initialized */
/** QMSS LLD queue open error */
/** QMSS memory region not initialized */
/** QMSS memory region already initialized */
/** QMSS memory region invalid parameter */
/** QMSS maximum number of allowed descriptor are already configured */
/** QMSS Specified memory region index is invalid or no memory regions are available */
/** QMSS memory region overlap */
/** QMSS memory region not in acscending order */
/** QMSS PDSP firmware download failure */
/** QMSS resource initialization permission denied */
/** QMSS resource usage permission denied */
/** QMSS memory region initialization permission denied */
/** QMSS memory region usage permission denied */
/** QMSS general linking RAM initialization permission denied */
/** QMSS firmware revision difference */

/** QMSS maximum number of memory regions */

/** Macro to get the descriptor pointer if the popped descriptor contains the descriptor size. 
 * If Qmss_queuePushDescSize() API is used to push a descriptor onto a queue, the descriptor when 
 * popped will have the descriptor size information in the lower 4 bits. This macro is provided to 
 * clear out the size information */

/** Macro to get the descriptor size if the popped descriptor contains the descriptor size. 
 * If Qmss_queuePushDescSize() API is used to push a descriptor onto a queue, the descriptor when 
 * popped will have the descriptor size information in the lower 4 bits. This macro is provided to 
 * obtain the size information. Minimum size is 16 bytes. Maximum size is 256 bytes */

/**
@}
*/

/**
@addtogroup QMSS_LLD_ENUM
@{
*/

/** 
 * @brief location where the packet is queued
 */
typedef enum
{
    /** Queue packet to the tail of the queue. Default behavior. */
    Qmss_Location_TAIL = 0,
    /** Queue packet to the head of the queue. */
    Qmss_Location_HEAD 
}Qmss_Location;

/** 
 * @brief Descriptor resource management
 */
typedef enum
{
    /** LLD doesnot manage the descriptors. The caller should manage them. */
    Qmss_ManageDesc_UNMANAGED_DESCRIPTOR = 0,
    /** LLD manages the descriptors. The descriptors are reclaimed using 
     * the QMSS_initDescriptor() or CPPI_initDescriptor() APIs
     * */
    Qmss_ManageDesc_MANAGE_DESCRIPTOR 
}Qmss_ManageDesc;

/** 
 * @brief Queue Manager's memory regions
 */
typedef enum
{
    /** Memory region not specified. LLD allocates the next available memory region */
    Qmss_MemRegion_MEMORY_REGION_NOT_SPECIFIED = -1,
    /** Configure memory region0. */
    Qmss_MemRegion_MEMORY_REGION0 = 0,
    /** Configure memory region 1. */
    Qmss_MemRegion_MEMORY_REGION1,
    /** Configure memory region 2. */
    Qmss_MemRegion_MEMORY_REGION2,
    /** Configure memory region 3. */
    Qmss_MemRegion_MEMORY_REGION3,
    /** Configure memory region 4. */
    Qmss_MemRegion_MEMORY_REGION4,
    /** Configure memory region 5. */
    Qmss_MemRegion_MEMORY_REGION5,
    /** Configure memory region 6. */
    Qmss_MemRegion_MEMORY_REGION6,
    /** Configure memory region 7. */
    Qmss_MemRegion_MEMORY_REGION7,
    /** Configure memory region 8. */
    Qmss_MemRegion_MEMORY_REGION8,
    /** Configure memory region 9. */
    Qmss_MemRegion_MEMORY_REGION9,
    /** Configure memory region 10. */
    Qmss_MemRegion_MEMORY_REGION10,
    /** Configure memory region 11. */
    Qmss_MemRegion_MEMORY_REGION11,
    /** Configure memory region 12. */
    Qmss_MemRegion_MEMORY_REGION12,
    /** Configure memory region 13. */
    Qmss_MemRegion_MEMORY_REGION13,
    /** Configure memory region 14. */
    Qmss_MemRegion_MEMORY_REGION14,
    /** Configure memory region 15. */
    Qmss_MemRegion_MEMORY_REGION15,
    /** Configure memory region 16. */
    Qmss_MemRegion_MEMORY_REGION16,
    /** Configure memory region 17. */
    Qmss_MemRegion_MEMORY_REGION17,
    /** Configure memory region 18. */
    Qmss_MemRegion_MEMORY_REGION18,
    /** Configure memory region 19. */
    Qmss_MemRegion_MEMORY_REGION19
}Qmss_MemRegion;

/** 
 * @brief PDSP ID
 */
typedef enum
{
    /** PDSP 1 */
    Qmss_PdspId_PDSP1 = 0,
    /** PDSP 2 */
    Qmss_PdspId_PDSP2
}Qmss_PdspId;

/** 
 * @brief INTD interrupt types
 */
typedef enum
{
    /** Interrupt generated for the high priority accumulator.
     * 32 interrupts are generated in response to events in the 32 high-priority queues.
     */
    Qmss_IntdInterruptType_HIGH = 0,
    /** Interrupt generated for the low priority accumulator.
     * 16 interrupts are generated in response to events in the 512 low-priority queues.
     */
    Qmss_IntdInterruptType_LOW,
    /** Interrupt generated for QMSS CDMA.
     * 2 interrupts are generated for buffer descriptor starvation event on 
     * receive SOP (start of packet) and MOP (middle of packet) for any of the receive DMA units in the CDMA.
     */
    Qmss_IntdInterruptType_CDMA
}Qmss_IntdInterruptType;

/**
@}
*/

/** @addtogroup QMSS_LLD_DATASTRUCT
@{ 
*/

/** 
 * @brief QMSS RM Handle
 */
typedef void *  Qmss_RmHnd;

/** 
 * @brief QMSS start configuration structure
 */
typedef struct
{
    /** Provide a handle to the Resource Manager instance */
    Qmss_RmHnd rmHandle;
} Qmss_StartCfg;

/** 
 * @brief Queue definition
 */
typedef struct
{
    /** Queue manager number */
    int32_t qMgr;        
    /** Queue number within Queue Manager */
    int32_t qNum;
}Qmss_Queue;

/** 
 * @brief Queue definition
 */
typedef struct
{
    /** Queue manager number */
    int32_t     startIndex;        
    /** Queue number within Queue Manager */
    int32_t     maxNum;
}Qmss_QueueNumRange;

/** 
 * @brief descriptor configuration structure
 */
typedef struct 
{
    uint32_t          memRegion;
    /** Number of descriptors that should be allocated */
    uint32_t          descNum;
    /** Queue where the descriptor is stored. If QueueNum is set to QMSS_PARAM_NOT_SPECIFIED then the next 
     * available queue of type Qmss_QueueType will be allocated */
    int32_t           destQueueNum;
    /** If QueueNum is set to QMSS_PARAM_NOT_SPECIFIED then the next available queue of type 
     * Qmss_QueueType will be allocated */
    Qmss_QueueType  queueType;
}Qmss_DescCfg;

/** 
 * @brief Memory region configuration information structure
 */
typedef struct 
{
    /** The base address of descriptor region. Note the 
     * descriptor Base address must be specified in ascending memory order
     * */
    uint32_t          *descBase;
    /** Size of each descriptor in the memory region. Must be a multiple of 16 */
    uint32_t          descSize;
    /** Number of descriptors in the memory region. 
     * Must be a minimum of 32. 
     * Must be 2^(5 or greater) 
     * Maximum supported value 2^20
     * */
    uint32_t          descNum;

    /** Memory Region corresponding to the descriptor. 
     * At init time this field must have a valid memory region 
     * index (0 to Maximum number of memory regions supported).
     *
     * At runtime this field is used to either 
     *      * set to Qmss_MemRegion_MEMORY_REGION_NOT_SPECIFIED, in this case the LLD 
     *      * will decide which memory region to use.
     *      * OR 
     *      * specify the descriptor memory region, must be a valid memory 
     *      * region index (0 to Maximum number of memory regions supported).
     */
    Qmss_MemRegion  memRegion;
    /** Flag control whether the descriptors are managed 
     * by LLD or by the caller allocating descriptor memory */
    Qmss_ManageDesc manageDescFlag;
    /** Used to leave holes by configuring dummy regions which can be later 
     * configured with actual values. Must be calculated and a correct startIndex must be 
     * specified if memRegion value is valid (0 to Maximum number of memory regions supported). */
    uint32_t          startIndex;
} Qmss_MemRegInfo;

/** 
 * @brief Memory region configuration information structure of all memory regions
 */
typedef struct 
{
    /** Descriptor information for each CPDMA passed during cppi_Init */
    Qmss_MemRegInfo memRegInfo[20];
    /** Current descriptor count. Sum of descriptors in all memory regions */
    uint32_t          currDescCnt;
} Qmss_MemRegCfg;

/** 
 * @brief QMSS PDSP firmware download information structure
 */
typedef struct
{
    /** ID of the PDSP to download this firmware to */
    Qmss_PdspId     pdspId;
    /** Pointer to the firmware image, If the firmware pointer is NULL, LLD will not 
     * download the firmware */
    void            *firmware;
    /** Size of firmware in bytes */
    uint32_t          size; 
}Qmss_PdspCfg;

/** 
 * @brief QMSS configuration structure
 */
typedef struct
{
    /** Base address of Linking RAM 0. LLD will configure linking RAM0 address to internal linking RAM 
     * address if a value of zero is specified. */
    uint32_t          linkingRAM0Base;
    /** Linking RAM 0 Size. LLD will configure linking RAM0 size to maximum internal linking RAM 
     * size if a value of zero is specified*/
    uint32_t          linkingRAM0Size; 
    /** Base address of Linking RAM 1. Depends on RAM 0 Size and total number of 
     * descriptors. If linkingRAM1Base is zero then linkingRAM0Size must be large 
     * enough to store all descriptors in the system */
    uint32_t          linkingRAM1Base;
    /** Maximum number of descriptors in the system. Should be equal to less than 
     * the RAM0+RAM1 size */
    uint32_t          maxDescNum;
    /** PDSP firmware to download. If the firmware pointer is NULL, LLD will not download the firmware */
    Qmss_PdspCfg    pdspFirmware[2];
    /** Status of QMSS HW. Set this to QMSS_HW_INIT_COMPLETE in case Initialization is already complete.
      * Setting this flag will bypass any QMSS Hardware initialization
      */
    uint32_t          qmssHwStatus;
}Qmss_InitCfg;

/** 
 * @brief QMSS Global configuration structure definition
 */
typedef struct
{
    /** Maximum number of queue Managers */
    uint32_t                                maxQueMgr;
    /** Maximum number of queues */
    uint32_t                                maxQue;

    /** Queue start index and maximum number of queues of each queue type */
    Qmss_QueueNumRange                      maxQueueNum[25];

    /** Base address for the CPDMA overlay registers */

    /** QM Global Config registers */
    CSL_Qm_configRegs                       *qmConfigReg;
    /** QM Descriptor Config registers */
    CSL_Qm_descriptor_region_configRegs     *qmDescReg;
    /** QM queue Management registers, accessed via CFG port */
    CSL_Qm_queue_managementRegs             *qmQueMgmtReg;
    /** QM queue Management Proxy registers, accessed via CFG port */
    CSL_Qm_queue_managementRegs             *qmQueMgmtProxyReg;
    /** QM queue status registers */
    CSL_Qm_queue_status_configRegs          *qmQueStatReg;
    /** QM INTD registers */
    CSL_Qm_intdRegs                         *qmQueIntdReg;
    /** QM PDSP command register */
    volatile uint32_t                       *qmPdspCmdReg[2];
    /** QM PDSP control register */
    CSL_PdspRegs                            *qmPdspCtrlReg[2];
    /** QM PDSP IRAM register */
    volatile uint32_t                       *qmPdspIRamReg[2];
    /** QM Status RAM */
    CSL_Qm_Queue_Status                     *qmStatusRAM;
    /** QM Linking RAM register */
    volatile uint32_t                       *qmLinkingRAMReg;
    /** QM McDMA register */
    CSL_McdmaRegs                           *qmMcDMAReg;
    /** QM Timer16 register */
    CSL_Cp_timer16Regs                      *qmTimer16Reg[2];
    /** QM queue Management registers, accessed via DMA port */
    CSL_Qm_queue_managementRegs             *qmQueMgmtDataReg;
    /** QM queue Management Proxy registers, accessed via DMA port */
    CSL_Qm_queue_managementRegs             *qmQueMgmtProxyDataReg;
    /** QM stores the Resource Manager handle for internal use */
    Qmss_RmHnd                              qmRmHandle;

}Qmss_GlobalConfigParams;

/** 
 * @brief Queue handle
 */
typedef int32_t   Qmss_QueueHnd;

/** 
 * @brief QMSS return result
 */
typedef int32_t   Qmss_Result;

/** 
 * @brief Handle used in the "Fast Push" set of APIs
 */
typedef uint32_t* Qmss_QueuePushHnd;

/** 
@} 
*/

/* Exported functions */
extern Qmss_Result Qmss_init (Qmss_InitCfg *initCfg, Qmss_GlobalConfigParams *qmssGblCfgParams);
extern Qmss_Result Qmss_start (void);
extern Qmss_Result Qmss_startCfg(Qmss_StartCfg *startCfg);
extern Qmss_Result Qmss_getMemoryRegionCfg (Qmss_MemRegCfg *memRegInfo);
extern Qmss_Result Qmss_insertMemoryRegion (Qmss_MemRegInfo *memRegCfg);
extern Qmss_QueueHnd Qmss_initDescriptor (Qmss_DescCfg *descCfg, uint32_t *numAllocated);
extern Qmss_QueueHnd Qmss_queueOpen (Qmss_QueueType queType, int32_t queNum, uint8_t *isAllocated);
extern Qmss_QueueHnd Qmss_queueOpenInRange (uint32_t startQueNum, uint32_t endQueNum, uint8_t *isAllocated);
extern Qmss_Result Qmss_queueClose (Qmss_QueueHnd hnd);
extern uint32_t Qmss_getQueueThreshold (Qmss_QueueHnd hnd);
extern Qmss_Result Qmss_setQueueThreshold (Qmss_QueueHnd hnd, uint16_t hilo, uint8_t threshold);
extern uint32_t Qmss_getStarvationCount (Qmss_QueueHnd hnd);
extern uint16_t Qmss_getQueueThresholdStatus (Qmss_QueueHnd hnd);
extern Qmss_Queue Qmss_getQueueNumber (Qmss_QueueHnd hnd);
extern Qmss_QueueHnd Qmss_getQueueHandle (Qmss_Queue queue);
extern uint32_t Qmss_getMemRegDescSize (uint32_t memRegion);
extern Qmss_Result Qmss_downloadFirmware (Qmss_PdspId pdspId, void *image, uint32_t size);
extern Qmss_Result Qmss_setEoiVector (Qmss_IntdInterruptType type, uint8_t accumCh);
extern Qmss_Result Qmss_ackInterrupt (uint8_t interruptNum, uint8_t value);
extern uint32_t Qmss_getVersion (void);
extern const char* Qmss_getVersionStr (void);
 


/**
 *   @file  qmss_acc.h
 *
 *   @brief   
 *      This is the Queue Manager accumulator header file.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009-2011, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/




/* QMSS LLD includes */
/**
 *   @file  qmss_drv.h
 *
 *   @brief   
 *      This is the Queue Manager Sub System Low Level Driver include file.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/


/** @defgroup QMSS_LLD_API QMSS
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 *
 * @subsection References
 *   -# QMSS Functional Specification 
 *
 * @subsection Assumptions
 *    
 */


/**
@addtogroup QMSS_LLD_SYMBOL
@{
*/

/** QMSS accumulator return and Error Codes */
/** QMSS accumulator idle return code */
/** QMSS accumulator successful return code */
/** QMSS accumulator invalid command return code */
/** QMSS accumulator invalid channel return code */
/** QMSS accumulator channel not active return code */
/** QMSS accumulator channel already active */
/** QMSS accumulator invalid queue number */

/**
@}
*/

/**
@addtogroup QMSS_LLD_ENUM
@{
*/

/** 
 * @brief Accumulator channel commands
 */
typedef enum
{
    /** Accumulator command to disable channel */
    Qmss_AccCmd_DISABLE_CHANNEL = 0x80,
    /** Accumulator command to enable channel */
    Qmss_AccCmd_ENABLE_CHANNEL = 0x81,
    /** Accumulator command to configure timer constant */
    Qmss_AccCmd_CONFIG_TIMER_CONSTANT = 0x82,
    /** Accumulator command to configure reclamation queue */
    Qmss_AccCmd_CONFIG_RECLAIM_QUEUE = 0x83,
    /** Accumulator command to configure diversion queue */
    Qmss_AccCmd_CONFIG_DIVERSION_QUEUE = 0x84

}Qmss_AccCmdType;

/** 
 * @brief Accumulator configuration - interrupt pacing mode
 */
typedef enum
{
    /** Interrupt on entry threshold count only */
    Qmss_AccPacingMode_NONE = 0,
    /** Time delay since last interrupt */
    Qmss_AccPacingMode_LAST_INTERRUPT,
    /** Time delay since first new packet */
    Qmss_AccPacingMode_FIRST_NEW_PACKET,
    /** Time delay since last new packet */
    Qmss_AccPacingMode_LAST_NEW_PACKET
}Qmss_AccPacingMode;

/** 
 * @brief Accumulator configuration - list entry size
 */
typedef enum
{
    /** 'D' register only (4 byte entries)
     * Word 0 : Packet Descriptor Pointer 
     */
    Qmss_AccEntrySize_REG_D = 0,
    /** 'C,D' registers (8 byte entries) 
     * Word 0 : Packet Length (as reported by queue manager)
     * Word 1 : Packet Descriptor Pointer
     */
    Qmss_AccEntrySize_REG_CD,
    /** 'A,B,C,D' registers (16 byte entries) 
     * Word 0 : Packet Count on Queue (when read)
     * Word 1 : Byte Count on Queue (when read)
     * Word 2 : Packet Length (as reported by queue manager)
     * Word 3 : Packet Descriptor Pointer
     */
    Qmss_AccEntrySize_REG_ABCD
}Qmss_AccEntrySize;

/** 
 * @brief Accumulator configuration - list count mode
 */
typedef enum
{
    /** NULL Terminate Mode - The last list entry is used to store a NULL pointer 
     * record (NULL terminator) to mark the end of list. In either case there is room for one less 
     * list entry in a page than is actually specified by the host.
     */
    Qmss_AccCountMode_NULL_TERMINATE = 0,
    /** Entry Count Mode - The first list entry is used to store the total list entry 
     * count (not including the length entry). 
     */
    Qmss_AccCountMode_ENTRY_COUNT
}Qmss_AccCountMode;


/** 
 * @brief Accumulator configuration - Multi-Queue Mode
 */
typedef enum
{
    /** Single Queue Mode - The channel monitors a single queue. */
    Qmss_AccQueueMode_SINGLE_QUEUE = 0,
    /** Multi-Queue Mode - The channel monitors up to 32 queues starting at the supplied base queue index. */
    Qmss_AccQueueMode_MULTI_QUEUE
}Qmss_AccQueueMode;

/**
@}
*/

/** @addtogroup QMSS_LLD_DATASTRUCT
@{ 
*/

/** 
 * @brief Accumulator Command interface structure
 */
typedef struct
{
    /** Accumulator channel affected (0-47) */
    uint8_t               channel;
    /** Accumulator channel command - Qmss_AccCmd_ENABLE_CHANNEL : Enable channel 
     * Qmss_AccCmd_DISABLE_CHANNEL : Disable channel */
    Qmss_AccCmdType     command;
    /** This field specifies which queues are to be included in the queue group. 
     * Bit 0 corresponds to the base queue index, and bit 31 corresponds to the base 
     * queue index plus 31. For any bit set in this mask, the corresponding queue index 
     * is included in the monitoring function.
     *
     * This field is ignored in single-queue mode.*/
    uint32_t              queueEnMask;
    /** Physical pointer to list ping/pong buffer. NULL when channel disabled */
    uint32_t              listAddress;
    /** Queue Manager and Queue Number index to monitor. This serves as a base queue index when the 
     * channel in multi-queue mode, and must be a multiple of 32 when multi-queue mode is enabled. */
    uint16_t              queMgrIndex;
    /** Max entries per list buffer page */
    uint16_t              maxPageEntries;
    /** Number of timer ticks to delay interrupt */
    uint16_t              timerLoadCount;
    /** Interrupt pacing mode. Specifies when the interrupt should be trigerred */
    Qmss_AccPacingMode  interruptPacingMode;
    /** List entry size. Specifies the size of each data entry */
    Qmss_AccEntrySize   listEntrySize;
    /** List count Mode. The number of entries in the list */
    Qmss_AccCountMode   listCountMode; 
    /** Queue mode. Moitor single or multiple queues */
    Qmss_AccQueueMode   multiQueueMode;
} Qmss_AccCmdCfg;

/** 
@} 
*/

/* Internal data structure to write accumulator command */
typedef struct
{
    /* Channel, Command */
    uint32_t              word0;
    /* Queue enable mask */
    uint32_t              word1; 
    /* List buffer physical address */
    uint32_t              word2; 
    /* Queue manager and base index, Maximum page entries */
    uint32_t              word3; 
    /* Timer Load Count, Configuration */
    uint32_t              word4; 
} Qmss_AccCmd;

/* Exported functions */
extern Qmss_Result Qmss_programAccumulator (Qmss_PdspId pdspId, Qmss_AccCmdCfg *cfg);
extern Qmss_Result Qmss_disableAccumulator (Qmss_PdspId pdspId, uint8_t channel);
extern Qmss_Result Qmss_configureAccTimer (Qmss_PdspId pdspId, uint16_t timerConstant);
extern Qmss_Result Qmss_programReclaimQueue (Qmss_PdspId pdspId, Qmss_QueueHnd hnd);
extern Qmss_Result Qmss_programDiversionQueue (Qmss_PdspId pdspId, Qmss_QueueHnd divQ,
                                               Qmss_QueueHnd divCompletionQ);



/**
 *   @file  qmss_qos.h
 *
 *   @brief   
 *      This is the QMSS QOS header file.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009-2011, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/




/* QMSS LLD includes */

/**
@addtogroup QMSS_LLD_SYMBOL
@{
*/

/** QMSS QoS PDSP number. QoS PDSP is downloaded to PDSP 1 */

/** Specifications for Round Robin cluster */

/** Specifications for the SRIO monitor cluster */

/** Offset relative to @ref Qmss_QosSrioCfg.queBase for first
 *  Shadow Garbage Collection Queue. 
 */

/** Offset relative to @ref Qmss_QosSrioCfg.queBase for first
 *  Shadow Transmit Queue. 
 *
 *  SW places descriptors for SRIO transactions here
 */

/** Offset relative to @ref Qmss_QosSrioCfg.queBase for first
 *  Shadow Transmit Completion Queue. 
 *
 *  SRIO's return queues should be pointed here.
 */

/** Offset relative to @ref Qmss_QosSrioCfg.queBase for first
 *  Garbage Collection Completion Queue. 
 *
 *  The firmware will move descriptors from the Shadow Garbage Collection
 *  Queues to the Garbage Collection Completion Queues
 */

/** Offset relative to @ref Qmss_QosSrioCfg.queBase for first
 *  Transmit Completion Queue. 
 *
 *  The firmware will move descriptors from the Shadow Transmit 
 *  Completion Queue to the Transmit Completion queue after 
 *  subtracting the pending descriptor the number of pending
 *  descriptors on the hardware tx queue.
 */


/** QMSS QoS commands */

/** QMSS QoS return and Error Codes */
/** QMSS QoS successful return code */
/** QMSS QoS invalid command return code */
/** QMSS QoS invalid index return code */
/** QMSS QoS invalid option return code */
/** QMSS QoS invalid cluster mode */
/** QMSS QoS invalid round robin high priority q num */
/** QMSS QoS invalid round robin low priority q num */
/** QMSS QoS invalid round robin low priority q num */
/** QMSS QoS SRIO invalid number of queues */

/**
@}
*/

/**
@addtogroup QMSS_LLD_ENUM
@{
*/

/** 
 * @brief QoS cluster mode
 */
typedef enum
{
    /** Modified Token Bucket Mode */
    Qmss_QosMode_TokenBucket,
    /** Round Robin Mode */
    Qmss_QosMode_RoundRobin
} Qmss_QosMode;

/**
@}
*/

/** @addtogroup QMSS_LLD_DATASTRUCT
@{ 
*/

/** 
 * @brief QoS queue configuration structure
 */
typedef struct
{
    /** Queue manger and Queue index of the forwarding queue */
    uint16_t              egressQueNum;
    /** The amount of forwarding byte credit that the queue receives every 25us */
    uint16_t              iterationCredit;
    /** The maximum amount of forwarding byte credit that the queue is allowed to 
     * hold at the end of the timer iteration. Any credit over the maximum limit 
     * is added to a global pool */
    uint32_t              maxCredit;
    /** The size in bytes at which point the QOS queue is considered to be congested */
    uint32_t              congestionThreshold;
} Qmss_QosQueueCfg;


/** 
 * @brief QoS cluster configuration structure for Modified Token Bucket
 */
typedef struct
{
    /** The maximum amount of global credit allowed to carry over to the next queue. 
     * Excess global credit is discarded */       
    uint32_t              maxGlobalCredit;
    /** The number of QOS queues in this cluster. Valid range is 1 to QMSS_QOS_MAX_QUE_PER_CLUSTER_COUNT */
    uint8_t               qosQueCnt;
    /** The queue index (0 to 63) of each QOS queue in the cluster listed 
     * in priority order. These queue indices are relative to the configured QOS 
     * queue base index 
     * Ensure that the queue base passed into @ref Qmss_setQosQueueBase supports 
     * the size of the queue index provided (eg some devices allocate fewer than 64
     * queues).
     */
    uint8_t               qosQueNum[9];
    /** This 9-bit mask contains 1 bit for each QOS queue in the cluster. 
     * When this bit is set for its corresponding QOS queue, iteration credit is treated 
     * as "real time" scheduling and does not scale when the egress queue become congested */
    uint16_t              qosQueRTFlags;
    /** The total number of egress queues sampled to obtain the egress queue congestion estimation. 
     * Valid range is 1 to QMSS_QOS_MAX_QUE_PER_CLUSTER_COUNT */
    uint8_t               egressQueCnt;
    /** The Queue manger and Queue index of every egress queue enumerated in Egress Queue Count. 
     * These queue indices are absolute index values */
    Qmss_Queue          egressQueNum[9];
    /** Each QOS cluster is configured with four egress congestion threshold values. 
     * Iteration credit is assigned to each queue in the cluster depending on the egress 
     * congestion, and the value of these four congestion thresholds. 
     *
     * It is implemented as shown below:
     *
     * Egress Queue Congestion (Backlog) Level  |   QOS Queue Credit Assigned
     * From no backlog to Threshold 1	        |   Double credit
     * Between Threshold 1 and Threshold 2	    |   Normal credit
     * Between Threshold 2 and Threshold 3	    |   Half credit
     * Between Threshold 3 and Threshold 4	    |   Quarter credit
     * Over Threshold 4	                        |   No credit
     * 
     */ 
    /** Egress Congestion Threshold point 1 */ 
    uint32_t              egressCongestionThreshold1;
    /** Egress Congestion Threshold point 2 */ 
    uint32_t              egressCongestionThreshold2;
    /** Egress Congestion Threshold point 3 */ 
    uint32_t              egressCongestionThreshold3;
    /** Egress Congestion Threshold point 4 */ 
    uint32_t              egressCongestionThreshold4;
} Qmss_QosClusterCfgTB;

/** 
@} 
*/

/** 
 * @brief QoS cluster configuration structure for Round Robin
 */
typedef struct
{
    /** The maximum amount of global credit allowed to carry over to the next queue. 
     * Excess global credit is discarded */       
    uint32_t              maxGlobalCredit;

    /** The number of high priority QOS queues in this cluster. Valid value is 4. */
    uint8_t               qosQueHighCnt;

    /** The queue index (0 to 63) of each QOS queue in the high priority 
     * round robin group. These queue indices are relative to the configured 
     * QOS queue base index. These fields must be set to 56, 57, 58, and 59 
     * respectively.  Ensure that the base address passed into 
     * @ref Qmss_setQosQueueBase supports 64 queues.
     */
    uint8_t               qosQueNumHigh[4];

    /** The number of high priority QOS queues in this cluster. Valid value is 4. */
    uint8_t               qosQueLowCnt;

    /** The queue index (0 to 63) of each QOS queue in the low priority 
     * round robin group. These queue indices are relative to the configured 
     * QOS queue base index. These fields must be set to 60, 61, 62, and 63 
     * respectively.  Ensure that the base address passed into 
     * @ref Qmss_setQosQueueBase supports 64 queues.
     */
    uint8_t               qosQueNumLow[4];

    /** This field holds the value of a packet size adjustment that can be 
     * applied to each packet. For example, setting this value to 24 
     * can adjust for the preamble, inter-packet gap, and CRC for packets 
     * without CRC being sent over Ethernet. This adjustment value is 
     * applied across all queues. */
    uint16_t              sizeAdjust;

    /** The total number of egress queues sampled to obtain the egress 
     * queue congestion estimation.  Valid value is 1.
     */
    uint8_t               egressQueCnt;

    /** The Queue manger and Queue index of every (1) egress queue enumerated 
     * in Egress Queue Count. 
     * These queue indices are absolute index values */
    Qmss_Queue            egressQueNum[1];

    /** This is the per timer tick real time iteration credit for the cluster. 
     * (The iteration credit specified in each of the round robin queues is 
     * ignored.) */
    uint32_t              iterationCredit;

    /** This is the max number of bytes allowed to reside in the egress 
     * queue(s). Note that packets will be written until this threshold is 
     * crossed, so the actual number of bytes queued can be larger. */
    uint32_t              maxEgressBacklog;

    /** This 8-bit mask contains 1 bit for each QOS queue in the cluster. 
     * When this bit is set for its corresponding QOS queue, the queue 
     * is disabled for forwarding. */
    uint32_t              queueDisableMask;
} Qmss_QosClusterCfgRR;

/** 
@} 
*/

/** 
 * @brief QoS cluster configuration structure
 */
typedef struct
{
    /** Select Modified Token Bucket or Round Robin mode */
    Qmss_QosMode mode;
    union { 
        /** configuration for Modified Token Bucket mode */
        Qmss_QosClusterCfgTB cfgTB;
        /** configuration for Round Robin mode */
        Qmss_QosClusterCfgRR cfgRR;
    } u;
} Qmss_QosClusterCfg;
/** 
@} 
*/

/** 
 * @brief QoS SRIO Tracking configuration structure
 */
typedef struct
{
    /** Hardware TX queue # N */
    Qmss_Queue txQ;
    /** High water mark for SRIO queue # at which additional
     *  transmit packets will be held. */
    uint8_t    threshold;
} Qmss_QosSrioTXQCfg;
/** 
@} 
*/

/** 
 * @brief QoS SRIO Tracking configuration structure
 */
typedef struct
{
    /** The number of queues to monitor. This controls both the number of 
     *  valid TXQ entries in this structure, plus the number of queues 
     *  considered valid from the SRIO base queue index. 
     *
     * The valid range is QMSS_QOS_SRIO_MIN_TX_Q to QMSS_QOS_SRIO_MAX_TX_Q.
     */
    uint8_t  queCount;

    /** The Queue index of the base queue of the SRIO queue cluster. 
     *  This value must be a multiple of 32.
     */
    uint16_t queBase;

    /** Configurations for each queue requested via @ref queCount */
    Qmss_QosSrioTXQCfg TXQs[5];
} Qmss_QosSrioCfg;

/** 
@} 
*/

/* Exported APIs */
extern Qmss_Result Qmss_setQosQueueBase (uint32_t queueNum);
extern Qmss_Result Qmss_getQosQueueBase (uint32_t *queueNum);
extern Qmss_Result Qmss_configureQosTimer (uint32_t timerConstant);
extern Qmss_Result Qmss_enableQosCluster (uint32_t clusterIndex);
extern Qmss_Result Qmss_disableQosCluster (uint32_t clusterIndex);
extern Qmss_Result Qmss_configureQosQueue (uint32_t queIndex, Qmss_QosQueueCfg *cfg);
extern Qmss_Result Qmss_configureQosCluster (uint32_t clusterIndex, Qmss_QosClusterCfg *cfg);
extern Qmss_Result Qmss_getQosQueueForwardPktStats (uint32_t queueIndex);
extern Qmss_Result Qmss_getQosQueueDroppedPktStats (uint32_t queueIndex);
extern Qmss_Result Qmss_resetQosQueueStats (uint32_t queueIndex);
extern Qmss_Result Qmss_configureQosSrioCluster (uint32_t clusterIndex, Qmss_QosSrioCfg *cfg);
extern Qmss_Result Qmss_enableQosSrioCluster (uint32_t clusterIndex);
extern Qmss_Result Qmss_disableQosSrioCluster (uint32_t clusterIndex);



/**
 *   @file  qmss_mgmt.h
 *
 *   @brief   
 *      This is the Queue Manager queue management APIs.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2010, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/




/* QMSS LLD includes */
/*
 *  file  qmss_pvt.h
 *
 *  Private data structures of Queue Manager Low Level Driver.
 *
 *  ============================================================================
 *      (C) Copyright 2009-2012, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/





/* CSL RL includes */

/* Maximum cache line size for alignment */

/* QMSS Global object definition. */
typedef struct 
{
    /** Store the configuration structure passed during Qmss_init */
    Qmss_GlobalConfigParams             qmssGblCfgParams;
    /** Store the intialization structure passed during Qmss_init */
    Qmss_InitCfg                        initCfg;
    /** Current Memory regions configuration */
    Qmss_MemRegInfo                     memRegInfo[20];
    /** General purpose source queue handles */
    int32_t                             descQueue[20];
    /** Current descriptor count */
    uint32_t                            currDescCnt;
} Qmss_GlobalObj_Unpadded;

typedef struct
{
    /** Data structure without padding, so sizeof() can compute padding */
    Qmss_GlobalObj_Unpadded obj;
    /** Pad out to end of QMSS_MAX_CACHE_ALIGN bytes to prevent something else
     * from being placed on same cache line as Cppi_Obj.  Note that 
     * pad[0] is illegal, so must add full QMSS_MAX_CACHE_ALIGN if structure
     * is already padded by chance. */
    uint8_t                 pad[128 - 
                            (sizeof(Qmss_GlobalObj_Unpadded) % 128)];
} Qmss_GlobalObj;

extern int32_t Qmss_getMemRegQueueHandle(uint32_t memRegion);
extern uint32_t Qmss_getMemRegDescSize (uint32_t memRegion);



        
/* QMSS OSAL layer */
/**
 *   @file  qmss_osal.h
 *
 *   @brief   
 *      This is the sample OS Adaptation layer which is used by the QMSS low level
 *      driver. The OSAL layer can be ported in either of the following 
 *      manners to a native OS:
 *
 *      <b> Approach 1: </b>
 *      @n  Use Prebuilt Libraries
 *           - Ensure that the provide an implementation of all 
 *             Osal_XXX API for their native OS.
 *           - Link the prebuilt libraries with their application.
 *           - Refer to the "example" directory for an example of this
 *       @n <b> Pros: </b>
 *           - Customers can reuse prebuilt TI provided libraries
 *       @n <b> Cons: </b>
 *           - Level of indirection in the API to get to the actual OS call
 *              
 *      <b> Approach 2: </b>
 *      @n  Rebuilt Library 
 *           - Create a copy of this file and modify it to directly 
 *             inline the native OS calls
 *           - Rebuild the QMSS low level driver library; ensure that the Include 
 *             path points to the directory where the copy of this file 
 *             has been provided.
 *           - Please refer to the "test" directory for an example of this 
 *       @n <b> Pros: </b>
 *           - Optimizations can be done to remove the level of indirection
 *       @n <b> Cons: </b>
 *           - QMSS LLD Libraries need to be rebuilt by the customer.
 *
 *  \par
 *  NOTE:
 *      (C) Copyright 2009 Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/

/** @addtogroup QMSS_LLD_OSAL
 @{ */

/**********************************************************************
 ************************* Extern Declarations ************************
 **********************************************************************/

extern void* memset(void *_mem, int32_t _ch, size_t _n);
extern void* memcpy(void *_s1, const void *_s2, size_t _n);
extern void* Osal_qmssMalloc (uint32_t num_bytes);
extern void Osal_qmssFree (void *ptr, uint32_t size);
extern void* Osal_qmssCsEnter (void);
extern void Osal_qmssCsExit (void *CsHandle);
extern void* Osal_qmssMtCsEnter (void);
extern void Osal_qmssMtCsExit (void *CsHandle);
extern void Osal_qmssLog (char *fmt, ... );
extern void Osal_qmssBeginMemAccess (void *ptr, uint32_t size);
extern void Osal_qmssEndMemAccess (void *ptr, uint32_t size);
extern void* Osal_qmssVirtToPhy (void *ptr);
extern void* Osal_qmssPhyToVirt (void *ptr);
extern void* Osal_qmssConvertDescVirtToPhy(void *descAddr);
extern void* Osal_qmssConvertDescPhyToVirt(void *descAddr);

/**
 * @brief   The macro is used by the QMSS LLD to allocate memory of specified
 * size
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Osal_qmssMalloc (uint32_t numBytes)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Number of bytes to be allocated
 *
 *  <b> Return Value </b>
 *  @n  Pointer to the allocated block size
 */


/**
 * @brief   The macro is used by the QMSS LLD to free a allocated block of 
 * memory 
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_qmssFree (void *ptr, uint32_t size)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Pointer to the block of memory to be cleaned up.
 *  @n  Size of the allocated memory which is being freed.
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */


/**
 * @brief   The macro is used by the QMSS LLD to provide critical sections to 
 * protect global and shared variables from
 *
 *      access from multiple cores 
 *      and 
 *      access from multiple threads on single core
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Osal_qmssCsEnter (void)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  None.
 *
 *  <b> Return Value </b>
 *  @n  Handle used to lock critical section.
 */

/**
 * @brief   The macro is used by the QMSS LLD to exit a critical section 
 *      protected using Osal_qmssCsEnter() API.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_qmssCsExit (void *CsHandle)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Handle for unlocking critical section.
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */

/**
 * @brief   The macro is used by the QMSS LLD to provide critical sections to 
 * protect global and shared variables from
 *
 *      access from multiple threads on single core
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Osal_qmssMtCsEnter (void)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  None.
 *
 *  <b> Return Value </b>
 *  @n  Handle used to lock critical section.
 */

/**
 * @brief   The macro is used by the QMSS LLD to exit a critical section 
 *      protected using Osal_qmssMtCsEnter() API.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_qmssMtCsExit (void *CsHandle)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Handle for unlocking critical section.
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */

/**
 * @brief   The macro is used by the QMSS LLD to log various 
 * messages. 
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_qmssLog( char *fmt, ... ) 
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  printf-style format string 
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */

/**
 * @brief   The macro is used by the QMSS LLD to indicate that a block
 * of memory is about to be accessed. If the memory block is cached then
 * this indicates that the application would need to ensure that the cache
 * is updated with the data from the actual memory.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_qmssBeginMemAccess (void *ptr, uint32_t size) 
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  Address of memory block.
 *  @n  Size of memory block.
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */

/**
 * @brief   The macro is used by the QMSS LLD to indicate that the block of 
 * memory has finished being accessed. If the memory block is cached then the 
 * application would need to ensure that the contents of the cache are updated
 * immediately to the actual memory.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_qmssEndMemAccess (void *ptr, uint32_t size) 
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  Address of memory block.
 *  @n  Size of memory block.
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */

/**
 * @brief   The macro is used by the QMSS LLD to get the Physical address for a
 * given Virtual address
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void *Osal_qmssVirtToPhy (void *ptr) 
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  Virtual Address of memory block.
 *
 *  <b> Return Value </b>
 *  @n  Physical address.
 */

/**
 * @brief   The macro is used by the QMSS LLD to get the Virtual address for a
 * given Physical address
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void *Osal_qmssPhyToVirt (void *ptr) 
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  Physical Address of memory block.
 *
 *  <b> Return Value </b>
 *  @n  Virtual address.
 */

/**
 * @brief This callback should traverse the descriptor and convert all address references
 * from virtual to physical.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Qmss_osalConvertDescVirtToPhy(void *descAddr)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  Virtual Address of the descriptor.
 *
 *  <b> Return Value </b>
 *  @n  Physical address of the descriptor.
 */

/**
 * @brief This callback should traverse the descriptor and convert all address references
 * from physical to virtual.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Qmss_osalConvertDescPhyToVirt(void *descAddr)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  Physical Address of the descriptor.
 *
 *  <b> Return Value </b>
 *  @n  Virtual address of the descriptor.
 */

/**
@}
*/



/**********************************************************************
 ************************** Externs *********************************
 **********************************************************************/
        
/* QMSS Local object */
extern Qmss_GlobalConfigParams  qmssLObj;

/** @addtogroup QMSS_LLD_FUNCTION
@{ 
*/

/**
 *  @b Description
 *  @n  
 *      This function pushes a descriptor onto a queue specified by the queue handle. 
 *      The "descSize" is used to specify the size of the descriptor being pushed.
 *      The optional parameter "packetSize" is used specify the size of packet during pop 
 *      operation. 
 *      The optional parameter "location" is used to override the default(tail) and push the packet 
 *      to the head of the queue.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  hnd
 *      Queue handle.
 *
 *  @param[in]  descAddr
 *      Memory address of the descriptor. Should be a global address.
 * 
 *  @param[in]  packetSize
 *      Size of packet pointed to by the descriptor.
 * 
 *  @param[in]  descSize
 *      Size of the descriptor. Minimum size is 16 bytes. Maximum size is 256 bytes
 * 
 *  @param[in]  location
 *      0 - Tail.
 *      1 - Head
 *
 *  @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @retval
 *      None
 */
static inline void Qmss_queuePush (Qmss_QueueHnd hnd, void *descAddr, uint32_t packetSize, uint32_t descSize, Qmss_Location location)
{
    uint32_t            regc = 0, regd = 0;
    uint64_t            dWord = 0;
    volatile uint64_t   *regCregDPtr;
    void                *key;
 
    descAddr = descAddr;

    ((regc) = ((regc) & ~(0x80000000u)) | (((location) << (0x0000001Fu)) & (0x80000000u)));
    
    ((regc) = ((regc) & ~(0x0001FFFFu)) | (((packetSize) << (0x00000000u)) & (0x0001FFFFu)));
   
    regd = ((uint32_t) descAddr | ((descSize >> 4) - 1));

    dWord = regd;
    dWord = ((dWord<<32)|regc);
    /* Begin Critical Section before accessing shared resources. */
    key = Osal_qmssMtCsEnter ();

    regCregDPtr = (volatile uint64_t *) (& qmssLObj.qmQueMgmtDataReg->QUEUE_MGMT_GROUP[hnd].QUEUE_REG_C);
    *regCregDPtr = dWord;
    
    /* End Critical Section */   
    Osal_qmssMtCsExit (key);


    return;
}

/**
 *  @b Description
 *  @n  
 *      It pushes a descriptor onto a queue specified by the queue handle. Does not allow
 *      specifying optional parameters. The descriptor size is not written to the queue. This 
 *      function should be used to push descriptors that will not be prefetched by the CPDMA.
 *
 *  @param[in]  hnd
 *      Queue handle.
 *
 *  @param[in]  descAddr
 *      Memory address of the descriptor. Should be a global address.
 * 
 *  @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @retval
 *      None
 */
static inline void Qmss_queuePushDesc (Qmss_QueueHnd hnd, void *descAddr)
{

    descAddr = descAddr;

    qmssLObj.qmQueMgmtDataReg->QUEUE_MGMT_GROUP[hnd].QUEUE_REG_D = (uint32_t) descAddr;
    return;
}

/**
 *  @b Description
 *  @n  
 *      It pushes a descriptor onto a queue specified by the queue handle. Does not allow
 *      specifying optional parameters.
 *
 *      The "descSize" is used to specify the size of the descriptor being pushed. This 
 *      function should be used to push descriptors that will be prefetched by the CPDMA.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  hnd
 *      Queue handle.
 *
 *  @param[in]  descAddr
 *      Memory address of the descriptor. Should be a global address.
 * 
 *  @param[in]  descSize
 *      Size of the descriptor. Minimum size is 16 bytes. Maximum size is 256 bytes
 * 
 *  @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @retval
 *      None
 */
static inline void Qmss_queuePushDescSize (Qmss_QueueHnd hnd, void *descAddr, uint32_t descSize)
{

    descAddr = descAddr;

    qmssLObj.qmQueMgmtDataReg->QUEUE_MGMT_GROUP[hnd].QUEUE_REG_D = ((uint32_t) descAddr | ((descSize >> 4) - 1));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function pop's a descriptor off the queue specified by the queue handle.
 *
 *      The lower 4 bits of the descriptor address contain the size of the descriptor 
 *      that was specified during the queue push operation.
 *      Caller should mask the lower order 4 bits before using the descriptor.
 *
 *      **No validation is done on the input parameters**
 *      
 *  @param[in]  hnd
 *      Queue handle.
 *
 * @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @retval
 *      Success - Descriptor address and size
 *  @retval
 *      0 -   If queue is empty
 */
static inline void* Qmss_queuePop (Qmss_QueueHnd hnd)
{
	return (void *) (qmssLObj . qmQueMgmtReg->QUEUE_MGMT_GROUP[hnd]. QUEUE_REG_D);
}

/**
 *  @b Description
 *  @n  
 *      This function pop's a descriptor off the queue specified by the queue handle.
 *      It also returns the packet size of the popped decriptor. The packet size is 
 *      available only if it was specified during the push operation. 
 *
 *      **This function is not multicore/multithread safe.**
 *
 *      It is possible that the descriptor is popped by another core/task between the time taken 
 *      to read the packet size and the descriptor address by the first core/task. 
 *      
 *       The caller should provide appropriate locks.
 *
 *      The packet size field is part of the descriptor and should be used to ensure correctness.
 *
 *      The lower 4 bits of the descriptor address contain the size of the descriptor 
 *      that was specified during the queue push operation.
 *      Caller should mask the lower order 4 bits before using the descriptor.
 *
 *      **No validation is done on the input parameters**
 *      
 *  @param[in]  hnd
 *      Queue handle.
 *
 *  @param[out]  descAddr
 *      Descriptor address and size.
 *
 *  @param[out]  packetSize
 *      Packet size in bytes.
 *
 * @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @retval
 *      None
 */
static inline void Qmss_queuePopDescSize (Qmss_QueueHnd hnd, void **descAddr, uint32_t *packetSize)
{
    *packetSize = (((qmssLObj . qmQueStatReg->QUEUE_STATUS_CONFIG_GROUP[hnd]. QUEUE_STATUS_CONFIG_REG_C) & (0x0001FFFFu)) >> (0x00000000u)); 
    *descAddr = (void *)(void *)qmssLObj . qmQueMgmtReg->QUEUE_MGMT_GROUP[hnd]. QUEUE_REG_D;
    return;
}

/** 
 *  @b Description
 *  @n  
 *      Given the queue handle the function returns the address of queue management register D. 
 *      register D is used to write the descriptor address during a queue push operation. 
 *
 *  @param[in]  hnd      
 *      Queue handle
 *
 *  @retval
 *      4 byte memory address.
 */
static inline Qmss_QueuePushHnd Qmss_getQueuePushHandle (Qmss_QueueHnd hnd)
{
    return ((Qmss_QueuePushHnd) &(qmssLObj.qmQueMgmtDataReg->QUEUE_MGMT_GROUP[hnd].QUEUE_REG_D));
}

/**
 *  @b Description
 *  @n  
 *      This function diverts the entire content of source queue to the destination queue. 
 *      "location" indicates whether the contents should be merged on to the head or tail 
 *      of the destination queue.
 * 
 *  @param[in]  srcQnum
 *      Source queue handle.
 *
 *  @param[in]  dstQnum
 *      Destination queue handle.
 * 
 *  @param[in]  location
 *      Head/Tail.
 * 
 *  @pre  
 *      Qmss_queueOpen function for source queue and destination queue should be called before 
 *      calling this function.
 *
 *  @post  
 *      Contents of source queue is moved to the destination queue. Source queue is empty.
 *
 *  @retval
 *      None
 */
static inline void Qmss_queueDivert (Qmss_QueueHnd srcQnum, Qmss_QueueHnd dstQnum, Qmss_Location location)
{
    uint32_t  temp = 0;
    
    ((temp) = ((temp) & ~(0x00003FFFu)) | (((srcQnum) << (0x00000000u)) & (0x00003FFFu)));
    ((temp) = ((temp) & ~(0x3FFF0000u)) | (((dstQnum) << (0x00000010u)) & (0x3FFF0000u)));
    ((temp) = ((temp) & ~(0x80000000u)) | (((location) << (0x0000001Fu)) & (0x80000000u)));

    qmssLObj.qmConfigReg->QUEUE_DIVERSION_REG = temp;
    return; 
}

/**
 *  @b Description
 *  @n  
 *      This function deletes all the contents of the queue.
 * 
 *  @param[in]  hnd
 *      Queue handle.
 *
 *  @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @post  
 *      Queue is empty
 *
 *  @retval
 *      None
 */
static inline void Qmss_queueEmpty (Qmss_QueueHnd hnd)
{
    qmssLObj.qmQueMgmtReg->QUEUE_MGMT_GROUP[hnd].QUEUE_REG_D = (uint32_t) 0x0;
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function returns the number of packets that are currently queued on the queue.
 * 
 *  @param[in]  hnd
 *      Queue handle.
 *
 *  @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @retval
 *      Queue entry count 
 */
static inline uint32_t Qmss_getQueueEntryCount (Qmss_QueueHnd hnd)
{
    return (uint32_t) (((qmssLObj . qmQueStatReg->QUEUE_STATUS_CONFIG_GROUP[hnd]. QUEUE_STATUS_CONFIG_REG_A) & (0x0007FFFFu)) >> (0x00000000u)); 
}

/**
 *  @b Description
 *  @n  
 *      This function returns the total number of bytes that are contained in all of the 
 *      packets that are currently queued on the queue.
 * 
 *  @param[in]  hnd
 *      Queue handle.
 *
 *  @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @retval
 *      Queue byte count 
 */
static inline uint32_t Qmss_getQueueByteCount (Qmss_QueueHnd hnd)
{
    return (uint32_t) (((qmssLObj . qmQueStatReg->QUEUE_STATUS_CONFIG_GROUP[hnd]. QUEUE_STATUS_CONFIG_REG_B) & (0xFFFFFFFFu)) >> (0x00000000u)); 
}

/**
 *  @b Description
 *  @n  
 *      This function returns the packet size of the packet queued at the head of the queue.
 * 
 *  @param[in]  hnd
 *      Queue handle.
 *
 *  @pre  
 *      Qmss_queueOpen function should be called before calling this function.
 *
 *  @retval
 *      Queue packet size
 */
static inline uint32_t Qmss_getQueuePacketSize (Qmss_QueueHnd hnd)
{
    return (uint32_t) (((qmssLObj . qmQueStatReg->QUEUE_STATUS_CONFIG_GROUP[hnd]. QUEUE_STATUS_CONFIG_REG_C) & (0x0001FFFFu)) >> (0x00000000u)); 
}

/** 
@} 
*/








/** @addtogroup CPPI_LLD_SYMBOL
@{
*/

/** Monolithic descriptor extended packet information block size */
/** Host descriptor extended packet information block size */

/** 
@} 
*/

/** @addtogroup CPPI_LLD_ENUM
@{ 
*/

/** 
 * @brief CPPI descriptor types
 */
typedef enum
{
    /** Host descriptor */
    Cppi_DescType_HOST = 0,
    /** Monolithic descriptor */
    Cppi_DescType_MONOLITHIC = 2
}Cppi_DescType;

/** 
 * @brief Packet return policy
 */
typedef enum
{
    /** Return entire packet */
    Cppi_ReturnPolicy_RETURN_ENTIRE_PACKET = 0,
    /** Return one buffer at a time */
    Cppi_ReturnPolicy_RETURN_BUFFER 
}Cppi_ReturnPolicy;

/** 
 * @brief protocol specific information location 
 */
typedef enum
{
    /** protocol specific information is located in descriptor */
    Cppi_PSLoc_PS_IN_DESC = 0,
    /** protocol specific information is located in SOP buffer */
    Cppi_PSLoc_PS_IN_SOP
}Cppi_PSLoc;

/** 
 * @brief extended packet information block
 */
typedef enum
{
    /** extended packet information block is not present in descriptor */
    Cppi_EPIB_NO_EPIB_PRESENT = 0,
    /** extended packet information block is present in descriptor  */
    Cppi_EPIB_EPIB_PRESENT
}Cppi_EPIB;

/** 
 * @brief Descriptor resource management
 */
typedef enum
{
    /** LLD initializes the descriptors with specified values */
    Cppi_InitDesc_INIT_DESCRIPTOR = 0,
    /** LLD does not initialize the descriptor with specified values */    
    Cppi_InitDesc_BYPASS_INIT 
}Cppi_InitDesc;

/** 
@} 
*/

/** @addtogroup CPPI_LLD_DATASTRUCT
@{ 
*/

/** 
 * @brief CPPI host descriptor configuration structure
 */
typedef struct 
{
    /** Indicates return policy for the packet. 
     * Valid only for host descriptor */
    Cppi_ReturnPolicy       returnPolicy;
    /** Indicates protocol specific location CPPI_PS_DESC - located in descriptor, CPPI_PS_SOP - located in SOP buffer 
     * Valid only for host descriptor */
    Cppi_PSLoc              psLocation;
}Cppi_HostDescCfg;

/** 
 * @brief CPPI monolithic descriptor configuration structure
 */
typedef struct 
{
    /** Byte offset from byte 0 of monolithic descriptor to the location where the valid data begins */
    uint32_t                  dataOffset;
}Cppi_MonolithicDescCfg;

/** 
 * @brief CPPI descriptor configuration structure
 */
typedef struct 
{
    /** Memory Region corresponding to the descriptor. */
    Qmss_MemRegion          memRegion;
    /** Number of descriptors that should be configured with value below */
    uint32_t                  descNum;
    /** Queue where the descriptor is stored. If destQueueNum is set to QMSS_PARAM_NOT_SPECIFIED then the next 
     * available queue of type Qmss_QueueType will be allocated */
    int32_t                   destQueueNum;
    /** If destQueueNum is set to QMSS_PARAM_NOT_SPECIFIED then the next available queue of type 
     * Qmss_QueueType will be allocated */
    Qmss_QueueType          queueType;

    /** Descriptor configuration parameters */
    /** Indicates if the descriptor should be initialized with parameters listed below */
    Cppi_InitDesc           initDesc;

    /** Type of descriptor - Host or Monolithic */
    Cppi_DescType           descType;
    /** Indicates return Queue Manager and Queue Number. If both qMgr and qNum in returnQueue is 
     * set to QMSS_PARAM_NOT_SPECIFIED then the destQueueNum is configured in returnQueue of the descriptor */
    Qmss_Queue              returnQueue;
    /** Indicates how the CPDMA returns descriptors to free queue */
    Qmss_Location           returnPushPolicy;
    /** Indicates presence of EPIB */
    Cppi_EPIB               epibPresent;

    /** Union contains configuration that should be initialized in for host or monolithic descriptor. 
     * The configuration for host or monolithic descriptor is choosen based on "descType" field. 
     * The approriate structure fields must be specified if "initDesc" field is set to CPPI_INIT_DESCRIPTOR. */
    union{
    /** Host descriptor configuration parameters */
    Cppi_HostDescCfg        host;
    /** Monolithic  descriptor configuration parameters */
    Cppi_MonolithicDescCfg  mono;
    }cfg;
}Cppi_DescCfg;

/** 
 * @brief CPPI descriptor Word 1 Tag information
 */
typedef struct {
    uint8_t srcTagHi;
    uint8_t srcTagLo;
    uint8_t destTagHi;
    uint8_t destTagLo;
}Cppi_DescTag;

/** 
 * @brief CPPI host descriptor layout
 */
typedef struct {
    /** Descriptor type, packet type, protocol specific region location, packet length */
    uint32_t          descInfo;  
    /** Source tag, Destination tag */
    uint32_t          tagInfo;
    /** EPIB present, PS valid word count, error flags, PS flags, return policy, return push policy, 
     * packet return QM number, packet return queue number */
    uint32_t          packetInfo;
    /** Number of valid data bytes in the buffer */
    uint32_t          buffLen;
    /** Byte aligned memory address of the buffer associated with this descriptor */
    uint32_t          buffPtr;
    /** 32-bit word aligned memory address of the next buffer descriptor */
    uint32_t          nextBDPtr;       
    /** Completion tag, original buffer size */
    uint32_t          origBufferLen;
    /** Original buffer pointer */
    uint32_t          origBuffPtr;
    /** Optional EPIB word0 */
    uint32_t          timeStamp;
    /** Optional EPIB word1 */
    uint32_t          softwareInfo0;
    /** Optional EPIB word2 */
    uint32_t          softwareInfo1;
    /** Optional EPIB word3 */
    uint32_t          softwareInfo2;
    /** Optional protocol specific data */
    uint32_t          psData; 
}Cppi_HostDesc;

/** 
 * @brief CPPI monolithic descriptor layout
 */
typedef struct {
    /** Descriptor type, packet type, data offset, packet length */
    uint32_t          descInfo;  
    /** Source tag, Destination tag */
    uint32_t          tagInfo;
    /** EPIB present, PS valid word count, error flags, PS flags, return push policy, 
     * packet return QM number, packet return queue number */
    uint32_t          packetInfo;
    /** NULL word to align the extended packet words to a 128 bit boundary */
    uint32_t          Reserved;
    /** Optional EPIB word0 */
    uint32_t          timeStamp;
    /** Optional EPIB word1 */
    uint32_t          softwareInfo0;
    /** Optional EPIB word2 */
    uint32_t          softwareInfo1;
    /** Optional EPIB word3 */
    uint32_t          softwareInfo2;
    /** Optional protocol specific data */
    uint32_t          psData; 
}Cppi_MonolithicDesc;

/** 
 * @brief CPPI descriptor
 */
typedef union {
    /** Host descriptor */
    Cppi_HostDesc       *ptrHostDesc;  
    /** Monolithic descriptor */
    Cppi_MonolithicDesc *ptrMonoDesc;
}Cppi_Desc;

/** 
@} 
*/

/** @addtogroup CPPI_LLD_FUNCTION
@{ 
*/

/**
 *  @b Description
 *  @n  
 *      This function is used to set the type of descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC, Cppi_DescType_TEARDOWN
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      None.
 */
static inline void Cppi_setDescType (Cppi_Desc *descAddr, Cppi_DescType descType)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    /* No validation of input parameters is done */

    ((descPtr->descInfo) = ((descPtr->descInfo) &~ (((1 << ((31) - (30) + 1)) - 1) << (30))) | (((descType) & ((1 << ((31) - (30) + 1)) - 1)) << (30)));
    return;
}
/**
 *  @b Description
 *  @n  
 *      This function is used to get the type of descriptor.
 *      Call this function if the descriptor type is not known so it 
 *      can be passed to the remaining descriptor manipulation functions.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      Word 0(bits 30 to 31) are returned
 *
 *      0 - Host descriptor
 *      2 - Monolithic descriptor
 */
static inline Cppi_DescType Cppi_getDescType (Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    /* No validation of input parameters is done */
    return (Cppi_DescType) (((descPtr->descInfo) >> (30)) & ((1 << ((31) - (30) + 1)) - 1));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the error flags (Word 2 bits 20:23) from the host or 
 *      monolithic descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      4 bit Error flag value from descriptor.
 */
static inline uint32_t Cppi_getDescError (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    /* No validation of input parameters is done */

    return ((((descPtr->packetInfo) >> (20)) & ((1 << ((23) - (20) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function copies the data buffer to the host or monolithic descriptor. 
 *      It is assumed that enough words are available to store the payload in case 
 *      of monolithic descriptor.
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  buffAddr
 *      Memory address of data buffer.
 *      
 *  @param[in]  buffLen
 *      Size of the data buffer.
 *
 *  @pre  
 *      Descriptor and data buffer must be allocated and be valid.
 *
 *  @post  
 *      In case of host descriptor 
 *          Word 3 and Word 4 are updated
 *
 *      In case of monolithic descriptor 
 *          Word 0 (bits 0 to 15) and payload are updated.
 *
 *  @retval
 *      None.
 */
static inline void Cppi_setData (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t *buffAddr, uint32_t buffLen)
{
    Cppi_HostDesc   *hostDescPtr;

    /* Does not update packet length */
    if (descType == Cppi_DescType_HOST)
    {
        hostDescPtr = (Cppi_HostDesc *) descAddr;
        hostDescPtr->buffPtr = (uint32_t) buffAddr;
        hostDescPtr->buffLen = (uint32_t) buffLen;
    }
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        uint16_t              dataOffset;

        dataOffset = (((monolithicDescPtr->descInfo) >> (16)) & ((1 << ((24) - (16) + 1)) - 1));
        memcpy ((void *) (((uint8_t *) monolithicDescPtr) + dataOffset), buffAddr, buffLen);        
        ((monolithicDescPtr->descInfo) = ((monolithicDescPtr->descInfo) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((buffLen) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
    }
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the data buffer pointer from the host descriptor
 *      and payload from monolithic descriptor. 
 *      Note that if PS data is present in SOP buffer, the offset to data must calculated by the caller
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[out]  buffAddr
 *      Memory address of data buffer.
 *      
 *  @param[out]  buffLen
 *      Size of the data buffer.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      In case of host descriptor Word 3 and Word 4 are returned
 *      In case of monolithic descriptor Word 0 (bits 0 to 15) and payload are returned.
 *
 *  @retval
 *      None.
 */
static inline void Cppi_getData (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t **buffAddr, uint32_t *buffLen)
{
    /* For monolithic, start of payload is returned. Check if need to skip data offset bytes */
    Cppi_HostDesc   *hostDescPtr;

    if (descType == Cppi_DescType_HOST)
    {
        hostDescPtr = (Cppi_HostDesc *) descAddr;
        *buffAddr = (uint8_t *) hostDescPtr->buffPtr;
        *buffLen = hostDescPtr->buffLen;
    }
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        uint16_t              dataOffset;

        dataOffset = (((monolithicDescPtr->descInfo) >> (16)) & ((1 << ((24) - (16) + 1)) - 1));

        *buffAddr = (uint8_t *) (((uint8_t *) monolithicDescPtr) + dataOffset);
        *buffLen = (((monolithicDescPtr->descInfo) >> (0)) & ((1 << ((15) - (0) + 1)) - 1));
    }
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function sets the data length in host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  buffLen
 *      Size of the data.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      In case of host descriptor 
 *          Word 3 is updated
 *
 *      In case of monolithic descriptor 
 *          Word 0 (bits 0 to 15) is updated.
 *
 *  @retval
 *      None.
 */
static inline void Cppi_setDataLen (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t buffLen)
{
    Cppi_HostDesc   *hostDescPtr;

    /* Does not update packet length */
    if (descType == Cppi_DescType_HOST)
    {
        hostDescPtr = (Cppi_HostDesc *) descAddr;
        hostDescPtr->buffLen = (uint32_t) buffLen;
    }
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        ((monolithicDescPtr->descInfo) = ((monolithicDescPtr->descInfo) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((buffLen) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
    }
    return;
}


/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the data length from host or monolithic descriptor
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      In case of host descriptor Word 3 is returned
 *      In case of monolithic descriptor Word 0 (bits 0 to 15) is returned.
 *   
 */
static inline uint32_t Cppi_getDataLen (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    /* For monolithic, start of payload is returned. Check if need to skip data offset bytes */
    Cppi_HostDesc   *hostDescPtr;

    if (descType == Cppi_DescType_HOST)
    {
        hostDescPtr = (Cppi_HostDesc *) descAddr;
        return (hostDescPtr->buffLen);
    }
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        return ((((monolithicDescPtr->descInfo) >> (0)) & ((1 << ((15) - (0) + 1)) - 1)));
    }
}

/**
 *  @b Description
 *  @n  
 *      This function is used to link a host descriptor with the next buffer descriptor.
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  nextBD
 *      Memory address of buffer descriptor that should be linked.
 *      
 *  @pre  
 *      Both descriptors must be allocated and be valid.
 *
 *  @post  
 *      Word5 is updated
 *
 *  @retval
 *      None.
 */
static inline void Cppi_linkNextBD (Cppi_DescType descType, Cppi_Desc *descAddr, Cppi_Desc *nextBD)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    hostDescPtr->nextBDPtr = (uint32_t) nextBD;
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the next buffer descriptor pointer from a host packet. 
 *      If the value is zero, then the current buffer is the last buffer in the packet.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      Word 5 of host descriptor 
 *      32 bit word aligned memory address - if current buffer is not the last buffer in packet.
 *      0  - if current buffer is the last buffer in packet.
 */
static inline Cppi_Desc* Cppi_getNextBD (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    return (Cppi_Desc *) hostDescPtr->nextBDPtr;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the original buffer information in the host descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  buffAddr
 *      Memory address of data buffer pointer.
 *      
 *  @param[in]  buffLen
 *      Size of the original data buffer.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      In case of host descriptor Word 6(bits 0 to 21) and Word 7 are updated
 *
 *  @retval
 *      None.
 */
static inline void Cppi_setOriginalBufInfo (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t *buffAddr, uint32_t buffLen)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    hostDescPtr->origBuffPtr = (uint32_t) buffAddr;
    ((hostDescPtr->origBufferLen) = ((hostDescPtr->origBufferLen) &~ (((1 << ((21) - (0) + 1)) - 1) << (0))) | (((buffLen) & ((1 << ((21) - (0) + 1)) - 1)) << (0)));
 
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the original buffer information from host descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[out]  buffAddr
 *      Memory address of data buffer pointer.
 *      
 *  @param[out]  buffLen
 *      Size of the original data buffer.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      In case of host descriptor Word 6(bits 0 to 21) and Word 7 are returned
 *
 *  @retval
 *      None.
 */
static inline void Cppi_getOriginalBufInfo (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t **buffAddr, uint32_t *buffLen)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    *buffAddr = (uint8_t *) hostDescPtr->origBuffPtr;
    *buffLen = (((hostDescPtr->origBufferLen) >> (0)) & ((1 << ((21) - (0) + 1)) - 1));

    return;
}
/**
 *  @b Description
 *  @n  
 *      This function is used to set the packet type in host or monolithic descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  packetType
 *      Indicates type of packet. Valid range is 0 to 31.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 0 (bits 25 to 29) of host or monolithic descriptor are updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setPacketType (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t packetType)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    ((descPtr->descInfo) = ((descPtr->descInfo) &~ (((1 << ((29) - (25) + 1)) - 1) << (25))) | (((packetType) & ((1 << ((29) - (25) + 1)) - 1)) << (25)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the packet type from host or monolithic descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      5 bit packet type field. Valid range is 0 to 31.
 */
static inline uint8_t Cppi_getPacketType (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    return ((((descPtr->descInfo) >> (25)) & ((1 << ((29) - (25) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the timestamp field in host or 
 *      monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  timeStamp
 *      Timestamp value.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated. 
 *
 *  @post
 *      Word 2 (bit 31) is updated.
 *      Word 0 of Extended Packet Info Block is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setTimeStamp (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t timeStamp)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    ((hostDescPtr->packetInfo) = ((hostDescPtr->packetInfo) &~ (((1 << ((31) - (31) + 1)) - 1) << (31))) | ((((uint32_t) 1) & ((1 << ((31) - (31) + 1)) - 1)) << (31)));
    if (descType == Cppi_DescType_HOST)
        hostDescPtr->timeStamp = timeStamp;
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        monolithicDescPtr->timeStamp = timeStamp;
    }
    return;
}
/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the timestamp field from the host or 
 *      monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[out]  timeStamp
 *      Timestamp value.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated and EPIB bit must be set in the descriptor 
 *
 *  @post  
 *      Word 0 of Extended Packet Info Block is returned.
 *
 *  @retval
 *      Success -   CPPI_SOK 
 *  @retval
 *      Failure -   CPPI_EPIB_NOT_PRESENT if EPIB bit is not set in the descriptor. 
 */
static inline Cppi_Result Cppi_getTimeStamp (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t *timeStamp)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    if ((((hostDescPtr->packetInfo) >> (31)) & ((1 << ((31) - (31) + 1)) - 1)) == 0)
    {
        return (-128)-10;
    }
    if (descType == Cppi_DescType_HOST)
        *timeStamp = hostDescPtr->timeStamp;
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        *timeStamp = monolithicDescPtr->timeStamp;
    }
    return 0;
}

/**
 *  @b Description
 *  @n  
 *      This function is used copy the optional software info field to the host or 
 *      monolithic descriptor. 
 *      It is assumed that enough words are available in the descriptor to store 
 *      information block.
 *      The API copies 3 words of software info into the descriptor.
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  infoAddr
 *      Pointer to the first word of software information block.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated.
 *
 *  @post 
 *   *  @post  
 *      Word 2 (bit 31) is updated.
 *      Word 1 to Word 3 of Extended Packet Info Block is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setSoftwareInfo (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t *infoAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    /* Does not update packet length */
    ((hostDescPtr->packetInfo) = ((hostDescPtr->packetInfo) &~ (((1 << ((31) - (31) + 1)) - 1) << (31))) | ((((uint32_t) 1) & ((1 << ((31) - (31) + 1)) - 1)) << (31)));
    
    if (descType == Cppi_DescType_HOST)
        memcpy ((void *) &hostDescPtr->softwareInfo0, infoAddr, 12);
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        memcpy ((void *) &monolithicDescPtr->softwareInfo0, infoAddr, 12);
    }
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the 3 words of software info field from the host or 
 *      monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[out]  infoAddr
 *      Pointer to the first word of software information block.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Pointer to Word 1 of Extended Packet Info Block is returned.
 *      EPIB block must be allocated and EPIB bit must be set in the descriptor 
 *
 *  @retval
 *      Success -   CPPI_SOK
 *  @retval
 *      Failure -   CPPI_EPIB_NOT_PRESENT if EPIB bit is not set in the descriptor.
 */
static inline Cppi_Result Cppi_getSoftwareInfo (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t **infoAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    if ((((hostDescPtr->packetInfo) >> (31)) & ((1 << ((31) - (31) + 1)) - 1)) == 0)
    {
        return (-128)-10;
    }
    if (descType == Cppi_DescType_HOST)
        *infoAddr = (uint8_t *) &hostDescPtr->softwareInfo0;
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        *infoAddr = (uint8_t *) &monolithicDescPtr->softwareInfo0;
    }
    return 0;
}

/**
 *  @b Description
 *  @n  
 *      This function is used copy the 1st word of optional software info field to the host or 
 *      monolithic descriptor. 
 *      It is assumed that enough words are available in the descriptor to store 
 *      information block.
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  value
 *      Value to write to word 1 of software information block.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated.
 *
 *  @post 
 *      Word 2 (bit 31) is updated.
 *      Word 1 of Extended Packet Info Block is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setSoftwareInfo0 (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t value)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    /* Does not update packet length */
    ((hostDescPtr->packetInfo) = ((hostDescPtr->packetInfo) &~ (((1 << ((31) - (31) + 1)) - 1) << (31))) | ((((uint32_t) 1) & ((1 << ((31) - (31) + 1)) - 1)) << (31)));
    
    if (descType == Cppi_DescType_HOST)
        hostDescPtr->softwareInfo0 = value;
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        monolithicDescPtr->softwareInfo0 = value;
    }
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the 1st word of software info field from the host or 
 *      monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated and EPIB bit must be set in the descriptor
 *
 *  @retval
 *      4 bytes of software info word 1
 *
 */
static inline uint32_t Cppi_getSoftwareInfo0 (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    if (descType == Cppi_DescType_HOST)
        return (hostDescPtr->softwareInfo0);
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        return (monolithicDescPtr->softwareInfo0);
    }
}


/**
 *  @b Description
 *  @n  
 *      This function is used copy the 2nd word of optional software info field to the host or 
 *      monolithic descriptor. 
 *      It is assumed that enough words are available in the descriptor to store 
 *      information block.
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *      **Does not update EPIB present bit**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  value
 *      Value to write to word 2 of software information block.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated.
 *
 *  @post 
 *      Word 2 of Extended Packet Info Block is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setSoftwareInfo1 (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t value)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    if (descType == Cppi_DescType_HOST)
        hostDescPtr->softwareInfo1 = value;
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        monolithicDescPtr->softwareInfo1 = value;
    }
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the 2nd word of software info field from the host or 
 *      monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated and EPIB bit must be set in the descriptor 
 *
 *  @retval
 *      4 bytes of software info word 2
 *
 *  @retval
 *      Failure -   CPPI_EPIB_NOT_PRESENT if EPIB bit is not set in the descriptor.
 */
static inline uint32_t Cppi_getSoftwareInfo1 (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    if (descType == Cppi_DescType_HOST)
        return (hostDescPtr->softwareInfo1);
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        return (monolithicDescPtr->softwareInfo1);
    }
}

/**
 *  @b Description
 *  @n  
 *      This function is used copy the 3rd word of optional software info field to the host or 
 *      monolithic descriptor. 
 *      It is assumed that enough words are available in the descriptor to store 
 *      information block.
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *      **Does not update EPIB present bit**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  value
 *      Value to write to word 3 of software information block.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated.
 *
 *  @post 
 *      Word 3 of Extended Packet Info Block is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setSoftwareInfo2 (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t value)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    if (descType == Cppi_DescType_HOST)
        hostDescPtr->softwareInfo2 = value;
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        monolithicDescPtr->softwareInfo2 = value;
    }
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the 3rd word of software info field from the host or 
 *      monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *      EPIB block must be allocated and EPIB bit must be set in the descriptor 
 *
 *  @retval
 *      4 bytes of software info word 3
 *
 *  @retval
 *      Failure -   CPPI_EPIB_NOT_PRESENT if EPIB bit is not set in the descriptor.
 */
static inline uint32_t Cppi_getSoftwareInfo2 (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    if (descType == Cppi_DescType_HOST)
        return (hostDescPtr->softwareInfo2);
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        return (monolithicDescPtr->softwareInfo2);
    }
}

/**
 *  @b Description
 *  @n  
 *      This function is used to copy the protocol specific data to the host or 
 *      monolithic descriptor. Used when PS data is located in the descriptor.
 *      This function should not be used to copy PS data to SOP buffer.
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  dataAddr
 *      Pointer to the first word of protocol specific data.
 *
 *  @param[in]  dataLen
 *      Size of the PS data.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 2 (bits 24 to 29) are updated.
 *      Word 0-N of PS data block is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setPSData (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t *dataAddr, uint32_t dataLen)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;
    uint8_t           epibPresent;
 
    /* Does not update packet length */
    ((hostDescPtr->packetInfo) = ((hostDescPtr->packetInfo) &~ (((1 << ((29) - (24) + 1)) - 1) << (24))) | ((((dataLen / 4)) & ((1 << ((29) - (24) + 1)) - 1)) << (24)));

    epibPresent = (((hostDescPtr->packetInfo) >> (31)) & ((1 << ((31) - (31) + 1)) - 1));

    if (descType == Cppi_DescType_HOST)
        memcpy ((void *) (((uint8_t *) &hostDescPtr->psData) - (!epibPresent * 16)), dataAddr, dataLen);
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        memcpy ((void *) (((uint8_t *) &monolithicDescPtr->psData) - (!epibPresent * 20)), dataAddr, dataLen);
    }
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to retrieve the protocol specific data from the host or 
 *      monolithic descriptor. In case of host descriptor the PS data is read from descriptor 
 *      or SOP buffer based on the PS location. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  location
 *      PS region location 
 *          CPPI_PS_DESC - PS words are located in the descriptor
 *          CPPI_PS_SOP  - PS words are located inthe SOP buffer immediately prior to data.
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[out]  dataAddr
 *      Pointer to the first word of protocol specific data.
 *
 *  @param[out]  dataLen
 *      Size of the PS data.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      For host descriptor, Pointer to Word 0 of PS data block or SOP buffer is returned.
 *      For monolithic descriptor, Pointer to Word 0 of PS data block is returned.
 *
 *  @retval
 *      Success -   CPPI_SOK
 *  @retval
 *      Failure -   CPPI_PSDATA_NOT_PRESENT if PS length is zero in the descriptor.
 */
static inline Cppi_Result Cppi_getPSData (Cppi_DescType descType, Cppi_PSLoc location, Cppi_Desc *descAddr, uint8_t **dataAddr, uint32_t *dataLen)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;
    uint8_t           epibPresent;

    if ((*dataLen = (((hostDescPtr->packetInfo) >> (24)) & ((1 << ((29) - (24) + 1)) - 1)) * 4) == 0)
    {
        return (-128)-11;
    }

    epibPresent = (((hostDescPtr->packetInfo) >> (31)) & ((1 << ((31) - (31) + 1)) - 1));

    if (descType == Cppi_DescType_HOST)
    {
        if (location == Cppi_PSLoc_PS_IN_SOP)
            *dataAddr = (uint8_t *) hostDescPtr->buffPtr;
        else
            *dataAddr = (uint8_t *) (((uint8_t *) &hostDescPtr->psData) - (!epibPresent * 16));
    }
    else
    {
        Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;
        *dataAddr = (uint8_t *) (((uint8_t *) &monolithicDescPtr->psData) - (!epibPresent * 20));
    }
    return 0;
}

/**
 *  @b Description
 *  @n  
 *      This function is update protocol specific data length in host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *      **Does not update packet length**.
 *
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  dataLen
 *      Size of PS data.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 2 (bits 24 to 29) are updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setPSLen (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t dataLen)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;
 
    /* Does not update packet length */
    ((descPtr->packetInfo) = ((descPtr->packetInfo) &~ (((1 << ((29) - (24) + 1)) - 1) << (24))) | ((((dataLen / 4)) & ((1 << ((29) - (24) + 1)) - 1)) << (24)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the protocol specific data length from host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      Size of PS data in bytes. Valid range is 0 to 128 bytes
 */
static inline uint32_t Cppi_getPSLen (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    return (((((descPtr->packetInfo) >> (24)) & ((1 << ((29) - (24) + 1)) - 1)) * 4));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the packet length in host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  packetLen
 *      Size of packet.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 0 (bits 0 to 21) of host descriptor are updated.
 *      Word 0 (bits 0 to 15) of monolithic descriptor are updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setPacketLen (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t packetLen)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    if (descType == Cppi_DescType_HOST)
        ((descPtr->descInfo) = ((descPtr->descInfo) &~ (((1 << ((21) - (0) + 1)) - 1) << (0))) | (((packetLen) & ((1 << ((21) - (0) + 1)) - 1)) << (0)));
    else
        ((descPtr->descInfo) = ((descPtr->descInfo) &~ (((1 << ((15) - (0) + 1)) - 1) << (0))) | (((packetLen) & ((1 << ((15) - (0) + 1)) - 1)) << (0)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the packet length from host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      Size of packet in bytes
 */
static inline uint32_t Cppi_getPacketLen (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    if (descType == Cppi_DescType_HOST)
        return ((((descPtr->descInfo) >> (0)) & ((1 << ((21) - (0) + 1)) - 1)));
    else
        return ((((descPtr->descInfo) >> (0)) & ((1 << ((15) - (0) + 1)) - 1)));
}
/**
 *  @b Description
 *  @n  
 *      This function is used to set the protocol specific region location in host descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *      
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  location
 *      PS region location 
 *          CPPI_PS_DESC - PS words are located in the descriptor
 *          CPPI_PS_SOP  - PS words are located inthe SOP buffer immediately prior to data.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 0 (bit 22) of host descriptor is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setPSLocation (Cppi_DescType descType, Cppi_Desc *descAddr, Cppi_PSLoc location)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    ((hostDescPtr->descInfo) = ((hostDescPtr->descInfo) &~ (((1 << ((22) - (22) + 1)) - 1) << (22))) | (((location) & ((1 << ((22) - (22) + 1)) - 1)) << (22)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the protocol specific region location from host descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *   
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *    
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      CPPI_PS_DESC - PS words are located in the descriptor
 *  @retval
 *      CPPI_PS_SOP  - PS words are located inthe SOP buffer immediately prior to data.
 */
static inline Cppi_PSLoc Cppi_getPSLocation (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    return ((Cppi_PSLoc) (((hostDescPtr->descInfo) >> (22)) & ((1 << ((22) - (22) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the protocol specific flags in host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *    
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  psFlags
 *      4 bit Protocol Specific flags value.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 2 (bits 16 to 19) of descriptor are updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setPSFlags (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t psFlags)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    ((descPtr->packetInfo) = ((descPtr->packetInfo) &~ (((1 << ((19) - (16) + 1)) - 1) << (16))) | (((psFlags) & ((1 << ((19) - (16) + 1)) - 1)) << (16)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the protocol specific flags from host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      4 bit PS flags value from descriptor.
 */
static inline uint8_t Cppi_getPSFlags (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    return ((((descPtr->packetInfo) >> (16)) & ((1 << ((19) - (16) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the original buffer pool index from which the attached buffer 
 *      was originally allocated from. This is different from the descriptor pool/queue index 
 *      since a single buffer may be referenced by more than one descriptor.
 *      
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *    
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  poolIndex
 *      index of buffer pool.
 *          
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 6 (Bit 28 to 31) of host descriptor is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setOrigBufferpooIndex (Cppi_DescType descType, Cppi_Desc *descAddr, uint8_t poolIndex)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    ((hostDescPtr->origBufferLen) = ((hostDescPtr->origBufferLen) &~ (((1 << ((31) - (28) + 1)) - 1) << (28))) | (((poolIndex) & ((1 << ((31) - (28) + 1)) - 1)) << (28)));

    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the original buffer pool index from which the attached buffer 
 *      was originally allocated from. This is different from the descriptor pool/queue index 
 *      since a single buffer may be referenced by more than one descriptor.
 *      
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *    
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      Word 6 (bit 28 to 31) of host descriptor 
 */
static inline uint8_t Cppi_getOrigBufferpooIndex (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    return ((((hostDescPtr->origBufferLen) >> (28)) & ((1 << ((31) - (28) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to increment the number of references that have been made to the 
 *      attached buffer by different descriptors.  Multiple buffer references are commonly used to 
 *      implement broadcast and multicast packet forwarding when zero packet data copies are desired. 
 *      
 *      **No validation is done on the input parameters**.
 *      **No check is made to prevent overflow **.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *    
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 6 (Bit 22 to 27) of host descriptor is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_incrementRefCount (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;
    uint8_t        count;

    count = (((hostDescPtr->origBufferLen) >> (22)) & ((1 << ((27) - (22) + 1)) - 1));
    ((hostDescPtr->origBufferLen) = ((hostDescPtr->origBufferLen) &~ (((1 << ((27) - (22) + 1)) - 1) << (22))) | (((++count) & ((1 << ((27) - (22) + 1)) - 1)) << (22)));

    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to decrement the number of references that have been made to the 
 *      attached buffer by different descriptors.  Multiple buffer references are commonly used to 
 *      implement broadcast and multicast packet forwarding when zero packet data copies are desired. 
 *      
 *      **No validation is done on the input parameters**.
 *      **No check is made to prevent overflow **.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *    
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 6 (Bit 22 to 27) of host descriptor is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_decrementRefCount (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;
    uint8_t        count;

    count = (((hostDescPtr->origBufferLen) >> (22)) & ((1 << ((27) - (22) + 1)) - 1));
    ((hostDescPtr->origBufferLen) = ((hostDescPtr->origBufferLen) &~ (((1 << ((27) - (22) + 1)) - 1) << (22))) | (((--count) & ((1 << ((27) - (22) + 1)) - 1)) << (22)));

    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the number of references that have been made 
 *      to the attached buffer by different descriptors.  Multiple buffer references are commonly 
 *      used to implement broadcast and multicast packet forwarding when zero packet data copies are desired. 
 *      
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *    
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      Word 6 (bit 22 to 27) of host descriptor 
 */
static inline uint8_t Cppi_getRefCount (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    return ((((hostDescPtr->origBufferLen) >> (22)) & ((1 << ((27) - (22) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the payload data offset in the monolithic descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_MONOLITHIC
 *    
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  dataOffset
 *      Data offset from byte 0 of word 0 of the descriptor to the location where 
 *      valid data begins.
 *      Valid range is 0 to 511 bytes.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 0 (bits 16 to 24) of monolithic descriptor are updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setDataOffset (Cppi_DescType descType, Cppi_Desc *descAddr, uint32_t dataOffset)
{
    Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;

    ((monolithicDescPtr->descInfo) = ((monolithicDescPtr->descInfo) &~ (((1 << ((24) - (16) + 1)) - 1) << (16))) | (((dataOffset) & ((1 << ((24) - (16) + 1)) - 1)) << (16)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the payload data offset from the monolithic descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      9 bit data offset. Valid range is 0 to 511 bytes
 */
static inline uint32_t Cppi_getDataOffset (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_MonolithicDesc *monolithicDescPtr = (Cppi_MonolithicDesc *) descAddr;

    return ((((monolithicDescPtr->descInfo) >> (16)) & ((1 << ((24) - (16) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the return policy for the packet in host descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  returnPolicy
 *      RETURN_ENTIRE_PACKET - Entire packet (linked with MOP and EOP BDs and data buffers) should be returned 
 *                      to the return queue specified in SOP descriptor.
 *      RETURN_BUFFER - Each buffer in this packet should be returned to the queue specified in its respective 
 *                      SOP, MOP or EOP descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 2 (bit 15) of host descriptor is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setReturnPolicy (Cppi_DescType descType, Cppi_Desc *descAddr, Cppi_ReturnPolicy returnPolicy)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    ((hostDescPtr->packetInfo) = ((hostDescPtr->packetInfo) &~ (((1 << ((15) - (15) + 1)) - 1) << (15))) | (((returnPolicy) & ((1 << ((15) - (15) + 1)) - 1)) << (15)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the return policy for the packet from host descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      RETURN_ENTIRE_PACKET - Entire packet (linked with MOP and EOP BDs and data buffers) should be returned 
 *                      to the return queue specified in SOP descriptor.
 *  @retval
 *      RETURN_BUFFER - Each buffer in this packet should be returned to the queue specified in its respective 
 *                      SOP, MOP or EOP descriptor.
 */
static inline Cppi_ReturnPolicy Cppi_getReturnPolicy (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    return ((Cppi_ReturnPolicy) (((hostDescPtr->packetInfo) >> (15)) & ((1 << ((15) - (15) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the return push policy in host or monolithic descriptor. 
 *      Return push policy is valid only if Return Policy is set to 1 in host descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  returnPushPolicy
 *      TAIL - Descriptor must be returned to tail of queue.
 *      HEAD - Descriptor must be returned to head of queue.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 2 (bit 14) of descriptor is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setReturnPushPolicy (Cppi_DescType descType, Cppi_Desc *descAddr, Qmss_Location returnPushPolicy)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    ((hostDescPtr->packetInfo) = ((hostDescPtr->packetInfo) &~ (((1 << ((14) - (14) + 1)) - 1) << (14))) | (((returnPushPolicy) & ((1 << ((14) - (14) + 1)) - 1)) << (14)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the return push policy for the packet from host or monolithic descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      TAIL - Descriptor must be returned to tail of queue.
 *  @retval
 *      HEAD - Descriptor must be returned to head of queue.
 */
static inline Qmss_Location Cppi_getReturnPushPolicy (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *hostDescPtr = (Cppi_HostDesc *) descAddr;

    return ((Qmss_Location) (((hostDescPtr->packetInfo) >> (14)) & ((1 << ((14) - (14) + 1)) - 1)));
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set the return queue manager and queue number in 
 *      host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  queue
 *      Queue Manager - 0 or 1.
 *      Queue Number - 0 to 4094 with in queue manager 0 or 1.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 2 (bit 14) of host or monolithic descriptor is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setReturnQueue (Cppi_DescType descType, Cppi_Desc *descAddr, Qmss_Queue queue)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    ((descPtr->packetInfo) = ((descPtr->packetInfo) &~ (((1 << ((13) - (12) + 1)) - 1) << (12))) | (((queue . qMgr) & ((1 << ((13) - (12) + 1)) - 1)) << (12)));
    ((descPtr->packetInfo) = ((descPtr->packetInfo) &~ (((1 << ((11) - (0) + 1)) - 1) << (0))) | (((queue . qNum) & ((1 << ((11) - (0) + 1)) - 1)) << (0)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the return queue manager and queue number from host 
 *      or monolithic descriptor.
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      Queue Manager - 0 or 1.
 *  @retval
 *      Queue Number - 0 to 4094 with in queue manager 0 or 1.
 */
static inline Qmss_Queue Cppi_getReturnQueue (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;
    Qmss_Queue      queue;

    queue.qMgr = (((descPtr->packetInfo) >> (12)) & ((1 << ((13) - (12) + 1)) - 1));
    queue.qNum = (((descPtr->packetInfo) >> (0)) & ((1 << ((11) - (0) + 1)) - 1));
    return (queue);
}

/**
 *  @b Description
 *  @n  
 *      This function is used to set source and destination tags in 
 *      host or monolithic descriptor. 
 *
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *
 *  @param[in]  tag
 *      Destination and source low and High tag value.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @post  
 *      Word 1 of host or monolithic descriptor is updated.
 *
 *  @retval
 *      None
 */
static inline void Cppi_setTag (Cppi_DescType descType, Cppi_Desc *descAddr, Cppi_DescTag *tag)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;

    ((descPtr->tagInfo) = ((descPtr->tagInfo) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((tag->destTagLo) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((descPtr->tagInfo) = ((descPtr->tagInfo) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((tag->destTagHi) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((descPtr->tagInfo) = ((descPtr->tagInfo) &~ (((1 << ((23) - (16) + 1)) - 1) << (16))) | (((tag->srcTagLo) & ((1 << ((23) - (16) + 1)) - 1)) << (16)));
    ((descPtr->tagInfo) = ((descPtr->tagInfo) &~ (((1 << ((31) - (24) + 1)) - 1) << (24))) | (((tag->srcTagHi) & ((1 << ((31) - (24) + 1)) - 1)) << (24)));
    return;
}

/**
 *  @b Description
 *  @n  
 *      This function is used to get the source and destination tags from 
 *      host or monolithic descriptor. 
 *      
 *      **No validation is done on the input parameters**.
 *
 *  @param[in]  descType
 *      Type of descriptor - Cppi_DescType_HOST, Cppi_DescType_MONOLITHIC
 *
 *  @param[in]  descAddr
 *      Memory address of descriptor.
 *      
 *  @pre  
 *      Descriptor must be allocated and be valid.
 *
 *  @retval
 *      8 bit destination low tag value.
 *  @retval
 *      8 bit destination high tag value.
 *  @retval
 *      8 bit source low tag value.
 *  @retval
 *      8 bit source high tag value.
 */
static inline Cppi_DescTag Cppi_getTag (Cppi_DescType descType, Cppi_Desc *descAddr)
{
    Cppi_HostDesc   *descPtr = (Cppi_HostDesc *) descAddr;
    Cppi_DescTag    tag;

    tag.destTagLo = (((descPtr->tagInfo) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    tag.destTagHi = (((descPtr->tagInfo) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    tag.srcTagLo = (((descPtr->tagInfo) >> (16)) & ((1 << ((23) - (16) + 1)) - 1));
    tag.srcTagHi = (((descPtr->tagInfo) >> (24)) & ((1 << ((31) - (24) + 1)) - 1));

    return (tag);
}

/**
@}
*/

extern Qmss_QueueHnd Cppi_initDescriptor (Cppi_DescCfg *descCfg, uint32_t *numAllocated);

/* 
 * Restore remark state for: remark #880-D: parameter "descType" was never referenced
 *
 * This allows the remark to still come out in user code
 */
#pragma diag_default 880
#pragma diag_default 681




/* CSL SRIO Header File  */



/* ============================================================= */
/**
 *   @file  sriover.h
 *
 *   path  ti/drv/srio/sriover.h
 *
 *   @brief  SRIO Driver Version Definitions
 *
 *  ============================================================
 *  Copyright (c) Texas Instruments Incorporated 2009-2011
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/**
 * @brief   This is the SRIO Driver Version. Versions numbers are encoded in the following 
 * format:
 *  0xAABBCCDD -> Arch (AA); API Changes (BB); Major (CC); Minor (DD)
 */

/**
 * @brief   This is the version string which describes the SRIO driver along with the
 * date and build information.
 */


  


/**
@defgroup SRIO_LLD_SYMBOL  SRIO LLD Symbols Defined
@ingroup SRIO_LLD_API
*/
/**
@defgroup SRIO_LLD_FUNCTION  SRIO LLD Functions
@ingroup SRIO_LLD_API
*/
/**
@defgroup SRIO_LLD_DATASTRUCT  SRIO LLD Data Structures
@ingroup SRIO_LLD_API
*/
/**
@defgroup SRIO_OSAL_API  SRIO OSAL Functions
@ingroup SRIO_LLD_API
*/
/**
@defgroup SRIO_DEVICE_API  SRIO Device Functions
@ingroup SRIO_LLD_API
*/

/** @addtogroup SRIO_LLD_SYMBOL
 @{ */

/* This macro generates compilier error if postulate is true, so 
 * allows 0 overhead compile time size check.  This "works" when
 * the expression contains sizeof() which otherwise doesn't work
 * with preprocessor */


/**
 * @brief   This defines the maximum depth of the SRIO socket receive queues.
 * This is the MAX number of packets which can be enqueued in the SRIO socket
 * receive queue before packets get dropped.
 */

/**
 * @brief This is the maximum number of Type9 and Type11 sockets that can 
 * be created. This is limited by the hardware and since Type9 and Type11 
 * share the same QID_MAP register both of them are limited to this 
 */

/**
 * @brief This is the maximum number of DIO sockets that can be created. This 
 * limit is specified by the number of LSU blocks. 
 */

/**
 * @brief This is a macro provided for the application and should be used if a DOORBELL
 * is to be transmitted.
 *
 * @sa
 *  Srio_sockSend 
 */

/**
 * @brief This is a macro provided for the application and should be used to get
 * the doorbell register information once data is received on the DIO socket.
 *
 * @sa
 *  Srio_sockRecv
 */

/**
 * @brief This is a macro provided for the application and should be used to get
 * the doorbell bit information once data is received on the DIO socket.
 *
 * @sa
 *  Srio_sockRecv
 */

/**
 * @brief Specifies to use hardware assigned Letter to which the message will be send. 
 * The hardware will check for an unused context starting with letter = 0 (A), 
 * and incrementing to letter = 3 (D). The first unused context with that letter 
 * will be used. If there are no context available with any letters then the 
 * packet is stopped and re-arbitrated in the TXU until one does get available.
 */

/**
 * @brief This value can be used to accept all mailbox values on receive side. 
 * Setting a mailbox number to this value will set MBX_MASK to "0x000000" in 
 * RIO_RXU_MAPxx_L register.
 */

/**
@}
*/

/** @addtogroup SRIO_LLD_DATASTRUCT
 @{ */

/** 
 * @brief 
 *  This is the handle which is used for sending and receiving data 
 */
typedef void*   Srio_SockHandle;

/** 
 * @brief 
 *  This is the handle which is used accessing the SRIO driver.
 */
typedef void*   Srio_DrvHandle;

/** 
 * @brief 
 *  This is the handle which encapsulates the SRIO driver buffer information.
 */
typedef void*   Srio_DrvBuffer;

/** 
 * @brief 
 *  The structure describes the SRIO Driver Managed Receive Configuration
 *
 * @details
 *  This specifies the Receive configuration which is a part of the Driver 
 *  Managed configuration. 
 */
typedef struct Srio_DrvManagedRxCfg
{
    /**
     * @brief   This is the memory region to be used for allocating 
     * the receive buffer descriptors. 
     */
    Qmss_MemRegion      rxMemRegion;

    /**
     * @brief   This is the Number of receive buffers and descriptors 
     * which are to be passed to the SRIO receive queues.
     */
    uint32_t            numRxBuffers;

    /**
     * @brief   For Normal sockets this is the Maximum data size which can be
     * received.
     */
    uint32_t            rxMTU;

    /**
     * @brief   This is the receive completion queue in which the received
     * SRIO packets will be placed. If interrupt support is required then the
     * application would need to ensure that they select a correct high priority
     * queue & accumulator channel. If no interrupts are required then this can
     * be any queue. 
     */
    Qmss_QueueHnd       rxCompletionQueue;

    /**
     * @brief   Boolean flag which indicates if the SRIO driver should configure
     * the accumulator with the provided accumulator configuration or not. If this
     * parameter is set to 0 the accumulator configuration below is ignored. This
     * in turn implies that there is no interrupt support and the application would
     * need to poll.
     */
    uint16_t            bIsAccumlatorCfgValid;

    /**
     * @brief   Accumulator Configuration is exposed to the application which 
     * allows the application to determine the parameters for programming 
     * the accumulator. 
     * Note: SRIO driver expects accumulator list (Qmss_AccCmdCfg.listAddress)
     * to be allocated from local memory (un-cached memory) for performance 
     * reasons. Using local memory reduces the overhead of cache invalidates 
     * on every Srio_rxCompletionIsr() call.
     */
    Qmss_AccCmdCfg      accCfg;
}Srio_DrvManagedRxCfg;

/** 
 * @brief 
 *  The structure describes the SRIO Driver Managed Transmit Configuration
 *
 * @details
 *  This specifies the Transmit configuration which is a part of the Driver 
 *  Managed configuration. 
 */
typedef struct Srio_DrvManagedTxCfg
{
    /**
     * @brief  The number of transmit buffers available to the driver instance
     * which can be used to transmit data.
     */
    uint32_t            numTxBuffers;

    /**
     * @brief   This is the memory region to be used for allocating the transmit 
     * buffer descriptors.
     */
    Qmss_MemRegion      txMemRegion;

    /**
     * @brief   For Normal sockets this is the Maximum data size which can be
     * transmitted.
     */
    uint32_t            txMTU;
}Srio_DrvManagedTxCfg;

/** 
 * @brief 
 *  The structure describes the SRIO Driver Managed Configuration
 *
 * @details
 *  The configuration exposes encapsulates majority of the low level configuration
 *  from the application. The configuration works only with NORMAL sockets. 
 */
typedef struct Srio_DrvManagedCfg
{
    /**
     * @brief   Boolean flag which indicates if the SRIO driver instance being
     * configured should support receive or not? If this flag is set to 0 the
     * Receive configuration below is ignored which implies that the the 
     * receive flow is not configured and thus the driver instance and any 
     * associated sockets opened on this instance are no longer capable of 
     * receiving any data.
     */
    uint16_t                bIsRxCfgValid;

    /**
     * @brief   The receive configuration which determines the location of
     * the buffer descriptors, size, receive MTU etc.
     */
    Srio_DrvManagedRxCfg    rxCfg;

    /**
     * @brief   Boolean flag which indicates if the SRIO driver instance being
     * configured should support transmit or not? If this flag is set to 0 the
     * transmit configuration below is ignored which implies that the driver 
     * instance does not have any transmit buffers available and thus any call 
     * to send out data will fail. 
     */
    uint16_t                bIsTxCfgValid;    

    /**
     * @brief   The transmit configuration which determines the location of
     * the buffer descriptors, size, transmit MTU etc.
     */
    Srio_DrvManagedTxCfg    txCfg;
}Srio_DrvManagedCfg;

/**
 * @brief
 *  SRIO priority level set in the TCHAN_SCHED_CFG_REGn registers.
 *
 * @details
 *  This enumeration provides the SRIO PKTDMA TX DMA channels priority.
 *  The value is encoded as follows: 
 *  0 = HIGH PRIORITY,   1 = MEDIUM-HIGH PRIORITY,
 *  2 = MEDIUM-LOW PRIO, 3 = LOW PRIORITY
 *
 *  The priority order from the CDMA is in the reverse order from 
 *  the SRIO. Thus, "0" maps to "3", "1" to "2", "2" to "1" and "3"
 *  to "0". The inversed priority level (3 --> 0, 2 --> 1 etc.) is 
 *  copied to the TX_QUEUE_SCH_INFOx register and used by the SRIO 
 *  IP when forming SRIO headers.
 */
typedef enum
{
    /*
    * @brief 0 = High Priority
    */
    Srio_PktDma_Prio_High = 0,

    /*
    * @brief 1 = Medium-High Priority
    */
    Srio_PktDma_Prio_MediumHigh,

    /*
    * @brief 2 = Medium-Low Priority
    */
    Srio_PktDma_Prio_MediumLow,

    /*
    * @brief 3 = Low Priority
    */
    Srio_PktDma_Prio_Low
}Srio_PktDma_Prio;

/** 
 * @brief
 *  The structure describes the application managed configuration
 *
 * @details
 *  In this configuration the entire low level configuration is exposed to the
 *  application. Applications can specify the CPPI Receive Flows, QMSS Accumulator
 *  configuration. This configuration works only with RAW sockets. 
 */
typedef struct Srio_AppManagedCfg
{
    /**
     * @brief   Boolean flag which indicates if the SRIO driver instance being
     * configured should support receive or not? If this flag is set to 0 the
     * Receive Flow configuration below is ignored which implies that the 
     * the receive flow is not configured and thus the driver instance and any 
     * associated sockets opened on this instance are no longer capable of 
     * receiving any data.
     */
    uint16_t            bIsRxFlowCfgValid;

    /**
     * @brief   The Receive Flow Configuration is exposed to the application. The 
     * Application specifies how flows need to be configured. This allows the 
     * applications complete control over the queues from where the buffer 
     * descriptors are removed when packets are received. 
     */
    Cppi_RxFlowCfg      rxFlowCfg;

    /**
     * @brief   Boolean flag which indicates if the SRIO driver should configure
     * the accumulator with the provided accumulator configuration or not. If this
     * parameter is set to 0 the accumulator configuration below is ignored.
     */
    uint16_t            bIsAccumlatorCfgValid;

    /**
     * @brief   Accumulator Configuration is exposed to the application which 
     * allows the application to determine the parameters for programming 
     * the accumulator. 
     */
    Qmss_AccCmdCfg      accCfg;

    /**
     * @brief   For RAW Sockets this is the receive cleanup API which needs to be 
     * provided by the application. This API is invoked by the driver to cleanup 
     * the buffer descriptor associated with the RAW socket. This parameter can 
     * be set to NULL if the application wishes to only operate on NORMAL sockets
     */
    void                (*rawRxFreeDrvBuffer)(Srio_DrvBuffer hDrvBuffer);

    /**
     * @brief   Indicates the queue number to be used for TX. Using this 
     * parameter same TX queue can be used for multiple SRIO driver instances.
     * This parameter needs to be set to either a valid queue number or 
     * QMSS_PARAM_NOT_SPECIFIED which indicates driver should allocate 
     * the next available queue.
     */
    int16_t             txQueueNum;

    /**
     * @brief   Receive Descriptor Size. This is required to 
     * invalidate cache on the receive side. If this is set to 
     * zero then invalidate will not take place e.g. in case of 
     * buffer descriptors that are allocated from L2 SARAM 
     * which don't need invalidation.
     */
    int32_t             rxDescSize;

    /**
     * @brief
     *  SRIO priority level set in the TCHAN_SCHED_CFG_REGn registers.
     *  This value provides the SRIO PKTDMA TX DMA channels priority.
     *  The value is encoded as follows: 
     *  0 = HIGH PRIORITY,   1 = MEDIUM-HIGH PRIORITY,
     *  2 = MEDIUM-LOW PRIO, 3 = LOW PRIORITY
     *
     *  The priority order from the CDMA is in the reverse order from 
     *  the SRIO. Thus, "0" maps to "3", "1" to "2", "2" to "1" and "3"
     *  to "0". The inversed priority level (3 --> 0, 2 --> 1 etc.) is 
     *  copied to the TX_QUEUE_SCH_INFOx register and used by the SRIO 
     *  IP when forming SRIO headers.
     */
    Srio_PktDma_Prio  srioPktDmaTxPrio;

}Srio_AppManagedCfg;

/**
 * @brief 
 *  Describes driver configuration.
 *
 * @details
 *  There are 2 types of configuration in the driver. Application Managed
 *  and Driver Managed. 
 */
typedef union Srio_DrvConfigType
{
    /**
     * @brief    This is the driver managed configuration.
     */
    Srio_DrvManagedCfg    drvManagedCfg;

    /**
     * @brief    This is the application managed configuration.
     */    
    Srio_AppManagedCfg    appManagedCfg;
}Srio_DrvConfigType;

/**
 * @brief 
 *  The structure describes the SRIO Driver Configuration 
 *
 * @details
 *  SRIO Driver users are expected to populate the driver configuration
 *  block and pass it to the driver during initialization.
 */
typedef struct Srio_DrvConfig
{
    /**
     * @brief   The SRIO driver can be configured to use either of the
     * following configurations:
     *  - Application Managed configuration
     *  - Driver Managed configuration
     *  This flag can be used to select which configuration is specified.
     */
    uint16_t            bAppManagedConfig;

    /**
     * @brief    Union structure for the driver configuration.
     */
    Srio_DrvConfigType  u;
}Srio_DrvConfig;

/** 
 * @brief 
 *  Enumeration Type which describes the socket.
 *
 * @details
 *  There can be different kinds of SRIO sockets which can be used to 
 *  send and receive data. These enumerations define the supported 
 *  types.
 */
typedef enum Srio_SocketType
{
    /**
     * @brief   Type9 Sockets
     */
    Srio_SocketType_TYPE9       = 0x1,

    /**
     * @brief   Type9 RAW Sockets
     */
    Srio_SocketType_RAW_TYPE9   = 0x2,
    
    /**
     * @brief   Type11 Sockets
     */
    Srio_SocketType_TYPE11      = 0x3,

    /**
     * @brief   Type11 RAW Sockets
     */
    Srio_SocketType_RAW_TYPE11  = 0x4,

    /**
     * @brief   Direct IO Socket.
     */        
    Srio_SocketType_DIO         = 0x5
}Srio_SocketType;

/** 
 * @brief 
 *  SRIO Socket Type11 Binding Information.
 *
 * @details
 *  The structure describes the address information required for binding 
 *  a Type11 socket. This includes information which describes the Type11
 *  endpoint characteristics and is used to describe the local characteristics 
 *  of the endpoint.
 */
typedef struct Srio_Type11BindAddrInfo
{
    /**
     * @brief   Transport Type; 16 bit or 8 bit identifiers. 
     */
    uint16_t      tt;

    /**
     * @brief   This is the 8 bit or 16 bit SRIO identifier 
     */
    uint16_t      id;

    /**
     * @brief   Letter Identifier 
     */
    uint16_t      letter;

    /**
     * @brief   Mailbox number 
     */
    uint16_t      mbox;

    /**
     * @brief   Segmentation Mapping Set to 0 for single segment and 1 for multi segment.
     */
    uint16_t      segMap;
}Srio_Type11BindAddrInfo;

/** 
 * @brief 
 *  SRIO Socket Type11 Address Information.
 *
 * @details
 *  The structure describes the address information required to send & 
 *  receive a Type11 message over a Type11 socket. This is populated to
 *  indicate the remote endpoint where the message has to be sent.
 */
typedef struct Srio_Type11AddrInfo
{
    /**
     * @brief   Transport Type; 16 bit or 8 bit identifiers. 
     */
    uint16_t      tt;

    /**
     * @brief   This is the 8 bit or 16 bit SRIO identifier 
     */
    uint16_t      id;

    /**
     * @brief   Letter Identifier 
     */
    uint16_t      letter;

    /**
     * @brief   Mailbox number 
     */
    uint16_t      mbox;
}Srio_Type11AddrInfo;

/** 
 * @brief 
 *  SRIO Socket Type9 Information.
 *
 * @details
 *  The structure describes the address information required to send & 
 *  receive a Type11 message over a Type11 socket. This is populated to
 *  indicate the remote endpoint where the message has to be sent.
 */
typedef struct Srio_Type9AddrInfo
{
    /**
     * @brief   Transport Type; 16 bit or 8 bit identifiers. 
     */
    uint16_t        tt;
 
    /**
     * @brief   This is the 8 bit or 16 bit SRIO identifier 
     */
    uint16_t        id;

    /**
     * @brief   Class of service
     */
    uint8_t         cos;

    /**
     * @brief   Stream identifier.
     */
    uint16_t        streamId;
}Srio_Type9AddrInfo;

/** 
 * @brief 
 *  SRIO Socket Type9 Binding Information.
 *
 * @details
 *  The structure describes the address information required for binding 
 *  a Type9 socket. This includes information which describes the Type9
 *  endpoint characteristics and is used to describe the local characteristics 
 *  of the endpoint. 
 */
typedef Srio_Type9AddrInfo  Srio_Type9BindAddrInfo;

/** 
 * @brief 
 *  SRIO Socket DIO Binding Information.
 *
 * @details
 *  The structure describes the address information required for binding 
 *  a DIO socket. This includes information which describes the DIO
 *  endpoint characteristics and is used to describe the local characteristics 
 *  of the endpoint. 
 */
typedef struct Srio_DioBindAddrInfo
{
    /**
     * @brief   Indicates if doorbell information needs to be sent out or not.
     */
    uint8_t   doorbellValid;

    /**
     * @brief   CPU controlled request bit used for interrupt generation
     */
    uint8_t   intrRequest;

    /**
     * @brief   Supress good interrupt.
     */
    uint8_t   supInt;

    /**
     * @brief   RapidIO xambs field specifying extended address 
     */
    uint8_t   xambs;

    /**
     * @brief   Packet Priority
     */
    uint8_t   priority;

    /*
     * @brief Indicates the output port number for the packet to be transmitted
     */
    uint8_t   outPortID;

    /*
     * @brief RapidIO tt field specifying 8 or 16bit DeviceIDs
     */    
    uint8_t   idSize;

    /*
     * @brief Defines which sourceID register to be used for this transaction
     */
    uint8_t   srcIDMap;

    /*
     * @brief RapidIO hop_count field specified for Type 8 Maintenance packets
     */    
    uint8_t   hopCount;

    /*
     * @brief RapidIO doorbell info: This is the doorbell register which is to be written 
     * There are 4 registers so this should have a value from 0 - 3.
     */
    uint8_t  doorbellReg;

    /*
     * @brief RapidIO doorbell info: This is the doorbell bit which is to be set. There 
     * are 16 doorbell bits so this should have a value from 0-15.
     */
    uint8_t  doorbellBit;
}Srio_DioBindAddrInfo;

/** 
 * @brief 
 *  SRIO Socket DIO Information
 *
 * @details
 *  The structure describes the DIO request which has to be sent to the remote
 *  endpoint.
 */
typedef struct Srio_DioAddrInfo
{
    /**
     * @brief   32b Ext Address Fields  Packet Types 2,5, and 6
     */
    uint32_t  rapidIOMSB;

    /**
     * @brief   32b Address  Packet Types 2,5, and 6 
     */
    uint32_t  rapidIOLSB;

    /*
     * @brief RapidIO destinationID field specifying target device
     */
    uint16_t  dstID;

    /*
     * @brief Transaction Type
     */
    uint8_t   ttype;

    /*
     * @brief FType for packets
     */
    uint8_t   ftype;
}Srio_DioAddrInfo;

/** 
 * @brief 
 *  SRIO Socket Bind Information
 *
 * @details
 *  There are different types of sockets and this union explains the different 
 *  types of binding information required.
 */
typedef union Srio_SockBindAddrInfo
{
    Srio_Type11BindAddrInfo         type11;
    Srio_Type9BindAddrInfo          type9;
    Srio_DioBindAddrInfo            dio;
}Srio_SockBindAddrInfo;

/** 
 * @brief 
 *  SRIO Socket Address Information
 *
 * @details
 *  The structure describes the various address socket type address characteristics
 *  which are used while sending & receiving data over the specific SRIO socket type.
 */
typedef union Srio_SockAddrInfo
{
    Srio_Type11AddrInfo         type11;
    Srio_Type9AddrInfo          type9;
    Srio_DioAddrInfo            dio;
}Srio_SockAddrInfo;

/** 
 * @brief 
 *  SRIO Driver Option Commands.
 *
 * @details
 *  These option commands are used for the get/set of various configuration
 *  parameters which exist in the driver.
 */
typedef enum Srio_Opt
{
    /**
     * @brief   This is the command which is used to get/set the MAX Pending
     * Packet limit for each socket. This command when used requires a 
     * 2 byte configuration data.
     */
    Srio_Opt_PENDING_PKT_COUNT       = 0x1,

    /**
     * @brief   This command is applicable only for DIO sockets and is used to
     * get the DIO socket last transfer completion code. If there is a pending 
     * transaction on the socket the function returns 0xFF else the function 
     * returns the last recorded completion code. The command uses a 1 byte 
     * configuration data to return the completion code. A value of 0 indicates 
     * transfer was complete with no errors. All other values indicate an error.
     */
    Srio_Opt_DIO_SOCK_COMP_CODE      = 0x2,

    /**
     * @brief   This command is applicable only for DIO sockets and is used 
     * register a DIO socket with a specific Doorbell register and Doorbell
     * bit. The mappings are maintained *only* on a core specific basis. 
     */
    Srio_Opt_REGISTER_DOORBELL       = 0x3,

    /**
     * @brief   This command is applicable only for DIO sockets and is used to
     * get the DIO socket transfer completion code. Note that this just returns 
     * the last recorded completion code in the socket data structure and doesn't 
     * check if transaction is pending or not. A typical use of this option would
     * be in the case where an ISR fills the completion code and application needs  
     * to know the status of completion code after ISR. The command uses a 1 byte 
     * configuration data to return the completion code. A value of 0 indicates 
     * transfer was complete with no errors. All other values indicate an error.
     */
    Srio_Opt_DIO_READ_SOCK_COMP_CODE = 0x4

}Srio_Opt;

/** 
 * @brief 
 *  RIO Format Type
 *
 * @details
 *  This enumberation describes the SRIO Packet Ftype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum 
{  
    /*
     * @brief Type 2 Packet Format (Request Class)
     */
    Srio_Ftype_REQUEST        = 2,

    /*
     * @brief Type 5 Packet Format (Write Class)
     */
    Srio_Ftype_WRITE          = 5,

    /*
     * @brief Type 6 Packet Format (Streaming Write Class)
     */
    Srio_Ftype_SWRITE         = 6,

    /*
     * @brief Type 7 Packet Format (Congestion Class)
     */
    Srio_Ftype_CONGESTION     = 7,

    /*
     * @brief Type 8 Packet Format (Maintenance)
     */
    Srio_Ftype_MAINTENANCE   = 8,

    /*
     * @brief Type 9 Packet Format (Data Streaming)
     */
    Srio_Ftype_DATA_STREAMING = 9,
    
    /*
     * @brief Type 10 Packet Format (Doorbell)
     */
    Srio_Ftype_DOORBELL       = 10,

    /*
     * @brief Type 11 Packet Format (Doorbell)
     */
    Srio_Ftype_MESSAGE        = 11,

    /*
     * @brief Type 13 Packet Format Response)
     */
    Srio_Ftype_RESPONSE       = 13
} Srio_Ftype;

/** 
 * @brief 
 *  RIO Transaction Type for Type2 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief NREAD Transaction
     */
    Srio_Ttype_Request_NREAD        = 4,

    /*
     * @brief ATOMIC Increment Transaction
     */
    Srio_Ttype_Request_ATOMIC_INC   = 12,

    /*
     * @brief ATOMIC Decrement Transaction
     */
    Srio_Ttype_Request_ATOMIC_DEC   = 13,

    /*
     * @brief ATOMIC Set Transaction
     */
    Srio_Ttype_Request_ATOMIC_SET   = 14,

    /*
     * @brief ATOMIC Clear Transaction
     */
    Srio_Ttype_Request_ATOMIC_CLR   = 15
}Srio_Ttype_Request;

/** 
 * @brief 
 *  RIO Transaction Type for Type5 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief NWRITE Transaction
     */
    Srio_Ttype_Write_NWRITE             = 4,

    /*
     * @brief NWRITE_R Transaction
     */
    Srio_Ttype_Write_NWRITE_R           = 5,

    /*
     * @brief Atomic Test and Set Transaction
     */
    Srio_Ttype_Write_ATOMIC_TEST_SET    = 14
}Srio_Ttype_Write;

/** 
 * @brief 
 *  RIO Transaction Type for Type6 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief For Streaming Write Transaction there is no Transaction Type.
     */
    Srio_Ttype_Swrite_DEFAULT            = 0
}Srio_Ttype_Swrite;

/** 
 * @brief 
 *  RIO Transaction Type for Type7 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief For Congestion Transaction there is no Transaction Type.
     */
    Srio_Ttype_Congestion_DEFAULT            = 0
}Srio_Ttype_Congestion;

/** 
 * @brief 
 *  RIO Transaction Type for Type8 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief Maintenance Read
     */
    Srio_Ttype_Maintenance_READ           = 0,

    /*
     * @brief Maintenance Write
     */
    Srio_Ttype_Maintenance_WRITE          = 1,

    /*
     * @brief Maintenance Read Response
     */
    Srio_Ttype_Maintenance_READR          = 2,

    /*
     * @brief Maintenance Write Response
     */
    Srio_Ttype_Maintenance_WRITER         = 3,

    /*
     * @brief Maintenance Port Write Response
     */
    Srio_Ttype_Maintenance_RORT_WRITE     = 4
}Srio_Ttype_Maintenance;

/** 
 * @brief 
 *  RIO Transaction Type for Type9 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief For Data Streaming there is no Transaction Type.
     */
    Srio_Ttype_Data_Streaming_DEFAULT      = 0
}Srio_Ttype_Data_Streaming;

/** 
 * @brief 
 *  RIO Transaction Type for Type10 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief For Doorbell there is no Transaction Type.
     */
    Srio_Ttype_Doorbell_DEFAULT            = 0
}Srio_Ttype_Doorbell;

/** 
 * @brief 
 *  RIO Transaction Type for Type11 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief For Message there is no Transaction Type.
     */
    Srio_Ttype_Message_DEFAULT            = 0
}Srio_Ttype_Message;

/** 
 * @brief 
 *  RIO Transaction Type for Type13 Packet Format
 *
 * @details
 *  This enumberation describes the SRIO Packet Ttype field which is present in the
 *  RIO packet. These are as per the Rapid IO Standard specifications.
 */
typedef enum
{
    /*
     * @brief Response + Doorbell response
     */
    Srio_Ttype_Response_RESPONSE            = 0,

    /*
     * @brief Message Response
     */
    Srio_Ttype_Response_MSG_RESPONSE        = 1,

    /*
     * @brief Response with payload
     */
    Srio_Ttype_Response_RESPONSE_PAYLOAD    = 8
}Srio_Ttype_Response;

/**
@}
*/

/**********************************************************************
 **************************** EXPORTED API ****************************
 **********************************************************************/

extern int32_t Srio_init (void);
extern Srio_DrvHandle Srio_start (Srio_DrvConfig* ptr_cfg);

extern Srio_SockHandle Srio_sockOpen (Srio_DrvHandle hSrio, Srio_SocketType type,uint16_t isBlocking);
extern int32_t Srio_sockBind         (Srio_SockHandle srioSock, Srio_SockBindAddrInfo* ptr_addrInfo);
extern int32_t Srio_sockBind_TYPE11  (Srio_SockHandle srioSock, Srio_SockBindAddrInfo* ptr_addrInfo);
extern int32_t Srio_sockBind_TYPE9   (Srio_SockHandle srioSock, Srio_SockBindAddrInfo* ptr_addrInfo);
extern int32_t Srio_sockBind_DIO     (Srio_SockHandle srioSock, Srio_SockBindAddrInfo* ptr_addrInfo);
extern int32_t Srio_sockSend         (Srio_SockHandle srioSock, Srio_DrvBuffer hBuffer, uint32_t size, Srio_SockAddrInfo* to);
extern int32_t Srio_sockSend_TYPE11  (Srio_SockHandle srioSock, Srio_DrvBuffer hBuffer, uint32_t size, Srio_SockAddrInfo* to);
extern int32_t Srio_sockSend_TYPE9   (Srio_SockHandle srioSock, Srio_DrvBuffer hBuffer, uint32_t size, Srio_SockAddrInfo* to);
extern int32_t Srio_sockSend_DIO     (Srio_SockHandle srioSock, Srio_DrvBuffer hBuffer, uint32_t size, Srio_SockAddrInfo* to);
extern int32_t Srio_sockRecv         (Srio_SockHandle srioSock, Srio_DrvBuffer* hDrvBuffer,Srio_SockAddrInfo* from);
extern void Srio_freeRxDrvBuffer     (Srio_SockHandle srioSock, Srio_DrvBuffer hDrvBuffer);
extern int32_t Srio_setSockOpt       (Srio_SockHandle srioSock, Srio_Opt option,void* optval,int32_t optlen);
extern int32_t Srio_getSockOpt       (Srio_SockHandle srioSock, Srio_Opt option,void* optval,int32_t optlen);
extern int32_t Srio_sockClose        (Srio_SockHandle srioSock);
extern int32_t Srio_sockClose_TYPE11 (Srio_SockHandle srioSock);
extern int32_t Srio_sockClose_TYPE9  (Srio_SockHandle srioSock);
extern int32_t Srio_sockClose_DIO    (Srio_SockHandle srioSock);

extern Srio_DrvBuffer Srio_allocTransmitBuffer (Srio_DrvHandle hSrioDrv, uint8_t** ptrData, uint32_t* bufferLen);
extern void Srio_freeTransmitBuffer            (Srio_DrvHandle hSrioDrv, Srio_DrvBuffer hDrvBuffer);

extern void Srio_dioCompletionIsr   (Srio_DrvHandle hSrioDrv, uint8_t intDstDoorbell[]);
extern void Srio_dioTxCompletionIsr (Srio_DrvHandle hSrioDrv, CSL_SrioHandle hSrioCSL);
extern void Srio_rxCompletionIsr    (Srio_DrvHandle hSrioDrv);

extern uint32_t Srio_getVersion (void);
extern const char* Srio_getVersionStr (void);


/**
 *   @file  srio_osal.h
 *
 *   @brief   
 *      This is the sample OS Adaptation layer which is used by the SRIO
 *      driver. The OSAL layer can be ported in either of the following 
 *      manners to a native OS:
 *
 *      <b> Approach 1: </b>
 *      @n  Use Prebuilt Libraries
 *           - Ensure that the provide an implementation of all 
 *             Osal_XXX API for their native OS.
 *           - Link the prebuilt libraries with their application.
 *           - Refer to the "example" directory for an example of this
 *       @n <b> Pros: </b>
 *           - Customers can reuse prebuilt TI provided libraries
 *       @n <b> Cons: </b>
 *           - Level of indirection in the API to get to the actual OS call
 *              
 *      <b> Approach 2: </b>
 *      @n  Rebuilt Library 
 *           - Create a copy of this file and modify it to directly 
 *             inline the native OS calls
 *           - Rebuild the SRIO Driver library; ensure that the Include 
 *             path points to the directory where the copy of this file 
 *             has been provided.
 *           - Please refer to the "test" directory for an example of this 
 *       @n <b> Pros: </b>
 *           - Optimizations can be done to remove the level of indirection
 *       @n <b> Cons: </b>
 *           - SRIO Libraries need to be rebuilt by the customer.
 *
 *  \par
 *  NOTE:
 *      (C) Copyright 2009-2012 Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  \par
*/


/** @addtogroup SRIO_OSAL_API
 @{ */

/**********************************************************************
 ************************* Extern Declarations ************************
 **********************************************************************/

/* #include <string.h> is here because there used to be 
 * memcpy/memset prototypes here.  This #include prevents warnings in 
 * other code that unintentionally worked because of these prototypes
 */
/*****************************************************************************/
/* string.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/




extern void* Osal_srioMalloc(uint32_t numBytes);
extern void  Osal_srioFree (void* ptr, uint32_t size);
extern void* Osal_srioDataBufferMalloc(uint32_t numBytes);
extern void  Osal_srioDataBufferFree(void* ptr, uint32_t numBytes);
extern void  Osal_srioLog(char* fmt, ... );
extern void* Osal_srioCreateSem(void);
extern void  Osal_srioDeleteSem(void* semHandle);
extern void  Osal_srioPendSem(void* semHandle);
extern void  Osal_srioPostSem(void* semHandle);
extern void* Osal_srioEnterMultipleCoreCriticalSection(void);
extern void  Osal_srioExitMultipleCoreCriticalSection(void* critSectHandle);
extern void* Osal_srioEnterSingleCoreCriticalSection(Srio_DrvHandle drvHandle);
extern void  Osal_srioExitSingleCoreCriticalSection(Srio_DrvHandle drvHandle, void* critSectHandle);
extern void  Osal_srioBeginMemAccess(void* ptr, uint32_t size);
extern void  Osal_srioEndMemAccess(void* ptr, uint32_t size);
extern void  Osal_srioBeginDescriptorAccess (Srio_DrvHandle drvHandle,void* ptr, uint32_t descSize);
extern void  Osal_srioEndDescriptorAccess (Srio_DrvHandle drvHandle,void* ptr, uint32_t descSize);

/**
 * @brief   The macro is used by the SRIO driver to create a semaphore for 
 * each SRIO socket opened in blocking mode. Semaphores created should 
 * *initially* be created with a count of 0 i.e. unavailable. 
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Osal_srioCreateSem(void);
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n Not Applicable
 *
 *  <b> Return Value </b>
 *  @n Semaphore Handle
 */

/**
 * @brief   The macro is used by the SRIO driver to delete a previously 
 * created semaphore. This is called when a SRIO socket opened in blocking mode
 * is being closed.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_srioDeleteSem(void* semHandle)
    @endverbatim

 *  <b> Parameter </b>
 *  @n  Semaphore Handle returned by the create semaphore
 *
 *  <b> Return Value </b>
 *  @n  Not Applicable
 */

/**
 * @brief   The macro is used by the SRIO driver to pend on a semaphore
 * This is called when an application tries to receive data on a blocking
 * socket when there is no data available. Since all semaphores are initially
 * created to be unavailable; this will cause the application to block.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_srioPendSem(void* semHandle)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  Semaphore Handle
 *
 *  <b> Return Value </b>
 *  @n  Not Applicable
 */

/**
 * @brief   The macro is used by the SRIO driver to post the semaphore
 * The driver posts the semaphore once data is received on a specific 
 * socket.  
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_srioPostSem(void* semHandle)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Semaphore Handle
 *
 *  <b> Return Value </b>
 *  @n  Not Applicable
 */

/**
 * @brief   The macro is used by the SRIO driver to allocate memory
 * The SRIO driver uses this macro to allocate memory for its internal 
 * driver structures. This is invoked during the driver initialization
 * and startup process.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Osal_srioMalloc(uint32_t numBytes)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Number of bytes to be allocated
 *
 *  <b> Return Value </b>
 *  @n  Pointer to the allocated block size
 *
 *  @sa
 *      Srio_osalDataBufferMalloc
 */

/**
 * @brief   The macro is used by the SRIO driver to free a previously
 * allocated block of memory
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_srioFree(void* ptr, uint32_t numBytes)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Pointer to the block of memory to be cleaned up.
 *  @n  Size of the allocated memory which is being freed.
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */

/**
 * @brief   The macro is used by the SRIO driver to allocate memory
 * for the data buffers in Driver Managed Configuration. All data
 * buffers should allocated should be in the global address space. 
 * This macro is invoked during the data path.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Osal_srioDataBufferMalloc(uint32_t numBytes)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Number of bytes to be allocated
 *
 *  <b> Return Value </b>
 *  @n  Pointer to the allocated block size
 */

/**
 * @brief   The macro is used by the SRIO driver to free a previously
 * allocated block data buffer. This macro is used to clean up previously
 * allocated data buffers and is invoked during the data path.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_srioDataBufferFree(void* ptr, uint32_t numBytes)
    @endverbatim
 *      
 *  <b> Parameter </b>
 *  @n  Pointer to the block of memory to be cleaned up.
 *  @n  Size of the allocated memory which is being freed.
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */

/**
 * @brief   The macro is used by the SRIO driver to log various 
 * messages. 
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void Osal_srioLog( char* fmt, ... ) 
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  printf-style format string 
 *
 *  <b> Return Value </b>
 *  @n  Not applicable.
 */

/**
 * @brief   The macro is used by the SRIO Driver to protect its shared resources
 * access from MULTIPLE CORES. This is required if the SRIO Driver API's are being
 * invoked from multiple cores. If this is not the case then these macros can be
 * defined to be NOP.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Osal_srioEnterMultipleCoreCriticalSection(void)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  None
 *
 *  <b> Return Value </b>
 *  @n  Opaque Handle used for holding critical section locking information
 */

/**
 * @brief   The macro is used by the SRIO driver to end the protection of its 
 * internal shared "resources" from MULTIPLE CORE access.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void  Osal_srioExitMultipleCoreCriticalSection(void* critSectHandle)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  Opaque Handle used for holding critical section locking information
 *
 *  <b> Return Value </b>
 *  @n  None
 */

/**
 * @brief   The macro is used by the SRIO driver to protect its internal shared
 * resources from SINGLE CORE MULTIPLE CONTEXT (thread or ISR) access. If all 
 * the SRIO Driver APIs are being called from threads then this API could 
 * use semaphores. However if the SRIO driver API's are being called from 
 * both ISR & Thread context then the critical section here would need to 
 * disable/enable interrupts. 
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void* Osal_srioEnterSingleCoreCriticalSection(Srio_DrvHandle drvHandle)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  drvHandle      - Driver Handle for which the critical section is being entered.
 *
 *  <b> Return Value </b>
 *  @n  Opaque Handle used for holding critical section locking information
 */

/**
 * @brief   The macro is used to denote the end of the protection of the internal
 * shared resource from SINGLE CORE MULTIPLE CONTEXT access.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void  Osal_srioExitSingleCoreCriticalSection(Srio_DrvHandle drvHandle, void* critSectHandle)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  drvHandle      - Driver Handle for which the critical section is being exited.
 *  @n  critSectHandle - Opaque Handle used for holding critical section locking information
 *
 *  <b> Return Value </b>
 *  @n  None
 */

/**
 * @brief   The macro is used by the SRIO driver to indicate that a block
 * of memory is about to be accessed. If the memory block is cached then
 * this indicates that the application would need to ensure that the cache
 * is updated with the data from the actual memory.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void  Osal_srioBeginMemAccess(void* ptr, uint32_t size)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  ptr  - Pointer to the memory
 *  @n  size - Size of the memory being accessed.
 *
 *  <b> Return Value </b>
 *  @n  None
 */

/**
 * @brief   The macro is used by the SRIO driver to indicate that  the block of 
 * memory has finished being accessed. If the memory block is cached then the 
 * application would need to ensure that the contents of the cache are updated
 * immediately to the actual memory.
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void  Osal_srioEndMemAccess(void* ptr, uint32_t size)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  ptr  - Pointer to the memory 
 *  @n  size - Size of the memory
 *
 *  <b> Return Value </b>
 *  @n  None
 */

/**
 * @brief   The macro is used by the SRIO driver to indicate that the driver
 * is about to start accessing a descriptor. 
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void  Osal_srioBeginDescriptorAccess (Srio_DrvHandle drvHandle,void* ptr, uint32_t descSize)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  drvHandle   - Driver Handle for which the descriptor is being accessed.
 *  @n  ptr         - Address of the descriptor which is being accessed.
 *  @n  size        - Size of the descriptor 
 *  @n                (Only Applicable for Driver Managed is 0 for App Managed)
 *
 *  <b> Return Value </b>
 *  @n  None
 */

/**
 * @brief   The macro is used by the SRIO driver to indicate that the driver
 * is finished populating the descriptor. 
 *
 * <b> Prototype: </b>
 *  The following is the C prototype for the expected OSAL API.
 *
 *  @verbatim
       void  Osal_srioEndDescriptorAccess (Srio_DrvHandle drvHandle,void* ptr, uint32_t descSize)
    @endverbatim
 *
 *  <b> Parameter </b>
 *  @n  drvHandle   - Driver Handle for which the descriptor is being accessed.
 *  @n  ptr         - Address of the descriptor which is being accessed.
 *  @n  size        - Size of the descriptor 
 *  @n                (Only Applicable for Driver Managed is 0 for App Managed)
 *
 *  <b> Return Value </b>
 *  @n  None
 */

/**
@}
*/



/* CPPI/QMSS Include Files. */
//#include <ti/drv/cppi/cppi_drv.h>
//#include <ti/drv/qmss/qmss_drv.h>


/* CSL Chip Functional Layer */

/* CSL Cache Functional Layer */

/* PSC CSL Include Files */

/* CSL SRIO Functional Layer */

/* CSL CPINTC Include Files. */

/*
 * platform.h
 *
 *  Created on: Feb 26, 2013
 *      Author: nachiappanr
 */

/* ========================================================================== */
/**
 *  @file   platform.h
 *
 *  @brief  The Platform Library is a thin utility
 *  layer on top of  CSL and other board utilities. It provides uniform APIs
 *  for all supported platforms. It aims to assist user to quickly write portable
 *  applications for its supported platforms by hiding board level details
 *  from the user.
 *
 *  ============================================================================
 */
/* --COPYRIGHT--,BSD
 * Copyright (c) 2010-2011, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/


/**
 * @mainpage Platform Utility APIs
 *  Defines a set of APIs for accessing and working with the various platform peripherals.
 *
 */


/** @defgroup  Platform_standard_data_types  Standard Data Types */
/*@{*/
/**
 *  @brief 	Platform Library uses basic C99 data types. The basic types used are
 *  		uint32_t, int32_t, uint8_t, int8_t, uint16_t and int16_t. The standard
 *  		C char is used for strings. Complex types (or typdefs) if used are defined
 *  		within this header file.
 */
/*@}*/  /* defgroup */

/** @defgroup  Platform_memory_section  Linker Memory Sections */
/*@{*/
/**
  * @brief  Memory Sections. You need to place these in your application linker map.
  *
  *			Section name: PLATFORM_LIB_SECTION
  *
  *			All of the static information used within the platform library is stored
  *			within this section.
  */
/*@}*/  /* defgroup */

/** @defgroup  Platform_cache Platform Cache */
/*@{*/
/**
  * @brief  The following definitions are for handling cache alignment on the platform.
  *
  * 		MAX_CACHE_LINE must be set to the cache line size of the platform.
  *
  * 		When allocating memory that must be cache aligned, it must be a multiple of
  * 		the cache line size. Use platform_roundup to get the appropriate size.
  *
  * 		As an example to allocate a cache aligned block of memory you would do
  * 		something like:
  *
  * 			buffer_len_aligned = platform_roundup (buffer_len, MAX_CACHE_LINE)
  * 			Malloc (buffer_len_aligned)
  *
  */
/* w should be power of 2 */

/**
 *   @n@b Convert_CoreLocal2GlobalAddr
 *
 *   @b Description
 *   @n This API converts a core local L2 address to a global L2 address.
 *
 *   @param[in]  addr  L2 address to be converted to global.
 *
 *   @return    uint32_t >0  Global L2 address
 *
 */
uint32_t Convert_CoreLocal2GlobalAddr (uint32_t  addr);


/*@}*/  /* defgroup */

/** @defgroup  Compilation_Flags Compilation Flags */
/*@{*/
/***
  * @brief  Flags for compiling the library.
  *
  * 		The file paltform_internal.h has compilation flags that can be set.
  */
/*@}*/  /* defgroup */

/** @defgroup  Platform_common  Common */
/*@{*/

/**
 * Error codes used by Platform functions. Negative values are errors,
 * while positive values indicate success.
 */



/* Set the endianess for the platform */


/**
 *  @brief This structure contains multicore processor information, e.g. # of the core, processor name, etc.
 */
typedef struct {
    int32_t core_count;
    /**<Number of cores*/
    char name[32];
    /**<Name of processor (eg: TMS320C6472)*/
    uint16_t id;
    /**<CPU ID of the Device (eg. Ch -> C64x CPU, 10h -> C64x+ CPU).*/
    uint16_t revision_id;
    /**<CPU Revision ID*/
    uint16_t megamodule_revision_major;
    /**<Megamodule Revision ID Major*/
    uint16_t megamodule_revision_minor;
    /**<Megamodule Revision ID Minor*/
    uint16_t silicon_revision_major;
    /**<Silicon Revision ID Major*/
    uint16_t silicon_revision_minor;
    /**<Silicon Revision ID Minor*/
    uint8_t endian;
    /**<Endian: {PLATFORM_LE | PLATFORM_BE}*/
} CPU_info;

/**
 *  @brief This structure contains information about the EMAC, e.g. # of EMAC port, MAC address for the port, etc.
 */
typedef struct {
    int32_t port_count;
    /**<Number of EMAC ports*/
    uint8_t efuse_mac_address[6];
    /**<EFUSE EMAC address */ /* August 15, 2011 - this field is deprecated, MAC address is now defined in the new data structure PLATFORM_EMAC_EXT_info */
    uint8_t eeprom_mac_address[6];
    /**<EEPROM EMAC address */ /* August 15, 2011 - this field is deprecated, MAC address is now defined in the new data structure PLATFORM_EMAC_EXT_info */
} EMAC_info;


/**
 * @brief Indicates the EMAC port mode
 *
 */
typedef enum {
    PLATFORM_EMAC_PORT_MODE_NONE,
    /**<EMAC port not used */
    PLATFORM_EMAC_PORT_MODE_PHY,
    /**<EMAC port connected to a PHY */
    PLATFORM_EMAC_PORT_MODE_AMC,
    /**<EMAC port connected to the backplane AMC chassis */
    PLATFORM_EMAC_PORT_MODE_MAX
    /**<End of port mode */
} PLATFORM_EMAC_PORT_MODE;


/**
 *  @brief This structure contains extended information about the EMAC, e.g. port #, port mode, port MAC addess, etc.
 */
typedef struct {
    uint32_t                        port_num;
    /**<Port number of the EMAC port */
    PLATFORM_EMAC_PORT_MODE         mode;
    /**<Mode of the EMAC port */
    uint8_t                         mac_address[6];
    /**<MAC address of the EMAC port */
} PLATFORM_EMAC_EXT_info;


/** @brief LED Classes */

typedef enum {
    PLATFORM_USER_LED_CLASS,
    /** <USER LED Group */
    PLATFORM_SYSTEM_LED_CLASS,
    /** <SYSTEM LED Group */
    PLATFORM_END_LED_CLASS
    /** END OF LED Groups */
} LED_CLASS_E;

/**
 *  @brief This structure contains information about LED on the platform
 */
typedef struct {
    int32_t count;
    /**<Number of LEDs*/
} LED_info;

/**
 * @brief Define how platform_write should behave.
 *    These write types can be set in the init structure
 */

typedef enum {
    PLATFORM_WRITE_UART,
    /** <Write to the UART */
    PLATFORM_WRITE_PRINTF,
    /** <printf mapped output -- CCS console */
    PLATFORM_WRITE_ALL
    /** <write all - default configuration */
} WRITE_info;

/**
 *  @brief This structure contains board specific information, e.g. cpu info, board Rev., LED info, etc.
 */
typedef struct {
    char version[16];
    /**<Platform library version */
    CPU_info cpu;
    /**<CPU information */
    char board_name[32];
    /**<Name of the board */
    char serial_nbr[16];
    /**<Serial number for the unit as read from the I2C */
    uint16_t board_rev;
    /**<Revision number of the board, as read from the H/W*/
	uint32_t frequency;
    /**<CPU frequency (MHz)*/
    /**<Peripheral information */
    EMAC_info emac;
    /**<EMAC information*/
    LED_info led[PLATFORM_END_LED_CLASS];
    /**<LED information*/
} platform_info;


/**
 *  @brief      Get platform information.
 *
 *
 *  @param[out] p_info  This structure will have platform information on return
 *
 */

void platform_get_info(platform_info * p_info);

/**
 *  @brief This structure contains peripherals to be initialized. It provides for basic board initialization.
 *			Flash and Character device are intiialized and controlled when they are opened.
 *
 *  @remark
 *     The init flags are set when platform_init() API is called by the application during
 *     the board initialization, by default all the flags are set to 1.
 */
typedef struct {
    uint8_t pll;
    /**<1: initialize PLL */
    uint8_t ddr;
    /**<1: initialize ddr */
    uint8_t tcsl;
    /**<1: initialize Time Stamp Counter (Low) Register */ /* June 2, 2011 - This flag is now deprecated and the TCSL is always initialized */
    uint8_t phy;
    /**<1: initialize PHY and its dependent components */
    uint8_t ecc;
    /**<1: initialize memory ECC checks. If 0, they are not disabled but the default power on state is disabled. */
} platform_init_flags;


/**
 *  @brief This structure contains initialization parameters
 */

typedef struct {
    uint32_t pllm;
    /**<Platform pll multiplier (0 to set the default value)*/
    uint32_t plld;
    /**<Platform pll divider (0 to set the default value)*/
    uint32_t prediv;
    /**<Platform pll predivider (0 to set the default value)*/
    uint32_t postdiv;
    /**<Platform pll postdivider (0 to set the default value)*/
    uint16_t mastercore;
    /** Designates this core as the Master. Default is Core 0 */
 } platform_init_config;

/**
 *  @brief     Plarform initialization
 *
 *  @param[in] p_flags  This structure will have init enable flags for peripherals
 *
 *  @param[in] p_config  This structure will have init configuration parameters
 *
 *  @retval    Platform_EOK on Success
 *
 *  @remark    This function can be called multiple times to init various peripherals,
 *             normally this API is called first when board is initialized by the application
 *
 */

int32_t platform_init(platform_init_flags * p_flags, platform_init_config * p_config);


/**
 *  @brief     Test external (DDR) memory region
 *
 *  @param[in] start_address  DDR Address to start at
 *
 *  @param[in] end_address    DDR Address to end at
 *
 *  @retval    Platform_EOK on Success
 *
 *  @remark    If the test fails, platform_errno will be set to the DDR address the test
 *			   failed at.
 */

int32_t platform_external_memory_test(uint32_t start_address, uint32_t end_address);

/**
 *  @brief     Test external (DDR) memory region
 *
 *  @param[in] id  Core to run th einternal memory test on
 * *
 *  @retval    Platform_EOK on Success
 *
 *  @remark    If the test fails, platform_errno will be set to the DDR address the test
 *			   failed at.
 */

int32_t platform_internal_memory_test(uint32_t id);



/**
 *  @brief     Plarform get core_id
 *
 *  @retval    Returns current core ID
 *
 */

uint32_t platform_get_coreid(void);

/**
 *  @brief     Platform get DIP switch state
 *
 *  @param[in] id ID of the switch
 *
 *  @retval    1 if ON and 0 if OFF
 *
 */

uint32_t platform_get_switch_state(uint32_t id);

/*@}*/  /* defgroup */

/** @defgroup    EMAC_PHY_support_functions  EMAC */
/*@{*/

/**
 * @brief MAC address type
 *
 */
typedef enum {
    /** MAC address in EFUSE */
    PLATFORM_MAC_TYPE_EFUSE,
    /** MAC address in EEPROM */
    PLATFORM_MAC_TYPE_EEPROM
} PLATFORM_MAC_TYPE;

/**
 *  @brief     Plarform get MAC address from EFUSE
 *
 *             August 15, 2011 - this API is deprecated, application needs to call
 *             the new API platform_get_emac_info() to get the MAC address of the port
 *
 *  @param[in] type  MAC address storage type
 *
 *  @param[out] mac_address  MAC address assigned to the core
 *
 *  @retval    Platform_EOK on Success
 *
 */

int32_t platform_get_macaddr(PLATFORM_MAC_TYPE type, uint8_t * mac_address);

/**
 *  @brief     Plarform get information of an EMAC port
 *
 *  @param[in] port_num  port number
 *
 *  @param[out] emac_info  EMAC port information
 *
 *  @retval    Platform_EOK on Success
 *
 */

int32_t platform_get_emac_info(uint32_t port_num, PLATFORM_EMAC_EXT_info * emac_info);

/**
 *  @brief     Get PHY address for a port number
 *
 *             Please note that this function is a place holder for C64x devices
 *             and is not used for KeyStone devices.
 *
 *  @param[in] port_num  port number
 *
 *  @retval    event id or -1 on failure
 *
 */

int32_t platform_get_phy_addr(uint32_t port_num);

/**
 *  @brief     Platform EMAC/PHY link status
 *
 *  @param[in] port_num  port number
 *
 *  @retval    0 on success
 *
 *  @remark    This is ONLY supported for on chip PHY
 *
 */

int32_t platform_phy_link_status(uint32_t port_num);

/*@}*/  /* defgroup */

/** @defgroup    Memory_device_support_functions  Memory Devices (e.g. Flash) */
/*@{*/

/**
 * @brief Devices
 *         The platform library provides a common interface for reading and writing
 *         flash and serial memory devices on the platform.
 *
 *         To work with a device you must first open it, perform a read or write, and
 *         then close it.
 *
 *         In addition to the basic operations of read and write, certain types of devices, like flash
 *         may support other extended operations.
 *
 * Devices
 *
 *  Types: 	NOR
 *			NAND
 *			EEPROM
 *
 * Operations:
 *			Open
 *			Close
 *			Read
 *			Write
 *
 *	Extended Operations:
 *			Erase			Supported by NOR and NAND devices
 *			ReadSpare		Supported by NAND devices
 *			WriteSpare		Supported by NAND devices
 *			MarkBlockBad	Supported by NAND devices
 *
 *
 *  Nand Device Notes:
 *
 *  Writes
 *
 *  When writing the NAND device you may either a) Write one page at a time or
 *  b) write a block of data that is larger than a single page. All writes to the
 *  NAND flash must be aligned to start on a page boundary.
 *
 *  When using platform_device_write() if you write a single page (done by
 *  setting the length of the write to the page size) then your application will need to
 *  take care of erasing and preserving the block the page is in.
 *
 *  If you write more than a page, the platform_device_write call will handle
 *  erasing the block the page is in and will also preserve the contents of other
 *  pages within the block that are not being written to. The algorithm used is as
 *  follows:
 *
 * 	   While we have data to write do
 *       skip block if bad (and keep skipping until the next good block is found)
 *       read the block    (page level)
 *       erase the block   (block level)
 *       write the block   (page level)
 *
 * 	Reads
 *
 *  When using platform_device_read on a NAND device it will currently only read a
 *  single page at a time.
 *
 *
 *  Nor Device Notes
 *
 *  Writes
 *
 *  When working the NOR device you may either write a block of data that is larger than
 *  a single page. All writes to the flash must be aligned to start on a page boundary.
 *
 *  When using platform_device_write() if you write a single page (done by
 *  setting the length of the write to the page size) then your application will need to
 *  take care of erasing and preserving the block the page is in.
 *
 *  If you write more than a page, the platform_device_write call will handle
 *  erasing the block the page is in and will also preserve the contents of other
 *  pages within the block that are not being written to. The algorithm used is as
 *  follows:
 *
 * 	   While we have data to write do
 *       skip block if bad (and keep skipping until the next good block is found)
 *       read the block    (page level)
 *       erase the block   (block level)
 *       write the block   (page level)
 *
 *  Reads
 *
 *  When using platform_device_read on a NOR device, you may read as much as you like.
 */

/**
 * @brief 	Device Identifiers. These are used in the Open call to allow access to a specific
 * 			memory device.
 *
 */

/**
 * @brief Indicates the type of device
 *
 */
typedef enum {
    PLATFORM_DEVICE_NAND,
    /**<NAND Flash*/
    PLATFORM_DEVICE_NOR,
    /**<NOR Flash*/
    PLATFORM_DEVICE_EEPROM,
    /**<NOR Flash*/
    PLATFORM_DEVICE_MAX
    /**<End of devices*/
} PLATFORM_DEVICE_TYPE;

/**
 *  @brief 	This type defines the opaque handle returned to a device that is opened.
 *  		The handle must be used in all subsequent operations.
 *
 */
typedef uint32_t PLATFORM_DEVHANDLE;

/**
 *  @brief This structure contains information about the flash device on the platform
 *
 *			The bblist points to an array of bytes where each position represents a
 *			block on the device. If the block is good it is marked as 0xFF. If the block
 *			is bad, it is marked as 0x00. For devices that do not support a bad block list this
 *			value will be NULL. The number of blocks in the bblist is determined by the block_count field.
 */
typedef struct {
    int32_t manufacturer_id;		/**<manufacturer ID*/
    int32_t device_id;				/**<Manufacturers device ID*/
    PLATFORM_DEVICE_TYPE  type;		/**<Type of device */
    int32_t width;					/**<Width in bits*/
    int32_t block_count;			/**<Total blocks. First block starts at 0. */
    int32_t page_count;				/**<Page count per block*/
    int32_t page_size;				/**<Number of bytes in a page including spare area*/
    int32_t spare_size;				/**<Spare area size in bytes*/
    PLATFORM_DEVHANDLE handle;		/**<Handle to the block device as returned by Open. Handle is Opaque, do not interpret or modify */
    int32_t	bboffset;				/**<Offset into spare area to check for a bad block */
	uint32_t column;				/**<Column for a NAND device */
	uint32_t flags;					/**<Flags is a copy of the flags that were used to open the device */
	void	*internal;				/**<Do not use. Used internally by the platform library */
    uint8_t *bblist;				/** <Bad Block list or NULL if device does not support one  */
} PLATFORM_DEVICE_info;

/**
 *  @brief       Opens a device for use
 *
 *  @param[in]   deviceid		Device to open
 *
 *	@param[in]	 flags			Various flags
 *
 *  @retval      NULL or a pointer to the File Handle if successful.
 *
 *  @remark
 *               On success a handle is returned in p_devinfo which should be used in
 *				 all subsequent calls. As of now, the devices are not virtualized and only
 *				 one open may exist at a time for a particular device.
 *
 *				 If NULL is returned paltform_errno should be set to indicate why the
 *				 open was un-successful.
 *
 * 				 Flag Usage: (Currently none defined, use 0)
 */

PLATFORM_DEVICE_info *platform_device_open(uint32_t deviceid, uint32_t flags);

/**
 *  @brief       Closes the device
 *
 *  @param[in]   handle  Handle to the device as returned in the open call.
 *
 *  @retval      Platform_EOK on Success
 *
 */

int32_t platform_device_close (PLATFORM_DEVHANDLE handle);


/**
 *  @brief      Write the data to the device
 *
 *  @param[in]  handle  Handle to the device as returned by open
 *
 *  @param[in]  offset 		Offset to start writing the data at.
 *
 *  @param[in] 	buf          Pointer to  data to write
 *
 *  @param[in] 	len          Length of the data pointed to by buf
 *
 *  @retval     Platform_EOK on Success
 *
 *  @remark		For NAND devices use the platform_blocknpage_to_offset call.
 *
 *
 */
int32_t platform_device_write(PLATFORM_DEVHANDLE 	handle,
									 uint32_t 	offset,
                                     uint8_t 	*buf,
                                     uint32_t	len);

/**
 *  @brief      Convert the block and page number to offset
 *
 *  @param[in]  handle  Handle to the device as returned by open
 *
 *  @param[in]  offset 		Offset to start writing the data at.
 *
 *  @param[in] 	block       Block number
 *
 *  @param[in] 	page        Page number
 *
 *  @retval     Platform_EOK on Success
 *
 *
 */
int32_t platform_blocknpage_to_offset(PLATFORM_DEVHANDLE 	handle,
									 uint32_t 	*offset,
                                     uint32_t 	block,
                                     uint32_t	page);


/**
 *  @brief      Convert the offset to block and page number
 *
 *  @param[in]  handle  Handle to the device as returned by open
 *
 *  @param[in]  offset 		Offset to start writing the data at.
 *
 *  @param[in] 	block       Pointer to the block number
 *
 *  @param[in] 	page        Pointer to the Page number
 *
 *  @retval     Platform_EOK on Success
 *
 *
 */
int32_t platform_offset_to_blocknpage(PLATFORM_DEVHANDLE handle,
									 uint32_t 	offset,
                                     uint32_t 	*block,
                                     uint32_t	*page);

/**
 *  @brief       Reads a page from the device
 *
 *  @param[in]   handle  Flash device handle from the open
 *
 *  @param[in]   offset Offset to start the read from
 *
 *  @param[in]   buf	Pointer to a buffer to read the data into
 *
 *  @param[in] 	len     Amount of data to read
 *
 *  @retval      Platform_EOK on Success
 *
 *  @remark      The buffer size should be page_size + spare_size
 *               The application should not write into the spare area
 *
 *               For NAND devices use the platform_offset_to_blocknpage call.
 *
 *  errno        This routine may set platform_errno to
 *               the following values on an error (see below for explanation):
 *               PLATFORM_ERRNO_ECC_FAIL
 */


int32_t platform_device_read(PLATFORM_DEVHANDLE 	handle,
									 uint32_t 	offset,
                                     uint8_t 	*buf,
                                     uint32_t	len);

/**
 *  @brief       Reads spare data from the flash device
 *
 *  @param[in]   handle  Flash device handle from the open
 *
 *  @param[in]   block_number Block ID to read from
 *
 *  @param[in]   page_number  Page to read the spare area from
 *
 *  @param[in]   buf          Pointer to message data
 *
 *  @retval      Platform_EOK on Success
 *
 *  @remark      The buffer size should be spare_size.
 */

int32_t platform_device_read_spare_data(PLATFORM_DEVHANDLE handle,
												uint32_t block_number,
												uint32_t page_number,
												uint8_t *buf);


/**
 *  @brief       Marks the block bad
 *
 *  @param[in]   handle  Handle from the open
 *
 *  @param[in]   block_number Block to write the spare area for
 *
 *
 *  @retval      Platform_EOK on Success
 *
 *  @remark      This API can be specifically used to mark a block to be bad
 *               when there is read error due to the ECC failure.
 *               The bad block mark byte is indexed by the bboffset. The application should
 *               only overwirte the bad block mark byte in the spare area
 *               data when marking a block bad.
 *
 */

int32_t platform_device_mark_block_bad (PLATFORM_DEVHANDLE handle,
                                                uint32_t block_number);

/**
 *  @brief       Writes spare data to the flash device
 *
 *  @param[in]   handle  Handle from the open
 *
 *  @param[in]   block_number Block to write the spare area for
 *
 *  @param[in]   page_number  Page to write the spare area for
 *
 *  @param[in]   buf          Pointer to spare area data to write
 *
 *  @retval      Platform_EOK on Success
 *
 *  @remark      This API can be used to mark a block to be bad when there
 *               is read error due to the ECC failure. The bad block mark
 *               byte is indexed by the bboffset. The application should
 *               only overwirte the bad block mark byte in the spare area
 *               data when marking a block bad.
 *
 *               The buffer size should be spare_size. This function
 *				 should ONLY be used when you know what you are doing
 *				 and have a specific purpose in mind. Incorrectly
 *				 changing the spare area of a block may lead to
 *				 unpredictable results or render it not useable.
 */

int32_t platform_device_write_spare_data(PLATFORM_DEVHANDLE handle,
                                                uint32_t block_number,
												uint32_t page_number,
												uint8_t *buf);

/**
 *  @brief       erase a block on the flash block
 *
 *  @param[in]   handle  Flash device handle from the open
 *
 *  @param[in]   block_number Block ID to erase
 *
 *  @retval      Platform_EOK on Success
 *
 */

int32_t platform_device_erase_block(PLATFORM_DEVHANDLE handle,
                                            uint32_t block_number);


/*@}*/  /* defgroup */

/** @defgroup    UART_functions  UART */
/*@{*/


/**
 *  @brief      Initialize the UART.
 *
 *  @retval     Platform_EOK on Success
 *
 *  @remark     This routine must be called before you read and write to the UART.
 *  			The default baudrate of 115200 will be set. It can be changed
 *  			by calling platform_uart_set_baudrate.
 */

int32_t platform_uart_init(void);


/**
 *  @brief      Set the baud rate for the UART
 *
 *  @param[in]  baudrate Baudrate to use: (2400, 4800, 9600, 19200, 38400, 57600, 115200)
 *
 *  @retval     Platform_EOK on Success
 *
 */

int32_t platform_uart_set_baudrate(uint32_t baudrate);

/**
 *  @brief      Read a byte from UART
 *
 *  @param[in]  buf  Pointer to message data
 *
 *  @param[in]  delay Wait time (in micro-seconds)
 *                    for input FIFO to be non-empty.
 *                    0 => Wait for ever.
 *
 *  @retval     Platform_EOK on Success
 *
 */

//Platform_STATUS platform_uart_read(uint8_t *buf, uint32_t delay);
 int32_t platform_uart_read(uint8_t *buf, uint32_t delay);
/**
 *  @brief      Write a character to the UART
 *
 *  @param[in]  chr 	character to write
 *
 *
 *  @retval     Platform_EOK on Success
 *
 */

int32_t platform_uart_write(uint8_t chr);

/**
 *  @brief       Platform Write
 *
 *  @param[in]   *fmt    printf style vararg
 *
 *  @retval      Nothing (but platform_errno may get set)
 *
 *  @remark      This routine will output the printf style string
 *               to one or both of the UART and/or through a printf
 *               call (in CCS this is mapped to the console window).
 *               By default, both are written. This can be controlled
 *               by setting write_type in the paltform_init structure.
 *               By default, both the UART and printf outputs are used.
 *
 *				 The largest string size you can write is 80 characters.
 *				 Some checking is performed (on the fmt string only) to be
 *				 sure it is under that length. Note that expansion could
 *				 set the string higher and therefore corrupt memory.
 *
 *               User platform_write_configure to control where the
 *               output appears. The call retturns the previous setting.
 *
 *				 This call is not intended to be used for serious debugging.
 *				 Its purpose is light duty writing of messages. It should not
 *               be called from an interrupt context as it uses printf when
 *				 writing to the console. The following wiki articles are good
 *               write ups on printf vs. system_printf vs. real time tracing
 *				  http://processors.wiki.ti.com/index.php/Printf_support_in_compiler
 *				  http://processors.wiki.ti.com/index.php/Tips_for_using_printf
 */

void uart_write(const char *fmt, ...);
WRITE_info platform_write_configure (WRITE_info write_type);

/*@}*/  /* defgroup */


/** @defgroup    Utility_functions  Utility Functions */
/*@{*/

/** LED operation
*/
typedef enum {

    /** Turn off LED
    */
    PLATFORM_LED_OFF = 0,

    /** Turn on LED
    */
    PLATFORM_LED_ON = 1

} PLATFORM_LED_OP;

/**
 *  @brief       Perform LED operation
 *
 *  @param[in]   led_id    LED ID
 *
 *  @param[in]   operation LED operation
 *
 *  @param[in]   led_class LED Class
 *
 *  @retval     Platform_EOK on Success
 *
 */

int32_t platform_led(uint32_t led_id, PLATFORM_LED_OP operation, LED_CLASS_E led_class);

/**
 *  @brief       Delay function. The call to this function returns after
 *               specified amount of time.
 *
 *  @param[in]   usecs Delay value in micro-seconds
 *
 *  @retval      Platform_EOK on Success
 *
 */

int32_t platform_delay(uint32_t usecs);

/**
 *  @brief       Delay function. The call to this function returns after
 *               specified amount of time. It uses the TSCL where 1 TCSL
 *               tick is 1 cycle.
 *
 *  @param[in]   cycles Delay value in clock cycles
 *
 *  @retval      None
 *
 */

void platform_delaycycles(uint32_t cycles);

/*@}*/  /* defgroup */

/** @defgroup    OSAL_functions  OSAL Functions
* These routines are called from Platform Library and must be implemented by the Application.
*/
/*@{*/

/**
 * ============================================================================
 *  @n@b Osal_platformMalloc
 *
 *  @b  brief
 *  @n  This API is used by platform_library to allocate memory. Applications
 *  	must provide this function and attach it to their memory allocator.
 *
 *  @param[in]  num_bytes
 *      Number of bytes to be allocated.
 *  @param[in]  alignment
 *      byte alignment needed
 *
 *  @return
 *      Allocated block address
 * =============================================================================
 */
uint8_t *Osal_platformMalloc (uint32_t num_bytes, uint32_t alignment);


/**
 * ============================================================================
 *  @n@b Osal_platformFree
 *
 *  @b  brief
 *  @n  Frees up memory allocated using
 *      @a Osal_platformMalloc ()
 *
 *		Applications must provide this function and attach it to ther memory
 *		free handler.
 *
 *  @param[in]  dataPtr
 *      Pointer to the memory block to be cleaned up.
 *
 *  @param[in]  num_bytes
 *      Size of the memory block to be cleaned up.
 *
 *  @return
 *      Not Applicable
 * =============================================================================
 */
void Osal_platformFree (uint8_t *dataPtr, uint32_t num_bytes);

/**
 * ============================================================================
 *  @n@b Osal_platformSpiCsEnter
 *
 *  @b  brief
 *  @n  This API ensures multi-core and multi-threaded
 *      synchronization for the SPI bus.
 *
 *      This is a BLOCKING API.
 *
 *
 *  @return
 *  @n  Handle used to lock critical section
 * =============================================================================
 */
void Osal_platformSpiCsEnter(void);


/**
 * ============================================================================
 *  @n@b Osal_platformSpiCsExit
 *
 *  @b  brief
 *  @n  This API needs to be called to exit a previously
 *      acquired critical section lock using @a Osal_platformSpiCsEnter ()
 *      API. It resets the multi-core and multi-threaded lock,
 *      enabling another process/core to grab the SPI bus.
 *
 *
 *  @return     None
 * =============================================================================
 */
void Osal_platformSpiCsExit (void);



/*@}*/  /* defgroup */

/** @defgroup    Error_handling  Error Handling (Errno values) */
/*@{*/

/**
 *  @brief platform_errno variable may be set to a non-zero value when
 *         a platform library call returns an error.
 *
 *      The errno value is not preserved. The calling application must
 *       save off the value if the platform function call fails.
 */
extern uint32_t platform_errno;

/** Platform errno values */








/*@}*/  /* defgroup */

/** @defgroup  Platform_common  Common */
/*@{*/

/**
 *  @brief Platform PLL init sequence return code
 *
 *  @remark This might be deprecated in future release of platform library
 */

extern uint32_t platform_init_return_code;

/*@}*/  /* defgroup */

//#include"spi.h"
/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/
 
 /******************************************************************************	
 *
 * File	Name:	evmc66x_gpio.h
 *
 * Description:	This file is the header	file for GPIO module
 *
 *
 ******************************************************************************/

/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/

/******************************************************************************	
 *
 * File Name:   evmc66x_spi.h
 *
 * Description: This is the header file for SPI API's.
 *
 ******************************************************************************/

/* ------------------------------------------------------------------------ *
 *  Include Files                                                           *
 * ------------------------------------------------------------------------ */
//#include "types.h"
/*
 * cslr_spi.h
 *
 * This file contains the macros for Register Chip Support Library (CSL) which 
 * can be used for operations on the respective underlying hardware/peripheral
 *
 * Copyright (C) 2010 Texas Instruments Incorporated - http://www.ti.com/
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/


/** ============================================================================
 *   @file  cslr_spi.h
 *
 *   @path  $(CSLPATH)
 *
 *   @desc  This file contains the Register Descriptions for SPI
 *
 *  ============================================================================
 */




/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 SPIGCR0;
    volatile Uint32 SPIGCR1;
    volatile Uint32 SPIINT0;
    volatile Uint32 SPILVL;
    volatile Uint32 SPIFLG;
    volatile Uint32 SPIPC0;
    volatile Uint32 SPIPC1;
    volatile Uint32 SPIPC2;
    volatile Uint32 SPIPC3;
    volatile Uint32 SPIPC4;
    volatile Uint32 SPIPC5;
    volatile Uint8 RSVD0[12];
    volatile Uint32 SPIDAT0;
    volatile Uint32 SPIDAT1;
    volatile Uint32 SPIBUF;
    volatile Uint32 SPIEMU;
    volatile Uint32 SPIDELAY;
    volatile Uint32 SPIDEF;
    volatile Uint32 SPIFMT[4];
    volatile Uint32 INTVEC[2];
} CSL_SpiRegs;

/*************************************************************************** Overlay structure typedef definition
\**************************************************************************/
typedef volatile CSL_SpiRegs         *CSL_SpiRegsOvly;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* SPIGCR0 */


/*----RESET Tokens----*/


/* SPIGCR1 */


/*----ENABLE Tokens----*/


/*----LOOPBACK Tokens----*/


/*----POWERDOWN Tokens----*/


/*----CLKMOD Tokens----*/

/*----MASTER Tokens----*/


/* SPIINT0 */


/*----ENABLEHIGHZ Tokens----*/


/*----DMAREQEN Tokens----*/


/*----TXINTENA Tokens----*/

/*----RXINTENA Tokens----*/


/*----OVRNINTENA Tokens----*/


/*----BITERRENA Tokens----*/

/*----DESYNCENA Tokens----*/

/*----PARERRENA Tokens----*/

/*----TIMEOUTENA Tokens----*/

/*----DLENERRENA Tokens----*/


/* SPILVL */


/*----TXINTLVL Tokens----*/

/*----RXINTLVL Tokens----*/


/*----OVRNINTLVL Tokens----*/


/*----BITERRLVL Tokens----*/

/*----DESYNCLVL Tokens----*/

/*----PARERRLVL Tokens----*/

/*----TIMEOUTLVL Tokens----*/

/*----DLENERRLVL Tokens----*/


/* SPIFLG */


/*----TXINTFLG Tokens----*/

/*----RXINTFLG Tokens----*/


/*----OVRNINTFLG Tokens----*/


/*----BITERRFLG Tokens----*/

/*----DESYNCFLG Tokens----*/

/*----PARERRFLG Tokens----*/

/*----TIMEOUTFLG Tokens----*/

/*----DLENERRFLG Tokens----*/


/* SPIPC0 */


/*----SOMIFUN Tokens----*/

/*----SIMOFUN Tokens----*/

/*----CLKFUN Tokens----*/

/*----ENAFUN Tokens----*/

/*----SCS0FUN7 Tokens----*/

/*----SCS0FUN6 Tokens----*/

/*----SCS0FUN5 Tokens----*/

/*----SCS0FUN4 Tokens----*/

/*----SCS0FUN3 Tokens----*/

/*----SCS0FUN2 Tokens----*/

/*----SCS0FUN1 Tokens----*/

/*----SCS0FUN0 Tokens----*/


/* SPIPC1 */


/*----SOMIDIR Tokens----*/

/*----SIMODIR Tokens----*/

/*----CLKDIR Tokens----*/

/*----ENADIR Tokens----*/

/*----SCS0DIR7 Tokens----*/

/*----SCS0DIR6 Tokens----*/

/*----SCS0DIR5 Tokens----*/

/*----SCS0DIR4 Tokens----*/

/*----SCS0DIR3 Tokens----*/

/*----SCS0DIR2 Tokens----*/

/*----SCS0DIR1 Tokens----*/

/*----SCS0DIR0 Tokens----*/


/* SPIPC2 */


/*----SOMIDIN Tokens----*/

/*----SIMODIN Tokens----*/

/*----CLKDIN Tokens----*/

/*----ENADIN Tokens----*/

/*----SCS0DIN7 Tokens----*/

/*----SCS0DIN6 Tokens----*/

/*----SCS0DIN5 Tokens----*/

/*----SCS0DIN4 Tokens----*/

/*----SCS0DIN3 Tokens----*/

/*----SCS0DIN2 Tokens----*/

/*----SCS0DIN1 Tokens----*/

/*----SCS0DIN0 Tokens----*/


/* SPIPC3 */


/*----SOMIDOUT Tokens----*/

/*----SIMODOUT Tokens----*/

/*----CLKDOUT Tokens----*/

/*----ENADOUT Tokens----*/

/*----SCS0DOUT7 Tokens----*/

/*----SCS0DOUT6 Tokens----*/

/*----SCS0DOUT5 Tokens----*/

/*----SCS0DOUT4 Tokens----*/

/*----SCS0DOUT3 Tokens----*/

/*----SCS0DOUT2 Tokens----*/

/*----SCS0DOUT1 Tokens----*/

/*----SCS0DOUT0 Tokens----*/


/* SPIPC4 */


/*----SOMISET Tokens----*/

/*----SIMOSET Tokens----*/

/*----CLKSET Tokens----*/

/*----ENASET Tokens----*/

/*----SCS0SET7 Tokens----*/

/*----SCS0SET6 Tokens----*/

/*----SCS0SET5 Tokens----*/

/*----SCS0SET4 Tokens----*/

/*----SCS0SET3 Tokens----*/

/*----SCS0SET2 Tokens----*/

/*----SCS0SET1 Tokens----*/

/*----SCS0SET0 Tokens----*/


/* SPIPC5 */


/*----SOMICLR Tokens----*/

/*----SIMOCLR Tokens----*/

/*----CLKCLR Tokens----*/

/*----ENACLR Tokens----*/

/*----SCS0CLR7 Tokens----*/

/*----SCS0CLR6 Tokens----*/

/*----SCS0CLR5 Tokens----*/

/*----SCS0CLR4 Tokens----*/

/*----SCS0CLR3 Tokens----*/

/*----SCS0CLR2 Tokens----*/

/*----SCS0CLR1 Tokens----*/

/*----SCS0CLR0 Tokens----*/


/* SPIDAT0 */




/* SPIDAT1 */


/*----CSHOLD Tokens----*/


/*----WDEL Tokens----*/

/*----DFSEL Tokens----*/




/* SPIBUF */

/*----RXEMPTY Tokens----*/

/*----RXOVR Tokens----*/

/*----TXFULL Tokens----*/

/*----BITERR Tokens----*/

/*----DESYNC Tokens----*/

/*----PARERR Tokens----*/

/*----TIMEOUT Tokens----*/

/*----DLENERR Tokens----*/




/* SPIEMU */




/* SPIDELAY */






/* SPIDEF */


/*----CSDEF0 Tokens----*/


/* SPIFMT */



/*----PARPOL Tokens----*/

/*----PARENA Tokens----*/

/*----WAITENA Tokens----*/

/*----SHIFTDIR Tokens----*/


/*----DISCSTIMERS Tokens----*/

/*----POLARITY Tokens----*/

/*----PHASE Tokens----*/





/* INTVEC */







/* ------------------------------------------------------------------------ *
 *  SPI Controller                                                          *
 * ------------------------------------------------------------------------ */



/* SPI error status */


Uint32 
spi_claim
(
    Uint32      cs,
    Uint32      freq
);

void 
spi_release
(
    void
);

Uint32 
spi_xfer
(
    Uint32              bitlen,
    Uint8*		        dout, 
    Uint8*              din, 
    Bool                flags
);

Uint32 
spi_cmd
(
    Uint8               cmd, 
    Uint8*              response, 
    Uint32              len
);

Uint32 
spi_cmd_read
(
    Uint8*              cmd,
    Uint32              cmd_len, 
    Uint8*              data, 
    Uint32              data_len
);

Uint32 
spi_cmd_write
(
    Uint8*              cmd, 
    Uint32              cmd_len,
    Uint8*              data, 
    Uint32              data_len
);

Uint32 
spi_read_word
(
    Uint16*             cmd_buf,
    Uint32              cmd_len, 
    Uint16*             data_buf, 
    Uint32              data_len
);

Uint32 
spi_write_word
(
    Uint16*             cmd_buf, 
    Uint32              cmd_len,
    Uint16*             data_buf, 
    Uint32              data_len
);

//#define EVMBOARD

/************************
 * Defines and Macros
 ************************/ 






// GPIO	pins and the Nand flash	controller signal mapping
// GPIO[7:0] are used as bi-directional	data-bus
// between DSP and FPGA	
// Command pins	


typedef	enum GpioDirection
{
	GPIO_OUT = 0,
	GPIO_IN	
}GpioDirection;	


/************************
 * Function declarations
 ************************/
void gpioInit(void);
void gpioSetDirection(uint32_t uiNumber, GpioDirection direction);
void gpioSetDataBusDirection(GpioDirection direction);
void gpioSetOutput(uint32_t uiNumber);
void gpioClearOutput(uint32_t uiNumber);
uint32_t gpioReadInput(uint32_t uiNumber);
void gpioWriteDataBus(uint8_t uchValue);
uint8_t gpioReadDataBus(void);
void gpioEnableGlobalInterrupt(void);
void gpioSetDataBus(uint8_t uchValue);
void gpioClearDataBus(uint8_t uchValue);
void gpioDisableGlobalInterrupt(void);
void gpioSetRisingEdgeInterrupt(uint32_t uiNumber);
void gpioClearRisingEdgeInterrupt(uint32_t uiNumber);
void gpioSetFallingEdgeInterrupt(uint32_t	uiNumber);
void gpioClearFallingEdgeInterrupt(uint32_t uiNumber);


//#include"spi_fpga.h"
/* ========================================================================== */
/**
 *  @file   platform_internal.h
 *
 *  @brief  Private definitions for the Platform Library.
 *
 *  ============================================================================
 */
/* --COPYRIGHT--,BSD
 * Copyright (c) 2011, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/


/********************************************************************************************
 * 					BUILD OPTIONS FOR THE LIBRARY											*
 *******************************************************************************************/

/***
 * @brief  The following flags are used for controlling the build of Platform Library
 */

/*  brief Platform Library version number */

/* Turn on and off debug statements (may not be safe in certain contexts) */

/* These flags compile in and out functionality offered by the library allowing you to control
 * the size of the code that is included.
 */
	/*
	 * Build the FULL version of Platform Library
	 */



/* This flag implements a workaround to re-initialize PLL and DDR 
   if DDR test after DDR initialization */

/********************************************************************************************
 * 					Includes for the Library Routines										*
 *******************************************************************************************/

/******************************************************************************	
 * Copyright (c) 2010-2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary	forms, with or without	
 *  modification, are permitted	provided that the following conditions	
 *  are	met:
 *
 *    Redistributions of source	code must retain the above copyright 
 *    notice, this list	of conditions and the following	disclaimer.
 *
 *    Redistributions in binary	form must reproduce the	above copyright	
 *    notice, this list	of conditions and the following	disclaimer in the 
 *    documentation and/or other materials provided with the	
 *    distribution.
 *
 *    Neither the name of Texas	Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this	software without specific prior	written	permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS	
 *  "AS	IS" AND	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO,	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR	ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY,	OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO,	PROCUREMENT OF SUBSTITUTE GOODS	OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION)	HOWEVER	CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,	OR TORT	
 *  (INCLUDING NEGLIGENCE OR OTHERWISE)	ARISING	IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/	

/******************************************************************************	
 *
 * File	Name:	types.h	
 *
 * Description:	This file contains the standard	data types used	
 * 
 ******************************************************************************/

/*********************************
 * Defines and Macros and globals
 *********************************/

// Generic masks.




// Macros for error




/*****************************************************************************/
/* STDIO.H v7.3.4                                                            */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/



/*****************************************************************************/
/* stdlib.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/


/*---------------------------------------------------------------------------*/
/* Attributes are only available in relaxed ANSI mode.                       */
/*---------------------------------------------------------------------------*/



typedef struct { int quot, rem; } div_t;

typedef struct { long quot, rem; } ldiv_t;

typedef struct { long long quot, rem; } lldiv_t;








/*---------------------------------------------------------------*/
/* NOTE - Normally, abs, labs, and fabs are expanded inline, so  */
/*        no formal definition is really required. However, ANSI */
/*        requires that they exist as separate functions, so     */
/*        they are supplied in the library.  The prototype is    */
/*        here mainly for documentation.                         */
/*---------------------------------------------------------------*/
      int       abs(int _val); 
      long      labs(long _val);
      long long llabs(long long _val);
     int       atoi(const char *_st);
     long      atol(const char *_st);
     long long atoll(const char *_st);
     int       ltoa(long val, char *buffer);
          static __inline double    atof(const char *_st);

     long      strtol(const char *_st, char **_endptr, int _base);
     unsigned long strtoul(const char *_st, char **_endptr,
    					  int _base);
     long long strtoll(const char *_st, char **_endptr, int _base);
     unsigned long long strtoull(const char *_st, char **_endptr,
					     int _base);
     double    strtod(const char *_st, char **_endptr);
     long double strtold(const char *_st, char **_endptr);
    
     int    rand(void);
     void   srand(unsigned _seed);
    
     void  *calloc(size_t _num, size_t _size)
               __attribute__((malloc));
     void  *malloc(size_t _size)
               __attribute__((malloc));
     void  *realloc(void *_ptr, size_t _size)
               __attribute__((malloc));
     void   free(void *_ptr);
     void  *memalign(size_t _aln, size_t _size)
               __attribute__((malloc));
    
     void   abort(void); 
     int    atexit(void (*_func)(void));
     void  *bsearch(const void *_key, const void *_base,
    				   size_t _nmemb, size_t _size, 
    			           int (*compar)(const void *,const void *));
     void   qsort(void *_base, size_t _nmemb, size_t _size, 
    			         int (*_compar)(const void *, const void *));
     void   exit(int _status);
    
     div_t  div(int _numer, int _denom);
     ldiv_t ldiv(long _numer, long _denom);
     lldiv_t lldiv(long long _numer, long long _denom);

     char  *getenv(const char *_string);
     int    system(const char *_name);

     int    mblen(const char *, size_t);
     size_t mbstowcs(wchar_t *, const char *, size_t);
     int    mbtowc(wchar_t *, const char *, size_t);

     size_t wcstombs(char *, const wchar_t *, size_t);
     int    wctomb(char *, wchar_t);





static __inline double atof(const char *_st) 
{
  return strtod(_st, (char **)0); 
}





/*****************************************************************************/
/* string.h   v7.3.4                                                         */
/*                                                                           */
/* Copyright (c) 1993-2012 Texas Instruments Incorporated                    */
/* http://www.ti.com/                                                        */
/*                                                                           */
/*  Redistribution and  use in source  and binary forms, with  or without    */
/*  modification,  are permitted provided  that the  following conditions    */
/*  are met:                                                                 */
/*                                                                           */
/*     Redistributions  of source  code must  retain the  above copyright    */
/*     notice, this list of conditions and the following disclaimer.         */
/*                                                                           */
/*     Redistributions in binary form  must reproduce the above copyright    */
/*     notice, this  list of conditions  and the following  disclaimer in    */
/*     the  documentation  and/or   other  materials  provided  with  the    */
/*     distribution.                                                         */
/*                                                                           */
/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
/*     of its  contributors may  be used to  endorse or  promote products    */
/*     derived  from   this  software  without   specific  prior  written    */
/*     permission.                                                           */
/*                                                                           */
/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
/*                                                                           */
/*****************************************************************************/




/*  ===========================================================================
 *  Copyright (c) Texas Instruments Incorporated 2011
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** ============================================================================
 *   @file  cslr_emif16.h
 *
 *   @path  $(CSLPATH)\inc
 *
 *   @desc  This file contains the Register Desciptions for EMIF16
 *
 */




/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 RCSR;
    volatile Uint32 AWCCR;
    volatile Uint8 RSVD0[8];
    volatile Uint32 A0CR;
    volatile Uint32 A1CR;
    volatile Uint32 A2CR;
    volatile Uint32 A3CR;
    volatile Uint8 RSVD1[32];
    volatile Uint32 IRR;
    volatile Uint32 IMR;
    volatile Uint32 IMSR;
    volatile Uint32 IMCR;
    volatile Uint32 IOCR;
    volatile Uint32 IOSR;
    volatile Uint8 RSVD2[8];
    volatile Uint32 NANDFCTL;
    volatile Uint32 NANDFSR;
    volatile Uint32 PMCR;
    volatile Uint8 RSVD3[4];
    volatile Uint32 NFECCCE0;
    volatile Uint32 NFECCCE1;
    volatile Uint32 NFECCCE2;
    volatile Uint32 NFECCCE3;
    volatile Uint8 RSVD4[4];
    volatile Uint32 IODFTEXECNT;
    volatile Uint32 IODFTGBLCTRL;
    volatile Uint8 RSVD5[4];
    volatile Uint32 IODFTTLAMISR;
    volatile Uint32 IODFTTLDMISR;
    volatile Uint32 IODFTTLDCMISR;
    volatile Uint8 RSVD6[20];
    volatile Uint32 MODRELNUM;
    volatile Uint8 RSVD7[8];
    volatile Uint32 NANDF4BECCLR;
    volatile Uint32 NANDF4BECC1R;
    volatile Uint32 NANDF4BECC2R;
    volatile Uint32 NANDF4BECC3R;
    volatile Uint32 NANDF4BECC4R;
    volatile Uint32 NANDFEA1R;
    volatile Uint32 NANDFEA2R;
    volatile Uint32 NANDFEV1R;
    volatile Uint32 NANDFEV2R;
} CSL_Emif16Regs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* RCSR */







/* AWCCR */

/*----wp3 Tokens----*/

/*----wp2 Tokens----*/

/*----wp1 Tokens----*/

/*----wp0 Tokens----*/


/*----ce3wait Tokens----*/

/*----ce2wait Tokens----*/

/*----ce1wait Tokens----*/

/*----ce0wait Tokens----*/




/* A0CR */

/*----ss Tokens----*/

/*----ew Tokens----*/








/*----asize Tokens----*/


/* A1CR */

/*----ss Tokens----*/

/*----ew Tokens----*/








/*----asize Tokens----*/


/* A2CR */

/*----ss Tokens----*/

/*----ew Tokens----*/








/*----asize Tokens----*/


/* A3CR */

/*----ss Tokens----*/

/*----ew Tokens----*/








/*----asize Tokens----*/


/* IRR */


/*----wr Tokens----*/

/*----lt Tokens----*/

/*----at Tokens----*/


/* IMR */


/*----wrm Tokens----*/

/*----ltm Tokens----*/

/*----atm Tokens----*/


/* IMSR */


/*----wrmset Tokens----*/

/*----ltmset Tokens----*/

/*----atmset Tokens----*/


/* IMCR */


/*----wrmclr Tokens----*/

/*----ltmclr Tokens----*/

/*----atmclr Tokens----*/


/* IOCR */




/* IOSR */




/* NANDFCTL */


/*----addr_calc_st Tokens----*/

/*----4bit_ecc_st Tokens----*/

/*----ce3ecc Tokens----*/

/*----ce2ecc Tokens----*/

/*----ce1ecc Tokens----*/

/*----ce0ecc Tokens----*/


/*----4bit_ecc_sel Tokens----*/

/*----ce3nand Tokens----*/

/*----ce2nand Tokens----*/

/*----ce1nand Tokens----*/

/*----ce0nand Tokens----*/


/* NANDFSR */


/*----err_num Tokens----*/


/*----corr_state Tokens----*/




/* PMCR */


/*----ce3pgsize Tokens----*/

/*----ce3pgmden Tokens----*/


/*----ce2pgsize Tokens----*/

/*----ce2pgmden Tokens----*/


/*----ce1pgsize Tokens----*/

/*----c3epgmden Tokens----*/


/*----ce0pgsize Tokens----*/

/*----ce0pgmden Tokens----*/


/* NFECCCE0 */




























/* NFECCCE1 */




























/* NFECCCE2 */




























/* NFECCCE3 */




























/* IODFTEXECNT */




/* IODFTGBLCTRL */






/*----mms Tokens----*/

/*----esel Tokens----*/

/*----toen Tokens----*/

/*----mc Tokens----*/




/* IODFTTLAMISR */




/* IODFTTLDMISR */



/* IODFTTLDCMISR */








/* MODRELNUM */




/* NANDF4BECCLR */




/* NANDF4BECC1R */






/* NANDF4BECC2R */






/* NANDF4BECC3R */






/* NANDF4BECC4R */






/* NANDFEA1R */






/* NANDFEA2R */






/* NANDFEV1R */






/* NANDFEV2R */






/**
 *   @file  csl_emif4.h
 *
 *   @brief   
 *      This is the main header file for the EMIF4F Module which defines
 *      all the data structures and exported API.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** @defgroup CSL_EMIF4F_API EMIF4F
 *
 * @section Introduction
 *  The External Memory Interface (EMIF) is a TI developed re-usable IP component 
 *  targeted for SOC designs. The EMIF is a VBUSM slave peripheral providing an 
 *  interface to a wide variety of DDR SDRAM. This memory controller is a soft 
 *  macro and must be used with the DDR PHY hard macros to interface to the 
 *  DDR SDRAM. 
 *
 * @subsection References
 *   -# EMIF4F Functional Specification
 */



/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 EMIF_MOD_ID_REV;
    volatile Uint32 STATUS;
    volatile Uint32 SDRAM_CONFIG;
    volatile Uint32 SDRAM_CONFIG_2;
    volatile Uint32 SDRAM_REF_CTRL;
    volatile Uint32 SDRAM_REF_CTRL_SHDW;
    volatile Uint32 SDRAM_TIM_1;
    volatile Uint32 SDRAM_TIM_1_SHDW;
    volatile Uint32 SDRAM_TIM_2;
    volatile Uint32 SDRAM_TIM_2_SHDW;
    volatile Uint32 SDRAM_TIM_3;
    volatile Uint32 SDRAM_TIM_3_SHDW;
    volatile Uint32 LPDDR2_NVM_TIM;
    volatile Uint32 LPDDR2_NVM_TIM_SHDW;
    volatile Uint32 PWR_MGMT_CTRL;
    volatile Uint32 PWR_MGMT_CTRL_SHDW;
    volatile Uint32 LPDDR2_MODE_REG_DATA;
    volatile Uint8 RSVD0[12];
    volatile Uint32 LPDDR2_MODE_REG_CFG;
    volatile Uint32 VBUSM_CONFIG;
    volatile Uint32 VBUSM_CFG_VAL_1;
    volatile Uint32 VBUSM_CFG_VAL_2;
    volatile Uint32 IODFT_TLGC;
    volatile Uint32 IODFT_CTRL_MISR_RSLT;
    volatile Uint32 IODFT_ADDR_MISR_RSLT;
    volatile Uint32 IODFT_DATA_MISR_RSLT_1;
    volatile Uint32 IODFT_DATA_MISR_RSLT_2;
    volatile Uint32 IODFT_DATA_MISR_RSLT_3;
    volatile Uint32 IODFT_DATA_MISR_RSLT_4;
    volatile Uint32 IODFT_DATA_MISR_RSLT_5;
    volatile Uint32 PERF_CNT_1;
    volatile Uint32 PERF_CNT_2;
    volatile Uint32 PERF_CNT_CFG;
    volatile Uint32 PERF_CNT_SEL;
    volatile Uint32 PERF_CNT_TIM;
    volatile Uint8 RSVD1[4];
    volatile Uint32 READ_IDLE_CTRL;
    volatile Uint32 READ_IDLE_CTRL_SHDW;
    volatile Uint8 RSVD2[4];
    volatile Uint32 IRQSTATUS_RAW_SYS;
    volatile Uint8 RSVD3[4];
    volatile Uint32 IRQSTATUS_SYS;
    volatile Uint8 RSVD4[4];
    volatile Uint32 IRQENABLE_SET_SYS;
    volatile Uint8 RSVD5[4];
    volatile Uint32 IRQENABLE_CLR_SYS;
    volatile Uint8 RSVD6[8];
    volatile Uint32 ZQ_CONFIG;
    volatile Uint32 TEMP_ALERT_CONFIG;
    volatile Uint32 VBUSM_ERR_LOG;
    volatile Uint32 RDWR_LVL_RMP_WIN;
    volatile Uint32 RDWR_LVL_RMP_CTRL;
    volatile Uint32 RDWR_LVL_CTRL;
    volatile Uint8 RSVD7[4];
    volatile Uint32 DDR_PHY_CTRL_1;
    volatile Uint32 DDR_PHY_CTRL_1_SHDW;
    volatile Uint32 DDR_PHY_CTRL_2;
    volatile Uint8 RSVD8[16];
    volatile Uint32 PRI_COS_MAP;
    volatile Uint32 MSTID_COS_1_MAP;
    volatile Uint32 MSTID_COS_2_MAP;
    volatile Uint8 RSVD9[4];
    volatile Uint32 ECC_CTRL;
    volatile Uint32 ECC_ADDR_RNG_1;
    volatile Uint32 ECC_ADDR_RNG_2;
    volatile Uint8 RSVD10[4];
    volatile Uint32 RD_WR_EXEC_THRSH;
} CSL_Emif4fRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* EMIF_MOD_ID_REV */







/* STATUS */









/* SDRAM_CONFIG */
















/* SDRAM_CONFIG_2 */






/* SDRAM_REF_CTRL */







/* SDRAM_REF_CTRL_SHDW */



/* SDRAM_TIM_1 */









/* SDRAM_TIM_1_SHDW */









/* SDRAM_TIM_2 */








/* SDRAM_TIM_2_SHDW */








/* SDRAM_TIM_3 */









/* SDRAM_TIM_3_SHDW */









/* LPDDR2_NVM_TIM */








/* LPDDR2_NVM_TIM_SHDW */








/* PWR_MGMT_CTRL */







/* PWR_MGMT_CTRL_SHDW */





/* LPDDR2_MODE_REG_DATA */



/* LPDDR2_MODE_REG_CFG */





/* VBUSM_CONFIG */





/* VBUSM_CFG_VAL_1 */






/* VBUSM_CFG_VAL_2 */





/* IODFT_TLGC */










/* IODFT_CTRL_MISR_RSLT */




/* IODFT_ADDR_MISR_RSLT */



/* IODFT_DATA_MISR_RSLT_1 */



































/* IODFT_DATA_MISR_RSLT_2 */



































/* IODFT_DATA_MISR_RSLT_3 */



































/* IODFT_DATA_MISR_RSLT_4 */



































/* IODFT_DATA_MISR_RSLT_5 */






















/* PERF_CNT_1 */



/* PERF_CNT_2 */



/* PERF_CNT_CFG */








/* PERF_CNT_SEL */






/* PERF_CNT_TIM */



/* READ_IDLE_CTRL */




/* READ_IDLE_CTRL_SHDW */




/* IRQSTATUS_RAW_SYS */







/* IRQSTATUS_SYS */







/* IRQENABLE_SET_SYS */







/* IRQENABLE_CLR_SYS */







/* ZQ_CONFIG */









/* TEMP_ALERT_CONFIG */








/* VBUSM_ERR_LOG */






/* RDWR_LVL_RMP_WIN */



/* RDWR_LVL_RMP_CTRL */







/* RDWR_LVL_CTRL */







/* DDR_PHY_CTRL_1 */




/* DDR_PHY_CTRL_1_SHDW */




/* DDR_PHY_CTRL_2 */



/* PRI_COS_MAP */











/* MSTID_COS_1_MAP */









/* MSTID_COS_2_MAP */









/* ECC_CTRL */






/* ECC_ADDR_RNG_1 */




/* ECC_ADDR_RNG_2 */




/* RD_WR_EXEC_THRSH */





/**
@defgroup CSL_EMIF4F_SYMBOL  EMIF4F Symbols Defined
@ingroup CSL_EMIF4F_API
*/
/**
@defgroup CSL_EMIF4F_DATASTRUCT  EMIF4F Data Structures
@ingroup CSL_EMIF4F_API
*/
/**
@defgroup CSL_EMIF4F_FUNCTION  EMIF4F Functions
@ingroup CSL_EMIF4F_API
*/

/**
@addtogroup CSL_EMIF4F_SYMBOL
@{
*/

/**
 *  Handle to access EMIF4F registers accessible through config bus.
 */

/**
@}
*/

/** @addtogroup CSL_EMIF4F_DATASTRUCT
 @{ */

/** @brief This is the handle to the MPU Register */
typedef volatile CSL_Emif4fRegs*   CSL_Emif4fHandle;

/** @brief EMIF4F SDRAM Configuration
 *
 * This structure is used to define the EMIF4F SDRAM 
 * Configuration
 */
typedef struct EMIF4F_SDRAM_CONFIG
{
    Uint8   type;
    Uint8   iBankPos;
    Uint8   ddrTerm;
    Uint8   ddrDDQS;
    Uint8   dynODT;
    Uint8   disableDLL;
    Uint8   SDRAMDrive;
    Uint8   CASWriteLat;
    Uint8   narrowMode;
    Uint8   CASLatency;
    Uint8   rowSize;
    Uint8   iBank;
    Uint8   eBank;
    Uint8   pageSize;

    Uint8   NVMEnable;
    Uint8   eBankPos;
    Uint8   rdbNum;
    Uint8   rdbSize;
}EMIF4F_SDRAM_CONFIG;

/** @brief EMIF4F Timing1 Configuration
 *
 * This structure is used to define the EMIF4F Timing1
 * Configuration
 */
typedef struct EMIF4F_TIMING1_CONFIG
{
    Uint8   t_rp;
    Uint8   t_rcd;
    Uint8   t_wr;
    Uint8   t_ras;
    Uint8   t_rc;
    Uint8   t_rrd;
    Uint8   t_wtr;
}EMIF4F_TIMING1_CONFIG;

/** @brief EMIF4F Timing2 Configuration
 *
 * This structure is used to define the EMIF4F Timing2
 * Configuration
 */
typedef struct EMIF4F_TIMING2_CONFIG
{
    Uint8   t_xp;
    Uint8   t_odt;
    Uint16  t_xsnr;
    Uint16  t_xsrd;
    Uint8   t_rtp;
    Uint8   t_cke;
}EMIF4F_TIMING2_CONFIG;

/** @brief EMIF4F Timing3 Configuration
 *
 * This structure is used to define the EMIF4F Timing3
 * Configuration
 */
typedef struct EMIF4F_TIMING3_CONFIG
{
    Uint8   t_pdll_ul;
    Uint8   t_csta;
    Uint8   t_ckesr;
    Uint8   zq_zqcs;
    Uint8   t_tdqsckmax;
    Uint16  t_rfc;
    Uint8   t_rasMax;
}EMIF4F_TIMING3_CONFIG;

/** @brief LPDDR2-NVM Timing Configuration
 *
 * This structure is used to define the LPDDR2-NVM Timing
 * Configuration
 */
typedef struct EMIF4F_LPDDR2NVM_TIMING_CONFIG
{
    Uint8   t_xp;
    Uint8   t_wtr;
    Uint8   t_rp;
    Uint8   t_wra;
    Uint8   t_rrd;
    Uint8   t_rcdmin;
}EMIF4F_LPDDR2NVM_TIMING_CONFIG;

/** @brief Power Management Configuration
 *
 * This structure is used to define the Power Management Configuration
 */
typedef struct EMIF4F_PWR_MGMT_CONFIG
{
    Uint8   pdTime;
    Uint8   dpdEnable;
    Uint8   lpMode;
    Uint8   srTime;
    Uint8   csTime;
}EMIF4F_PWR_MGMT_CONFIG;

/** @brief VBUS Configuration Values
 *
 * This structure is used to define the VBUS Configuration Values
 */
typedef struct EMIF4F_VBUS_CONFIG_VALUE
{
    Uint8   sysBusWidth;
    Uint8   statFIFODepth;
    Uint8   wrFIFODepth;
    Uint8   cmdFIFODepth;
    Uint8   rregFIFODepth;
    Uint8   rsdFIFODepth;
    Uint8   rcmdFIFODepth;
}EMIF4F_VBUS_CONFIG_VALUE;

/** @brief IODFT Control Values
 *
 * This structure is used to define the IODFT Test Logic Global
 * Control Values.
 */
typedef struct EMIF4F_IODFT_CONTROL
{
    Uint16  tlec;
    Uint8   mt;
    Uint8   actCapEn;
    Uint8   opgld;
    Uint8   mms;
    Uint8   mc;
    Uint8   pc;
    Uint8   tm;
}EMIF4F_IODFT_CONTROL;

/** @brief Performance Counter Configuration
 *
 * This structure is used to define the performance counter 
 * configuration
 */
typedef struct EMIF4F_PERF_CONFIG
{
    Uint8  mstIDEn;
    Uint8  regEn;
    Uint8  cntCfg;
}EMIF4F_PERF_CONFIG;

/** @brief SDRAM Output Impedance Calibration Configuation
 *
 * This structure is used to define the SDRAM Output Impedance 
 * Calibration Configuration.
 */
typedef struct EMIF4F_OUTPUT_IMP_CONFIG
{
    Uint8   zqCS1En;
    Uint8   zqCS0En;
    Uint8   zqDualCSEn;
    Uint8   zqSFEXITEn;
    Uint8   zqZQCLInterval;
    Uint8   zqZQCLMult;
    Uint16  zqRefInterval;
}EMIF4F_OUTPUT_IMP_CONFIG;

/** @brief Temperature Alert Configuration
 *
 * This structure is used to define the Temperature Alert Configuration.
 */
typedef struct EMIF4F_TEMP_ALERT_CONFIG
{
    Uint8   taCS1En;
    Uint8   taCS0En;
    Uint8   taSFEXITEn;
    Uint8   taDevWdth;
    Uint8   taDevCnt;
    Uint32  taRefInterval;
}EMIF4F_TEMP_ALERT_CONFIG;

/** @brief Priority to COS Mapping
 *
 * This structure is used to define the Priority to COS Mapping.
 */
typedef struct EMIF4_PRI_COS_MAPPING
{
    Uint8   enable;
    Uint8   pri7cos;
    Uint8   pri6cos;
    Uint8   pri5cos;
    Uint8   pri4cos;
    Uint8   pri3cos;
    Uint8   pri2cos;
    Uint8   pri1cos;
    Uint8   pri0cos;
}EMIF4_PRI_COS_MAPPING;

/** @brief Master ID to COS Mapping
 *
 * This structure is used to define the Master ID to COS Mapping.
 */
typedef struct EMIF4_MSTID_COS_MAPPING
{
    Uint8   enable;
    Uint8   mst1;
    Uint8   mstMask1;
    Uint8   mst2;
    Uint8   mstMask2;
    Uint8   mst3;
    Uint8   mstMask3;
}EMIF4_MSTID_COS_MAPPING;

/** @brief ECC Control 
 *
 * This structure is used to define the ECC Control Configuration.
 */
typedef struct EMIF4_ECC_CONTROL
{
    Uint8   enable;
    Uint8   addrRngProt;
    Uint8   addrRng2En;
    Uint8   addrRng1En;
}EMIF4_ECC_CONTROL;

/* @} */

/** @addtogroup CSL_EMIF4F_FUNCTION
 @{ */

/* @} */


/**
 *   @file  csl_emif4fAux.h
 *
 *   @brief   
 *      This is the EMIF4F Auxilary Header File which exposes the various
 *      CSL Functional Layer API's to configure the EMIF4F Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/




/** @addtogroup CSL_EMIF4F_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetModuleInfo
 *
 *   @b Description
 *   @n This function reads the peripheral ID register which identifies the 
 *      module id, RTL version information etc.
 *
 *   @b Arguments
     @verbatim
          moduleID     Module Id Information populated by this API
          rtlInfo      RTL Version Information populated by this API
          majRev       Major Revision Information populated by this API
          minRev       Minor Revision Information populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_EMIF_MOD_ID_REV_REG_MODULE_ID,EMIF4F_EMIF_MOD_ID_REV_REG_RTL_VERSION,
 *      EMIF4F_EMIF_MOD_ID_REV_REG_MAJOR_REVISION,EMIF4F_EMIF_MOD_ID_REV_REG_MINOR_REVISION
 *
 *   @b Example
 *   @verbatim
        Uint8   moduleID;
        Uint8   rtlInfo;
        Uint8   majRev;
        Uint8   minRev;

        // Get the EMIF4F Module Information.
        CSL_EMIF4F_GetModuleInfo (&moduleID, &rtlInfo, &majRev, &minRev);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetModuleInfo
(
    Uint8*  moduleID,    
    Uint8*  rtlInfo, 
    Uint8*  majRev, 
    Uint8*  minRev
)
{
    Uint32 value = ((CSL_Emif4fRegs*)(0x21000000))->EMIF_MOD_ID_REV;

    *moduleID = (((value) & (0x0FFF0000u)) >> (0x00000010u));
    *rtlInfo  = (((value) & (0x0000F800u)) >> (0x0000000Bu));
    *majRev   = (((value) & (0x00000700u)) >> (0x00000008u));
    *minRev   = (((value) & (0x0000003Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_IsBigEndian
 *
 *   @b Description
 *   @n The function gets the endianess mode in which the EMIF4F is operating. 
 *
 *   @b Arguments
     @verbatim
         None 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    -   Big Endian Mode
 *   @n FALSE   -   Little Endian Mode.
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_STATUS_REG_BE
 *
 *   @b Example
 *   @verbatim

        // Get the EMIF4F Endianness mode.
        if (CSL_EMIF4F_IsBigEndian () == TRUE)
        {
            // Big Endian Mode.
        }
        else
        {
            // Little Endian Mode.
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_EMIF4F_IsBigEndian()
{
    return (Bool)(((((CSL_Emif4fRegs*)(0x21000000))->STATUS) & (0x80000000u)) >> (0x0000001Fu));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_IsAsynchronous
 *
 *   @b Description
 *   @n The function gets the dual clock mode on which the EMIF4F is operating.
 *
 *   @b Arguments
     @verbatim
         None 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    -   Asynchronous (V_CLK and M_CLK can have any freq ratio)
 *   @n FALSE   -   Synchronous  (V_CLK is the same as M_CLK)
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_STATUS_REG_DUAL_CLK_MODE
 *
 *   @b Example
 *   @verbatim

        // Get the EMIF4F Clock
        if (CSL_EMIF4F_IsAsynchronous () == TRUE)
        {
            // Asynchronous Clock
        }
        else
        {
            // Synchronous Clock
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_EMIF4F_IsAsynchronous()
{
    return (Bool)(((((CSL_Emif4fRegs*)(0x21000000))->STATUS) & (0x40000000u)) >> (0x0000001Eu));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_IsFastInit
 *
 *   @b Description
 *   @n The function gets the status of the EMIF fast initialization mode 
 *
 *   @b Arguments
     @verbatim
         None 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    -   Fast Initialization Mode has been enabled.
 *   @n FALSE   -   Fast Initialization Mode has been disabled.
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_STATUS_REG_FAST_INIT
 *
 *   @b Example
 *   @verbatim

        // Get the EMIF4F Fast Initialization status
        if (CSL_EMIF4F_IsFastInit () == TRUE)
        {
            // Fast Initialization is disabled
        }
        else
        {
            // Fast Initialization is enabled
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_EMIF4F_IsFastInit()
{
    return (Bool)(((((CSL_Emif4fRegs*)(0x21000000))->STATUS) & (0x20000000u)) >> (0x0000001Du));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_IsReadDQSGateTrainingTimeout
 *
 *   @b Description
 *   @n The function gets the status of the DQS Gate Training Time out.
 *
 *   @b Arguments
     @verbatim
         None 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    -   DQS Gate Training Timed out
 *   @n FALSE   -   DQS Gate Training has not Timed out
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_STATUS_REG_RDLVLGATETO
 *
 *   @b Example
 *   @verbatim

        // Get the EMIF4F DQS gate training timeout status
        if (CSL_EMIF4F_IsReadDQSGateTrainingTimeout () == TRUE)
        {
            // DQS gate training has timed out
        }
        else
        {
            // DQS gate training has not timed out
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_EMIF4F_IsReadDQSGateTrainingTimeout()
{
    return (Bool)(((((CSL_Emif4fRegs*)(0x21000000))->STATUS) & (0x00000040u)) >> (0x00000006u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_IsReadDataEyeTrainingTimeout
 *
 *   @b Description
 *   @n The function gets the status of the Data eye training timeout.
 *
 *   @b Arguments
     @verbatim
         None 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    -   Data Eye Training Timed out
 *   @n FALSE   -   Data Eye Training has not Timed out
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_STATUS_REG_RDLVLTO
 *
 *   @b Example
 *   @verbatim

        // Get the EMIF4F Data Eye training timeout status
        if (CSL_EMIF4F_IsReadDataEyeTrainingTimeout () == TRUE)
        {
            // Data Eye training has timed out
        }
        else
        {
            // Data Eye training has not timed out
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_EMIF4F_IsReadDataEyeTrainingTimeout()
{
    return (Bool)(((((CSL_Emif4fRegs*)(0x21000000))->STATUS) & (0x00000020u)) >> (0x00000005u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_IsWriteLevelingTimeout
 *
 *   @b Description
 *   @n The function gets the status of the Write Leveling Timeout
 *
 *   @b Arguments
     @verbatim
         None 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    -   Write Leveling Timed out
 *   @n FALSE   -   Write Leveling has not Timed out
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_STATUS_REG_WRLVLTO
 *
 *   @b Example
 *   @verbatim

        // Get the EMIF4F Write Leveling timeout status
        if (CSL_EMIF4F_IsWriteLevelingTimeout () == TRUE)
        {
            // Write Leveling has timed out
        }
        else
        {
            // Write Leveling has not timed out
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_EMIF4F_IsWriteLevelingTimeout()
{
    return (Bool)(((((CSL_Emif4fRegs*)(0x21000000))->STATUS) & (0x00000010u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_IsDDRPhyRead
 *
 *   @b Description
 *   @n The function gets the status of the DDR PHY
 *
 *   @b Arguments
     @verbatim
         None 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE    -   DDR PHY is ready
 *   @n FALSE   -   DDR PHY is not ready
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_STATUS_REG_PHY_DLL_READY
 *
 *   @b Example
 *   @verbatim

        // Get the EMIF4F DDR PHY Ready Status
        if (CSL_EMIF4F_IsDDRPhyRead () == TRUE)
        {
            // DDR PHY is ready
        }
        else
        {
            // DDR PHY is not ready
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_EMIF4F_IsDDRPhyRead()
{
    return (Bool)(((((CSL_Emif4fRegs*)(0x21000000))->STATUS) & (0x00000004u)) >> (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetSDRAMConfig
 *
 *   @b Description
 *   @n The function gets the current SDRAM Configuration.
 *
 *   @b Arguments
     @verbatim
         ptrConfig  SDRAM Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_CONFIG_REG_SDRAM_TYPE,EMIF4F_SDRAM_CONFIG_REG_IBANK_POS,
 *      EMIF4F_SDRAM_CONFIG_REG_DDR_TERM,EMIF4F_SDRAM_CONFIG_REG_DDR2_DDQS,
 *      EMIF4F_SDRAM_CONFIG_REG_DYN_ODT,EMIF4F_SDRAM_CONFIG_REG_DDR_DISABLE_DLL,
 *      EMIF4F_SDRAM_CONFIG_REG_SDRAM_DRIVE,EMIF4F_SDRAM_CONFIG_REG_CWL,
 *      EMIF4F_SDRAM_CONFIG_REG_NARROW_MODE,EMIF4F_SDRAM_CONFIG_REG_CL,
 *      EMIF4F_SDRAM_CONFIG_REG_ROWSIZE,EMIF4F_SDRAM_CONFIG_REG_IBANK,
 *      EMIF4F_SDRAM_CONFIG_REG_EBANK,EMIF4F_SDRAM_CONFIG_REG_PAGESIZE,
 *   @n EMIF4F_SDRAM_CONFIG_2_REG_CS1NVMEN,EMIF4F_SDRAM_CONFIG_2_REG_EBANK_POS,
 *      EMIF4F_SDRAM_CONFIG_2_REG_RDBNUM,EMIF4F_SDRAM_CONFIG_2_REG_RDBSIZE
 *
 *   @b Example
 *   @verbatim
        EMIF4F_SDRAM_CONFIG  sdramConfig;
        ...
        // Get the EMIF4F SDRAM Configuration.
        CSL_EMIF4F_GetSDRAMConfig (&sdramConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetSDRAMConfig(EMIF4F_SDRAM_CONFIG* ptrConfig)
{
    Uint32  sdramConfig = ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_CONFIG;

    /* Extract all the fields from the SDRAM Configuration. */
    ptrConfig->type         = (((sdramConfig) & (0xE0000000u)) >> (0x0000001Du));
    ptrConfig->iBankPos     = (((sdramConfig) & (0x18000000u)) >> (0x0000001Bu));
    ptrConfig->ddrTerm      = (((sdramConfig) & (0x07000000u)) >> (0x00000018u));
    ptrConfig->ddrDDQS      = (((sdramConfig) & (0x00800000u)) >> (0x00000017u));
    ptrConfig->dynODT       = (((sdramConfig) & (0x00600000u)) >> (0x00000015u));
    ptrConfig->disableDLL   = (((sdramConfig) & (0x00100000u)) >> (0x00000014u));
    ptrConfig->SDRAMDrive   = (((sdramConfig) & (0x000C0000u)) >> (0x00000012u));
    ptrConfig->CASWriteLat  = (((sdramConfig) & (0x00030000u)) >> (0x00000010u));
    ptrConfig->narrowMode   = (((sdramConfig) & (0x0000C000u)) >> (0x0000000Eu));
    ptrConfig->CASLatency   = (((sdramConfig) & (0x00003C00u)) >> (0x0000000Au));
    ptrConfig->rowSize      = (((sdramConfig) & (0x00000380u)) >> (0x00000007u));
    ptrConfig->iBank        = (((sdramConfig) & (0x00000070u)) >> (0x00000004u));
    ptrConfig->eBank        = (((sdramConfig) & (0x00000008u)) >> (0x00000003u));
    ptrConfig->pageSize     = (((sdramConfig) & (0x00000007u)) >> (0x00000000u));

    /* Get the SDRAM Configuration 2 Register */
    sdramConfig = ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_CONFIG_2;

    ptrConfig->NVMEnable   = (((sdramConfig) & (0x40000000u)) >> (0x0000001Eu));
    ptrConfig->eBankPos    = (((sdramConfig) & (0x08000000u)) >> (0x0000001Bu));
    ptrConfig->rdbNum      = (((sdramConfig) & (0x00000030u)) >> (0x00000004u));
    ptrConfig->rdbSize     = (((sdramConfig) & (0x00000007u)) >> (0x00000000u)); 
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetSDRAMConfig
 *
 *   @b Description
 *   @n The function sets the SDRAM Configuration as specified.
 *
 *   @b Arguments
     @verbatim
         ptrConfig  SDRAM Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_CONFIG_REG_SDRAM_TYPE,EMIF4F_SDRAM_CONFIG_REG_IBANK_POS,
 *      EMIF4F_SDRAM_CONFIG_REG_DDR_TERM,EMIF4F_SDRAM_CONFIG_REG_DDR2_DDQS,
 *      EMIF4F_SDRAM_CONFIG_REG_DYN_ODT,EMIF4F_SDRAM_CONFIG_REG_DDR_DISABLE_DLL,
 *      EMIF4F_SDRAM_CONFIG_REG_SDRAM_DRIVE,EMIF4F_SDRAM_CONFIG_REG_CWL,
 *      EMIF4F_SDRAM_CONFIG_REG_NARROW_MODE,EMIF4F_SDRAM_CONFIG_REG_CL,
 *      EMIF4F_SDRAM_CONFIG_REG_ROWSIZE,EMIF4F_SDRAM_CONFIG_REG_IBANK,
 *      EMIF4F_SDRAM_CONFIG_REG_EBANK,EMIF4F_SDRAM_CONFIG_REG_PAGESIZE
 *   @n EMIF4F_SDRAM_CONFIG_2_REG_CS1NVMEN,EMIF4F_SDRAM_CONFIG_2_REG_EBANK_POS,
 *      EMIF4F_SDRAM_CONFIG_2_REG_RDBNUM,EMIF4F_SDRAM_CONFIG_2_REG_RDBSIZE
 *
 *   @b Example
 *   @verbatim
        EMIF4F_SDRAM_CONFIG  sdramConfig;
        ...
        // Get the EMIF4F SDRAM Configuration.
        CSL_EMIF4F_GetSDRAMConfig (&sdramConfig);
        ...
        // Set the SDRAM Data Bus Width to be 32 bits
        sdramConfig.narrowMode = 0;

        // Set the EMIF4F SDRAM Configuration.
        CSL_EMIF4F_SetSDRAMConfig (&sdramConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetSDRAMConfig(EMIF4F_SDRAM_CONFIG* ptrConfig)
{
    Uint32  sdramConfig = 0;

    /* Initialize the SDRAM Configuration. */
    ((sdramConfig) = ((sdramConfig) & ~(0xE0000000u)) | (((ptrConfig->type) << (0x0000001Du)) & (0xE0000000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x18000000u)) | (((ptrConfig->iBankPos) << (0x0000001Bu)) & (0x18000000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x07000000u)) | (((ptrConfig->ddrTerm) << (0x00000018u)) & (0x07000000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00800000u)) | (((ptrConfig->ddrDDQS) << (0x00000017u)) & (0x00800000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00600000u)) | (((ptrConfig->dynODT) << (0x00000015u)) & (0x00600000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00100000u)) | (((ptrConfig->disableDLL) << (0x00000014u)) & (0x00100000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x000C0000u)) | (((ptrConfig->SDRAMDrive) << (0x00000012u)) & (0x000C0000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00030000u)) | (((ptrConfig->CASWriteLat) << (0x00000010u)) & (0x00030000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x0000C000u)) | (((ptrConfig->narrowMode) << (0x0000000Eu)) & (0x0000C000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00003C00u)) | (((ptrConfig->CASLatency) << (0x0000000Au)) & (0x00003C00u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00000380u)) | (((ptrConfig->rowSize) << (0x00000007u)) & (0x00000380u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00000070u)) | (((ptrConfig->iBank) << (0x00000004u)) & (0x00000070u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00000008u)) | (((ptrConfig->eBank) << (0x00000003u)) & (0x00000008u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00000007u)) | (((ptrConfig->pageSize) << (0x00000000u)) & (0x00000007u)));

    /* Write to the register */
    ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_CONFIG = sdramConfig;
    
    /* Initialize the SDRAM2 Configuration. */
    sdramConfig = 0;    
    ((sdramConfig) = ((sdramConfig) & ~(0x40000000u)) | (((ptrConfig->NVMEnable) << (0x0000001Eu)) & (0x40000000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x08000000u)) | (((ptrConfig->eBankPos) << (0x0000001Bu)) & (0x08000000u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00000030u)) | (((ptrConfig->rdbNum) << (0x00000004u)) & (0x00000030u)));
    ((sdramConfig) = ((sdramConfig) & ~(0x00000007u)) | (((ptrConfig->rdbSize) << (0x00000000u)) & (0x00000007u)));

    /* Write to the register. */
    ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_CONFIG_2 = sdramConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_DisableInitRefresh
 *
 *   @b Description
 *   @n The function is used to disable the initialization and refresh.
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_INITREF_DIS=1
 *
 *   @b Example
 *   @verbatim

        // Disable Initialization & Refresh
        CSL_EMIF4F_DisableInitRefresh();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_DisableInitRefresh(void)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & ~(0x80000000u)) | ((((Uint32)1) << (0x0000001Fu)) & (0x80000000u)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_EnableInitRefresh
 *
 *   @b Description
 *   @n The function is used to enable the initialization and refresh.
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_INITREF_DIS=0
 *
 *   @b Example
 *   @verbatim

        // Enable Initialization & Refresh
        CSL_EMIF4F_EnableInitRefresh();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_EnableInitRefresh(void)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & ~(0x80000000u)) | (((0) << (0x0000001Fu)) & (0x80000000u)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetSelfRefreshTemp
 *
 *   @b Description
 *   @n The function is used to get the DDR3 Self Refresh Temperature.
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n 0 - Normal Operating Temperature
 *   @n 1 - Extended Operating Temperature
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_SRT
 *
 *   @b Example
 *   @verbatim

        // Get the current self refresh temperature configuration.
        if (CSL_EMIF4F_GetSelfRefreshTemp() == 0)
        {
            // Normal Operating Temperature
        }
        else
        {
            // Extended Operating Temperature
        }

     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_EMIF4F_GetSelfRefreshTemp(void)
{
    return (((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & (0x20000000u)) >> (0x0000001Du));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetSelfRefreshTemp
 *
 *   @b Description
 *   @n The function is used to get the DDR3 Self Refresh Temperature.
 *
 *   @b Arguments
     @verbatim
         temperature    - Operating Temperature to be configured.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_SRT
 *
 *   @b Example
 *   @verbatim

        // Set Self Referesh Temperature for normal operation.
        CSL_EMIF4F_SetSelfRefreshTemp(0);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetSelfRefreshTemp(Uint8 temperature)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & ~(0x20000000u)) | (((temperature) << (0x0000001Du)) & (0x20000000u)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_EnableAutoRefresh
 *
 *   @b Description
 *   @n The function is used to enable auto self refresh.
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_ASR=1
 *
 *   @b Example
 *   @verbatim

        // Enable Auto Self Refresh
        CSL_EMIF4F_EnableAutoRefresh();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_EnableAutoRefresh(void)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & ~(0x10000000u)) | (((1) << (0x0000001Cu)) & (0x10000000u)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_DisableAutoRefresh
 *
 *   @b Description
 *   @n The function is used to disable auto self refresh.
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_ASR=0
 *
 *   @b Example
 *   @verbatim

        // Disable Auto Self Refresh
        CSL_EMIF4F_DisableAutoRefresh();

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_DisableAutoRefresh(void)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & ~(0x10000000u)) | (((0) << (0x0000001Cu)) & (0x10000000u)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPartialArraySelfRefresh
 *
 *   @b Description
 *   @n The function is used to get the partial array self refresh.
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_PASR
 *
 *   @b Example
 *   @verbatim
        Uint8 pasr;

        // Get the Partial Array Refresh Rate Configuration
        pasr = CSL_EMIF4F_GetPartialArraySelfRefresh();
        ...
     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_EMIF4F_GetPartialArraySelfRefresh(void)
{
    return (((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & (0x07000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetPartialArraySelfRefresh
 *
 *   @b Description
 *   @n The function is used to set the partial array self refresh.
 *
 *   @b Arguments
     @verbatim
         pasr   Partial Array Self Refresh configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_PASR
 *
 *   @b Example
 *   @verbatim

        // Set the Partial Array Refresh Rate Configuration to be for full array
        CSL_EMIF4F_SetPartialArraySelfRefresh(0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetPartialArraySelfRefresh(Uint8 pasr)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & ~(0x07000000u)) | (((pasr) << (0x00000018u)) & (0x07000000u)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetRefreshRate
 *
 *   @b Description
 *   @n The function is used to get the refresh rate
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Current Refresh Rate configuration
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_REFRESH_RATE
 *
 *   @b Example
 *   @verbatim
        Uint8   refreshRate;

        // Get the Refresh Rate 
        refreshRate = CSL_EMIF4F_GetRefreshRate();
        ...
     @endverbatim
 * =============================================================================
 */
static inline Uint16 CSL_EMIF4F_GetRefreshRate(void)
{
    return (((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetRefreshRate
 *
 *   @b Description
 *   @n The function is used to set the refresh rate
 *
 *   @b Arguments
     @verbatim
         refreshRate   Refresh Rate to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_REF_CTRL_REG_REFRESH_RATE
 *
 *   @b Example
 *   @verbatim

        // Enable Initialization & Refresh
        CSL_EMIF4F_EnableInitRefresh();

        // Set the Refresh Rate to be 15.7 us 
        CSL_EMIF4F_SetRefreshRate(0x7AA);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetRefreshRate(Uint16 refreshRate)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL) & ~(0x0000FFFFu)) | (((refreshRate) << (0x00000000u)) & (0x0000FFFFu)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetShadowRefreshRate
 *
 *   @b Description
 *   @n The function is used to get the refresh rate from the shadow register
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Current Shadow register Refresh Rate configuration
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_REF_CTRL_SHDW_REG_REFRESH_RATE_SHDW
 *
 *   @b Example
 *   @verbatim
        Uint8   refreshRate;

        // Get the Shadow Register Refresh Rate 
        refreshRate = CSL_EMIF4F_GetShadowRefreshRate();
        ...
     @endverbatim
 * =============================================================================
 */
static inline Uint16 CSL_EMIF4F_GetShadowRefreshRate(void)
{
    return (((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL_SHDW) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetShadowRefreshRate
 *
 *   @b Description
 *   @n The function is used to set the refresh rate
 *
 *   @b Arguments
     @verbatim
         refreshRate   Refresh Rate to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_REF_CTRL_SHDW_REG_REFRESH_RATE_SHDW
 *
 *   @b Example
 *   @verbatim

        // Set the Shadow Register Refresh Rate to be 15.7 us 
        CSL_EMIF4F_SetShadowRefreshRate(0x7AA);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetShadowRefreshRate(Uint16 refreshRate)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL_SHDW) = ((((CSL_Emif4fRegs*)(0x21000000))->SDRAM_REF_CTRL_SHDW) & ~(0x0000FFFFu)) | (((refreshRate) << (0x00000000u)) & (0x0000FFFFu)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetTiming1Config
 *
 *   @b Description
 *   @n The function is used to get the SDRAM Timing1 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_TIM_1_REG_T_RP, EMIF4F_SDRAM_TIM_1_REG_T_RCD,
 *      EMIF4F_SDRAM_TIM_1_REG_T_WR, EMIF4F_SDRAM_TIM_1_REG_T_RAS,
 *      EMIF4F_SDRAM_TIM_1_REG_T_RC, EMIF4F_SDRAM_TIM_1_REG_T_RRD,
 *      EMIF4F_SDRAM_TIM_1_REG_T_WTR
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING1_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetTiming1Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetTiming1Config(EMIF4F_TIMING1_CONFIG* ptrTimingConfig)
{   
    Uint32 timingConfig = ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_1;

    /* Extract all the fields from the Timing Register */
    ptrTimingConfig->t_rp  = (((timingConfig) & (0x1E000000u)) >> (0x00000019u));
    ptrTimingConfig->t_rcd = (((timingConfig) & (0x01E00000u)) >> (0x00000015u));
    ptrTimingConfig->t_wr  = (((timingConfig) & (0x001E0000u)) >> (0x00000011u));
    ptrTimingConfig->t_ras = (((timingConfig) & (0x0001F000u)) >> (0x0000000Cu));
    ptrTimingConfig->t_rc  = (((timingConfig) & (0x00000FC0u)) >> (0x00000006u));
    ptrTimingConfig->t_rrd = (((timingConfig) & (0x00000038u)) >> (0x00000003u));
    ptrTimingConfig->t_wtr = (((timingConfig) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetTiming1Config
 *
 *   @b Description
 *   @n The function is used to set the SDRAM Timing1 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_TIM_1_REG_T_RP, EMIF4F_SDRAM_TIM_1_REG_T_RCD,
 *      EMIF4F_SDRAM_TIM_1_REG_T_WR, EMIF4F_SDRAM_TIM_1_REG_T_RAS,
 *      EMIF4F_SDRAM_TIM_1_REG_T_RC, EMIF4F_SDRAM_TIM_1_REG_T_RRD,
 *      EMIF4F_SDRAM_TIM_1_REG_T_WTR
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING1_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetTiming1Config(&timingConfig);

        // Set the min number of m_clk cycles from precharge to activate
        timingConfig.t_rp = 1;

        // Set the timing configuration.
        CSL_EMIF4F_SetTiming1Config (&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetTiming1Config(EMIF4F_TIMING1_CONFIG* ptrTimingConfig)
{   
    Uint32 timingConfig = 0;

    /* Insert all the fields from the Timing Register */
    ((timingConfig) = ((timingConfig) & ~(0x1E000000u)) | (((ptrTimingConfig->t_rp) << (0x00000019u)) & (0x1E000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x01E00000u)) | (((ptrTimingConfig->t_rcd) << (0x00000015u)) & (0x01E00000u)));
    ((timingConfig) = ((timingConfig) & ~(0x001E0000u)) | (((ptrTimingConfig->t_wr) << (0x00000011u)) & (0x001E0000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0001F000u)) | (((ptrTimingConfig->t_ras) << (0x0000000Cu)) & (0x0001F000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000FC0u)) | (((ptrTimingConfig->t_rc) << (0x00000006u)) & (0x00000FC0u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000038u)) | (((ptrTimingConfig->t_rrd) << (0x00000003u)) & (0x00000038u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000007u)) | (((ptrTimingConfig->t_wtr) << (0x00000000u)) & (0x00000007u)));

    /* Initialize the timing configuration register. */
    ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_1 = timingConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetShadowTiming1Config
 *
 *   @b Description
 *   @n The function is used to get the Shadow SDRAM Timing1 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RP_SHDW, EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RCD_SHDW,
 *      EMIF4F_SDRAM_TIM_1_SHDW_REG_T_WR_SHDW, EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RAS_SHDW,
 *      EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RC_SHDW, EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RRD_SHDW,
 *      EMIF4F_SDRAM_TIM_1_SHDW_REG_T_WTR_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING1_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetShadowTiming1Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetShadowTiming1Config(EMIF4F_TIMING1_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_1_SHDW;

    /* Extract all the fields from the Timing Register */
    ptrTimingConfig->t_rp  = (((timingConfig) & (0x1E000000u)) >> (0x00000019u));
    ptrTimingConfig->t_rcd = (((timingConfig) & (0x01E00000u)) >> (0x00000015u));
    ptrTimingConfig->t_wr  = (((timingConfig) & (0x001E0000u)) >> (0x00000011u));
    ptrTimingConfig->t_ras = (((timingConfig) & (0x0001F000u)) >> (0x0000000Cu));
    ptrTimingConfig->t_rc  = (((timingConfig) & (0x00000FC0u)) >> (0x00000006u));
    ptrTimingConfig->t_rrd = (((timingConfig) & (0x00000038u)) >> (0x00000003u));
    ptrTimingConfig->t_wtr = (((timingConfig) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetShadowTiming1Config
 *
 *   @b Description
 *   @n The function is used to set the Shadow SDRAM Timing1 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RP_SHDW, EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RCD_SHDW,
 *      EMIF4F_SDRAM_TIM_1_SHDW_REG_T_WR_SHDW, EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RAS_SHDW,
 *      EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RC_SHDW, EMIF4F_SDRAM_TIM_1_SHDW_REG_T_RRD_SHDW,
 *      EMIF4F_SDRAM_TIM_1_SHDW_REG_T_WTR_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING1_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetShadowTiming1Config(&timingConfig);
        ...
        // Set the min number of m_clk cycles from precharge to activate
        timingConfig.t_rp = 1;

        // Configure the Timing Shadow         
        CSL_EMIF4F_SetShadowTiming1Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetShadowTiming1Config(EMIF4F_TIMING1_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = 0;

    /* Insert all the fields from the Timing Register */
    ((timingConfig) = ((timingConfig) & ~(0x1E000000u)) | (((ptrTimingConfig->t_rp) << (0x00000019u)) & (0x1E000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x01E00000u)) | (((ptrTimingConfig->t_rcd) << (0x00000015u)) & (0x01E00000u)));
    ((timingConfig) = ((timingConfig) & ~(0x001E0000u)) | (((ptrTimingConfig->t_wr) << (0x00000011u)) & (0x001E0000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0001F000u)) | (((ptrTimingConfig->t_ras) << (0x0000000Cu)) & (0x0001F000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000FC0u)) | (((ptrTimingConfig->t_rc) << (0x00000006u)) & (0x00000FC0u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000038u)) | (((ptrTimingConfig->t_rrd) << (0x00000003u)) & (0x00000038u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000007u)) | (((ptrTimingConfig->t_wtr) << (0x00000000u)) & (0x00000007u)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_1_SHDW = timingConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetTiming2Config
 *
 *   @b Description
 *   @n The function is used to get the SDRAM Timing2 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_TIM_2_REG_T_XP,  EMIF4F_SDRAM_TIM_2_REG_T_ODT,
 *      EMIF4F_SDRAM_TIM_2_REG_T_XSNR,EMIF4F_SDRAM_TIM_2_REG_T_XSRD,
 *      EMIF4F_SDRAM_TIM_2_REG_T_RTP, EMIF4F_SDRAM_TIM_2_REG_T_CKE
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING2_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetTiming2Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetTiming2Config(EMIF4F_TIMING2_CONFIG* ptrTimingConfig)
{   
    Uint32 timingConfig = ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_2;

    /* Extract all the fields from the Timing Register */
    ptrTimingConfig->t_xp   = (((timingConfig) & (0x70000000u)) >> (0x0000001Cu));
    ptrTimingConfig->t_odt  = (((timingConfig) & (0x0E000000u)) >> (0x00000019u));
    ptrTimingConfig->t_xsnr = (((timingConfig) & (0x01FF0000u)) >> (0x00000010u));
    ptrTimingConfig->t_xsrd = (((timingConfig) & (0x0000FFC0u)) >> (0x00000006u));
    ptrTimingConfig->t_rtp  = (((timingConfig) & (0x00000038u)) >> (0x00000003u));
    ptrTimingConfig->t_cke  = (((timingConfig) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetTiming2Config
 *
 *   @b Description
 *   @n The function is used to set the SDRAM Timing2 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_TIM_2_REG_T_XP,  EMIF4F_SDRAM_TIM_2_REG_T_ODT,
 *      EMIF4F_SDRAM_TIM_2_REG_T_XSNR,EMIF4F_SDRAM_TIM_2_REG_T_XSRD,
 *      EMIF4F_SDRAM_TIM_2_REG_T_RTP, EMIF4F_SDRAM_TIM_2_REG_T_CKE
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING2_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetTiming2Config(&timingConfig);

        // Set the number of m_clk cycles from Power Down to any command
        timingConfig.t_xp = 0x2;

        // Set the new timing configuration.
        CSL_EMIF4F_SetTiming2Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetTiming2Config(EMIF4F_TIMING2_CONFIG* ptrTimingConfig)
{   
    Uint32 timingConfig = 0;

    /* Initialize all the fields for the timing configuration */
    ((timingConfig) = ((timingConfig) & ~(0x70000000u)) | (((ptrTimingConfig->t_xp) << (0x0000001Cu)) & (0x70000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0E000000u)) | (((ptrTimingConfig->t_odt) << (0x00000019u)) & (0x0E000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x01FF0000u)) | (((ptrTimingConfig->t_xsnr) << (0x00000010u)) & (0x01FF0000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0000FFC0u)) | (((ptrTimingConfig->t_xsrd) << (0x00000006u)) & (0x0000FFC0u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000038u)) | (((ptrTimingConfig->t_rtp) << (0x00000003u)) & (0x00000038u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000007u)) | (((ptrTimingConfig->t_cke) << (0x00000000u)) & (0x00000007u)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_2 = timingConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetShadowTiming2Config
 *
 *   @b Description
 *   @n The function is used to get the Shadow SDRAM Timing2 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_TIM_2_SHDW_REG_T_XP_SHDW,  EMIF4F_SDRAM_TIM_2_SHDW_REG_T_ODT_SHDW,
 *      EMIF4F_SDRAM_TIM_2_SHDW_REG_T_XSNR_SHDW,EMIF4F_SDRAM_TIM_2_SHDW_REG_T_XSRD_SHDW,
 *      EMIF4F_SDRAM_TIM_2_SHDW_REG_T_RTP_SHDW, EMIF4F_SDRAM_TIM_2_SHDW_REG_T_CKE_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING2_CONFIG timingConfig;

        // Get the current shadow timing configuration.
        CSL_EMIF4F_GetShadowTiming2Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetShadowTiming2Config(EMIF4F_TIMING2_CONFIG* ptrTimingConfig)
{   
    Uint32 timingConfig = ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_2_SHDW;

    /* Extract all the fields from the Timing Register */
    ptrTimingConfig->t_xp   = (((timingConfig) & (0x70000000u)) >> (0x0000001Cu));
    ptrTimingConfig->t_odt  = (((timingConfig) & (0x0E000000u)) >> (0x00000019u));
    ptrTimingConfig->t_xsnr = (((timingConfig) & (0x01FF0000u)) >> (0x00000010u));
    ptrTimingConfig->t_xsrd = (((timingConfig) & (0x0000FFC0u)) >> (0x00000006u));
    ptrTimingConfig->t_rtp  = (((timingConfig) & (0x00000038u)) >> (0x00000003u));
    ptrTimingConfig->t_cke  = (((timingConfig) & (0x00000007u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetShadowTiming2Config
 *
 *   @b Description
 *   @n The function is used to set the Shadow SDRAM Timing2 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_TIM_2_SHDW_REG_T_XP_SHDW,  EMIF4F_SDRAM_TIM_2_SHDW_REG_T_ODT_SHDW,
 *      EMIF4F_SDRAM_TIM_2_SHDW_REG_T_XSNR_SHDW,EMIF4F_SDRAM_TIM_2_SHDW_REG_T_XSRD_SHDW,
 *      EMIF4F_SDRAM_TIM_2_SHDW_REG_T_RTP_SHDW, EMIF4F_SDRAM_TIM_2_SHDW_REG_T_CKE_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING2_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetShadowTiming2Config(&timingConfig);

        // Set the number of m_clk cycles from Power Down to any command
        timingConfig.t_xp = 0x2;

        // Set the new timing configuration.
        CSL_EMIF4F_SetShadowTiming2Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetShadowTiming2Config(EMIF4F_TIMING2_CONFIG* ptrTimingConfig)
{   
    Uint32 timingConfig = 0;

    /* Initialize all the fields for the timing configuration */
    ((timingConfig) = ((timingConfig) & ~(0x70000000u)) | (((ptrTimingConfig->t_xp) << (0x0000001Cu)) & (0x70000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0E000000u)) | (((ptrTimingConfig->t_odt) << (0x00000019u)) & (0x0E000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x01FF0000u)) | (((ptrTimingConfig->t_xsnr) << (0x00000010u)) & (0x01FF0000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0000FFC0u)) | (((ptrTimingConfig->t_xsrd) << (0x00000006u)) & (0x0000FFC0u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000038u)) | (((ptrTimingConfig->t_rtp) << (0x00000003u)) & (0x00000038u)));
    ((timingConfig) = ((timingConfig) & ~(0x00000007u)) | (((ptrTimingConfig->t_cke) << (0x00000000u)) & (0x00000007u)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_2_SHDW = timingConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetTiming3Config
 *
 *   @b Description
 *   @n The function is used to get the SDRAM Timing3 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_TIM_3_REG_T_PDLL_UL,  EMIF4F_SDRAM_TIM_3_REG_T_CSTA,
 *      EMIF4F_SDRAM_TIM_3_REG_T_CKESR,  EMIF4F_SDRAM_TIM_3_REG_ZQ_ZQCS,
 *      EMIF4F_SDRAM_TIM_3_REG_T_TDQSCKMAX,EMIF4F_SDRAM_TIM_3_REG_T_RFC,
 *      EMIF4F_SDRAM_TIM_3_REG_T_RAS_MAX
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING3_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetTiming3Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetTiming3Config(EMIF4F_TIMING3_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_3;

    /* Extract all the fields from the Timing Register */
    ptrTimingConfig->t_pdll_ul  = (((timingConfig) & (0xF0000000u)) >> (0x0000001Cu));
    ptrTimingConfig->t_csta     = (((timingConfig) & (0x0F000000u)) >> (0x00000018u));
    ptrTimingConfig->t_ckesr    = (((timingConfig) & (0x00E00000u)) >> (0x00000015u));
    ptrTimingConfig->zq_zqcs    = (((timingConfig) & (0x001F8000u)) >> (0x0000000Fu));
    ptrTimingConfig->t_tdqsckmax= (((timingConfig) & (0x00006000u)) >> (0x0000000Du));
    ptrTimingConfig->t_rfc      = (((timingConfig) & (0x00001FF0u)) >> (0x00000004u));
    ptrTimingConfig->t_rasMax   = (((timingConfig) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetTiming3Config
 *
 *   @b Description
 *   @n The function is used to set the SDRAM Timing3 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_TIM_3_REG_T_PDLL_UL,  EMIF4F_SDRAM_TIM_3_REG_T_CSTA,
 *      EMIF4F_SDRAM_TIM_3_REG_T_CKESR,  EMIF4F_SDRAM_TIM_3_REG_ZQ_ZQCS,
 *      EMIF4F_SDRAM_TIM_3_REG_T_TDQSCKMAX,EMIF4F_SDRAM_TIM_3_REG_T_RFC,
 *      EMIF4F_SDRAM_TIM_3_REG_T_RAS_MAX
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING3_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetTiming3Config(&timingConfig);

        // Set the Maximum number of reg_refresh_rate intervals from Activate to Precharge command. 
        timingConfig.t_rasMax = 0x3;

        // Set the timing configuration 
        CSL_EMIF4F_SetTiming3Config (&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetTiming3Config(EMIF4F_TIMING3_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = 0;

    /* Initialize all the fields */
    ((timingConfig) = ((timingConfig) & ~(0xF0000000u)) | (((ptrTimingConfig->t_pdll_ul) << (0x0000001Cu)) & (0xF0000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0F000000u)) | (((ptrTimingConfig->t_csta) << (0x00000018u)) & (0x0F000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00E00000u)) | (((ptrTimingConfig->t_ckesr) << (0x00000015u)) & (0x00E00000u)));
    ((timingConfig) = ((timingConfig) & ~(0x001F8000u)) | (((ptrTimingConfig->zq_zqcs) << (0x0000000Fu)) & (0x001F8000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00006000u)) | (((ptrTimingConfig->t_tdqsckmax) << (0x0000000Du)) & (0x00006000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00001FF0u)) | (((ptrTimingConfig->t_rfc) << (0x00000004u)) & (0x00001FF0u)));
    ((timingConfig) = ((timingConfig) & ~(0x0000000Fu)) | (((ptrTimingConfig->t_rasMax) << (0x00000000u)) & (0x0000000Fu)));

    /* Configure the register */
    ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_3 = timingConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetShadowTiming3Config
 *
 *   @b Description
 *   @n The function is used to get the Shadow SDRAM Timing3 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_SDRAM_TIM_3_SHDW_REG_T_PDLL_UL_SHDW,   EMIF4F_SDRAM_TIM_3_SHDW_REG_T_CSTA_SHDW,
 *      EMIF4F_SDRAM_TIM_3_SHDW_REG_T_CKESR_SHDW,     EMIF4F_SDRAM_TIM_3_SHDW_REG_ZQ_ZQCS_SHDW,
 *      EMIF4F_SDRAM_TIM_3_SHDW_REG_T_TDQSCKMAX_SHDW, EMIF4F_SDRAM_TIM_3_SHDW_REG_T_RFC_SHDW,
 *      EMIF4F_SDRAM_TIM_3_SHDW_REG_T_RAS_MAX_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING3_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetShadowTiming3Config(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetShadowTiming3Config(EMIF4F_TIMING3_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_3_SHDW;

    /* Extract all the fields from the Timing Register */
    ptrTimingConfig->t_pdll_ul  = (((timingConfig) & (0xF0000000u)) >> (0x0000001Cu));
    ptrTimingConfig->t_csta     = (((timingConfig) & (0x0F000000u)) >> (0x00000018u));
    ptrTimingConfig->t_ckesr    = (((timingConfig) & (0x00E00000u)) >> (0x00000015u));
    ptrTimingConfig->zq_zqcs    = (((timingConfig) & (0x001F8000u)) >> (0x0000000Fu));
    ptrTimingConfig->t_tdqsckmax= (((timingConfig) & (0x00006000u)) >> (0x0000000Du));
    ptrTimingConfig->t_rfc      = (((timingConfig) & (0x00001FF0u)) >> (0x00000004u));
    ptrTimingConfig->t_rasMax   = (((timingConfig) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetShadowTiming3Config
 *
 *   @b Description
 *   @n The function is used to set the Shadow SDRAM Timing3 Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_SDRAM_TIM_3_SHDW_REG_T_PDLL_UL_SHDW,   EMIF4F_SDRAM_TIM_3_SHDW_REG_T_CSTA_SHDW,
 *      EMIF4F_SDRAM_TIM_3_SHDW_REG_T_CKESR_SHDW,     EMIF4F_SDRAM_TIM_3_SHDW_REG_ZQ_ZQCS_SHDW,
 *      EMIF4F_SDRAM_TIM_3_SHDW_REG_T_TDQSCKMAX_SHDW, EMIF4F_SDRAM_TIM_3_SHDW_REG_T_RFC_SHDW,
 *      EMIF4F_SDRAM_TIM_3_SHDW_REG_T_RAS_MAX_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TIMING3_CONFIG timingConfig;

        // Get the current timing configuration.
        CSL_EMIF4F_GetShadowTiming3Config(&timingConfig);

        // Set the Maximum number of reg_refresh_rate intervals from Activate to Precharge command. 
        timingConfig.t_rasMax = 0x3;

        // Set the timing configuration 
        CSL_EMIF4F_SetShadowTiming3Config (&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetShadowTiming3Config(EMIF4F_TIMING3_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = 0;

    /* Initialize all the fields */
    ((timingConfig) = ((timingConfig) & ~(0xF0000000u)) | (((ptrTimingConfig->t_pdll_ul) << (0x0000001Cu)) & (0xF0000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0F000000u)) | (((ptrTimingConfig->t_csta) << (0x00000018u)) & (0x0F000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00E00000u)) | (((ptrTimingConfig->t_ckesr) << (0x00000015u)) & (0x00E00000u)));
    ((timingConfig) = ((timingConfig) & ~(0x001F8000u)) | (((ptrTimingConfig->zq_zqcs) << (0x0000000Fu)) & (0x001F8000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00006000u)) | (((ptrTimingConfig->t_tdqsckmax) << (0x0000000Du)) & (0x00006000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00001FF0u)) | (((ptrTimingConfig->t_rfc) << (0x00000004u)) & (0x00001FF0u)));
    ((timingConfig) = ((timingConfig) & ~(0x0000000Fu)) | (((ptrTimingConfig->t_rasMax) << (0x00000000u)) & (0x0000000Fu)));

    /* Configure the register */
    ((CSL_Emif4fRegs*)(0x21000000))->SDRAM_TIM_3_SHDW = timingConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetLPDDR2NVMTimingConfig
 *
 *   @b Description
 *   @n The function is used to get the LPDDR2 NVM Timing Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_XP,  EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_WTR,
 *      EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_RP,  EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_WRA,
 *      EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_RRD, EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_RCDMIN
 *
 *   @b Example
 *   @verbatim
        EMIF4F_LPDDR2NVM_TIMING_CONFIG timingConfig;

        // Get the current LPDDR2 NVM configuration.
        CSL_EMIF4F_GetLPDDR2NVMTimingConfig(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetLPDDR2NVMTimingConfig(EMIF4F_LPDDR2NVM_TIMING_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = ((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_NVM_TIM;

    /* Extract all the fields from the Timing Register */
    ptrTimingConfig->t_xp       = (((timingConfig) & (0x70000000u)) >> (0x0000001Cu));
    ptrTimingConfig->t_wtr      = (((timingConfig) & (0x07000000u)) >> (0x00000018u));
    ptrTimingConfig->t_rp       = (((timingConfig) & (0x00F00000u)) >> (0x00000014u));
    ptrTimingConfig->t_wra      = (((timingConfig) & (0x000F0000u)) >> (0x00000010u));
    ptrTimingConfig->t_rrd      = (((timingConfig) & (0x0000FF00u)) >> (0x00000008u));
    ptrTimingConfig->t_rcdmin   = (((timingConfig) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetLPDDR2NVMTimingConfig
 *
 *   @b Description
 *   @n The function is used to set the LPDDR2 NVM Timing Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_XP,  EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_WTR,
 *      EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_RP,  EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_WRA,
 *      EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_RRD, EMIF4F_LPDDR2_NVM_TIM_REG_NVM_T_RCDMIN
 *
 *   @b Example
 *   @verbatim
        EMIF4F_LPDDR2NVM_TIMING_CONFIG timingConfig;

        // Get the current LPDDR2 NVM configuration.
        CSL_EMIF4F_GetLPDDR2NVMTimingConfig(&timingConfig);

        // Set the Minimum number of m_clk cycles from Power-Down exit to any command
        timingConfig.t_xp = 1;

        // Set the LPDDR2 NVM configuration.
        CSL_EMIF4F_SetLPDDR2NVMTimingConfig(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetLPDDR2NVMTimingConfig(EMIF4F_LPDDR2NVM_TIMING_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = 0;

    /* Extract all the fields from the Timing Register */
    ((timingConfig) = ((timingConfig) & ~(0x70000000u)) | (((ptrTimingConfig->t_xp) << (0x0000001Cu)) & (0x70000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x07000000u)) | (((ptrTimingConfig->t_wtr) << (0x00000018u)) & (0x07000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00F00000u)) | (((ptrTimingConfig->t_rp) << (0x00000014u)) & (0x00F00000u)));
    ((timingConfig) = ((timingConfig) & ~(0x000F0000u)) | (((ptrTimingConfig->t_wra) << (0x00000010u)) & (0x000F0000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0000FF00u)) | (((ptrTimingConfig->t_rrd) << (0x00000008u)) & (0x0000FF00u)));
    ((timingConfig) = ((timingConfig) & ~(0x000000FFu)) | (((ptrTimingConfig->t_rcdmin) << (0x00000000u)) & (0x000000FFu)));

    /* Initialize the register. */
    ((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_NVM_TIM = timingConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetShadowLPDDR2NVMTimingConfig
 *
 *   @b Description
 *   @n The function is used to get the Shadow LPDDR2 NVM Timing Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_XP_SHDW,  EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_WTR_SHDW,
 *      EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_RP_SHDW,  EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_WRA_SHDW,
 *      EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_RRD_SHDW, EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_RCDMIN_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_LPDDR2NVM_TIMING_CONFIG timingConfig;

        // Get the current Shadow LPDDR2 NVM configuration.
        CSL_EMIF4F_GetShadowLPDDR2NVMTimingConfig(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetShadowLPDDR2NVMTimingConfig(EMIF4F_LPDDR2NVM_TIMING_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = ((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_NVM_TIM_SHDW;

    /* Extract all the fields from the Timing Register */
    ptrTimingConfig->t_xp       = (((timingConfig) & (0x70000000u)) >> (0x0000001Cu));
    ptrTimingConfig->t_wtr      = (((timingConfig) & (0x07000000u)) >> (0x00000018u));
    ptrTimingConfig->t_rp       = (((timingConfig) & (0x00F00000u)) >> (0x00000014u));
    ptrTimingConfig->t_wra      = (((timingConfig) & (0x000F0000u)) >> (0x00000010u));
    ptrTimingConfig->t_rrd      = (((timingConfig) & (0x0000FF00u)) >> (0x00000008u));
    ptrTimingConfig->t_rcdmin   = (((timingConfig) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetShadowLPDDR2NVMTimingConfig
 *
 *   @b Description
 *   @n The function is used to set the Shadow LPDDR2 NVM Timing Configuration
 *
 *   @b Arguments
     @verbatim
         ptrTimingConfig       Timing Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_XP_SHDW,  EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_WTR_SHDW,
 *      EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_RP_SHDW,  EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_WRA_SHDW,
 *      EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_RRD_SHDW, EMIF4F_LPDDR2_NVM_TIM_SHDW_REG_NVM_T_RCDMIN_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_LPDDR2NVM_TIMING_CONFIG timingConfig;

        // Get the current Shadow LPDDR2 NVM configuration.
        CSL_EMIF4F_GetShadowLPDDR2NVMTimingConfig(&timingConfig);

        // Set the Minimum number of m_clk cycles from Power-Down exit to any command
        timingConfig.t_xp = 1;

        // Set the Shadow LPDDR2 NVM configuration.
        CSL_EMIF4F_SetShadowLPDDR2NVMTimingConfig(&timingConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetShadowLPDDR2NVMTimingConfig(EMIF4F_LPDDR2NVM_TIMING_CONFIG* ptrTimingConfig)
{
    Uint32 timingConfig = 0;

    /* Extract all the fields from the Timing Register */
    ((timingConfig) = ((timingConfig) & ~(0x70000000u)) | (((ptrTimingConfig->t_xp) << (0x0000001Cu)) & (0x70000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x07000000u)) | (((ptrTimingConfig->t_wtr) << (0x00000018u)) & (0x07000000u)));
    ((timingConfig) = ((timingConfig) & ~(0x00F00000u)) | (((ptrTimingConfig->t_rp) << (0x00000014u)) & (0x00F00000u)));
    ((timingConfig) = ((timingConfig) & ~(0x000F0000u)) | (((ptrTimingConfig->t_wra) << (0x00000010u)) & (0x000F0000u)));
    ((timingConfig) = ((timingConfig) & ~(0x0000FF00u)) | (((ptrTimingConfig->t_rrd) << (0x00000008u)) & (0x0000FF00u)));
    ((timingConfig) = ((timingConfig) & ~(0x000000FFu)) | (((ptrTimingConfig->t_rcdmin) << (0x00000000u)) & (0x000000FFu)));

    /* Initialize the register. */
    ((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_NVM_TIM_SHDW = timingConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPowerMgmtConfig
 *
 *   @b Description
 *   @n The function is used to get the Power Management Configuration.
 *
 *   @b Arguments
     @verbatim
         ptrPwrMgmtConfig       Power Management Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_PWR_MGMT_CTRL_REG_PD_TIM,  EMIF4F_PWR_MGMT_CTRL_REG_DPD_EN,
 *      EMIF4F_PWR_MGMT_CTRL_REG_LP_MODE, EMIF4F_PWR_MGMT_CTRL_REG_SR_TIM,
 *      EMIF4F_PWR_MGMT_CTRL_REG_CS_TIM
 *
 *   @b Example
 *   @verbatim
        EMIF4F_PWR_MGMT_CONFIG pwrConfig;

        // Get the power management configuration.
        CSL_EMIF4F_GetPowerMgmtConfig(&pwrConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetPowerMgmtConfig(EMIF4F_PWR_MGMT_CONFIG* ptrPwrMgmtConfig)
{
    Uint32 powerMgmtConfig = ((CSL_Emif4fRegs*)(0x21000000))->PWR_MGMT_CTRL;

    /* Extract all the fields from the Power Management Register */
    ptrPwrMgmtConfig->pdTime     = (((powerMgmtConfig) & (0x0000F000u)) >> (0x0000000Cu));
    ptrPwrMgmtConfig->dpdEnable  = (((powerMgmtConfig) & (0x00000800u)) >> (0x0000000Bu));
    ptrPwrMgmtConfig->lpMode     = (((powerMgmtConfig) & (0x00000700u)) >> (0x00000008u));
    ptrPwrMgmtConfig->srTime     = (((powerMgmtConfig) & (0x000000F0u)) >> (0x00000004u));
    ptrPwrMgmtConfig->csTime     = (((powerMgmtConfig) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetPowerMgmtConfig
 *
 *   @b Description
 *   @n The function is used to set the Power Management Configuration.
 *
 *   @b Arguments
     @verbatim
         ptrPwrMgmtConfig       Power Management Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_PWR_MGMT_CTRL_REG_PD_TIM,  EMIF4F_PWR_MGMT_CTRL_REG_DPD_EN,
 *      EMIF4F_PWR_MGMT_CTRL_REG_LP_MODE, EMIF4F_PWR_MGMT_CTRL_REG_SR_TIM,
 *      EMIF4F_PWR_MGMT_CTRL_REG_CS_TIM
 *
 *   @b Example
 *   @verbatim
        EMIF4F_PWR_MGMT_CONFIG pwrConfig;

        // Get the power management configuration.
        CSL_EMIF4F_GetPowerMgmtConfig(&pwrConfig);

        // Enable Deep Power Down Mode
        pwrConfig.dpdEnable = 1;

        // Set the power management configuration
        CSL_EMIF4F_SetPowerMgmtConfig(&pwrConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetPowerMgmtConfig(EMIF4F_PWR_MGMT_CONFIG* ptrPwrMgmtConfig)
{
    Uint32 powerMgmtConfig = 0;

    /* Initialzie all the fields for the Power Management Register */
    ((powerMgmtConfig) = ((powerMgmtConfig) & ~(0x0000F000u)) | (((ptrPwrMgmtConfig->pdTime) << (0x0000000Cu)) & (0x0000F000u)));
    ((powerMgmtConfig) = ((powerMgmtConfig) & ~(0x00000800u)) | (((ptrPwrMgmtConfig->dpdEnable) << (0x0000000Bu)) & (0x00000800u)));
    ((powerMgmtConfig) = ((powerMgmtConfig) & ~(0x00000700u)) | (((ptrPwrMgmtConfig->lpMode) << (0x00000008u)) & (0x00000700u)));
    ((powerMgmtConfig) = ((powerMgmtConfig) & ~(0x000000F0u)) | (((ptrPwrMgmtConfig->srTime) << (0x00000004u)) & (0x000000F0u)));
    ((powerMgmtConfig) = ((powerMgmtConfig) & ~(0x0000000Fu)) | (((ptrPwrMgmtConfig->csTime) << (0x00000000u)) & (0x0000000Fu)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->PWR_MGMT_CTRL = powerMgmtConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetShadowPowerMgmtConfig
 *
 *   @b Description
 *   @n The function is used to get the Shadow Power Management Configuration.
 *
 *   @b Arguments
     @verbatim
         ptrPwrMgmtConfig       Power Management Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_PWR_MGMT_CTRL_SHDW_REG_PD_TIM_SHDW, 
 *      EMIF4F_PWR_MGMT_CTRL_SHDW_REG_SR_TIM_SHDW,
 *      EMIF4F_PWR_MGMT_CTRL_SHDW_REG_CS_TIM_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_PWR_MGMT_CONFIG pwrConfig;

        // Get the shadow power management configuration.
        CSL_EMIF4F_GetShadowPowerMgmtConfig(&pwrConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetShadowPowerMgmtConfig(EMIF4F_PWR_MGMT_CONFIG* ptrPwrMgmtConfig)
{
    Uint32 powerMgmtConfig = ((CSL_Emif4fRegs*)(0x21000000))->PWR_MGMT_CTRL_SHDW;

    /* Extract all the fields from the Power Management Register */
    ptrPwrMgmtConfig->pdTime = (((powerMgmtConfig) & (0x0000F000u)) >> (0x0000000Cu));
    ptrPwrMgmtConfig->srTime = (((powerMgmtConfig) & (0x000000F0u)) >> (0x00000004u));
    ptrPwrMgmtConfig->csTime = (((powerMgmtConfig) & (0x0000000Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetShadowPowerMgmtConfig
 *
 *   @b Description
 *   @n The function is used to set the Shadow Power Management Configuration.
 *
 *   @b Arguments
     @verbatim
         ptrPwrMgmtConfig       Power Management Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_PWR_MGMT_CTRL_SHDW_REG_PD_TIM_SHDW, 
 *      EMIF4F_PWR_MGMT_CTRL_SHDW_REG_SR_TIM_SHDW,
 *      EMIF4F_PWR_MGMT_CTRL_SHDW_REG_CS_TIM_SHDW
 *
 *   @b Example
 *   @verbatim
        EMIF4F_PWR_MGMT_CONFIG pwrConfig;

        // Get the power management configuration.
        CSL_EMIF4F_GetShadowPowerMgmtConfig(&pwrConfig);

        // Set the power management timer for clock stop to immediately enter clock stop
        pwrConfig.csTime = 0;

        // Set the power management configuration
        CSL_EMIF4F_SetShadowPowerMgmtConfig(&pwrConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetShadowPowerMgmtConfig(EMIF4F_PWR_MGMT_CONFIG* ptrPwrMgmtConfig)
{
    Uint32 powerMgmtConfig = 0;

    /* Initialzie all the fields for the Power Management Register */
    ((powerMgmtConfig) = ((powerMgmtConfig) & ~(0x0000F000u)) | (((ptrPwrMgmtConfig->pdTime) << (0x0000000Cu)) & (0x0000F000u)));
    ((powerMgmtConfig) = ((powerMgmtConfig) & ~(0x000000F0u)) | (((ptrPwrMgmtConfig->srTime) << (0x00000004u)) & (0x000000F0u)));
    ((powerMgmtConfig) = ((powerMgmtConfig) & ~(0x0000000Fu)) | (((ptrPwrMgmtConfig->csTime) << (0x00000000u)) & (0x0000000Fu)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->PWR_MGMT_CTRL_SHDW = powerMgmtConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetLPDDR2Mode
 *
 *   @b Description
 *   @n The function is used to get the LPDDR2 Mode
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n LPDDR2 Mode 
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_LPDDR2_MODE_REG_DATA_REG_VALUE_0 
 *
 *   @b Example
 *   @verbatim
        Uint8 mode;

        // Get the LPDDR2 Mode
        mode = CSL_EMIF4F_GetLPDDR2Mode();
        ...
     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_EMIF4F_GetLPDDR2Mode(void)
{
    return (((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_DATA) & (0x0000007Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetLPDDR2Mode
 *
 *   @b Description
 *   @n The function is used to get the LPDDR2 Mode
 *
 *   @b Arguments
     @verbatim
         mode   LPDDR2 Mode to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None 
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_LPDDR2_MODE_REG_DATA_REG_VALUE_0 
 *
 *   @b Example
 *   @verbatim

        // Set the LPDDR2 Mode
        CSL_EMIF4F_SetLPDDR2Mode(1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetLPDDR2Mode(Uint8 mode)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_DATA) = ((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_DATA) & ~(0x0000007Fu)) | (((mode) << (0x00000000u)) & (0x0000007Fu)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetLPDDR2ConfigCS
 *
 *   @b Description
 *   @n The function is used to get the LPDDR2 Configuration Chip Select
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n LPDDR2 Configuration Chip Select 
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_LPDDR2_MODE_REG_CFG_REG_CS 
 *
 *   @b Example
 *   @verbatim
        Uint8 cs;

        // Get the LPDDR2 Chip Select
        cs = CSL_EMIF4F_GetLPDDR2ConfigCS();
        ...
     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_EMIF4F_GetLPDDR2ConfigCS(void)
{
    return (((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) & (0x80000000u)) >> (0x0000001Fu));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetLPDDR2ConfigCS
 *
 *   @b Description
 *   @n The function is used to set the LPDDR2 Configuration Chip Select
 *
 *   @b Arguments
     @verbatim
         chipSelect     LPDDR2 Configuration Chip Select 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_LPDDR2_MODE_REG_CFG_REG_CS 
 *
 *   @b Example
 *   @verbatim

        // Set the LPDDR2 Chip Select to use CS0
        CSL_EMIF4F_SetLPDDR2ConfigCS(0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetLPDDR2ConfigCS(Uint8 chipSelect)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) & ~(0x80000000u)) | (((chipSelect) << (0x0000001Fu)) & (0x80000000u)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetLPDDR2ConfigRefreshEnable
 *
 *   @b Description
 *   @n The function is used to get the LPDDR2 Configuration Refresh Enable
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n LPDDR2 Configuration Refresh Enable
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_LPDDR2_MODE_REG_CFG_REG_REFRESH_EN 
 *
 *   @b Example
 *   @verbatim
        Uint8 refreshEnable;

        // Get the LPDDR2 Config Refresh Enable
        refreshEnable = CSL_EMIF4F_GetLPDDR2ConfigRefreshEnable();
        ...
     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_EMIF4F_GetLPDDR2ConfigRefreshEnable(void)
{
    return (((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) & (0x40000000u)) >> (0x0000001Eu));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetLPDDR2ConfigRefreshEnable
 *
 *   @b Description
 *   @n The function is used to set the LPDDR2 Configuration Refresh Enable
 *
 *   @b Arguments
     @verbatim
         refreshEnable  LPDDR2 Configuration Refresh Enable State
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_LPDDR2_MODE_REG_CFG_REG_REFRESH_EN 
 *
 *   @b Example
 *   @verbatim

        // Enable refresh enable after MRW
        CSL_EMIF4F_SetLPDDR2ConfigRefreshEnable(1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetLPDDR2ConfigRefreshEnable(Uint8 refreshEnable)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) & ~(0x40000000u)) | (((refreshEnable) << (0x0000001Eu)) & (0x40000000u)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetLPDDR2ConfigModeRegAddress
 *
 *   @b Description
 *   @n The function is used to get the LPDDR2 Configuration Mode Register Address
 *
 *   @b Arguments
     @verbatim
         None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n LPDDR2 Configuration Mode Register Address
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_LPDDR2_MODE_REG_CFG_REG_ADDRESS 
 *
 *   @b Example
 *   @verbatim
        Uint8 modeRegAddress;

        // Get the LPDDR2 Config Mode Register Address
        modeRegAddress = CSL_EMIF4F_GetLPDDR2ConfigModeRegAddress();
        ...
     @endverbatim
 * =============================================================================
 */
static inline Uint8 CSL_EMIF4F_GetLPDDR2ConfigModeRegAddress(void)
{
    return (((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetLPDDR2ConfigModeRegAddress
 *
 *   @b Description
 *   @n The function is used to set the LPDDR2 Configuration Mode Register Address
 *
 *   @b Arguments
     @verbatim
         modeRegAddr    LPDDR2 Configuration Mode Register Address
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_LPDDR2_MODE_REG_CFG_REG_ADDRESS 
 *
 *   @b Example
 *   @verbatim

        // Set the LPDDR2 Config Mode Register Address
        CSL_EMIF4F_SetLPDDR2ConfigModeRegAddress(0x10);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetLPDDR2ConfigModeRegAddress(Uint8 modeRegAddr)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->LPDDR2_MODE_REG_CFG) & ~(0x000000FFu)) | (((modeRegAddr) << (0x00000000u)) & (0x000000FFu)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetVBUSConfig
 *
 *   @b Description
 *   @n The function is used to get the VBUSM Configuration
 *
 *   @b Arguments
     @verbatim
        cosCount1   Priority Raise Counter for Class of Service 1
        cosCount2   Priority Raise Counter for Class of Service 2
        prOldCount  Priority Raise Old Counter
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Priority Raise Old Counter
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_VBUSM_CONFIG_REG_COS_COUNT_1, EMIF4F_VBUSM_CONFIG_REG_COS_COUNT_2,
 *   @n EMIF4F_VBUSM_CONFIG_REG_PR_OLD_COUNT
 *
 *   @b Example
 *   @verbatim
        Uint8 cosCount1;
        Uint8 cosCount2;
        Uint8 prOldCount;

        // Get the VBUS Configuration
        CSL_EMIF4F_GetVBUSConfig(&cosCount1, &cosCount2, &prOldCount);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetVBUSConfig(Uint8* cosCount1, Uint8* cosCount2, Uint8* prOldCount)
{
    *cosCount1  = (((((CSL_Emif4fRegs*)(0x21000000))->VBUSM_CONFIG) & (0x00FF0000u)) >> (0x00000010u));
    *cosCount2  = (((((CSL_Emif4fRegs*)(0x21000000))->VBUSM_CONFIG) & (0x0000FF00u)) >> (0x00000008u));
    *prOldCount = (((((CSL_Emif4fRegs*)(0x21000000))->VBUSM_CONFIG) & (0x000000FFu)) >> (0x00000000u));
    return;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetVBUSConfig
 *
 *   @b Description
 *   @n The function is used to set the VBUSM Configuration
 *
 *   @b Arguments
     @verbatim
        cosCount1   Priority Raise Counter for Class of Service 1
        cosCount2   Priority Raise Counter for Class of Service 2
        prOldCount  Priority Raise Old Counter
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None 
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_VBUSM_CONFIG_REG_COS_COUNT_1, EMIF4F_VBUSM_CONFIG_REG_COS_COUNT_2,
 *   @n EMIF4F_VBUSM_CONFIG_REG_PR_OLD_COUNT
 *
 *   @b Example
 *   @verbatim
        Uint8 cosCount1;
        Uint8 cosCount2;
        Uint8 prOldCount;

        // Get the VBUS Configuration
        CSL_EMIF4F_GetVBUSConfig(&cosCount1, &cosCount2, &prOldCount);

        // Set the VBUS Configuration
        CSL_EMIF4F_SetVBUSConfig(cosCount1, cosCount2, 0x1);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetVBUSConfig(Uint8 cosCount1, Uint8 cosCount2, Uint8 prOldCount)
{
    ((CSL_Emif4fRegs*)(0x21000000))->VBUSM_CONFIG = (((cosCount1) << (0x00000010u)) & (0x00FF0000u)) |
                          (((cosCount2) << (0x00000008u)) & (0x0000FF00u)) |
                          (((prOldCount) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetVBUSConfigValues
 *
 *   @b Description
 *   @n The function is used to get the VBUSM Configuration values
 *
 *   @b Arguments
     @verbatim
        ptrVBUSConfigValue      VBUS Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_VBUSM_CFG_VAL_1_REG_SYS_BUS_WIDTH, EMIF4F_VBUSM_CFG_VAL_1_REG_STAT_FIFO_DEPTH,
 *      EMIF4F_VBUSM_CFG_VAL_1_REG_WR_FIFO_DEPTH, EMIF4F_VBUSM_CFG_VAL_1_REG_CMD_FIFO_DEPTH,
 *   @n EMIF4F_VBUSM_CFG_VAL_2_REG_RREG_FIFO_DEPTH, EMIF4F_VBUSM_CFG_VAL_2_REG_RSD_FIFO_DEPTH,
 *      EMIF4F_VBUSM_CFG_VAL_2_REG_RCMD_FIFO_DEPTH
 *
 *   @b Example
 *   @verbatim
        EMIF4F_VBUS_CONFIG_VALUE     VBUSconfigValue;

        // Get the VBUS Configuration values
        CSL_EMIF4F_GetVBUSConfigValues(&VBUSconfigValue);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetVBUSConfigValues(EMIF4F_VBUS_CONFIG_VALUE* ptrVBUSConfigValue)
{
    Uint32  vbusConfigValue = ((CSL_Emif4fRegs*)(0x21000000))->VBUSM_CFG_VAL_1;

    /* Extract all the VBUS Configuration Values */
    ptrVBUSConfigValue->sysBusWidth  = (((vbusConfigValue) & (0xC0000000u)) >> (0x0000001Eu));
    ptrVBUSConfigValue->statFIFODepth= (((vbusConfigValue) & (0x00FF0000u)) >> (0x00000010u));
    ptrVBUSConfigValue->wrFIFODepth  = (((vbusConfigValue) & (0x0000FF00u)) >> (0x00000008u));
    ptrVBUSConfigValue->cmdFIFODepth = (((vbusConfigValue) & (0x000000FFu)) >> (0x00000000u));

    /* Get the configuration from the second register */
    vbusConfigValue = ((CSL_Emif4fRegs*)(0x21000000))->VBUSM_CFG_VAL_2;

    /* Extract all the VBUS Configuration Values */
    ptrVBUSConfigValue->rregFIFODepth = (((vbusConfigValue) & (0x00FF0000u)) >> (0x00000010u));
    ptrVBUSConfigValue->rsdFIFODepth  = (((vbusConfigValue) & (0x0000FF00u)) >> (0x00000008u));
    ptrVBUSConfigValue->rcmdFIFODepth = (((vbusConfigValue) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetIODFTControl
 *
 *   @b Description
 *   @n The function is used to get the IODFT Control configuration
 *
 *   @b Arguments
     @verbatim
        ptrIODFTControl      IODFT Control Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_IODFT_TLGC_REG_TLEC,      EMIF4F_IODFT_TLGC_REG_MT,
 *      EMIF4F_IODFT_TLGC_REG_ACT_CAP_EN,EMIF4F_IODFT_TLGC_REG_OPG_LD,
 *      EMIF4F_IODFT_TLGC_REG_MMS,       EMIF4F_IODFT_TLGC_REG_MC,        
 *      EMIF4F_IODFT_TLGC_REG_PC,        EMIF4F_IODFT_TLGC_REG_TM
 *
 *   @b Example
 *   @verbatim
        EMIF4F_IODFT_CONTROL     IODFTcontrol;

        // Get the IODFT Configuration values
        CSL_EMIF4F_GetIODFTControl(&IODFTcontrol);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetIODFTControl(EMIF4F_IODFT_CONTROL* ptrIODFTControl)
{
    Uint32  iodftControl = ((CSL_Emif4fRegs*)(0x21000000))->IODFT_TLGC;

    /* Extract all the IODFT Control Values */
    ptrIODFTControl->tlec    = (((iodftControl) & (0xFFFF0000u)) >> (0x00000010u));
    ptrIODFTControl->mt      = (((iodftControl) & (0x00004000u)) >> (0x0000000Eu));
    ptrIODFTControl->actCapEn= (((iodftControl) & (0x00002000u)) >> (0x0000000Du));
    ptrIODFTControl->opgld   = (((iodftControl) & (0x00001000u)) >> (0x0000000Cu));
    ptrIODFTControl->mms     = (((iodftControl) & (0x00000100u)) >> (0x00000008u));
    ptrIODFTControl->mc      = (((iodftControl) & (0x00000030u)) >> (0x00000004u));
    ptrIODFTControl->pc      = (((iodftControl) & (0x0000000Eu)) >> (0x00000001u));
    ptrIODFTControl->tm      = (((iodftControl) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetIODFTControl
 *
 *   @b Description
 *   @n The function is used to set the IODFT Control configuration
 *
 *   @b Arguments
     @verbatim
        ptrIODFTControl      IODFT Control Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_IODFT_TLGC_REG_TLEC,      EMIF4F_IODFT_TLGC_REG_MT,
 *      EMIF4F_IODFT_TLGC_REG_ACT_CAP_EN,EMIF4F_IODFT_TLGC_REG_OPG_LD,
 *      EMIF4F_IODFT_TLGC_REG_MMS,       EMIF4F_IODFT_TLGC_REG_MC,        
 *      EMIF4F_IODFT_TLGC_REG_PC,        EMIF4F_IODFT_TLGC_REG_TM
 *
 *   @b Example
 *   @verbatim
        EMIF4F_IODFT_CONTROL     IODFTcontrol;

        // Get the IODFT Configuration values
        CSL_EMIF4F_GetIODFTControl(&IODFTcontrol);

        // Set the new IODFT configuration 
        CSL_EMIF4F_SetIODFTControl (&IODFTcontrol);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetIODFTControl(EMIF4F_IODFT_CONTROL* ptrIODFTControl)
{
    Uint32  iodftControl = 0;

    /* Initialize all the IODFT Control Values */
    ((iodftControl) = ((iodftControl) & ~(0xFFFF0000u)) | (((ptrIODFTControl->tlec) << (0x00000010u)) & (0xFFFF0000u)));
    ((iodftControl) = ((iodftControl) & ~(0x00004000u)) | (((ptrIODFTControl->mt) << (0x0000000Eu)) & (0x00004000u)));
    ((iodftControl) = ((iodftControl) & ~(0x00002000u)) | (((ptrIODFTControl->actCapEn) << (0x0000000Du)) & (0x00002000u)));
    ((iodftControl) = ((iodftControl) & ~(0x00001000u)) | (((ptrIODFTControl->opgld) << (0x0000000Cu)) & (0x00001000u)));
    ((iodftControl) = ((iodftControl) & ~(0x00000100u)) | (((ptrIODFTControl->mms) << (0x00000008u)) & (0x00000100u)));
    ((iodftControl) = ((iodftControl) & ~(0x00000030u)) | (((ptrIODFTControl->mc) << (0x00000004u)) & (0x00000030u)));
    ((iodftControl) = ((iodftControl) & ~(0x0000000Eu)) | (((ptrIODFTControl->pc) << (0x00000001u)) & (0x0000000Eu)));
    ((iodftControl) = ((iodftControl) & ~(0x00000001u)) | (((ptrIODFTControl->tm) << (0x00000000u)) & (0x00000001u)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->IODFT_TLGC = iodftControl;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetIODFTControlResults
 *
 *   @b Description
 *   @n The function is used to get the IODFT Control results.
 *
 *   @b Arguments
     @verbatim
        dqmTLMRResults      DQM TLMR Results populated by this API
        ctlTLMRResults      CTL TLMR Results populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_IODFT_CTRL_MISR_RSLT_REG_DQM_TLMR, EMIF4F_IODFT_CTRL_MISR_RSLT_REG_CTL_TLMR
 *
 *   @b Example
 *   @verbatim
        Uint16     dqmTLMRResults;
        Uint16     ctlTLMRResults;

        // Get the IODFT Control Results
        CSL_EMIF4F_GetIODFTControlResults(&dqmTLMRResults, &ctlTLMRResults);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetIODFTControlResults(Uint16* dqmTLMRResults, Uint16* ctlTLMRResults)
{
    *dqmTLMRResults = (((((CSL_Emif4fRegs*)(0x21000000))->IODFT_CTRL_MISR_RSLT) & (0xFFFFF000u)) >> (0x0000000Cu));
    *ctlTLMRResults = (((((CSL_Emif4fRegs*)(0x21000000))->IODFT_CTRL_MISR_RSLT) & (0x000007FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetIODFTAddrResults
 *
 *   @b Description
 *   @n The function is used to get the IODFT Address results.
 *
 *   @b Arguments
     @verbatim
        addrTLMRResults      Addr TLMR Results populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_IODFT_ADDR_MISR_RSLT_REG_ADDR_TLMR
 *
 *   @b Example
 *   @verbatim
        Uint32     addrTLMRResults;

        // Get the IODFT Address results
        CSL_EMIF4F_GetIODFTAddrResults(&addrTLMRResults);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetIODFTAddrResults(Uint32* addrTLMRResults)
{
    *addrTLMRResults = (((((CSL_Emif4fRegs*)(0x21000000))->IODFT_ADDR_MISR_RSLT) & (0x001FFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetIODFTDataResults
 *
 *   @b Description
 *   @n The function is used to get the IODFT Data results.
 *
 *   @b Arguments
     @verbatim
        dataTLMRResults1      Data TLMR1 Results populated by this API
        dataTLMRResults2      Data TLMR2 Results populated by this API
        dataTLMRResults3      Data TLMR3 Results populated by this API
        dataTLMRResults4      Data TLMR4 Results populated by this API
        dataTLMRResults5      Data TLMR5 Results populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_IODFT_DATA_MISR_RSLT_1,EMIF4F_IODFT_DATA_MISR_RSLT_2,
 *      EMIF4F_IODFT_DATA_MISR_RSLT_3,EMIF4F_IODFT_DATA_MISR_RSLT_4,
 *      EMIF4F_IODFT_DATA_MISR_RSLT_5
 *
 *   @b Example
 *   @verbatim
        Uint32     dataTLMRResults1;
        Uint32     dataTLMRResults2;
        Uint32     dataTLMRResults3;
        Uint32     dataTLMRResults4;
        Uint32     dataTLMRResults5;

        // Get the IODFT Data results
        CSL_EMIF4F_GetIODFTDataResults(&dataTLMRResults1, &dataTLMRResults2, 
                                      &dataTLMRResults3, &dataTLMRResults4, 
                                      &dataTLMRResults5);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetIODFTDataResults
(
    Uint32* dataTLMRResults1,
    Uint32* dataTLMRResults2,
    Uint32* dataTLMRResults3,
    Uint32* dataTLMRResults4,
    Uint32* dataTLMRResults5
)
{
    *dataTLMRResults1 = ((CSL_Emif4fRegs*)(0x21000000))->IODFT_DATA_MISR_RSLT_1;
    *dataTLMRResults2 = ((CSL_Emif4fRegs*)(0x21000000))->IODFT_DATA_MISR_RSLT_2;
    *dataTLMRResults3 = ((CSL_Emif4fRegs*)(0x21000000))->IODFT_DATA_MISR_RSLT_3;
    *dataTLMRResults4 = ((CSL_Emif4fRegs*)(0x21000000))->IODFT_DATA_MISR_RSLT_4;
    *dataTLMRResults5 = ((CSL_Emif4fRegs*)(0x21000000))->IODFT_DATA_MISR_RSLT_5;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPerfCounters
 *
 *   @b Description
 *   @n The function is used to get the performance counters
 *
 *   @b Arguments
     @verbatim
        perfCounter1        Performance Counter1 populated by this API
        perfCounter2        Performance Counter2 populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_PERF_CNT_1,EMIF4F_PERF_CNT_2
 *
 *   @b Example
 *   @verbatim
        Uint32     perfCounter1;
        Uint32     perfCounter2;

        // Get the EMIF4F Performance counters
        CSL_EMIF4F_GetPerfCounters(&perfCounter1, &perfCounter2);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetPerfCounters
(
    Uint32* perfCounter1,
    Uint32* perfCounter2
)
{
    *perfCounter1 = ((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_1;
    *perfCounter2 = ((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_2;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPerfCounterConfig
 *
 *   @b Description
 *   @n The function is used to get the configuration for performance counters
 *
 *   @b Arguments
     @verbatim
        counter                 Perf Counter for which configuration is required (1 or 2)
        ptrPerfCounterConfig    Performance Counter Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_PERF_CNT_CFG_REG_CNTR2_MSTID_EN, EMIF4F_PERF_CNT_CFG_REG_CNTR2_REGION_EN,
 *      EMIF4F_PERF_CNT_CFG_REG_CNTR2_CFG;
 *      EMIF4F_PERF_CNT_CFG_REG_CNTR1_MSTID_EN,
 *      EMIF4F_PERF_CNT_CFG_REG_CNTR1_REGION_EN, EMIF4F_PERF_CNT_CFG_REG_CNTR1_CFG
 *
 *   @b Example
 *   @verbatim
        EMIF4F_PERF_CONFIG     perfCounterConfig;

        // Get the EMIF4F Performance Counter Configuration for counter 1
        CSL_EMIF4F_GetPerfCounterConfig(1, &perfCounterConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetPerfCounterConfig
(
    Uint8              counter,
    EMIF4F_PERF_CONFIG* ptrPerfCounterConfig
)
{
    Uint32  perfConfig = ((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG;

    if (counter == 2)
    {
        ptrPerfCounterConfig->mstIDEn = (((perfConfig) & (0x80000000u)) >> (0x0000001Fu));
        ptrPerfCounterConfig->regEn   = (((perfConfig) & (0x40000000u)) >> (0x0000001Eu));
        ptrPerfCounterConfig->cntCfg  = (((perfConfig) & (0x000F0000u)) >> (0x00000010u));
    } 
    else if (counter == 1)
    {
        ptrPerfCounterConfig->mstIDEn = (((perfConfig) & (0x00008000u)) >> (0x0000000Fu));
        ptrPerfCounterConfig->regEn   = (((perfConfig) & (0x00004000u)) >> (0x0000000Eu));
        ptrPerfCounterConfig->cntCfg  = (((perfConfig) & (0x0000000Fu)) >> (0x00000000u));
    }
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetPerfCounterConfig
 *
 *   @b Description
 *   @n The function is used to set the configuration for performance counters
 *
 *   @b Arguments
     @verbatim
        counter                 Perf Counter for which configuration is to be set (1 or 2)
        ptrPerfCounterConfig    Performance Counter Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_PERF_CNT_CFG_REG_CNTR2_MCONNID_EN, EMIF4F_PERF_CNT_CFG_REG_CNTR2_REGION_EN,
 *      EMIF4F_PERF_CNT_CFG_REG_CNTR2_CFG;
 *      EMIF4F_PERF_CNT_CFG_REG_CNTR1_MCONNID_EN,
 *      EMIF4F_PERF_CNT_CFG_REG_CNTR1_REGION_EN,  EMIF4F_PERF_CNT_CFG_REG_CNTR1_CFG
 *
 *   @b Example
 *   @verbatim
        EMIF4F_PERF_CONFIG     perfCounterConfig;

        // Get the EMIF4F Performance Counter Configuration for counter 2
        CSL_EMIF4F_GetPerfCounterConfig(2, &perfCounterConfig);

        // Enable Master ID Filter Enable 
        perfCounterConfig.mstIDEn = 1;
        
        // Set the EMIF4F Performance Counter Configuration.
        CSL_EMIF4F_SetPerfCounterConfig(2, &perfCounterConfig);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetPerfCounterConfig
(
    Uint8               counter, 
    EMIF4F_PERF_CONFIG*  ptrPerfCounterConfig
)
{
    /* Configure the performance counter configuration.*/
    if (counter == 1)
    {
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) & ~(0x00008000u)) | (((ptrPerfCounterConfig->mstIDEn) << (0x0000000Fu)) & (0x00008000u)));
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) & ~(0x00004000u)) | (((ptrPerfCounterConfig->regEn) << (0x0000000Eu)) & (0x00004000u)));
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) & ~(0x0000000Fu)) | (((ptrPerfCounterConfig->cntCfg) << (0x00000000u)) & (0x0000000Fu)));
    }
    else if (counter == 2)
    {
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) & ~(0x80000000u)) | (((ptrPerfCounterConfig->mstIDEn) << (0x0000001Fu)) & (0x80000000u)));
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) & ~(0x40000000u)) | (((ptrPerfCounterConfig->regEn) << (0x0000001Eu)) & (0x40000000u)));
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_CFG) & ~(0x000F0000u)) | (((ptrPerfCounterConfig->cntCfg) << (0x00000010u)) & (0x000F0000u)));
    }
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPerfCounterMasterRegion
 *
 *   @b Description
 *   @n The function is used to get the master region selection for the specific
 *      performance counters
 *
 *   @b Arguments
     @verbatim
        counter          Perf Counter for which master region selection is configured
        mstID            Master ID selection for the specified performance counter
        regionSel        Region Selection for the specified performance counter
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_PERF_CNT_SEL_REG_MCONNID1, EMIF4F_PERF_CNT_SEL_REG_REGION_SEL1;
 *      EMIF4F_PERF_CNT_SEL_REG_MCONNID2, EMIF4F_PERF_CNT_SEL_REG_REGION_SEL2
 *
 *   @b Example
 *   @verbatim
        Uint8   mstID;
        Uint8   regionSel;

        // Get the Master Region Selection for Counter 1
        CSL_EMIF4F_GetPerfCounterMasterRegion (1, &mstID, &regionSel);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetPerfCounterMasterRegion
(
    Uint8   counter,
    Uint8*  mstID,
    Uint8*  regionSel
)
{
    if (counter == 1)
    {
        *mstID     = (((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) & (0x0000FF00u)) >> (0x00000008u));
        *regionSel = (((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) & (0x0000000Fu)) >> (0x00000000u));
    }
    else if (counter == 2)
    {
        *mstID     = (((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) & (0xFF000000u)) >> (0x00000018u));
        *regionSel = (((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) & (0x000F0000u)) >> (0x00000010u));
    }
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetPerfCounterMasterRegion
 *
 *   @b Description
 *   @n The function is used to set the master region selection for the specific
 *      performance counters
 *
 *   @b Arguments
     @verbatim
        counter          Perf Counter for which master region selection is configured
        mstID            Master ID selection for the specified performance counter
        regionSel        Region Selection for the specified performance counter
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_PERF_CNT_SEL_REG_MCONNID1, EMIF4F_PERF_CNT_SEL_REG_REGION_SEL1;
 *      EMIF4F_PERF_CNT_SEL_REG_MCONNID2, EMIF4F_PERF_CNT_SEL_REG_REGION_SEL2
 *
 *   @b Example
 *   @verbatim
        Uint8   mstID;
        Uint8   regionSel;

        // Get the Master Region Selection for Counter 1
        CSL_EMIF4F_GetPerfCounterMasterRegion (1, &mstID, &regionSel);

        // Change Master ID to be 5
        CSL_EMIF4F_SetPerfCounterMasterRegion(1, 5, regionSel);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetPerfCounterMasterRegion
(
    Uint8   counter,
    Uint8   mstID,
    Uint8   regionSel
)
{
    if (counter == 1)
    {
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) & ~(0x0000FF00u)) | (((mstID) << (0x00000008u)) & (0x0000FF00u)));
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) & ~(0x0000000Fu)) | (((regionSel) << (0x00000000u)) & (0x0000000Fu)));
    }
    else if (counter == 2)
    {
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) & ~(0xFF000000u)) | (((mstID) << (0x00000018u)) & (0xFF000000u)));
        ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) = ((((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_SEL) & ~(0x000F0000u)) | (((regionSel) << (0x00000010u)) & (0x000F0000u)));
    }
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPerfCounterTime
 *
 *   @b Description
 *   @n The function is used to get the performance counter timer register
 *
 *   @b Arguments
     @verbatim
        None
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n Performance counter Time Register
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_PERF_CNT_TIM
 *
 *   @b Example
 *   @verbatim
        Uint32  perfCount;

        // Get the Performance Counter Time Register
        perfCount = CSL_EMIF4F_GetPerfCounterTime ();
        ...
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_EMIF4F_GetPerfCounterTime(void)
{
    return ((CSL_Emif4fRegs*)(0x21000000))->PERF_CNT_TIM;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetIdleControl
 *
 *   @b Description
 *   @n The function is used to get the idle control information
 *
 *   @b Arguments
     @verbatim
        idleLen         Idle Length populated by this API
        idleInterval    Idle Interval populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_READ_IDLE_CTRL_REG_READ_IDLE_LEN, EMIF4F_READ_IDLE_CTRL_REG_READ_IDLE_INTERVAL
 *
 *   @b Example
 *   @verbatim
        Uint8   idleLen;
        Uint16  idleInterval;

        // Get the Idle Control Configuration
        CSL_EMIF4F_GetIdleControl (&idleLen, &idleInterval);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetIdleControl(Uint8* idleLen, Uint16* idleInterval)
{
    *idleLen      = (((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL) & (0x000F0000u)) >> (0x00000010u));
    *idleInterval = (((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL) & (0x000001FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetIdleControl
 *
 *   @b Description
 *   @n The function is used to set the idle control information
 *
 *   @b Arguments
     @verbatim
        idleLen         Idle Length to be configured
        idleInterval    Idle Interval to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_READ_IDLE_CTRL_REG_READ_IDLE_LEN, 
 *      EMIF4F_READ_IDLE_CTRL_REG_READ_IDLE_INTERVAL
 *
 *   @b Example
 *   @verbatim
        ...
        // Set the Idle Control Configuration
        CSL_EMIF4F_SetIdleControl (5, 10);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetIdleControl(Uint8 idleLen, Uint16 idleInterval)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL) & ~(0x000F0000u)) | (((idleLen) << (0x00000010u)) & (0x000F0000u)));
    ((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL) = ((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL) & ~(0x000001FFu)) | (((idleInterval) << (0x00000000u)) & (0x000001FFu)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetIdleControlShadow
 *
 *   @b Description
 *   @n The function is used to get the idle control information from the Shadow
 *      register.
 *
 *   @b Arguments
     @verbatim
        idleLen         Idle Length populated by this API
        idleInterval    Idle Interval populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n EMIF4F_READ_IDLE_CTRL_SHDW_REG_READ_IDLE_LEN_SHDW, 
 *      EMIF4F_READ_IDLE_CTRL_SHDW_REG_READ_IDLE_INTERVAL_SHDW
 *
 *   @b Example
 *   @verbatim
        // Get the Idle Control Configuration from the Shadow  register
        CSL_EMIF4F_GetIdleControlShadow (&idleLen, &idleInterval);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetIdleControlShadow(Uint8* idleLen, Uint16* idleInterval)
{
    *idleLen      = (((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL_SHDW) & (0x000F0000u)) >> (0x00000010u));
    *idleInterval = (((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL_SHDW) & (0x000001FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetIdleControlShadow
 *
 *   @b Description
 *   @n The function is used to set the idle control information in the Shadow
 *      register
 *
 *   @b Arguments
     @verbatim
        idleLen         Idle Length to be configured
        idleInterval    Idle Interval to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n EMIF4F_READ_IDLE_CTRL_SHDW_REG_READ_IDLE_LEN_SHDW, 
 *      EMIF4F_READ_IDLE_CTRL_SHDW_REG_READ_IDLE_INTERVAL_SHDW
 *
 *   @b Example
 *   @verbatim
        ...
        // Set the Idle Control Configuration in the Shadow register
        CSL_EMIF4F_SetIdleControlShadow (5, 10);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetIdleControlShadow(Uint8 idleLen, Uint16 idleInterval)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL_SHDW) = ((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL_SHDW) & ~(0x000F0000u)) | (((idleLen) << (0x00000010u)) & (0x000F0000u)));
    ((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL_SHDW) = ((((CSL_Emif4fRegs*)(0x21000000))->READ_IDLE_CTRL_SHDW) & ~(0x000001FFu)) | (((idleInterval) << (0x00000000u)) & (0x000001FFu)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetInterruptRawStatus
 *
 *   @b Description
 *   @n The function is used to get the interrupt RAW status 
 *
 *   @b Arguments
     @verbatim
        rawStatus       Raw Interrupt Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *     EMIF4F_IRQSTATUS_RAW_SYS
 *
 *   @b Example
 *   @verbatim
        Uint8   rawStatus;

        // Get the Interrupt RAW Status
        CSL_EMIF4F_GetInterruptRawStatus (&rawStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetInterruptRawStatus(Uint8* rawStatus)
{
    *rawStatus = ((CSL_Emif4fRegs*)(0x21000000))->IRQSTATUS_RAW_SYS;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetInterruptRawStatus
 *
 *   @b Description
 *   @n The function is used to set the interrupt RAW status 
 *
 *   @b Arguments
     @verbatim
        rawStatus       Raw Interrupt Status to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *     EMIF4F_IRQSTATUS_RAW_SYS
 *
 *   @b Example
 *   @verbatim
        
        // Set the Interrupt RAW Status for LPDDR2 NVM data not valid
        CSL_EMIF4F_SetInterruptRawStatus (0x4);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetInterruptRawStatus(Uint8 rawStatus)
{
    ((CSL_Emif4fRegs*)(0x21000000))->IRQSTATUS_RAW_SYS = rawStatus;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetInterruptStatus
 *
 *   @b Description
 *   @n The function is used to get the interrupt status 
 *
 *   @b Arguments
     @verbatim
        intrStatus       Interrupt Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *     EMIF4F_IRQSTATUS_SYS
 *
 *   @b Example
 *   @verbatim
        Uint8   intrStatus;

        // Get the Interrupt Status
        CSL_EMIF4F_GetInterruptStatus (&intrStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetInterruptStatus(Uint8* intrStatus)
{
    *intrStatus = ((CSL_Emif4fRegs*)(0x21000000))->IRQSTATUS_SYS;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_ClearInterruptStatus
 *
 *   @b Description
 *   @n The function is used to clear the interrupt status 
 *
 *   @b Arguments
     @verbatim
        intrStatus       Interrupt Status populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *     EMIF4F_IRQSTATUS_SYS
 *
 *   @b Example
 *   @verbatim
        Uint8   intrStatus;

        // Get the Interrupt Status
        CSL_EMIF4F_GetInterruptRawStatus (&intrStatus);
        ...
        // Process the interrupts
        ...
        // Clear the Interrupts
        CSL_EMIF4F_ClearInterruptStatus (intrStatus);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_ClearInterruptStatus(Uint8 intrStatus)
{
    ((CSL_Emif4fRegs*)(0x21000000))->IRQSTATUS_SYS = intrStatus;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_EnableInterrupts
 *
 *   @b Description
 *   @n The function is used to enable interrupts
 *
 *   @b Arguments
     @verbatim
        intrFlag       Interrupt flag for interrupts to be enabled
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *     EMIF4F_IRQENABLE_SET_SYS
 *
 *   @b Example
 *   @verbatim

        // Enable address error interrupt 
        CSL_EMIF4F_EnableInterrupts (0x1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_EnableInterrupts(Uint8 intrStatus)
{
    ((CSL_Emif4fRegs*)(0x21000000))->IRQENABLE_SET_SYS = intrStatus;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_DisableInterrupts
 *
 *   @b Description
 *   @n The function is used to disable interrupts
 *
 *   @b Arguments
     @verbatim
        intrFlag       Interrupt flag for interrupts to be disabled
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *     EMIF4F_IRQENABLE_CLR_SYS
 *
 *   @b Example
 *   @verbatim

        // Disable address error interrupt 
        CSL_EMIF4F_DisableInterrupts (0x1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_DisableInterrupts(Uint8 intrStatus)
{
    ((CSL_Emif4fRegs*)(0x21000000))->IRQENABLE_CLR_SYS = intrStatus;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetOutputImpedanceConfig
 *
 *   @b Description
 *   @n The function is used to get the Output Impedance Calibrartion configuration
 *
 *   @b Arguments
     @verbatim
        ptrOutputImpedanceConfig    Output Impedance Calibrartion configuration 
                                    populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *     EMIF4F_ZQ_CONFIG_REG_ZQ_CS1EN,      EMIF4F_ZQ_CONFIG_REG_ZQ_CS0EN, 
 *     EMIF4F_ZQ_CONFIG_REG_ZQ_DUALCALEN,  EMIF4F_ZQ_CONFIG_REG_ZQ_SFEXITEN,
 *     EMIF4F_ZQ_CONFIG_REG_ZQ_ZQINIT_MULT,EMIF4F_ZQ_CONFIG_REG_ZQ_ZQCL_MULT,
 *     EMIF4F_ZQ_CONFIG_REG_ZQ_REFINTERVAL
 *
 *   @b Example
 *   @verbatim
        EMIF4F_OUTPUT_IMP_CONFIG outputImpConfig; 

        // Get the output impedance configuration
        CSL_EMIF4F_GetOutputImpedanceConfig (&outputImpConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetOutputImpedanceConfig(EMIF4F_OUTPUT_IMP_CONFIG* ptrOutputImpedanceConfig)
{
    Uint32 zqConfig = ((CSL_Emif4fRegs*)(0x21000000))->ZQ_CONFIG;

    /* Extract all the fields and populate the structure */
    ptrOutputImpedanceConfig->zqCS1En       = (((zqConfig) & (0x80000000u)) >> (0x0000001Fu));
    ptrOutputImpedanceConfig->zqCS0En       = (((zqConfig) & (0x40000000u)) >> (0x0000001Eu));
    ptrOutputImpedanceConfig->zqDualCSEn    = (((zqConfig) & (0x20000000u)) >> (0x0000001Du));
    ptrOutputImpedanceConfig->zqSFEXITEn    = (((zqConfig) & (0x10000000u)) >> (0x0000001Cu));
    ptrOutputImpedanceConfig->zqZQCLInterval= (((zqConfig) & (0x000C0000u)) >> (0x00000012u));
    ptrOutputImpedanceConfig->zqZQCLMult    = (((zqConfig) & (0x00030000u)) >> (0x00000010u));
    ptrOutputImpedanceConfig->zqRefInterval = (((zqConfig) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetOutputImpedanceConfig
 *
 *   @b Description
 *   @n The function is used to set the Output Impedance Calibrartion configuration
 *
 *   @b Arguments
     @verbatim
        ptrOutputImpedanceConfig    Output Impedance Calibrartion configuration to be
                                    configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *     EMIF4F_ZQ_CONFIG_REG_ZQ_CS1EN,      EMIF4F_ZQ_CONFIG_REG_ZQ_CS0EN, 
 *     EMIF4F_ZQ_CONFIG_REG_ZQ_DUALCALEN,  EMIF4F_ZQ_CONFIG_REG_ZQ_SFEXITEN,
 *     EMIF4F_ZQ_CONFIG_REG_ZQ_ZQINIT_MULT,EMIF4F_ZQ_CONFIG_REG_ZQ_ZQCL_MULT,
 *     EMIF4F_ZQ_CONFIG_REG_ZQ_REFINTERVAL
 *
 *   @b Example
 *   @verbatim
        EMIF4F_OUTPUT_IMP_CONFIG outputImpConfig; 

        // Get the output impedance configuration
        CSL_EMIF4F_GetOutputImpedanceConfig (&outputImpConfig);

        // Enable ZQ Calibration for CS1
        outputImpConfig.zqCS1En = 1;

        // Set the new output impedance configuration.
        CSL_EMIF4F_SetOutputImpedanceConfig(&outputImpConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetOutputImpedanceConfig(EMIF4F_OUTPUT_IMP_CONFIG* ptrOutputImpedanceConfig)
{
    Uint32 zqConfig = 0;

    /* Initialize the fields */
    ((zqConfig) = ((zqConfig) & ~(0x80000000u)) | (((ptrOutputImpedanceConfig->zqCS1En) << (0x0000001Fu)) & (0x80000000u)));
    ((zqConfig) = ((zqConfig) & ~(0x40000000u)) | (((ptrOutputImpedanceConfig->zqCS0En) << (0x0000001Eu)) & (0x40000000u)));
    ((zqConfig) = ((zqConfig) & ~(0x20000000u)) | (((ptrOutputImpedanceConfig->zqDualCSEn) << (0x0000001Du)) & (0x20000000u)));
    ((zqConfig) = ((zqConfig) & ~(0x10000000u)) | (((ptrOutputImpedanceConfig->zqSFEXITEn) << (0x0000001Cu)) & (0x10000000u)));
    ((zqConfig) = ((zqConfig) & ~(0x000C0000u)) | (((ptrOutputImpedanceConfig->zqZQCLInterval) << (0x00000012u)) & (0x000C0000u)));
    ((zqConfig) = ((zqConfig) & ~(0x00030000u)) | (((ptrOutputImpedanceConfig->zqZQCLMult) << (0x00000010u)) & (0x00030000u)));
    ((zqConfig) = ((zqConfig) & ~(0x0000FFFFu)) | (((ptrOutputImpedanceConfig->zqRefInterval) << (0x00000000u)) & (0x0000FFFFu)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->ZQ_CONFIG = zqConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetTempAlertConfig
 *
 *   @b Description
 *   @n The function is used to get the Temperature Alert configuration
 *
 *   @b Arguments
     @verbatim
        ptrTempAlertConfig    Temperature Alert Configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *     EMIF4F_TEMP_ALERT_CONFIG_REG_TA_CS1EN,    EMIF4F_TEMP_ALERT_CONFIG_REG_TA_CS0EN, 
 *     EMIF4F_TEMP_ALERT_CONFIG_REG_TA_SFEXITEN, EMIF4F_TEMP_ALERT_CONFIG_REG_TA_DEVWDT,
 *     EMIF4F_TEMP_ALERT_CONFIG_REG_TA_DEVCNT,   EMIF4F_TEMP_ALERT_CONFIG_REG_TA_REFINTERVAL
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TEMP_ALERT_CONFIG tempAlertConfig; 

        // Get the temperature alert configuration.
        CSL_EMIF4F_GetTempAlertConfig (&tempAlertConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetTempAlertConfig(EMIF4F_TEMP_ALERT_CONFIG* ptrTempAlertConfig)
{
    Uint32 tempAlertConfig = ((CSL_Emif4fRegs*)(0x21000000))->TEMP_ALERT_CONFIG;

    /* Extract all the fields and populate the structure */
    ptrTempAlertConfig->taCS1En       = (((tempAlertConfig) & (0x80000000u)) >> (0x0000001Fu));
    ptrTempAlertConfig->taCS0En       = (((tempAlertConfig) & (0x40000000u)) >> (0x0000001Eu));
    ptrTempAlertConfig->taSFEXITEn    = (((tempAlertConfig) & (0x10000000u)) >> (0x0000001Cu));
    ptrTempAlertConfig->taDevWdth     = (((tempAlertConfig) & (0x0C000000u)) >> (0x0000001Au));
    ptrTempAlertConfig->taDevCnt      = (((tempAlertConfig) & (0x03000000u)) >> (0x00000018u));
    ptrTempAlertConfig->taRefInterval = (((tempAlertConfig) & (0x003FFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetTempAlertConfig
 *
 *   @b Description
 *   @n The function is used to set the Temperature Alert configuration
 *
 *   @b Arguments
     @verbatim
        ptrTempAlertConfig    Temperature Alert Configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *     EMIF4F_TEMP_ALERT_CONFIG_REG_TA_CS1EN,    EMIF4F_TEMP_ALERT_CONFIG_REG_TA_CS0EN, 
 *     EMIF4F_TEMP_ALERT_CONFIG_REG_TA_SFEXITEN, EMIF4F_TEMP_ALERT_CONFIG_REG_TA_DEVWDT,
 *     EMIF4F_TEMP_ALERT_CONFIG_REG_TA_DEVCNT,   EMIF4F_TEMP_ALERT_CONFIG_REG_TA_REFINTERVAL
 *
 *   @b Example
 *   @verbatim
        EMIF4F_TEMP_ALERT_CONFIG tempAlertConfig; 

        // Get the temperature alert configuration.
        CSL_EMIF4F_GetTempAlertConfig (&tempAlertConfig);

        // Enable Temperature Alert Polling for CS1
        tempAlertConfig.taCS1En = 1;

        // Set the new temperature alert configuration.
        CSL_EMIF4F_SetTempAlertConfig(&tempAlertConfig);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetTempAlertConfig(EMIF4F_TEMP_ALERT_CONFIG* ptrTempAlertConfig)
{
    Uint32 tempAlertConfig = 0;

    /* Extract all the fields and populate the structure */
    ((tempAlertConfig) = ((tempAlertConfig) & ~(0x80000000u)) | (((ptrTempAlertConfig->taCS1En) << (0x0000001Fu)) & (0x80000000u)));
    ((tempAlertConfig) = ((tempAlertConfig) & ~(0x40000000u)) | (((ptrTempAlertConfig->taCS0En) << (0x0000001Eu)) & (0x40000000u)));
    ((tempAlertConfig) = ((tempAlertConfig) & ~(0x10000000u)) | (((ptrTempAlertConfig->taSFEXITEn) << (0x0000001Cu)) & (0x10000000u)));
    ((tempAlertConfig) = ((tempAlertConfig) & ~(0x0C000000u)) | (((ptrTempAlertConfig->taDevWdth) << (0x0000001Au)) & (0x0C000000u)));
    ((tempAlertConfig) = ((tempAlertConfig) & ~(0x03000000u)) | (((ptrTempAlertConfig->taDevCnt) << (0x00000018u)) & (0x03000000u)));
    ((tempAlertConfig) = ((tempAlertConfig) & ~(0x003FFFFFu)) | (((ptrTempAlertConfig->taRefInterval) << (0x00000000u)) & (0x003FFFFFu)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->TEMP_ALERT_CONFIG = tempAlertConfig;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetErrorLog
 *
 *   @b Description
 *   @n The function is used to get the error log
 *
 *   @b Arguments
     @verbatim
        errCRSel    CRSel for the first errored transaction populated by this API
        errAddMode  Addressing Mode populated by this API
        errCmdType  Command Type of the first errored transaction populated by this API
        errMstID    Master ID of the first errored transaction populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *     EMIF4F_VBUSM_ERR_LOG_REG_CRSEL,EMIF4F_VBUSM_ERR_LOG_REG_CAMODE, 
 *     EMIF4F_VBUSM_ERR_LOG_REG_CDIR, EMIF4F_VBUSM_ERR_LOG_REG_CMSTID
 *
 *   @b Example
 *   @verbatim
        Uint8  errCRSel;
        Uint8  errAddMode;
        Uint8  errCmdType;
        Uint8  errMstID;

        // Get the Error Log 
        CSL_EMIF4F_GetErrorLog (&errCRSel, &errAddMode, &errCmdType, &errMstID);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetErrorLog
(
    Uint8*  errCRSel,
    Uint8*  errAddMode,
    Uint8*  errCmdType,
    Uint8*  errMstID
)
{
    Uint32 errLog = ((CSL_Emif4fRegs*)(0x21000000))->VBUSM_ERR_LOG;

    /* Extract all the fields from the error log register */
    *errCRSel   = (((errLog) & (0x00007800u)) >> (0x0000000Bu));
    *errAddMode = (((errLog) & (0x00000600u)) >> (0x00000009u));
    *errCmdType = (((errLog) & (0x00000100u)) >> (0x00000008u));
    *errMstID   = (((errLog) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetLevelingRampWindow
 *
 *   @b Description
 *   @n The function is used to get the incremental leveling ramp window.
 *
 *   @b Arguments
     @verbatim
        lvlRampWindow   - Incremental leveling ramp window in number of 
                          refresh periods
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_RDWR_LVL_RMP_WIN_REG_RDWRLVLINC_RMP_WIN
 *
 *   @b Example
 *   @verbatim
        Uint16  lvlRampWindow;

        // Get the Leveling Ramp Window
        CSL_EMIF4F_GetLevelingRampWindow (&lvlRampWindow);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetLevelingRampWindow(Uint16* lvlRampWindow)
{
    *lvlRampWindow = (((((CSL_Emif4fRegs*)(0x21000000))->RDWR_LVL_RMP_WIN) & (0x00001FFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetLevelingRampWindow
 *
 *   @b Description
 *   @n The function is used to set the incremental leveling ramp window.
 *
 *   @b Arguments
     @verbatim
        lvlRampWindow   - Incremental leveling ramp window in number of 
                          refresh periods
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_RDWR_LVL_RMP_WIN_REG_RDWRLVLINC_RMP_WIN
 *
 *   @b Example
 *   @verbatim
        
        // Set the Leveling Ramp Window
        CSL_EMIF4F_SetLevelingRampWindow (1000);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetLevelingRampWindow(Uint16 lvlRampWindow)
{
    ((((CSL_Emif4fRegs*)(0x21000000))->RDWR_LVL_RMP_WIN) = ((((CSL_Emif4fRegs*)(0x21000000))->RDWR_LVL_RMP_WIN) & ~(0x00001FFFu)) | (((lvlRampWindow) << (0x00000000u)) & (0x00001FFFu)));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetLevelingRampControlInfo
 *
 *   @b Description
 *   @n The function is used to get the incremental leveling ramp control information
 *
 *   @b Arguments
     @verbatim
        preScalar   - Incremental leveling pre-scalar in number of refresh periods
        readDataEye - Incremental read data eye training interval during ramp window
        readDQS     - Incremental read DQS gate training interval during ramp window
        writeInt    - Incremental write leveling interval during ramp window
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_RDWRLVL_EN,
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_RDWRLVLINC_RMP_PRE,
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_RDLVLINC_RMP_INT,
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_RDLVLGATEINC_RMP_INT,
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_WRLVLINC_RMP_INT
 *
 *   @b Example
 *   @verbatim
        Uint8  preScalar;
        Uint8  readDataEye;
        Uint8  readDQS;
        Uint8  writeInt;
        Bool   enable;

        // Get the Leveling Ramp Control Information
        CSL_EMIF4F_GetLevelingRampControlInfo (&enable, &preScalar, &readDataEye, &readDQS, &writeInt);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetLevelingRampControlInfo
(
    Bool*   enable,
    Uint8*  preScalar,
    Uint8*  readDataEye,
    Uint8*  readDQS,
    Uint8*  writeInt
)
{
    Uint32  value = ((CSL_Emif4fRegs*)(0x21000000))->RDWR_LVL_RMP_CTRL;

    *enable      = (((value) & (0x80000000u)) >> (0x0000001Fu));
    *preScalar   = (((value) & (0x7F000000u)) >> (0x00000018u));
    *readDataEye = (((value) & (0x00FF0000u)) >> (0x00000010u));
    *readDQS     = (((value) & (0x0000FF00u)) >> (0x00000008u));
    *writeInt    = (((value) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetLevelingRampControlInfo
 *
 *   @b Description
 *   @n The function is used to set the incremental leveling ramp control information
 *
 *   @b Arguments
     @verbatim
        enable      - Read-write leveling enable.
        preScalar   - Incremental leveling pre-scalar in number of refresh periods
        readDataEye - Incremental read data eye training interval during ramp window
        readDQS     - Incremental read DQS gate training interval during ramp window
        writeInt    - Incremental write leveling interval during ramp window
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_RDWRLVL_EN,
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_RDWRLVLINC_RMP_PRE,
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_RDLVLINC_RMP_INT,
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_RDLVLGATEINC_RMP_INT,
 *      EMIF4F_RDWR_LVL_RMP_CTRL_REG_WRLVLINC_RMP_INT
 *
 *   @b Example
 *   @verbatim
        Uint8  preScalar;
        Uint8  readDataEye;
        Uint8  readDQS;
        Uint8  writeInt;
        Bool   enable;

        // Get the Leveling Ramp Control Information
        CSL_EMIF4F_GetLevelingRampControlInfo (&enable, &preScalar, &readDataEye, &readDQS, &writeInt);
        ...
        // Set the Leveling Ramp control information.
        CSL_EMIF4F_SetLevelingRampControlInfo(enable, preScalar, readDataEye, readDQS, 0x1);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetLevelingRampControlInfo
(
    Bool   enable,
    Uint8  preScalar,
    Uint8  readDataEye,
    Uint8  readDQS,
    Uint8  writeInt
)
{
    ((CSL_Emif4fRegs*)(0x21000000))->RDWR_LVL_RMP_CTRL = (((enable) << (0x0000001Fu)) & (0x80000000u)) |
                               (((preScalar) << (0x00000018u)) & (0x7F000000u)) |
                               (((readDataEye) << (0x00000010u)) & (0x00FF0000u)) |
                               (((readDQS) << (0x00000008u)) & (0x0000FF00u)) |
                               (((writeInt) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetLevelingControlInfo
 *
 *   @b Description
 *   @n The function is used to get the incremental leveling control information
 *
 *   @b Arguments
     @verbatim
        trigger     - Full leveling trigger
        preScalar   - Incremental leveling pre-scalar in number of refresh periods
        readDataEye - Incremental read data eye training interval
        readDQS     - Incremental read DQS gate training interval
        writeInt    - Incremental write leveling interval
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_RDWR_LVL_CTRL_REG_RDWRLVLFULL_START,
 *      EMIF4F_RDWR_LVL_CTRL_REG_RDWRLVLINC_PRE,
 *      EMIF4F_RDWR_LVL_CTRL_REG_RDLVLINC_INT,
 *      EMIF4F_RDWR_LVL_CTRL_REG_RDLVLGATEINC_INT,
 *      EMIF4F_RDWR_LVL_CTRL_REG_WRLVLINC_INT
 *
 *   @b Example
 *   @verbatim
        Uint8  trigger;
        Uint8  preScalar;
        Uint8  readDataEye;
        Uint8  readDQS;
        Uint8  writeInt;

        // Get the Leveling Control Information
        CSL_EMIF4F_GetLevelingControlInfo (&trigger, &preScalar, &readDataEye, &readDQS, &writeInt);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetLevelingControlInfo
(
    Uint8*  trigger,
    Uint8*  preScalar,
    Uint8*  readDataEye,
    Uint8*  readDQS,
    Uint8*  writeInt
)
{
    Uint32  value = ((CSL_Emif4fRegs*)(0x21000000))->RDWR_LVL_CTRL;

    *trigger     = (((value) & (0x80000000u)) >> (0x0000001Fu));
    *preScalar   = (((value) & (0x7F000000u)) >> (0x00000018u));
    *readDataEye = (((value) & (0x00FF0000u)) >> (0x00000010u));
    *readDQS     = (((value) & (0x0000FF00u)) >> (0x00000008u));
    *writeInt    = (((value) & (0x000000FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetLevelingControlInfo
 *
 *   @b Description
 *   @n The function is used to set the incremental leveling control information
 *
 *   @b Arguments
     @verbatim
        trigger     - Full leveling trigger
        preScalar   - Incremental leveling pre-scalar in number of refresh periods
        readDataEye - Incremental read data eye training interval
        readDQS     - Incremental read DQS gate training interval
        writeInt    - Incremental write leveling interval
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_RDWR_LVL_CTRL_REG_RDWRLVLFULL_START,
 *      EMIF4F_RDWR_LVL_CTRL_REG_RDWRLVLINC_PRE,
 *      EMIF4F_RDWR_LVL_CTRL_REG_RDLVLINC_INT,
 *      EMIF4F_RDWR_LVL_CTRL_REG_RDLVLGATEINC_INT,
 *      EMIF4F_RDWR_LVL_CTRL_REG_WRLVLINC_INT
 *
 *   @b Example
 *   @verbatim
        Uint8  trigger;
        Uint8  preScalar;
        Uint8  readDataEye;
        Uint8  readDQS;
        Uint8  writeInt;

        // Get the Leveling Control Information
        CSL_EMIF4F_GetLevelingControlInfo (&trigger, &preScalar, &readDataEye, &readDQS, &writeInt);
        ...
        // Set the Leveling Control Information
        CSL_EMIF4F_SetLevelingControlInfo(1, preScalar, readDataEye, readDQS, writeInt);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetLevelingControlInfo
(
    Uint8  trigger,
    Uint8  preScalar,
    Uint8  readDataEye,
    Uint8  readDQS,
    Uint8  writeInt
)
{
    ((CSL_Emif4fRegs*)(0x21000000))->RDWR_LVL_CTRL = (((trigger) << (0x0000001Fu)) & (0x80000000u))    |
                           (((preScalar) << (0x00000018u)) & (0x7F000000u))     |
                           (((readDataEye) << (0x00000010u)) & (0x00FF0000u))     |
                           (((readDQS) << (0x00000008u)) & (0x0000FF00u))     |
                           (((writeInt) << (0x00000000u)) & (0x000000FFu));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPhyControl
 *
 *   @b Description
 *   @n The function is used to get the DDR PHY Control
 *
 *   @b Arguments
     @verbatim
        ddrPHYControl       DDR PHY Control specific info populated by this API
        ddrPHYReadLatency   DDR PHY Read Latency populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_DDR_PHY_CTRL_1_REG_DDR_PHY_CTRL_1, EMIF4F_DDR_PHY_CTRL_1_REG_READ_LATENCY
 *
 *   @b Example
 *   @verbatim
        Uint32 ddrPHYControl;
        Uint8  ddrPHYReadLatency;

        // Get the DDR PHY Control
        CSL_EMIF4F_GetPhyControl (&ddrPHYControl, &ddrPHYReadLatency);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetPhyControl
(
    Uint32* ddrPHYControl,
    Uint8*  ddrPHYReadLatency
)
{
    Uint32 ddrControl = ((CSL_Emif4fRegs*)(0x21000000))->DDR_PHY_CTRL_1;

    /* Extract all the fields from the PHY Control register */
    *ddrPHYControl     = (((ddrControl) & (0xFFFFFFE0u)) >> (0x00000005u));
    *ddrPHYReadLatency = (((ddrControl) & (0x0000001Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetPhyControl
 *
 *   @b Description
 *   @n The function is used to set the DDR PHY Control
 *
 *   @b Arguments
     @verbatim
        ddrPHYControl       DDR PHY Control specific to be configured
        ddrPHYReadLatency   DDR PHY Read Latency to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_DDR_PHY_CTRL_1_REG_DDR_PHY_CTRL_1, EMIF4F_DDR_PHY_CTRL_1_REG_READ_LATENCY
 *
 *   @b Example
 *   @verbatim
        Uint32 ddrPHYControl;
        Uint8  ddrPHYReadLatency;

        // Get the DDR PHY Control
        CSL_EMIF4F_GetPhyControl (&ddrPHYControl, &ddrPHYReadLatency);

        // Set Read Latency as 5 and reconfigure the PHY
        CSL_EMIF4F_SetPhyControl(ddrPHYControl, 5);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetPhyControl
(
    Uint32 ddrPHYControl,
    Uint8  ddrPHYReadLatency
)
{
    Uint32 ddrControl = 0x0;

    /* Initialize the fields in the DDR PHY Control */
    ((ddrControl) = ((ddrControl) & ~(0xFFFFFFE0u)) | (((ddrPHYControl) << (0x00000005u)) & (0xFFFFFFE0u)));
    ((ddrControl) = ((ddrControl) & ~(0x0000001Fu)) | (((ddrPHYReadLatency) << (0x00000000u)) & (0x0000001Fu)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->DDR_PHY_CTRL_1 = ddrControl;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetShadowPhyControl
 *
 *   @b Description
 *   @n The function is used to get the Shadow DDR PHY Control
 *
 *   @b Arguments
     @verbatim
        ddrPHYControl       DDR PHY Control specific info populated by this API
        ddrPHYReadLatency   DDR PHY Read Latency populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_DDR_PHY_CTRL_1_SHDW_REG_DDR_PHY_CTRL_1_SHDW, 
 *      EMIF4F_DDR_PHY_CTRL_1_SHDW_REG_READ_LATENCY_SHDW
 *
 *   @b Example
 *   @verbatim
        Uint32 ddrPHYControl;
        Uint8  ddrPHYReadLatency;

        // Get the DDR PHY Control
        CSL_EMIF4F_GetShadowPhyControl (&ddrPHYControl, &ddrPHYReadLatency);

     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetShadowPhyControl
(
    Uint32* ddrPHYControl,
    Uint8*  ddrPHYReadLatency
)
{
    Uint32 ddrControl = ((CSL_Emif4fRegs*)(0x21000000))->DDR_PHY_CTRL_1_SHDW;

    /* Extract all the fields from the PHY Control register */
    *ddrPHYControl     = (((ddrControl) & (0xFFFFFFE0u)) >> (0x00000005u));
    *ddrPHYReadLatency = (((ddrControl) & (0x0000001Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetShadowPhyControl
 *
 *   @b Description
 *   @n The function is used to set the Shadow DDR PHY Control
 *
 *   @b Arguments
     @verbatim
        ddrPHYControl       DDR PHY Control specific to be configured
        ddrPHYReadLatency   DDR PHY Read Latency to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_DDR_PHY_CTRL_1_SHDW_REG_DDR_PHY_CTRL_1_SHDW, 
 *      EMIF4F_DDR_PHY_CTRL_1_SHDW_REG_READ_LATENCY_SHDW
 *
 *   @b Example
 *   @verbatim
        Uint32 ddrPHYControl;
        Uint8  ddrPHYReadLatency;

        // Get the DDR PHY Control
        CSL_EMIF4F_GetShadowPhyControl (&ddrPHYControl, &ddrPHYReadLatency);

        // Set Read Latency as 5 and reconfigure the PHY
        CSL_EMIF4F_SetShadowPhyControl(ddrPHYControl, 5);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetShadowPhyControl
(
    Uint32 ddrPHYControl,
    Uint8  ddrPHYReadLatency
)
{
    Uint32 ddrControl = 0x0;

    /* Initialize the fields in the DDR PHY Control */
    ((ddrControl) = ((ddrControl) & ~(0xFFFFFFE0u)) | (((ddrPHYControl) << (0x00000005u)) & (0xFFFFFFE0u)));
    ((ddrControl) = ((ddrControl) & ~(0x0000001Fu)) | (((ddrPHYReadLatency) << (0x00000000u)) & (0x0000001Fu)));

    /* Initialize the register */
    ((CSL_Emif4fRegs*)(0x21000000))->DDR_PHY_CTRL_1_SHDW = ddrControl;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPhyControl2
 *
 *   @b Description
 *   @n The function is used to read the DDR PHY Control2 register. This is
 *      PHY specific
 *
 *   @b Arguments
     @verbatim
        ddrPHYControl       DDR PHY Control configuration populated by this API
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_DDR_PHY_CTRL_2
 *
 *   @b Example
 *   @verbatim
        Uint32 ddrPHYControl;

        // Get the DDR PHY Control
        CSL_EMIF4F_GetPhyControl2 (&ddrPHYControl);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetPhyControl2(Uint32* ddrPHYControl)
{
    *ddrPHYControl = ((CSL_Emif4fRegs*)(0x21000000))->DDR_PHY_CTRL_2;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetPhyControl2
 *
 *   @b Description
 *   @n The function is used to write the DDR PHY Control2 register. This is
 *      PHY specific
 *
 *   @b Arguments
     @verbatim
        ddrPHYControl       DDR PHY Control configuration to be configured
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_DDR_PHY_CTRL_2
 *
 *   @b Example
 *   @verbatim
 
        // Set the DDR PHY Control2 configuration
        CSL_EMIF4F_SetPhyControl2 (0x10);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetPhyControl2(Uint32 ddrPHYControl)
{
    ((CSL_Emif4fRegs*)(0x21000000))->DDR_PHY_CTRL_2 = ddrPHYControl;
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetPriorityToCOSMapping
 *
 *   @b Description
 *   @n The function is used to get the priority to class of service mapping.
 *
 *   @b Arguments
     @verbatim
        ptrPriCosMapper       Priority to COS Mapping configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_PRI_COS_MAP_REG_PRI_COS_MAP_EN, EMIF4F_PRI_COS_MAP_REG_PRI_7_COS,
 *      EMIF4F_PRI_COS_MAP_REG_PRI_5_COS, EMIF4F_PRI_COS_MAP_REG_PRI_4_COS,
 *      EMIF4F_PRI_COS_MAP_REG_PRI_3_COS, EMIF4F_PRI_COS_MAP_REG_PRI_2_COS,
 *      EMIF4F_PRI_COS_MAP_REG_PRI_1_COS, EMIF4F_PRI_COS_MAP_REG_PRI_0_COS     
 *
 *   @b Example
 *   @verbatim
        EMIF4_PRI_COS_MAPPING priCosMapper;

        // Get the Priority to COS Mapper information
        CSL_EMIF4F_GetPriorityToCOSMapping (&priCosMapper);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetPriorityToCOSMapping(EMIF4_PRI_COS_MAPPING* ptrPriCosMapper)
{
    Uint32 value = ((CSL_Emif4fRegs*)(0x21000000))->PRI_COS_MAP;

    ptrPriCosMapper->enable  = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrPriCosMapper->pri7cos = (((value) & (0x0000C000u)) >> (0x0000000Eu));
    ptrPriCosMapper->pri6cos = (((value) & (0x00003000u)) >> (0x0000000Cu));
    ptrPriCosMapper->pri5cos = (((value) & (0x00000C00u)) >> (0x0000000Au));
    ptrPriCosMapper->pri4cos = (((value) & (0x00000300u)) >> (0x00000008u));
    ptrPriCosMapper->pri3cos = (((value) & (0x000000C0u)) >> (0x00000006u));
    ptrPriCosMapper->pri2cos = (((value) & (0x00000030u)) >> (0x00000004u));
    ptrPriCosMapper->pri1cos = (((value) & (0x0000000Cu)) >> (0x00000002u));
    ptrPriCosMapper->pri0cos = (((value) & (0x00000003u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetPriorityToCOSMapping
 *
 *   @b Description
 *   @n The function is used to set the priority to class of service mapping.
 *
 *   @b Arguments
     @verbatim
        ptrPriCosMapper       Priority to COS Mapping configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_PRI_COS_MAP_REG_PRI_COS_MAP_EN, EMIF4F_PRI_COS_MAP_REG_PRI_7_COS,
 *      EMIF4F_PRI_COS_MAP_REG_PRI_5_COS, EMIF4F_PRI_COS_MAP_REG_PRI_4_COS,
 *      EMIF4F_PRI_COS_MAP_REG_PRI_3_COS, EMIF4F_PRI_COS_MAP_REG_PRI_2_COS,
 *      EMIF4F_PRI_COS_MAP_REG_PRI_1_COS, EMIF4F_PRI_COS_MAP_REG_PRI_0_COS     
 *
 *   @b Example
 *   @verbatim
        EMIF4_PRI_COS_MAPPING priCosMapper;

        // Get the Priority to COS Mapper information
        CSL_EMIF4F_GetPriorityToCOSMapping (&priCosMapper);
        ...
        // Configure the mapper to allow priority to COS mapping 
        priCosMapper.enable = 1;
        CSL_EMIF4F_SetPriorityToCOSMapping (&priCosMapper);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetPriorityToCOSMapping(EMIF4_PRI_COS_MAPPING* ptrPriCosMapper)
{
    ((CSL_Emif4fRegs*)(0x21000000))->PRI_COS_MAP = 
        (((ptrPriCosMapper->enable) << (0x0000001Fu)) & (0x80000000u))  |
        (((ptrPriCosMapper->pri7cos) << (0x0000000Eu)) & (0x0000C000u))      |
        (((ptrPriCosMapper->pri6cos) << (0x0000000Cu)) & (0x00003000u))      |
        (((ptrPriCosMapper->pri5cos) << (0x0000000Au)) & (0x00000C00u))      |
        (((ptrPriCosMapper->pri4cos) << (0x00000008u)) & (0x00000300u))      |
        (((ptrPriCosMapper->pri3cos) << (0x00000006u)) & (0x000000C0u))      |
        (((ptrPriCosMapper->pri2cos) << (0x00000004u)) & (0x00000030u))      |
        (((ptrPriCosMapper->pri1cos) << (0x00000002u)) & (0x0000000Cu))      |
        (((ptrPriCosMapper->pri0cos) << (0x00000000u)) & (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetMstIDToCos1Mapping
 *
 *   @b Description
 *   @n The function is used to get the master id to Class of Service 1 mapping
 *
 *   @b Arguments
     @verbatim
        ptrMstIDCosMapper       Master ID to COS Mapping configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_MSTID_COS_1_MAP_REG_MSTID_COS_1_MAP_EN, EMIF4F_MSTID_COS_1_MAP_REG_MSTID_1_COS_1,
 *      EMIF4F_MSTID_COS_1_MAP_REG_MSK_1_COS_1, EMIF4F_MSTID_COS_1_MAP_REG_MSTID_2_COS_1,
 *      EMIF4F_MSTID_COS_1_MAP_REG_MSK_2_COS_1, EMIF4F_MSTID_COS_1_MAP_REG_MSTID_3_COS_1,
 *      EMIF4F_MSTID_COS_1_MAP_REG_MSK_3_COS_1
 *
 *   @b Example
 *   @verbatim
        EMIF4_MSTID_COS_MAPPING mstIDCosMapper;

        // Get the Master ID to COS1 Mapper information
        CSL_EMIF4F_GetMstIDToCos1Mapping (&mstIDCosMapper);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetMstIDToCos1Mapping(EMIF4_MSTID_COS_MAPPING* ptrMstIDCosMapper)
{
    Uint32 value = ((CSL_Emif4fRegs*)(0x21000000))->MSTID_COS_1_MAP;

    ptrMstIDCosMapper->enable   = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrMstIDCosMapper->mst1     = (((value) & (0x7F800000u)) >> (0x00000017u));
    ptrMstIDCosMapper->mstMask1 = (((value) & (0x00700000u)) >> (0x00000014u));
    ptrMstIDCosMapper->mst2     = (((value) & (0x000FF000u)) >> (0x0000000Cu));
    ptrMstIDCosMapper->mstMask2 = (((value) & (0x00000C00u)) >> (0x0000000Au));
    ptrMstIDCosMapper->mst3     = (((value) & (0x000003FCu)) >> (0x00000002u));
    ptrMstIDCosMapper->mstMask3 = (((value) & (0x00000003u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetMstIDToCos1Mapping
 *
 *   @b Description
 *   @n The function is used to set the master id to Class of Service 1 mapping
 *
 *   @b Arguments
     @verbatim
        ptrMstIDCosMapper       Master ID to COS Mapping configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_MSTID_COS_1_MAP_REG_MSTID_COS_1_MAP_EN, EMIF4F_MSTID_COS_1_MAP_REG_MSTID_1_COS_1,
 *      EMIF4F_MSTID_COS_1_MAP_REG_MSK_1_COS_1, EMIF4F_MSTID_COS_1_MAP_REG_MSTID_2_COS_1,
 *      EMIF4F_MSTID_COS_1_MAP_REG_MSK_2_COS_1, EMIF4F_MSTID_COS_1_MAP_REG_MSTID_3_COS_1,
 *      EMIF4F_MSTID_COS_1_MAP_REG_MSK_3_COS_1
 *
 *   @b Example
 *   @verbatim
        EMIF4_MSTID_COS_MAPPING mstIDCosMapper;

        // Get the Master ID to COS1 Mapper information
        CSL_EMIF4F_GetMstIDToCos1Mapping (&mstIDCosMapper);
        ...
        // Enable the Master ID to COS1 Mapping
        mstIDCosMapper.enable = 1;
        CSL_EMIF4F_SetMstIDToCos1Mapping (&mstIDCosMapper);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetMstIDToCos1Mapping(EMIF4_MSTID_COS_MAPPING* ptrMstIDCosMapper)
{
    ((CSL_Emif4fRegs*)(0x21000000))->MSTID_COS_1_MAP = 
            (((ptrMstIDCosMapper->enable) << (0x0000001Fu)) & (0x80000000u))  |
            (((ptrMstIDCosMapper->mst1) << (0x00000017u)) & (0x7F800000u))    |
            (((ptrMstIDCosMapper->mstMask1) << (0x00000014u)) & (0x00700000u))|
            (((ptrMstIDCosMapper->mst2) << (0x0000000Cu)) & (0x000FF000u))    |
            (((ptrMstIDCosMapper->mstMask2) << (0x0000000Au)) & (0x00000C00u))|
            (((ptrMstIDCosMapper->mst3) << (0x00000002u)) & (0x000003FCu))    |
            (((ptrMstIDCosMapper->mstMask3) << (0x00000000u)) & (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetMstIDToCos2Mapping
 *
 *   @b Description
 *   @n The function is used to get the master id to Class of Service 2 mapping
 *
 *   @b Arguments
     @verbatim
        ptrMstIDCosMapper       Master ID to COS Mapping configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_MSTID_COS_2_MAP_REG_MSTID_COS_2_MAP_EN, EMIF4F_MSTID_COS_2_MAP_REG_MSTID_1_COS_2,
 *      EMIF4F_MSTID_COS_2_MAP_REG_MSK_1_COS_2, EMIF4F_MSTID_COS_2_MAP_REG_MSTID_2_COS_2,
 *      EMIF4F_MSTID_COS_2_MAP_REG_MSK_2_COS_2, EMIF4F_MSTID_COS_2_MAP_REG_MSTID_3_COS_2,
 *      EMIF4F_MSTID_COS_2_MAP_REG_MSK_3_COS_2
 *
 *   @b Example
 *   @verbatim
        EMIF4_MSTID_COS_MAPPING mstIDCosMapper;

        // Get the Master ID to COS2 Mapper information
        CSL_EMIF4F_GetMstIDToCos2Mapping (&mstIDCosMapper);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetMstIDToCos2Mapping(EMIF4_MSTID_COS_MAPPING* ptrMstIDCosMapper)
{
    Uint32 value = ((CSL_Emif4fRegs*)(0x21000000))->MSTID_COS_2_MAP;

    ptrMstIDCosMapper->enable   = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrMstIDCosMapper->mst1     = (((value) & (0x7F800000u)) >> (0x00000017u));
    ptrMstIDCosMapper->mstMask1 = (((value) & (0x00700000u)) >> (0x00000014u));
    ptrMstIDCosMapper->mst2     = (((value) & (0x000FF000u)) >> (0x0000000Cu));
    ptrMstIDCosMapper->mstMask2 = (((value) & (0x00000C00u)) >> (0x0000000Au));
    ptrMstIDCosMapper->mst3     = (((value) & (0x000003FCu)) >> (0x00000002u));
    ptrMstIDCosMapper->mstMask3 = (((value) & (0x00000003u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetMstIDToCos2Mapping
 *
 *   @b Description
 *   @n The function is used to set the master id to Class of Service 2 mapping
 *
 *   @b Arguments
     @verbatim
        ptrMstIDCosMapper       Master ID to COS Mapping configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_MSTID_COS_2_MAP_REG_MSTID_COS_2_MAP_EN, EMIF4F_MSTID_COS_2_MAP_REG_MSTID_1_COS_2,
 *      EMIF4F_MSTID_COS_2_MAP_REG_MSK_1_COS_2, EMIF4F_MSTID_COS_2_MAP_REG_MSTID_2_COS_2,
 *      EMIF4F_MSTID_COS_2_MAP_REG_MSK_2_COS_2, EMIF4F_MSTID_COS_2_MAP_REG_MSTID_3_COS_2,
 *      EMIF4F_MSTID_COS_2_MAP_REG_MSK_3_COS_2
 *
 *   @b Example
 *   @verbatim
        EMIF4_MSTID_COS_MAPPING mstIDCosMapper;

        // Get the Master ID to COS2 Mapper information
        CSL_EMIF4F_GetMstIDToCos2Mapping (&mstIDCosMapper);
        ...
        // Enable the Master ID to COS2 Mapping
        mstIDCosMapper.enable = 1;
        CSL_EMIF4F_SetMstIDToCos2Mapping (&mstIDCosMapper);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetMstIDToCos2Mapping(EMIF4_MSTID_COS_MAPPING* ptrMstIDCosMapper)
{
    ((CSL_Emif4fRegs*)(0x21000000))->MSTID_COS_2_MAP = 
            (((ptrMstIDCosMapper->enable) << (0x0000001Fu)) & (0x80000000u))  |
            (((ptrMstIDCosMapper->mst1) << (0x00000017u)) & (0x7F800000u))    |
            (((ptrMstIDCosMapper->mstMask1) << (0x00000014u)) & (0x00700000u))|
            (((ptrMstIDCosMapper->mst2) << (0x0000000Cu)) & (0x000FF000u))    |
            (((ptrMstIDCosMapper->mstMask2) << (0x0000000Au)) & (0x00000C00u))|
            (((ptrMstIDCosMapper->mst3) << (0x00000002u)) & (0x000003FCu))    |
            (((ptrMstIDCosMapper->mstMask3) << (0x00000000u)) & (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetECCControl
 *
 *   @b Description
 *   @n The function is used to get the ECC Control Information
 *
 *   @b Arguments
     @verbatim
        ptrECCControl       ECC Control Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_ECC_CTRL_REG_ECC_EN, EMIF4F_ECC_CTRL_REG_ECC_ADDR_RNG_PROT,
 *      EMIF4F_ECC_CTRL_REG_ECC_ADDR_RNG_2_EN, EMIF4F_ECC_CTRL_REG_ECC_ADDR_RNG_1_EN
 *
 *   @b Example
 *   @verbatim
        EMIF4_ECC_CONTROL eccControl;

        // Get the ECC Control Configuration
        CSL_EMIF4F_GetECCControl (&eccControl);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetECCControl(EMIF4_ECC_CONTROL* ptrECCControl)
{
    Uint32 value = ((CSL_Emif4fRegs*)(0x21000000))->ECC_CTRL;

    ptrECCControl->enable       = (((value) & (0x80000000u)) >> (0x0000001Fu));
    ptrECCControl->addrRngProt  = (((value) & (0x40000000u)) >> (0x0000001Eu));
    ptrECCControl->addrRng2En   = (((value) & (0x00000002u)) >> (0x00000001u));
    ptrECCControl->addrRng1En   = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetECCControl
 *
 *   @b Description
 *   @n The function is used to set the ECC Control Information
 *
 *   @b Arguments
     @verbatim
        ptrECCControl       ECC Control Configuration
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_ECC_CTRL_REG_ECC_EN, EMIF4F_ECC_CTRL_REG_ECC_ADDR_RNG_PROT,
 *      EMIF4F_ECC_CTRL_REG_ECC_ADDR_RNG_2_EN, EMIF4F_ECC_CTRL_REG_ECC_ADDR_RNG_1_EN
 *
 *   @b Example
 *   @verbatim
        EMIF4_ECC_CONTROL eccControl;

        // Get the ECC Control Configuration
        CSL_EMIF4F_GetECCControl (&eccControl);
        ..
        // Enable ECC 
        eccControl.enable = 1;
        CSL_EMIF4F_SetECCControl (&eccControl);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetECCControl(EMIF4_ECC_CONTROL* ptrECCControl)
{
    ((CSL_Emif4fRegs*)(0x21000000))->ECC_CTRL = 
        (((ptrECCControl->enable) << (0x0000001Fu)) & (0x80000000u))      |
        (((ptrECCControl->addrRngProt) << (0x0000001Eu)) & (0x40000000u)) |
        (((ptrECCControl->addrRng2En) << (0x00000001u)) & (0x00000002u))  |
        (((ptrECCControl->addrRng1En) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetECCAddressRange
 *
 *   @b Description
 *   @n The function is used to get the ECC Address Range
 *
 *   @b Arguments
     @verbatim
        range           Address Range for which start and end address are required
        endAddr         End Address
        startAddr       Start Address
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_ECC_ADDR_RNG_1_REG_ECC_END_ADDR_1, EMIF4F_ECC_ADDR_RNG_1_REG_ECC_STRT_ADDR_1;
 *      EMIF4F_ECC_ADDR_RNG_2_REG_ECC_END_ADDR_2, EMIF4F_ECC_ADDR_RNG_2_REG_ECC_STRT_ADDR_2
 *
 *   @b Example
 *   @verbatim
        Uint16  endAddr;
        Uint16  startAddr;

        // Get the ECC Address Range1
        CSL_EMIF4F_GetECCAddressRange (1, &endAddr, &startAddr);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetECCAddressRange(Uint8 range, Uint16* endAddr, Uint16* startAddr)
{
    Uint32 value;

    if (range == 1)
    {
        value = ((CSL_Emif4fRegs*)(0x21000000))->ECC_ADDR_RNG_1;
        *endAddr    = (((value) & (0xFFFF0000u)) >> (0x00000010u));
        *startAddr  = (((value) & (0x0000FFFFu)) >> (0x00000000u));
    }
    else if (range == 2)
    {
        value = ((CSL_Emif4fRegs*)(0x21000000))->ECC_ADDR_RNG_2;
        *endAddr    = (((value) & (0xFFFF0000u)) >> (0x00000010u));
        *startAddr  = (((value) & (0x0000FFFFu)) >> (0x00000000u));
    }
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetECCAddressRange
 *
 *   @b Description
 *   @n The function is used to set the ECC Address Range
 *
 *   @b Arguments
     @verbatim
        range           Address Range for which start and end address are required
        endAddr         End Address
        startAddr       Start Address
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_ECC_ADDR_RNG_1_REG_ECC_END_ADDR_1, EMIF4F_ECC_ADDR_RNG_1_REG_ECC_STRT_ADDR_1;
 *      EMIF4F_ECC_ADDR_RNG_2_REG_ECC_END_ADDR_2, EMIF4F_ECC_ADDR_RNG_2_REG_ECC_STRT_ADDR_2
 *
 *   @b Example
 *   @verbatim
        Uint16  endAddr;
        Uint16  startAddr;

        // Set the ECC Address Range1
        CSL_EMIF4F_SetECCAddressRange (1, 0x100, 0x0);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetECCAddressRange(Uint8 range, Uint16 endAddr, Uint16 startAddr)
{
    if (range == 1)
    {
        ((CSL_Emif4fRegs*)(0x21000000))->ECC_ADDR_RNG_1 = 
            (((endAddr) << (0x00000010u)) & (0xFFFF0000u)) |
            (((startAddr) << (0x00000000u)) & (0x0000FFFFu));
    }
    else if (range == 2)
    {
        ((CSL_Emif4fRegs*)(0x21000000))->ECC_ADDR_RNG_2 = 
            (((endAddr) << (0x00000010u)) & (0xFFFF0000u)) |
            (((startAddr) << (0x00000000u)) & (0x0000FFFFu));
    }
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_GetReadWriteThreshold
 *
 *   @b Description
 *   @n The function is used to get the Read, Write Execution Thresholds
 *
 *   @b Arguments
     @verbatim
        wrThreshold       Write Threshold
        rdThreshold       Read  Threshold
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *      EMIF4F_RD_WR_EXEC_THRSH_REG_WR_THRSH, EMIF4F_RD_WR_EXEC_THRSH_REG_RD_THRSH
 *
 *   @b Example
 *   @verbatim
        Uint8   wrThreshold;
        Uint8   rdThreshold;

        // Get the Read, Write Execution Thresholds.
        CSL_EMIF4F_GetReadWriteThreshold (&wrThreshold, &rdThreshold);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_GetReadWriteThreshold(Uint8* wrThreshold, Uint8* rdThreshold)
{
    Uint32 value = ((CSL_Emif4fRegs*)(0x21000000))->RD_WR_EXEC_THRSH;

    *wrThreshold = (((value) & (0x00001F00u)) >> (0x00000008u));
    *rdThreshold = (((value) & (0x0000001Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_EMIF4F_SetReadWriteThreshold
 *
 *   @b Description
 *   @n The function is used to set the Read, Write Execution Thresholds
 *
 *   @b Arguments
     @verbatim
        wrThreshold       Write Threshold
        rdThreshold       Read  Threshold
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n None
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *      EMIF4F_RD_WR_EXEC_THRSH_REG_WR_THRSH, EMIF4F_RD_WR_EXEC_THRSH_REG_RD_THRSH
 *
 *   @b Example
 *   @verbatim

        // Get the Read, Write Execution Thresholds.
        CSL_EMIF4F_SetReadWriteThreshold (1, 2);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_EMIF4F_SetReadWriteThreshold(Uint8 wrThreshold, Uint8 rdThreshold)
{
    ((CSL_Emif4fRegs*)(0x21000000))->RD_WR_EXEC_THRSH = 
        (((wrThreshold) << (0x00000008u)) & (0x00001F00u)) |
        (((rdThreshold) << (0x00000000u)) & (0x0000001Fu));
}




/* @} */







/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/

/******************************************************************************	
 *
 * File	Name:	evmc66x_fpga.h
 *
 * Description:	This is	the header file	for FPGA interface
 *
 ******************************************************************************/


/************************
 * Defines and Macros
 ************************/

/* ------------------------------------------------------------------------ *
 *  FPGA Error Status                                                       *
 * ------------------------------------------------------------------------ */



/* FPGA Configuration Register offsets */

// Macros for errors

/************************
 * Structures and Enums
 ************************/
typedef	enum _FPGA_LedStatus
{
    FPGA_LED_OFF = 0,
    FPGA_LED_ON	= 1
}FPGA_LedStatus;

typedef	enum _FPGA_UserLed
{
    FPGA_USER_LED0 = 0,
    FPGA_USER_LED1 = 1,
    FPGA_USER_LED2 = 2,
    FPGA_USER_LED3 = 3    
}FPGA_UserLed;

/************************
 * Function declarations
 ************************/
uint32_t getBoardVersion(void);
uint32_t getFpgaDevID(void);
uint32_t fpgaGetAMCDetect(void);
void fpgaEnableNandWriteProtect(void);
void fpgaDisableNandWriteProtect(void);
void fpgaEnableNorWriteProtect(void);
void fpgaDisableNorWriteProtect(void);
void fpgaEnableEepromWriteProtect(void);
void fpgaDisableEepromWriteProtect(void);
void fpgaControlUserLEDs(FPGA_UserLed uchUserLEDNum, 
						 FPGA_LedStatus uchStatus);
uint32_t fpgaGetUserSwitch(uint32_t	uiSwitchNum);
uint32_t fpgaWriteConfigurationRegister(uint8_t uchAddress,
										uint8_t uchValue);
uint32_t fpgaReadConfigurationRegister(uint8_t uchAddress,
										uint8_t *puchValue);






/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/

/******************************************************************************	
 *
 * File	Name:	evmc66x_i2c.h
 *
 * Description:	This contains i2c specific structure, typedefs,	function
 *				prototypes.
 *
 *
 ******************************************************************************/

/************************
 * Include Files
 ************************/
/* =============================================================================
 *   Copyright (c) Texas Instruments Incorporated 2002, 2003, 2004, 2005, 2006
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/** ============================================================================
 *   @file  cslr_i2c.h
 *
 *   @path  $(CSLPATH)
 *
 *   @desc  This file contains the Register Desciptions for I2C
 *  ============================================================================
 */



/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 ICOAR;
    volatile Uint32 ICIMR;
    volatile Uint32 ICSTR;
    volatile Uint32 ICCLKL;
    volatile Uint32 ICCLKH;
    volatile Uint32 ICCNT;
    volatile Uint32 ICDRR;
    volatile Uint32 ICSAR;
    volatile Uint32 ICDXR;
    volatile Uint32 ICMDR;
    volatile Uint32 ICIVR;
    volatile Uint32 ICEMDR;
    volatile Uint32 ICPSC;
    volatile Uint32 ICPID1;
    volatile Uint32 ICPID2;
} CSL_I2cRegs;

typedef volatile CSL_I2cRegs             *CSL_I2cRegsOvly;


/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* ICOAR */



/* ICIMR */


/*----AAS Tokens----*/


/*----SCD Tokens----*/


/*----ICXRDY Tokens----*/


/*----ICRRDY Tokens----*/


/*----ARDY Tokens----*/


/*----NACK Tokens----*/


/*----AL Tokens----*/


/* ICSTR */















/* ICCLKL */



/* ICCLKH */



/* ICCNT */



/* ICDRR */



/* ICSAR */



/* ICDXR */



/* ICMDR */















/* ICIVR */



/*----INTCODE Tokens----*/


/* ICEMDR */



/* ICPSC */



/* ICPID1 */




/* ICPID2 */




/************************
 * Defines and Macros
 ************************/
    
    // Interrupt

// I2C prescalar set to 16 to get module freq (1000MHz/6)/17 = 9.8 MHz
// Setting the divider to divide module freq 9.8MHz/((36+6)+(36+6)) = 116.67 KHz

/************************
 * Globals
 ************************/

/************************
 * Function declarations
 ************************/
void evmI2CInit(void);

/**  
 * @file csl_cpsw.h
 *
 * @brief 
 *  Header file for CSL functional layer of 3 Port Ethernet Switch Subsystem.
 *
 *  It contains the various enumerations, structure definitions and function 
 *  declarations
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/** ============================================================================ 
 *
 * @defgroup CSL_CPSW_API CPSW
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * @subsection References
 *    -# Ethernet Media Access Controller User Guide
 * ============================================================================
 */ 
/**  
 * @file  csl_cpsw_3gfssAux.h
 *
 * @brief  
 *  API Auxilary header file for Ethernet switch subsystem CSL. 
 *
 *  Contains the different control command and status query functions definations
 *   
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/**  
 * @file  csl_cpsw_3gfss_s.h
 *
 * @brief  
 *  Header file containing various enumerations, structure definitions and function 
 *  declarations for the Ethernet switch subsystem module of EMAC.
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* Modified by CSL team for:
 *      (1) Header files are included to be RTSC compliant
 */



/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 IDVER_REG;
} CSL_Cpsw_3gfss_sRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* idver_reg */







/** ============================================================================ 
 *
 * @defgroup CSL_CPSW_3GFSS_S_API Ethernet Switch Subsystem Module (CPSW_3GFSS_S)
 * @ingroup CSL_CPSW_API
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * @subsection References
 *    -# Ethernet Media Access Controller User Guide
 * ============================================================================
 */         
/**
@defgroup CSL_CPSW_3GFSS_S_SYMBOL  CPSW_3GFSS_S Symbols Defined
@ingroup CSL_CPSW_3GFSS_S_API
*/
/**
@defgroup CSL_CPSW_3GFSS_S_DATASTRUCT  CPSW_3GFSS_S Data Structures
@ingroup CSL_CPSW_3GFSS_S_API
*/
/**
@defgroup CSL_CPSW_3GFSS_S_FUNCTION  CPSW_3GFSS_S Functions
@ingroup CSL_CPSW_3GFSS_S_API
*/
/**
@defgroup CSL_CPSW_3GFSS_S_ENUM CPSW_3GFSS_S Enumerated Data Types
@ingroup CSL_CPSW_3GFSS_S_API
*/

/**
@addtogroup CSL_CPSW_3GFSS_S_SYMBOL
@{
*/

/**
@}
*/

/** @addtogroup CSL_CPSW_3GFSS_S_DATASTRUCT
 @{ */

/** Constants for passing parameters to the functions.
 */
/** @brief Pointer to the Ethernet Switch Subsystem overlay registers */

/** @brief      
 *
 *  Holds the Ethernet switch subsystem's version info. 
 */        
typedef struct {
	/**  Minor version value */	
	Uint32      minorVer;

	/**  Major version value */	
	Uint32      majorVer;

	/**  RTL version value */	
	Uint32      rtlVer;

	/**  Identification value */	
	Uint32      id;
} CSL_CPSW_3GFSS_VERSION;        
        
/**
@}
*/


/** @addtogroup CSL_CPSW_3GFSS_S_FUNCTION
 @{ */

/**
@}
*/



/**
@}
*/

/** @addtogroup CSL_CPSW_3GFSS_S_FUNCTION
@{ */

/** ============================================================================
 *   @n@b CSL_CPSW_3GFSS_getVersionInfo
 *
 *   @b Description
 *   @n This function retrieves the ethernet switch subsystem version 
 *      information.
 *
 *   @b Arguments
     @verbatim
        versionInfo         CSL_CPSW_3GFSS_VERSION structure that needs to be populated
                            with the version info read from the hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GFSS_S_IDVER_REG_MINOR_VER,
 *      CPSW_3GFSS_S_IDVER_REG_MAJOR_VER,
 *      CPSW_3GFSS_S_IDVER_REG_RTL_VER,
 *      CPSW_3GFSS_S_IDVER_REG_IDENT
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GFSS_VERSION    versionInfo;

        CSL_CPSW_3GFSS_getVersionInfo (&versionInfo);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GFSS_getVersionInfo (
	CSL_CPSW_3GFSS_VERSION* versionInfo     
)
{
    versionInfo->minorVer   =   (((((CSL_Cpsw_3gfss_sRegs *) ((0x02000000) + 0x00090000))->IDVER_REG) & (0x000000FFu)) >> (0x00000000u));
    versionInfo->majorVer   =   (((((CSL_Cpsw_3gfss_sRegs *) ((0x02000000) + 0x00090000))->IDVER_REG) & (0x00000700u)) >> (0x00000008u));
    versionInfo->rtlVer     =   (((((CSL_Cpsw_3gfss_sRegs *) ((0x02000000) + 0x00090000))->IDVER_REG) & (0x0000F800u)) >> (0x0000000Bu));
    versionInfo->id         =   (((((CSL_Cpsw_3gfss_sRegs *) ((0x02000000) + 0x00090000))->IDVER_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;        
}



/**
@}
*/
/**  
 * @file  csl_cpsw_3gfAux.h
 *
 * @brief  
 *  API Auxilary header file for Ethernet switch module CSL. 
 *
 *  Contains the different control command and status query functions definations
 *   
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/**  
 * @file  csl_cpsw_3gf.h
 *
 * @brief  
 *  Header file containing various enumerations, structure definitions and function 
 *  declarations for the Ethernet switch submodule (CPSW_3GF) of EMAC.
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* Modified by CSL team for:
 *      (1) Header files are included to be RTSC compliant
 */



/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for port_info_group
\**************************************************************************/
typedef struct  {
    volatile Uint32 P_MAX_BLKS_REG;
    volatile Uint32 P_BLK_CNT_REG;
    volatile Uint32 P_PORT_VLAN_REG;
    volatile Uint32 P_TX_PRI_MAP_REG;
    volatile Uint32 SL_SA_LO_REG;
    volatile Uint32 SL_SA_HI_REG;
    volatile Uint32 P_TS_CTL_REG;
    volatile Uint32 P_TS_SEQ_LTYPE_REG;
    volatile Uint32 P_TS_VLAN_LTYPE_REG;
    volatile Uint8  RSVD2[12];
} CSL_Cpsw_3gfPort_info_groupRegs;

/*************************************************************************** Register Overlay Structure for port_stats_group
\**************************************************************************/
typedef struct  {
    volatile Uint32 RXGOODFRAMES;
    volatile Uint32 RXBROADCASTFRAMES;
    volatile Uint32 RXMULTICASTFRAMES;
    volatile Uint32 RXPAUSEFRAMES;
    volatile Uint32 RXCRCERRORS;
    volatile Uint32 RXALIGNCODEERRORS;
    volatile Uint32 RXOVERSIZEDFRAMES;
    volatile Uint32 RXJABBERFRAMES;
    volatile Uint32 RXUNDERSIZEDFRAMES;
    volatile Uint32 RXFRAGMENTS;
    volatile Uint8  RSVD0[8];
    volatile Uint32 RXOCTETS;
    volatile Uint32 TXGOODFRAMES;
    volatile Uint32 TXBROADCASTFRAMES;
    volatile Uint32 TXMULTICASTFRAMES;
    volatile Uint32 TXPAUSEFRAMES;
    volatile Uint32 TXDEFERREDFRAMES;
    volatile Uint32 TXCOLLISIONFRAMES;
    volatile Uint32 TXSINGLECOLLFRAMES;
    volatile Uint32 TXMULTCOLLFRAMES;
    volatile Uint32 TXEXCESSIVECOLLISIONS;
    volatile Uint32 TXLATECOLLISIONS;
    volatile Uint32 TXUNDERRUN;
    volatile Uint32 TXCARRIERSENSEERRORS;
    volatile Uint32 TXOCTETS;
    volatile Uint32 OCTETFRAMES64;
    volatile Uint32 OCTETFRAMES65T127;
    volatile Uint32 OCTETFRAMES128T255;
    volatile Uint32 OCTETFRAMES256T511;
    volatile Uint32 OCTETFRAMES512T1023;
    volatile Uint32 OCTETFRAMES1024TUP;
    volatile Uint32 NETOCTETS;
    volatile Uint32 RXSOFOVERRUNS;
    volatile Uint32 RXMOFOVERRUNS;
    volatile Uint32 RXDMAOVERRUNS;
    volatile Uint8  RSVD4[112];
} CSL_Cpsw_3gfPort_stats_groupRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 CPSW_ID_VER_REG;
    volatile Uint32 CPSW_CONTROL_REG;
    volatile Uint32 EM_CONTROL_REG;
    volatile Uint32 STAT_PORT_EN_REG;
    volatile Uint32 PTYPE_REG;
    volatile Uint8  RSVD0[8];
    volatile Uint32 GAP_THRESH_CPGMAC_SL_REG;
    volatile Uint32 TX_START_WDS_REG;
    volatile Uint32 FLOW_CONTROL_REG;
    volatile Uint8  RSVD1[12];
    volatile Uint32 P0_CPPI_SRC_ID_REG;
    volatile Uint32 P0_PORT_VLAN_REG;
    volatile Uint32 P0_RX_PRI_MAP_REG;
    volatile Uint32 RX_MAXLEN_REG;
    volatile Uint8  RSVD3[28];
    CSL_Cpsw_3gfPort_info_groupRegs PORT_INFO_GROUP[2];
    volatile Uint8  RSVD5[576];
    CSL_Cpsw_3gfPort_stats_groupRegs PORT_STATS_GROUP[2];
    volatile Uint8  RSVD6[256];
    volatile Uint32 ALE_ID_REG;
    volatile Uint8  RSVD7[4];
    volatile Uint32 ALE_CONTROL_REG;
    volatile Uint8  RSVD8[4];
    volatile Uint32 ALE_PRESCALE_REG;
    volatile Uint8  RSVD9[4];
    volatile Uint32 ALE_UNKNOWN_VLAN_REG;
    volatile Uint8  RSVD10[4];
    volatile Uint32 ALE_TABLE_CONTROL_REG;
    volatile Uint8  RSVD11[16];
    volatile Uint32 ALE_TABLE_WORD2_REG;
    volatile Uint32 ALE_TABLE_WORD1_REG;
    volatile Uint32 ALE_TABLE_WORD0_REG;
    volatile Uint32 ALE_PORT_CONTROL_REG[3];
    volatile Uint8  RSVD12[12];
} CSL_Cpsw_3gfRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* p_max_blks_reg */




/* p_blk_cnt_reg */




/* p_port_vlan_reg */





/* p_tx_pri_map_reg */










/* sl_sa_lo_reg */




/* sl_sa_hi_reg */






/* p_ts_ctl_reg */











/* p_ts_seq_ltype_reg */




/* p_ts_vlan_ltype_reg */




/* RxGoodFrames */



/* RxBroadcastFrames */



/* RxMulticastFrames */



/* RxPauseFrames */



/* RxCRCErrors */



/* RxAlignCodeErrors */



/* RxOversizedFrames */



/* RxJabberFrames */



/* RxUndersizedFrames */



/* RxFragments */



/* RxOctets */



/* TxGoodFrames */



/* TxBroadcastFrames */



/* TxMulticastFrames */



/* TxPauseFrames */



/* TxDeferredFrames */



/* TxCollisionFrames */



/* TxSingleCollFrames */



/* TxMultCollFrames */



/* TxExcessiveCollisions */



/* TxLateCollisions */



/* TxUnderrun */



/* TxCarrierSenseErrors */



/* TxOctets */



/* 64octetFrames */



/* 65t127octetFrames */



/* 128t255octetFrames */



/* 256t511octetFrames */



/* 512t1023octetFrames */



/* 1024tUPoctetFrames */



/* NetOctets */



/* RxSofOverruns */



/* RxMofOverruns */



/* RxDmaOverruns */



/* cpsw_id_ver_reg */






/* cpsw_control_reg */








/* em_control_reg */




/* stat_port_en_reg */






/* ptype_reg */






/* gap_thresh_cpgmac_sl_reg */



/* tx_start_wds_reg */



/* flow_control_reg */





/* p0_cppi_src_id_reg */




/* p0_port_vlan_reg */





/* p0_rx_pri_map_reg */










/* rx_maxlen_reg */



/* ale_id_reg */





/* ale_control_reg */













/* ale_prescale_reg */



/* ale_unknown_vlan_reg */






/* ale_table_control_reg */




/* ale_table_word2_reg */



/* ale_table_word1_reg */



/* ale_table_word0_reg */



/* ale_port_control_reg0 */









/** ============================================================================ 
 *
 * @defgroup CSL_CPSW_3GF_API Ethernet switch submodule (CPSW_3GF)
 * @ingroup CSL_CPSW_API
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * @subsection References
 *    -# Ethernet Media Access Controller User Guide
 * ============================================================================
 */         
/**
@defgroup CSL_CPSW_3GF_SYMBOL  CPSW_3GF Symbols Defined
@ingroup CSL_CPSW_3GF_API
*/
/**
@defgroup CSL_CPSW_3GF_DATASTRUCT  CPSW_3GF Data Structures
@ingroup CSL_CPSW_3GF_API
*/
/**
@defgroup CSL_CPSW_3GF_FUNCTION  CPSW_3GF Functions
@ingroup CSL_CPSW_3GF_API
*/
/**
@defgroup CSL_CPSW_3GF_ENUM CPSW_3GF Enumerated Data Types
@ingroup CSL_CPSW_3GF_API
*/

/**
@addtogroup CSL_CPSW_3GF_SYMBOL
@{
*/

/**
@}
*/

/** @addtogroup CSL_CPSW_3GF_DATASTRUCT
 @{ */

/** Constants for passing parameters to the functions.
 */
/** @brief Pointer to the Ethernet Switch overlay registers */

/** @brief Number of statistic blocks. 
 *
 *  EMAC has two sub-blocks: STATSA and STATSB.
 *
 *  STATSA holds statistics for Host/CPU port (Switch port 0).
 *  STATSB holds statistics for MAC ports (Switch ports 1, 2).
 */

/** @brief Number of hardware statistics registers */

/** @brief Maximum number of ALE entries that can be programmed */

/** @brief ALE control register configuration definitions */       

/**  Enable Broadcast/Multicast rate limit */	

/**  MAC auhorization mode enable */	

/**  VLAN Aware Mode enable */	

/**  Tx rate limit enable */	

/**  OUI deny enable */	

/**  VID0 mode enable */	

/**  Learn no VID enable */	

/**  Age out now enable */	

/**  Clear table enable */	

/**  ALE enable */	

/** @brief Port Mask definitions */       

/**  Port 0 Enable */	

/**  Port 1 Enable */	

/**  Port 2 Enable */	
        

/** @brief      
 *
 *  Holds the Time sync submodule's version info. 
 */        
typedef struct {
	/**  Minor version value */	
	Uint32      minorVer;

	/**  Major version value */	
	Uint32      majorVer;

	/**  RTL version value */	
	Uint32      rtlVer;

	/**  Identification value */	
	Uint32      id;
} CSL_CPSW_3GF_VERSION;        

/** @brief      
 *
 *  Holds CPSW control register contents. 
 */        
typedef struct {
	/**  FIFO loopback mode */	
	Uint32      fifoLb;

	/**  Vlan aware mode */	
	Uint32      vlanAware;

	/** Port 0 Enable */	
	Uint32      p0Enable;

	/**  Port 0 Pass Priority Tagged */	
	Uint32      p0PassPriTag;

	/**  Port 1 Pass Priority Tagged */	
	Uint32      p1PassPriTag;

	/**  Port 2 Pass Priority Tagged */	
	Uint32      p2PassPriTag;
} CSL_CPSW_3GF_CONTROL;

/** @brief      
 *
 *  Holds Port Statistics Enable register contents. 
 */        
typedef struct {
	/**  Port 0 Statistics A Enable bit */	
	Uint32      p0AStatEnable;

	/**  Port 0 Statistics B Enable bit */	
	Uint32      p0BStatEnable;

	/**  Port 1 Statistics Enable bit */	
	Uint32      p1StatEnable;

	/**  Port 2 Statistics Enable bit */	
	Uint32      p2StatEnable;
} CSL_CPSW_3GF_PORTSTAT;

/** @brief      
 *
 *  Holds Priority type register contents. 
 */        
typedef struct {
	/**  Escalate priority load value */	
	Uint32      escPriLdVal;

	/**  Port 0 Priority type escalate */	
	Uint32      p0PtypeEsc;

	/**  Port 1 Priority type escalate */	
	Uint32      p1PtypeEsc;

	/**  Port 2 Priority type escalate */	
	Uint32      p2PtypeEsc;
} CSL_CPSW_3GF_PTYPE;

/** @brief      
 *
 *  Holds flow control register contents. 
 */        
typedef struct {
	/**  Port 0 flow control enable */	
	Uint32      p0FlowEnable;

	/**  Port 1 flow control enable */	
	Uint32      p1FlowEnable;

	/**  Port 2 flow control enable */	
	Uint32      p2FlowEnable;
} CSL_CPSW_3GF_FLOWCNTL;

/** @brief      
 *
 *  Holds Port Time Sync Control register contents. 
 */        
typedef struct {
	/**  Port Time sync receive enable bit */	
	Uint32      tsRxEnable;

	/**  Port Time sync receive VLAN LTYPE 1 enable bit */	
	Uint32      tsRxVlanLType1Enable;

	/**  Port Time sync receive VLAN LTYPE 2 enable bit */	
	Uint32      tsRxVlanLType2Enable;

	/**  Port Time sync transmit enable bit */	
	Uint32      tsTxEnable;

	/**  Port Time sync transmit VLAN LTYPE 1 enable bit */	
	Uint32      tsTxVlanLType1Enable;

	/**  Port Time sync transmit VLAN LTYPE 2 enable bit */	
	Uint32      tsTxVlanLType2Enable;

	/**  Port Time sync message type enable bit */	
	Uint32      txMsgTypeEnable;
} CSL_CPSW_3GF_TSCNTL;

/** @brief      
 *  
 *  Holds the EMAC statistics.
 *
 *  The statistics structure is the used to retrieve the current count
 *  of various packet events in the system. These values represent the
 *  delta values from the last time the statistics were read.
 */
typedef struct {
    /** Good Frames Received                      */        
    Uint32      RxGoodFrames;     

    /** Good Broadcast Frames Received            */
    Uint32      RxBCastFrames;    

    /** Good Multicast Frames Received            */
    Uint32      RxMCastFrames;    

    /** PauseRx Frames Received                   */
    Uint32      RxPauseFrames;    

    /** Frames Received with CRC Errors           */
    Uint32      RxCRCErrors;      

    /** Frames Received with Alignment/Code Errors*/
    Uint32      RxAlignCodeErrors;

    /** Oversized Frames Received                 */
    Uint32      RxOversized;      

    /** Jabber Frames Received                    */
    Uint32      RxJabber;         

    /** Undersized Frames Received                */
    Uint32      RxUndersized;     

    /** Rx Frame Fragments Received               */
    Uint32      RxFragments;      

    /** Reserved       */
    Uint32      reserved;         

    /** Reserved */
    Uint32      reserved2;      

    /** Total Received Bytes in Good Frames       */
    Uint32      RxOctets;         

    /** Good Frames Sent                          */
    Uint32      TxGoodFrames;     
    
    /** Good Broadcast Frames Sent                */
    Uint32      TxBCastFrames;    

    /** Good Multicast Frames Sent                */
    Uint32      TxMCastFrames;    

    /** PauseTx Frames Sent                       */
    Uint32      TxPauseFrames;    

    /** Frames Where Transmission was Deferred    */
    Uint32      TxDeferred;       

    /** Total Frames Sent With Collision          */
    Uint32      TxCollision;      

    /** Frames Sent with Exactly One Collision    */
    Uint32      TxSingleColl;     

    /** Frames Sent with Multiple Colisions       */
    Uint32      TxMultiColl;      

    /** Tx Frames Lost Due to Excessive Collisions*/
    Uint32      TxExcessiveColl;  

    /** Tx Frames Lost Due to a Late Collision    */
    Uint32      TxLateColl;       

    /** Tx Frames Lost with Tx Underrun Error     */
    Uint32      TxUnderrun;       

    /** Tx Frames Lost Due to Carrier Sense Loss  */
    Uint32      TxCarrierSLoss;   

    /** Total Transmitted Bytes in Good Frames    */
    Uint32      TxOctets;         

    /** Total Tx&Rx with Octet Size of 64         */
    Uint32      Frame64;          

    /** Total Tx&Rx with Octet Size of 65 to 127  */
    Uint32      Frame65t127;      

    /** Total Tx&Rx with Octet Size of 128 to 255 */
    Uint32      Frame128t255;     

    /** Total Tx&Rx with Octet Size of 256 to 511 */
    Uint32      Frame256t511;     

    /** Total Tx&Rx with Octet Size of 512 to 1023*/
    Uint32      Frame512t1023;    

    /** Total Tx&Rx with Octet Size of >=1024     */
    Uint32      Frame1024tUp;     

    /** Sum of all Octets Tx or Rx on the Network */
    Uint32      NetOctets;        

    /** Total Rx Start of Frame Overruns          */
    Uint32      RxSOFOverruns;    

    /** Total Rx Middle of Frame Overruns         */
    Uint32      RxMOFOverruns;    

    /** Total Rx DMA Overruns                     */
    Uint32      RxDMAOverruns;    
} CSL_CPSW_3GF_STATS;


/** @brief      
 *
 *  Holds the ALE submodule's version info. 
 */        
typedef struct {
	/**  Minor version value */	
	Uint32      minorVer;

	/**  Major version value */	
	Uint32      majorVer;

	/**  Identification value */	
	Uint32      id;
} CSL_CPSW_3GF_ALE_VERSION;

/** @brief      
 *
 *  Defines ALE port states
 */        
typedef enum {
    ALE_PORTSTATE_DISABLED = 0,
    ALE_PORTSTATE_BLOCKED,
    ALE_PORTSTATE_LEARN,
    ALE_PORTSTATE_FORWARD
} CSL_CPSW_3GF_ALE_PORTSTATE;

/** @brief      
 *
 *  Holds the ALE Port control register info. 
 */        
typedef struct {
	/**  Port state */	
	CSL_CPSW_3GF_ALE_PORTSTATE  portState;

	/**  Drop non-VLAN tagged ingress packets?  */	
	Uint32                      dropUntaggedEnable;

	/**  VLAN ID Ingress check enable */	
	Uint32                      vidIngressCheckEnable;

	/**  No learn mode enable */	
	Uint32                      noLearnModeEnable;

	/**  Multicast packet rate limit */	
	Uint32                      mcastLimit;

	/**  Broadcast packet rate limit */	
	Uint32                      bcastLimit;
} CSL_CPSW_3GF_ALE_PORTCONTROL;

/** @brief      
 *
 *  Defines ALE Table Entry types
 */        
typedef enum {
    ALE_ENTRYTYPE_FREE = 0,
    ALE_ENTRYTYPE_ADDRESS,
    ALE_ENTRYTYPE_VLAN,
    ALE_ENTRYTYPE_VLANADDRESS
} CSL_CPSW_3GF_ALE_ENTRYTYPE;

/** @brief      
 *
 *  Defines ALE Unicast types
 */        
typedef enum {
    ALE_UCASTTYPE_UCAST_NOAGE = 0,
    ALE_UCASTTYPE_UCAST_AGENOTOUCH,
    ALE_UCASTTYPE_UCAST_OUI,
    ALE_UCASTTYPE_UCAST_AGETOUCH
} CSL_CPSW_3GF_ALE_UCASTTYPE;

/** @brief      
 *
 *  Defines ALE Address types
 */        
typedef enum {
    ALE_ADDRTYPE_UCAST = 0,
    ALE_ADDRTYPE_MCAST,
    ALE_ADDRTYPE_OUI
} CSL_CPSW_3GF_ALE_ADDRTYPE;

/** @brief      
 *
 *  Holds the ALE Multicast Address Table entry
 *  configuration.
 */        
typedef struct {
	/**  Multicast address */	
	Uint8                       macAddress [6];

	/**  Multicast forward state  */	
	Uint32                      mcastFwdState;

	/**  Supervisory bit enable? */	
	Uint32                      superEnable;

	/**  Port Mask. */	
	Uint32                      portMask;
} CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY;

/** @brief      
 *
 *  Holds the ALE VLAN/Multicast Address Table entry
 *  configuration.
 */        
typedef struct {
	/**  Multicast address */	
	Uint8                       macAddress [6];

	/**  VLAN Id  */	
	Uint32                      vlanId;

	/**  Multicast forward state  */	
	Uint32                      mcastFwdState;

	/**  Supervisory bit enable? */	
	Uint32                      superEnable;

	/**  Port Mask. */	
	Uint32                      portMask;
} CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY;

/** @brief      
 *
 *  Holds the ALE Unicast Address Table entry
 *  configuration.
 */        
typedef struct {
	/**  Unicast address */	
	Uint8                       macAddress [6];

	/**  Unicast type  */	
	CSL_CPSW_3GF_ALE_UCASTTYPE  ucastType;

	/**  Secure bit enable?  */	
	Uint32                      secureEnable;

	/**  Block bit enable? */	
	Uint32                      blockEnable;

	/**  Port Number to forward matching packets to. */	
	Uint32                      portNumber;
} CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY;

/** @brief      
 *
 *  Holds the ALE OUI Unicast Address Table entry
 *  configuration.
 */        
typedef struct {
	/**  OUI Unicast address */	
	Uint8                       ouiAddress [3];

	/**  Unicast type  */	
	CSL_CPSW_3GF_ALE_UCASTTYPE  ucastType;
} CSL_CPSW_3GF_ALE_OUIADDR_ENTRY;

/** @brief      
 *
 *  Holds the ALE VLAN Unicast Address Table entry
 *  configuration.
 */        
typedef struct {
	/**  Unicast address */	
	Uint8                       macAddress [6];

	/**  VLAN Id  */	
	Uint32                      vlanId;

	/**  Unicast type  */	
	CSL_CPSW_3GF_ALE_UCASTTYPE  ucastType;

	/**  Secure bit enable?  */	
	Uint32                      secureEnable;

	/**  Block bit enable? */	
	Uint32                      blockEnable;

	/**  Port Number to forward matching packets to. */	
	Uint32                      portNumber;
} CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY;

/** @brief      
 *
 *  Holds the ALE VLAN Table entry configuration.
 */        
typedef struct {
	/**  VLAN Id  */	
	Uint32                      vlanId;

	/**  VLAN member list */	
	Uint32                      vlanMemList;

	/**  Unregistered Multicast Flood mask  */	
	Uint32                      unRegMcastFloodMask;

	/**  Registered Multicast Flood mask  */	
	Uint32                      regMcastFloodMask;

	/**  Force Untagged Packet Egress. */	
	Uint32                      forceUntaggedEgress;
} CSL_CPSW_3GF_ALE_VLAN_ENTRY;

/**
@}
*/


/** @addtogroup CSL_CPSW_3GF_FUNCTION
 @{ */

/**
@}
*/



/**
@}
*/

/** @addtogroup CSL_CPSW_3GF_FUNCTION
@{ */

/********************************************************************************
************************* Ethernet Switch (CPSW) Submodule **********************
********************************************************************************/


/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getCpswVersionInfo
 *
 *   @b Description
 *   @n This function retrieves the CPSW identification and version information.
 *
 *   @b Arguments
     @verbatim
        pVersionInfo        CSL_CPSW_3GF_VERSION structure that needs to be populated
                            with the version info read from the hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_CPSW_ID_VER_REG_CPSW_3GF_MINOR_VER,
 *      CPSW_3GF_CPSW_ID_VER_REG_CPSW_3GF_MAJ_VER,
 *      CPSW_3GF_CPSW_ID_VER_REG_CPSW_3GF_RTL_VER,
 *      CPSW_3GF_CPSW_ID_VER_REG_CPSW_3GF_IDENT
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GF_VERSION    versionInfo;

        CSL_CPSW_3GF_getCpswVersionInfo (&versionInfo);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getCpswVersionInfo (
	CSL_CPSW_3GF_VERSION*       pVersionInfo     
)
{

    pVersionInfo->minorVer  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_ID_VER_REG) & (0x000000FFu)) >> (0x00000000u));
    pVersionInfo->majorVer  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_ID_VER_REG) & (0x00000700u)) >> (0x00000008u));
    pVersionInfo->rtlVer    =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_ID_VER_REG) & (0x0000F800u)) >> (0x0000000Bu));
    pVersionInfo->id        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_ID_VER_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isFIFOLoopbackEnabled
 *
 *   @b Description
 *   @n This function indicates if FIFO loopback mode is enabled in the CPSW
 *      control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   FIFO loopback mode enabled. Each packet received is 
 *	                            turned around and sent out on the same port's transmit
 *	                            path.
 *	 @n  FALSE                  FIFO loopback mode disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isFIFOLoopbackEnabled (portNum) == TRUE)
        {
            // FIFO loopback mode enabled
        }
        else
        {
            // FIFO loopback mode disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isFIFOLoopbackEnabled (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableFIFOLoopback
 *
 *   @b Description
 *   @n This function configures the CPSW control register to enable FIFO loopback
 *      mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableFIFOLoopback ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableFIFOLoopback (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableFIFOLoopback
 *
 *   @b Description
 *   @n This function configures the CPSW control register to disable FIFO loopback
 *      mode
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableFIFOLoopback ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableFIFOLoopback (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isVlanAwareEnabled
 *
 *   @b Description
 *   @n This function indicates if VLAN aware mode is enabled in the CPSW
 *      control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   VLAN aware mode enabled. 
 *	 @n  FALSE                  VLAN aware mode disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isVlanAwareEnabled (portNum) == TRUE)
        {
            // VLAN aware mode enabled
        }
        else
        {
            // VLAN aware mode disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isVlanAwareEnabled (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000002u)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableVlanAware
 *
 *   @b Description
 *   @n This function configures the CPSW control register to enable VLAN aware
 *      mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableVlanAware ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableVlanAware (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableVlanAware
 *
 *   @b Description
 *   @n This function configures the CPSW control register to disable VLAN aware
 *      mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableVlanAware ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableVlanAware (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000002u)) | (((0) << (0x00000001u)) & (0x00000002u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isPort0Enabled
 *
 *   @b Description
 *   @n This function indicates if CPPI Port (Port 0) is enabled in the CPSW
 *      control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Port 0 enabled. 
 *	 @n  FALSE                  Port 0 disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isPort0Enabled (portNum) == TRUE)
        {
            // Port 0 enabled
        }
        else
        {
            // Port 0 disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isPort0Enabled (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000004u)) >> (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enablePort0
 *
 *   @b Description
 *   @n This function configures the CPSW control register to enable the Port 0.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enablePort0 ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enablePort0 (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000004u)) | (((1) << (0x00000002u)) & (0x00000004u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disablePort0
 *
 *   @b Description
 *   @n This function configures the CPSW control register to disable the Port 0.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disablePort0 ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disablePort0 (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000004u)) | (((0) << (0x00000002u)) & (0x00000004u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isPort0PassPriTagEnabled
 *
 *   @b Description
 *   @n This function indicates if priority tagging is enabled for Port 0.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Port 0 ingress priority tagging enabled. 
 *	 @n  FALSE                  Port 0 ingress priority tagging disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isPort0PassPriTagEnabled (portNum) == TRUE)
        {
            // Port 0 pass priority tagging enabled
        }
        else
        {
            // Port 0 pass priority tagging disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isPort0PassPriTagEnabled (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000010u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enablePort0PassPriTag
 *
 *   @b Description
 *   @n This function configures the CPSW control register to enable the Ingress
 *      priority tagging on Port 0.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enablePort0PassPriTag ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enablePort0PassPriTag (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000010u)) | (((1) << (0x00000004u)) & (0x00000010u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disablePort0PassPriTag
 *
 *   @b Description
 *   @n This function configures the CPSW control register to disable the Ingress
 *      priority tagging on Port 0.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disablePort0PassPriTag ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disablePort0PassPriTag (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000010u)) | (((0) << (0x00000004u)) & (0x00000010u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isPort1PassPriTagEnabled
 *
 *   @b Description
 *   @n This function indicates if priority tagging is enabled for Port 1.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Port 1 ingress priority tagging enabled. 
 *	 @n  FALSE                  Port 1 ingress priority tagging disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isPort1PassPriTagEnabled (portNum) == TRUE)
        {
            // Port 1 pass priority tagging enabled
        }
        else
        {
            // Port 1 pass priority tagging disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isPort1PassPriTagEnabled (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000020u)) >> (0x00000005u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enablePort1PassPriTag
 *
 *   @b Description
 *   @n This function configures the CPSW control register to enable the Ingress
 *      priority tagging on Port 1.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enablePort1PassPriTag ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enablePort1PassPriTag (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000020u)) | (((1) << (0x00000005u)) & (0x00000020u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disablePort1PassPriTag
 *
 *   @b Description
 *   @n This function configures the CPSW control register to disable the Ingress
 *      priority tagging on Port 1.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disablePort1PassPriTag ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disablePort1PassPriTag (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000020u)) | (((0) << (0x00000005u)) & (0x00000020u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isPort2PassPriTagEnabled
 *
 *   @b Description
 *   @n This function indicates if priority tagging is enabled for Port 2.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Port 2 ingress priority tagging enabled. 
 *	 @n  FALSE                  Port 2 ingress priority tagging disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isPort2PassPriTagEnabled (portNum) == TRUE)
        {
            // Port 2 pass priority tagging enabled
        }
        else
        {
            // Port 2 pass priority tagging disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isPort2PassPriTagEnabled (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000040u)) >> (0x00000006u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enablePort2PassPriTag
 *
 *   @b Description
 *   @n This function configures the CPSW control register to enable the Ingress
 *      priority tagging on Port 2.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enablePort2PassPriTag ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enablePort2PassPriTag (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000040u)) | (((1) << (0x00000006u)) & (0x00000040u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disablePort2PassPriTag
 *
 *   @b Description
 *   @n This function configures the CPSW control register to disable the Ingress
 *      priority tagging on Port 2.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disablePort2PassPriTag ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disablePort2PassPriTag (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000040u)) | (((0) << (0x00000006u)) & (0x00000040u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getCpswControlReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the CPSW Control register.
 *
 *   @b Arguments
     @verbatim
        pControlRegInfo     CSL_CPSW_CONTROL structure that needs to be populated
                            with the control register contents.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK,
 *      CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE,
 *      CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE,
 *      CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED,
 *      CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED,
 *      CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GF_CONTROL    controlRegInfo;

        CSL_CPSW_3GF_getCpswControlReg (&controlRegInfo);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getCpswControlReg (
	CSL_CPSW_3GF_CONTROL*   pControlRegInfo     
)
{

    pControlRegInfo->fifoLb         =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000001u)) >> (0x00000000u));
    pControlRegInfo->vlanAware      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000002u)) >> (0x00000001u));
    pControlRegInfo->p0Enable       =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000004u)) >> (0x00000002u));
    pControlRegInfo->p0PassPriTag   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000010u)) >> (0x00000004u));
    pControlRegInfo->p1PassPriTag   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000020u)) >> (0x00000005u));
    pControlRegInfo->p2PassPriTag   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & (0x00000040u)) >> (0x00000006u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setCpswControlReg
 *
 *   @b Description
 *   @n This function populates the contents of the CPSW Control register.
 *
 *   @b Arguments
     @verbatim
        pControlRegInfo     CSL_CPSW_CONTROL structure that holds the values 
                            that need to be configured to the CPSW control register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSW control register modified with values provided.
 *
 *   @b Writes
 *   @n CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK,
 *      CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE,
 *      CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE,
 *      CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED,
 *      CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED,
 *      CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GF_CONTROL    controlRegInfo;

        controlRegInfo.fifoLb       =   1;
        controlRegInfo.vlanAware    =   0;
        ...

        CSL_CPSW_3GF_setCpswControlReg (&controlRegInfo);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setCpswControlReg (
	CSL_CPSW_3GF_CONTROL*   pControlRegInfo     
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000001u)) | (((pControlRegInfo->fifoLb) << (0x00000000u)) & (0x00000001u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000002u)) | (((pControlRegInfo->vlanAware) << (0x00000001u)) & (0x00000002u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000004u)) | (((pControlRegInfo->p0Enable) << (0x00000002u)) & (0x00000004u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000010u)) | (((pControlRegInfo->p0PassPriTag) << (0x00000004u)) & (0x00000010u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000020u)) | (((pControlRegInfo->p1PassPriTag) << (0x00000005u)) & (0x00000020u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->CPSW_CONTROL_REG) & ~(0x00000040u)) | (((pControlRegInfo->p2PassPriTag) << (0x00000006u)) & (0x00000040u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getEmulationControlReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the CPSW Emulation Control register.
 *
 *   @b Arguments
     @verbatim
        pFree                   Emulation free bit read from the hardware.
        pSoft                   Emulation soft bit read from the hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_EM_CONTROL_REG_FREE,
 *      CPSW_3GF_EM_CONTROL_REG_SOFT
 *
 *   @b Example
 *   @verbatim
        Uint32  free, soft;

        CSL_CPSW_3GF_getEmulationControlReg (&free, &soft);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getEmulationControlReg (
    Uint32*                     pFree,
    Uint32*                     pSoft
)
{

    *pFree      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->EM_CONTROL_REG) & (0x00000001u)) >> (0x00000000u));
    *pSoft      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->EM_CONTROL_REG) & (0x00000002u)) >> (0x00000001u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setEmulationControlReg
 *
 *   @b Description
 *   @n This function sets up the contents of the CPSW Emulation Control register.
 *
 *   @b Arguments
     @verbatim
        free                   Emulation free bit configuration
        soft                   Emulation soft bit configuration
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_EM_CONTROL_REG_FREE,
 *      CPSW_3GF_EM_CONTROL_REG_SOFT
 *
 *   @b Example
 *   @verbatim
        Uint32 free, soft;

        free   =   0;
        soft   =   1;

        CSL_CPSW_3GF_setEmulationControlReg (free, soft);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setEmulationControlReg (
    Uint32                      free,
    Uint32                      soft
)
{

    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->EM_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->EM_CONTROL_REG) & ~(0x00000001u)) | (((free) << (0x00000000u)) & (0x00000001u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->EM_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->EM_CONTROL_REG) & ~(0x00000002u)) | (((soft) << (0x00000001u)) & (0x00000002u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortStatsEnableReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the CPSW Port Statistics
 *      Enable register.
 *
 *   @b Arguments
     @verbatim
        pPortStatsCfg       CSL_CPSW_3GF_PORTSTAT structure that needs to be populated
                            with the port statistics enable register contents.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_STAT_PORT_EN_REG_P0A_STAT_EN,
 *      CPSW_3GF_STAT_PORT_EN_REG_P0B_STAT_EN,
 *      CPSW_3GF_STAT_PORT_EN_REG_P1_STAT_EN,
 *      CPSW_3GF_STAT_PORT_EN_REG_P2_STAT_EN
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GF_PORTSTAT       portStatsCfg;

        CSL_CPSW_3GF_getPortStatsEnableReg (&portStatsCfg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortStatsEnableReg (
	CSL_CPSW_3GF_PORTSTAT*  pPortStatsCfg     
)
{
    pPortStatsCfg->p0AStatEnable    =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) & (0x00000001u)) >> (0x00000000u));
    pPortStatsCfg->p0BStatEnable    =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) & (0x00000002u)) >> (0x00000001u));
    pPortStatsCfg->p1StatEnable     =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) & (0x00000004u)) >> (0x00000002u));
    pPortStatsCfg->p2StatEnable     =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) & (0x00000008u)) >> (0x00000003u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPortStatsEnableReg
 *
 *   @b Description
 *   @n This function sets up the contents of the CPSW Port Statistics
 *      Enable register.
 *
 *   @b Arguments
     @verbatim
        pPortStatsCfg       CSL_CPSW_3GF_PORTSTAT structure that contains the values
                            to be used to setup port statistics enable register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_STAT_PORT_EN_REG_P0A_STAT_EN,
 *      CPSW_3GF_STAT_PORT_EN_REG_P0B_STAT_EN,
 *      CPSW_3GF_STAT_PORT_EN_REG_P1_STAT_EN,
 *      CPSW_3GF_STAT_PORT_EN_REG_P2_STAT_EN
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GF_PORTSTAT       portStatsCfg;

        portStatsCfg.p0AStatEnable  =   1;
        portStatsCfg.p0BStatEnable  =   1;
        portStatsCfg.p1StatEnable   =   1;
        portStatsCfg.p2StatEnable   =   1;

        CSL_CPSW_3GF_setPortStatsEnableReg (&portStatsCfg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPortStatsEnableReg (
	CSL_CPSW_3GF_PORTSTAT*  pPortStatsCfg     
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) & ~(0x00000001u)) | (((pPortStatsCfg->p0AStatEnable) << (0x00000000u)) & (0x00000001u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) & ~(0x00000002u)) | (((pPortStatsCfg->p0BStatEnable) << (0x00000001u)) & (0x00000002u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) & ~(0x00000004u)) | (((pPortStatsCfg->p1StatEnable) << (0x00000002u)) & (0x00000004u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->STAT_PORT_EN_REG) & ~(0x00000008u)) | (((pPortStatsCfg->p2StatEnable) << (0x00000003u)) & (0x00000008u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPrioTypeReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the CPSW Priority Type
 *      register.
 *
 *   @b Arguments
     @verbatim
        pTypeCfg            CSL_CPSW_3GF_PTYPE structure that needs to be populated
                            with the priority type register contents.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_PTYPE_REG_ESC_PRI_LD_VAL,
 *      CPSW_3GF_PTYPE_REG_P0_PTYPE_ESC,
 *      CPSW_3GF_PTYPE_REG_P1_PTYPE_ESC,
 *      CPSW_3GF_PTYPE_REG_P2_PTYPE_ESC
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GF_PTYPE       pTypeCfg;

        CSL_CPSW_3GF_getPrioTypeReg (&pTypeCfg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPrioTypeReg (
	CSL_CPSW_3GF_PTYPE*     pTypeCfg     
)
{
    pTypeCfg->escPriLdVal   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) & (0x0000001Fu)) >> (0x00000000u));
    pTypeCfg->p0PtypeEsc    =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) & (0x00000100u)) >> (0x00000008u));
    pTypeCfg->p1PtypeEsc    =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) & (0x00000200u)) >> (0x00000009u));
    pTypeCfg->p2PtypeEsc    =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) & (0x00000400u)) >> (0x0000000Au));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPrioTypeReg
 *
 *   @b Description
 *   @n This function modifies the contents of the CPSW Priority Type
 *      register.
 *
 *   @b Arguments
     @verbatim
        pTypeCfg            CSL_CPSW_3GF_PTYPE structure that contains the values that
                            need to be populated to Priority type register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_PTYPE_REG_ESC_PRI_LD_VAL,
 *      CPSW_3GF_PTYPE_REG_P0_PTYPE_ESC,
 *      CPSW_3GF_PTYPE_REG_P1_PTYPE_ESC,
 *      CPSW_3GF_PTYPE_REG_P2_PTYPE_ESC
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GF_PTYPE       pTypeCfg;

        pTypeCfg.escPriLdVal    =   1;
        pTypeCfg.p0PtypeEsc     =   1;
        ...

        CSL_CPSW_3GF_setPrioTypeReg (&pTypeCfg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPrioTypeReg (
	CSL_CPSW_3GF_PTYPE*     pTypeCfg     
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) & ~(0x0000001Fu)) | (((pTypeCfg->escPriLdVal) << (0x00000000u)) & (0x0000001Fu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) & ~(0x00000100u)) | (((pTypeCfg->p0PtypeEsc) << (0x00000008u)) & (0x00000100u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) & ~(0x00000200u)) | (((pTypeCfg->p1PtypeEsc) << (0x00000009u)) & (0x00000200u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PTYPE_REG) & ~(0x00000400u)) | (((pTypeCfg->p2PtypeEsc) << (0x0000000Au)) & (0x00000400u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getShortGapThreshold
 *
 *   @b Description
 *   @n This function retrieves the contents of the CPSW MAC Short Gap Threshold
 *      register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 >=0                    MAC short gap threshold value read from the hardware.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_GAP_THRESH_CPGMAC_SL_REG_GAP_THRESH
 *
 *   @b Example
 *   @verbatim
 *      Uint32          gapThreshVal;

        gapThreshVal    =   CSL_CPSW_3GF_getShortGapThreshold ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_getShortGapThreshold (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->GAP_THRESH_CPGMAC_SL_REG) & (0x0000001Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setShortGapThreshold
 *
 *   @b Description
 *   @n This function sets up the contents of the CPSW MAC Short Gap Threshold
 *      register.
 *
 *   @b Arguments
     @verbatim
        gapThreshVal        Gap threshold value to use to configure the MAC Short
                            gap threshold value.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_GAP_THRESH_CPGMAC_SL_REG_GAP_THRESH
 *
 *   @b Example
 *   @verbatim
 *      Uint32          gapThreshVal;
 *
 *      gapThreshVal    =   11;

        CSL_CPSW_3GF_setShortGapThreshold (gapThreshVal);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setShortGapThreshold (
    Uint32                  gapThreshVal                
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->GAP_THRESH_CPGMAC_SL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->GAP_THRESH_CPGMAC_SL_REG) & ~(0x0000001Fu)) | (((gapThreshVal) << (0x00000000u)) & (0x0000001Fu)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getTxStartWordsReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Transmit FIFO start words
 *      register.
 *
 *   @b Arguments
     @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_TX_START_WDS_REG_TX_START_WDS
 *
 *   @b Example
 *   @verbatim
 *      Uint32          startWordsVal;

        startWordsVal   =   CSL_CPSW_3GF_getTxStartWordsReg ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_getTxStartWordsReg (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->TX_START_WDS_REG) & (0x000007FFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setTxStartWordsReg
 *
 *   @b Description
 *   @n This function sets up the contents of the Transmit FIFO start words
 *      register.
 *
 *   @b Arguments
     @verbatim
        pStartWordsVal      Start words value to be set to the Transmit FIFO start
                            words register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_TX_START_WDS_REG_TX_START_WDS
 *
 *   @b Example
 *   @verbatim
 *      Uint32          startWordsVal;
 *
 *      startWordsVal   =   32;

        CSL_CPSW_3GF_setTxStartWordsReg (startWordsVal);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setTxStartWordsReg (
    Uint32                  startWordsVal                
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->TX_START_WDS_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->TX_START_WDS_REG) & ~(0x000007FFu)) | (((startWordsVal) << (0x00000000u)) & (0x000007FFu)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getFlowControlReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Flow control register.
 *
 *   @b Arguments
     @verbatim
        pFlowControlCfg     CSL_CPSW_3GF_FLOWCNTL structure that needs to be populated
                            with contents of Flow control register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_FLOW_CONTROL_REG_P0_FLOW_EN,
 *      CPSW_3GF_FLOW_CONTROL_REG_P1_FLOW_EN,
 *      CPSW_3GF_FLOW_CONTROL_REG_P2_FLOW_EN
 *
 *   @b Example
 *   @verbatim
 *      CSL_CPSW_3GF_FLOWCNTL       flowControlCfg;

        CSL_CPSW_3GF_getFlowControlReg (&flowControlCfg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getFlowControlReg (
    CSL_CPSW_3GF_FLOWCNTL*  pFlowControlCfg    
)
{
    pFlowControlCfg->p0FlowEnable   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) & (0x00000001u)) >> (0x00000000u));
    pFlowControlCfg->p1FlowEnable   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) & (0x00000002u)) >> (0x00000001u));
    pFlowControlCfg->p2FlowEnable   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) & (0x00000004u)) >> (0x00000002u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setFlowControlReg
 *
 *   @b Description
 *   @n This function sets up the contents of the Flow control register.
 *
 *   @b Arguments
     @verbatim
        pFlowControlCfg     CSL_CPSW_3GF_FLOWCNTL structure that contains the values
                            that need to be configured to Flow control register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_FLOW_CONTROL_REG_P0_FLOW_EN,
 *      CPSW_3GF_FLOW_CONTROL_REG_P1_FLOW_EN,
 *      CPSW_3GF_FLOW_CONTROL_REG_P2_FLOW_EN
 *
 *   @b Example
 *   @verbatim
 *      CSL_CPSW_3GF_FLOWCNTL       flowControlCfg;
 
        flowControlCfg.p0FlowEnable =   1;
        flowControlCfg.p1FlowEnable =   1;:
        flowControlCfg.p2FlowEnable =   1;

        CSL_CPSW_3GF_setFlowControlReg (&flowControlCfg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setFlowControlReg (
    CSL_CPSW_3GF_FLOWCNTL*  pFlowControlCfg    
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) & ~(0x00000001u)) | (((pFlowControlCfg->p0FlowEnable) << (0x00000000u)) & (0x00000001u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) & ~(0x00000002u)) | (((pFlowControlCfg->p1FlowEnable) << (0x00000001u)) & (0x00000002u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->FLOW_CONTROL_REG) & ~(0x00000004u)) | (((pFlowControlCfg->p2FlowEnable) << (0x00000002u)) & (0x00000004u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getCppiSourceIdReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the CPPI Source Identification
 *      register.
 *
 *   @b Arguments
     @verbatim
        pTxASrcId           CPPI Info Word0 Source Id Value on TxA.
        pTxBSrcId           CPPI Info Word0 Source Id Value on TxB.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P0_CPPI_SRC_ID_REG_TXA_SRC_ID,
 *      CPSW_3GF_P0_CPPI_SRC_ID_REG_TXB_SRC_ID
 *
 *   @b Example
 *   @verbatim
 *      Uint32      txASrcId, txBSrcId;

        CSL_CPSW_3GF_getCppiSourceIdReg (&txASrcId, &txBSrcId);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getCppiSourceIdReg (
    Uint32*                 pTxASrcId,
    Uint32*                 pTxBSrcId
)
{
    *pTxASrcId      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_CPPI_SRC_ID_REG) & (0x000000FFu)) >> (0x00000000u));
    *pTxBSrcId      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_CPPI_SRC_ID_REG) & (0x0000FF00u)) >> (0x00000008u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setCppiSourceIdReg
 *
 *   @b Description
 *   @n This function sets up the contents of the CPPI Source Identification
 *      register.
 *
 *   @b Arguments
     @verbatim
        txASrcId            CPPI Source Id to configure for TxA.
        txBSrcId            CPPI Source Id to configure for TxB.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P0_CPPI_SRC_ID_REG_TXA_SRC_ID,
 *      CPSW_3GF_P0_CPPI_SRC_ID_REG_TXB_SRC_ID
 *
 *   @b Example
 *   @verbatim
 *      Uint32      txASrcId, txBSrcId;
 
        txASrcId    =   1;
        txBSrcId    =   2;

        CSL_CPSW_3GF_setCppiSourceIdReg (txASrcId, txBSrcId);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setCppiSourceIdReg (
    Uint32                  txASrcId,
    Uint32                  txBSrcId
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_CPPI_SRC_ID_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_CPPI_SRC_ID_REG) & ~(0x000000FFu)) | (((txASrcId) << (0x00000000u)) & (0x000000FFu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_CPPI_SRC_ID_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_CPPI_SRC_ID_REG) & ~(0x0000FF00u)) | (((txBSrcId) << (0x00000008u)) & (0x0000FF00u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPort0VlanReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Port 0 VLAN Register.
 *
 *   @b Arguments
     @verbatim
        pPortVID                Port VLAN Id
        pPortCFI                Port CFI bit
        pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P0_PORT_VLAN_REG_PORT_VID,
 *      CPSW_3GF_P0_PORT_VLAN_REG_PORT_CFI,
 *      CPSW_3GF_P0_PORT_VLAN_REG_PORT_PRI
 *
 *   @b Example
 *   @verbatim
 *      Uint32      portVID, portCFI, portPRI;
 
        CSL_CPSW_3GF_getPort0VlanReg (&portVID, &portCFI, &portPRI);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPort0VlanReg (
    Uint32*                     pPortVID,
    Uint32*                     pPortCFI,
    Uint32*                     pPortPRI
)
{
    *pPortVID   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) & (0x00000FFFu)) >> (0x00000000u));
    *pPortCFI   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) & (0x00001000u)) >> (0x0000000Cu));
    *pPortPRI   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) & (0x0000E000u)) >> (0x0000000Du));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPort0VlanReg
 *
 *   @b Description
 *   @n This function sets up the contents of the Port 0 VLAN Register.
 *
 *   @b Arguments
     @verbatim
        portVID                 Port VLAN Id to be configured
        portCFI                 Port CFI bit to be configured
        portPRI                 Port VLAN priority to be configured
                                (0-7, 7 is highest priority)
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P0_PORT_VLAN_REG_PORT_VID,
 *      CPSW_3GF_P0_PORT_VLAN_REG_PORT_CFI,
 *      CPSW_3GF_P0_PORT_VLAN_REG_PORT_PRI
 *
 *   @b Example
 *   @verbatim
 *      Uint32      portVID, portCFI, portPRI;
 
        portVID     =   1;
        portCFI     =   0;
        portPRI     =   7;

        CSL_CPSW_3GF_setPort0VlanReg (portVID, portCFI, portPRI);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPort0VlanReg (
    Uint32                      portVID,
    Uint32                      portCFI,
    Uint32                      portPRI
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) & ~(0x00000FFFu)) | (((portVID) << (0x00000000u)) & (0x00000FFFu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) & ~(0x00001000u)) | (((portCFI) << (0x0000000Cu)) & (0x00001000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_PORT_VLAN_REG) & ~(0x0000E000u)) | (((portPRI) << (0x0000000Du)) & (0x0000E000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPort0RxPriMapReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Port 0 Receive Packet
 *      Priority to Header Priority Mapping Register.
 *
 *   @b Arguments
     @verbatim
        pPortRxPriMap           Array of Port 0 Rx priority map priority values 
                                read from the register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  The input parameter 'pPortRxPriMap' must be large enough to hold all
 *       the 8 priority values read from the register.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P0_RX_PRI_MAP_REG_PRI0,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI1,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI2,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI3,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI4,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI5,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI6,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI7
 *
 *   @b Example
 *   @verbatim
 *      Uint32      port0RxPriMap [8];
 
        CSL_CPSW_3GF_getPort0RxPriMapReg (port0RxPriMap);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPort0RxPriMapReg (
    Uint32*                     pPortRxPriMap                
)
{
    pPortRxPriMap [0]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & (0x00000007u)) >> (0x00000000u));
    pPortRxPriMap [1]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & (0x00000070u)) >> (0x00000004u));
    pPortRxPriMap [2]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & (0x00000700u)) >> (0x00000008u));
    pPortRxPriMap [3]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & (0x00007000u)) >> (0x0000000Cu));
    pPortRxPriMap [4]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & (0x00070000u)) >> (0x00000010u));
    pPortRxPriMap [5]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & (0x00700000u)) >> (0x00000014u));
    pPortRxPriMap [6]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & (0x07000000u)) >> (0x00000018u));
    pPortRxPriMap [7]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & (0x70000000u)) >> (0x0000001Cu));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPort0RxPriMapReg
 *
 *   @b Description
 *   @n This function sets up the contents of the Port 0 Receive Packet
 *      Priority to Header Priority Mapping Register.
 *
 *   @b Arguments
     @verbatim
        pPortRxPriMap           Array of Port 0 Rx priority map priority values 
                                that must be configured to the register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P0_RX_PRI_MAP_REG_PRI0,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI1,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI2,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI3,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI4,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI5,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI6,
 *      CPSW_3GF_P0_RX_PRI_MAP_REG_PRI7
 *
 *   @b Example
 *   @verbatim
 *      Uint32      i, port0RxPriMap [8];

        for (i = 0; i < 8; i ++)
            port0RxPriMap [i] = i;

        CSL_CPSW_3GF_setPort0RxPriMapReg (port0RxPriMap);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPort0RxPriMapReg (
    Uint32*                     pPortRxPriMap                
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & ~(0x00000007u)) | (((pPortRxPriMap [0]) << (0x00000000u)) & (0x00000007u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & ~(0x00000070u)) | (((pPortRxPriMap [1]) << (0x00000004u)) & (0x00000070u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & ~(0x00000700u)) | (((pPortRxPriMap [2]) << (0x00000008u)) & (0x00000700u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & ~(0x00007000u)) | (((pPortRxPriMap [3]) << (0x0000000Cu)) & (0x00007000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & ~(0x00070000u)) | (((pPortRxPriMap [4]) << (0x00000010u)) & (0x00070000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & ~(0x00700000u)) | (((pPortRxPriMap [5]) << (0x00000014u)) & (0x00700000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & ~(0x07000000u)) | (((pPortRxPriMap [6]) << (0x00000018u)) & (0x07000000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->P0_RX_PRI_MAP_REG) & ~(0x70000000u)) | (((pPortRxPriMap [7]) << (0x0000001Cu)) & (0x70000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPort0RxMaxLen
 *
 *   @b Description
 *   @n This function retrieves the contents of the Port 0 Receive Maximum Length
 *      Register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_RX_MAXLEN_REG_RX_MAXLEN
 *
 *   @b Example
 *   @verbatim
 *      Uint32      rxMaxLen;
 
        rxMaxLen    =   CSL_CPSW_3GF_getPort0RxMaxLen ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_getPort0RxMaxLen (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->RX_MAXLEN_REG) & (0x00003FFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPort0RxMaxLen
 *
 *   @b Description
 *   @n This function sets up the Port0 Receive Maximum length register.
 *
 *   @b Arguments
     @verbatim
        rxMaxLen            Maximum receive frame length to configure.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_RX_MAXLEN_REG_RX_MAXLEN
 *
 *   @b Example
 *   @verbatim
 *      Uint32      rxMaxLen;
 
        rxMaxLen    =   1518;            
 
        CSL_CPSW_3GF_setPort0RxMaxLen (rxMaxLen);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPort0RxMaxLen (
    Uint32                  rxMaxLen
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->RX_MAXLEN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->RX_MAXLEN_REG) & ~(0x00003FFFu)) | (((rxMaxLen) << (0x00000000u)) & (0x00003FFFu)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortMaxBlocksReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Port Max Blocks Register 
 *      corresponding to the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the max block numbers
                                must be retrieved.
        pRxMaxBlks              Receive FIFO Maximum blocks read for this port.                                
        pTxMaxBlks              Transmit FIFO Maximum blocks read for this port.                                
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P_MAX_BLKS_REG_RX_MAX_BLKS,
 *      CPSW_3GF_P_MAX_BLKS_REG_TX_MAX_BLKS
 *
 *   @b Example
 *   @verbatim
 *      Uint32      rxMaxBlks, txMaxBlks, portNum;

        portNum =   1;            
 
        CSL_CPSW_3GF_getPortMaxBlocksReg (portNum, &rxMaxBlks, &txMaxBlks);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortMaxBlocksReg (
    Uint32                      portNum,
    Uint32*                     pRxMaxBlks,
    Uint32*                     pTxMaxBlks
)
{
    *pRxMaxBlks  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_MAX_BLKS_REG) & (0x0000000Fu)) >> (0x00000000u));
    *pTxMaxBlks  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_MAX_BLKS_REG) & (0x000001F0u)) >> (0x00000004u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPortMaxBlocksReg
 *
 *   @b Description
 *   @n This function sets up the contents of the Port Max Blocks Register 
 *      corresponding to the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the max block numbers
                                must be configured.
        rxMaxBlks               Maximum number of 4K memory blocks that must be allocated
                                for the port's FIFO logical receive priority queues.
        txMaxBlks               Maximum number of 4K memory blocks that must be allocated
                                for the port's FIFO logical transmit priority queues.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P_MAX_BLKS_REG_RX_MAX_BLKS,
 *      CPSW_3GF_P_MAX_BLKS_REG_TX_MAX_BLKS
 *
 *   @b Example
 *   @verbatim
 *      Uint32      rxMaxBlks, txMaxBlks, portNum;

        portNum     =   1;            
        rxMaxBlks   =   3;
        txMaxBlks   =   17;
 
        CSL_CPSW_3GF_getPortMaxBlocksReg (portNum, rxMaxBlks, txMaxBlks);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPortMaxBlocksReg (
    Uint32                      portNum,
    Uint32                      rxMaxBlks,
    Uint32                      txMaxBlks
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_MAX_BLKS_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_MAX_BLKS_REG) & ~(0x0000000Fu)) | (((rxMaxBlks) << (0x00000000u)) & (0x0000000Fu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_MAX_BLKS_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_MAX_BLKS_REG) & ~(0x000001F0u)) | (((txMaxBlks) << (0x00000004u)) & (0x000001F0u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortBlockCountReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Port Block Count register 
 *      corresponding to the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the block count
                                must be retrieved.
        pRxBlkCnt               Receive block count usage read for this port.                                
        pTxBlkCnt               Transmit block count usage read for this port.                                
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P_BLK_CNT_REG_RX_BLK_CNT,
 *      CPSW_3GF_P_BLK_CNT_REG_TX_BLK_CNT
 *
 *   @b Example
 *   @verbatim
 *      Uint32      rxBlkCnt, txBlkCnt, portNum;

        portNum =   1;            
 
        CSL_CPSW_3GF_getPortBlockCountReg (portNum, &rxBlkCnt, &txBlkCnt);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortBlockCountReg (
    Uint32                      portNum,
    Uint32*                     pRxBlkCnt,
    Uint32*                     pTxBlkCnt
)
{
    *pRxBlkCnt  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_BLK_CNT_REG) & (0x0000000Fu)) >> (0x00000000u));
    *pTxBlkCnt  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_BLK_CNT_REG) & (0x000001F0u)) >> (0x00000004u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortVlanReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the VLAN Register corresponding
 *      to the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the VLAN register 
                                contents must be read
        pPortVID                Port VLAN Id
        pPortCFI                Port CFI bit
        pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P_PORT_VLAN_REG_PORT_VID,
 *      CPSW_3GF_P_PORT_VLAN_REG_PORT_CFI,
 *      CPSW_3GF_P_PORT_VLAN_REG_PORT_PRI
 *
 *   @b Example
 *   @verbatim
 *      Uint32      portVID, portCFI, portPRI, portNum;
 
        portNum =   2;
 
        CSL_CPSW_3GF_getPortVlanReg (portNum, &portVID, &portCFI, &portPRI);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortVlanReg (
    Uint32                      portNum,                
    Uint32*                     pPortVID,
    Uint32*                     pPortCFI,
    Uint32*                     pPortPRI
)
{
    *pPortVID   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) & (0x00000FFFu)) >> (0x00000000u));
    *pPortCFI   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) & (0x00001000u)) >> (0x0000000Cu));
    *pPortPRI   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) & (0x0000E000u)) >> (0x0000000Du));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPortVlanReg
 *
 *   @b Description
 *   @n This function sets up the contents of the VLAN Register corresponding to
 *      the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the VLAN register 
                                must be configured.
        portVID                 Port VLAN Id to be configured
        portCFI                 Port CFI bit to be configured
        portPRI                 Port VLAN priority to be configured
                                (0-7, 7 is highest priority)
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P_PORT_VLAN_REG_PORT_VID,
 *      CPSW_3GF_P_PORT_VLAN_REG_PORT_CFI,
 *      CPSW_3GF_P_PORT_VLAN_REG_PORT_PRI
 *
 *   @b Example
 *   @verbatim
 *      Uint32      portVID, portCFI, portPRI, portNum;
    
        portNum     =   2;
        portVID     =   1;
        portCFI     =   0;
        portPRI     =   7;

        CSL_CPSW_3GF_setPortVlanReg (portNum, portVID, portCFI, portPRI);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPortVlanReg (
    Uint32                      portNum,                
    Uint32                      portVID,
    Uint32                      portCFI,
    Uint32                      portPRI
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) & ~(0x00000FFFu)) | (((portVID) << (0x00000000u)) & (0x00000FFFu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) & ~(0x00001000u)) | (((portCFI) << (0x0000000Cu)) & (0x00001000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_PORT_VLAN_REG) & ~(0x0000E000u)) | (((portPRI) << (0x0000000Du)) & (0x0000E000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortTxPriMapReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Transmit Header Priority to
 *      Switch Priority Mapping Register corresponding to the MAC port number
 *      specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the register contents
                                must be read and returned.
        pPortTxPriMap           Array of Port Tx priority map priority values 
                                read from the register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  The input parameter 'pPortTxPriMap' must be large enough to hold all
 *       the 8 priority values read from the register.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P_TX_PRI_MAP_REG_PRI0,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI1,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI2,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI3,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI4,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI5,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI6,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI7
 *
 *   @b Example
 *   @verbatim
 *      Uint32      portTxPriMap [8], portNum;
 
        portNum =   1;
 
        CSL_CPSW_3GF_getPortTxPriMapReg (portNum, portTxPriMap);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortTxPriMapReg (
    Uint32                      portNum,                
    Uint32*                     pPortTxPriMap                
)
{
    pPortTxPriMap [0]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & (0x00000003u)) >> (0x00000000u));
    pPortTxPriMap [1]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & (0x00000030u)) >> (0x00000004u));
    pPortTxPriMap [2]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & (0x00000300u)) >> (0x00000008u));
    pPortTxPriMap [3]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & (0x00003000u)) >> (0x0000000Cu));
    pPortTxPriMap [4]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & (0x00030000u)) >> (0x00000010u));
    pPortTxPriMap [5]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & (0x00300000u)) >> (0x00000014u));
    pPortTxPriMap [6]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & (0x03000000u)) >> (0x00000018u));
    pPortTxPriMap [7]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & (0x30000000u)) >> (0x0000001Cu));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPortTxPriMapReg
 *
 *   @b Description
 *   @n This function sets up the contents of the Port Transmit Header Priority
 *      to Switch Priority Mapping Register.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the register contents
                                must be configured.
        pPortTxPriMap           Array of Port Tx priority map priority values 
                                that must be configured to the register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P_TX_PRI_MAP_REG_PRI0,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI1,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI2,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI3,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI4,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI5,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI6,
 *      CPSW_3GF_P_TX_PRI_MAP_REG_PRI7
 *
 *   @b Example
 *   @verbatim
 *      Uint32      i, portTxPriMap [8], portNum;

        for (i = 0; i < 8; i ++)
            portTxPriMap [i] = i;

        portNum =   1;            

        CSL_CPSW_3GF_setPortTxPriMapReg (portNum, portTxPriMap);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPortTxPriMapReg (
    Uint32                      portNum,                
    Uint32*                     pPortTxPriMap                
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & ~(0x00000003u)) | (((pPortTxPriMap [0]) << (0x00000000u)) & (0x00000003u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & ~(0x00000030u)) | (((pPortTxPriMap [1]) << (0x00000004u)) & (0x00000030u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & ~(0x00000300u)) | (((pPortTxPriMap [2]) << (0x00000008u)) & (0x00000300u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & ~(0x00003000u)) | (((pPortTxPriMap [3]) << (0x0000000Cu)) & (0x00003000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & ~(0x00030000u)) | (((pPortTxPriMap [4]) << (0x00000010u)) & (0x00030000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & ~(0x00300000u)) | (((pPortTxPriMap [5]) << (0x00000014u)) & (0x00300000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & ~(0x03000000u)) | (((pPortTxPriMap [6]) << (0x00000018u)) & (0x03000000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TX_PRI_MAP_REG) & ~(0x30000000u)) | (((pPortTxPriMap [7]) << (0x0000001Cu)) & (0x30000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortMACAddress
 *
 *   @b Description
 *   @n This function retreives the source MAC address corresponding to the 
 *      MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the source MAC address
                                must be read and returned.
        pMacAddress             6 byte Source MAC address read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  The input parameter 'pMacAddres' must be large enough the 6 byte
 *       MAC address returned by this API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_SL_SA_LO_REG_MACSRCADDR_7_0,
 *      CPSW_3GF_SL_SA_LO_REG_MACSRCADDR_15_8,
 *      CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_23_16,
 *      CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_31_24,
 *      CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_39_32,
 *      CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_47_40
 *
 *   @b Example
 *   @verbatim
 *      Uint8   macAddress [6], portNum;
 
        portNum =   1;
 
        CSL_CPSW_3GF_getPortMACAddress (portNum, macAddress);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortMACAddress (
    Uint32                      portNum,                
    Uint8*                      pMacAddress                
)
{
    pMacAddress [0]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_LO_REG) & (0x0000FF00u)) >> (0x00000008u));
    pMacAddress [1]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_LO_REG) & (0x000000FFu)) >> (0x00000000u));
    pMacAddress [2]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) & (0xFF000000u)) >> (0x00000018u));
    pMacAddress [3]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) & (0x00FF0000u)) >> (0x00000010u));
    pMacAddress [4]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) & (0x0000FF00u)) >> (0x00000008u));
    pMacAddress [5]   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) & (0x000000FFu)) >> (0x00000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPortMACAddress
 *
 *   @b Description
 *   @n This function sets up the source MAC address corresponding to the 
 *      MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the source MAC address
                                must be setup.
        pMacAddress             6 byte Source MAC address to configure.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  The input parameter 'pMacAddres' is expected to be 6 bytes long.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_SL_SA_LO_REG_MACSRCADDR_7_0,
 *      CPSW_3GF_SL_SA_LO_REG_MACSRCADDR_15_8,
 *      CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_23_16,
 *      CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_31_24,
 *      CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_39_32,
 *      CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_47_40
 *
 *   @b Example
 *   @verbatim
 *      Uint8   macAddress [6], portNum;
 
        portNum         =   1;
        macAddress [0]  =   0x01;
        macAddress [1]  =   0x02;
        macAddress [2]  =   0x03;
        macAddress [3]  =   0x04;
        macAddress [4]  =   0x05;
        macAddress [5]  =   0x06;
 
        CSL_CPSW_3GF_setPortMACAddress (portNum, macAddress);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPortMACAddress (
    Uint32                      portNum,                
    Uint8*                      pMacAddress                
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_LO_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_LO_REG) & ~(0x0000FF00u)) | (((pMacAddress [0]) << (0x00000008u)) & (0x0000FF00u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_LO_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_LO_REG) & ~(0x000000FFu)) | (((pMacAddress [1]) << (0x00000000u)) & (0x000000FFu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) & ~(0xFF000000u)) | (((pMacAddress [2]) << (0x00000018u)) & (0xFF000000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) & ~(0x00FF0000u)) | (((pMacAddress [3]) << (0x00000010u)) & (0x00FF0000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) & ~(0x0000FF00u)) | (((pMacAddress [4]) << (0x00000008u)) & (0x0000FF00u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. SL_SA_HI_REG) & ~(0x000000FFu)) | (((pMacAddress [5]) << (0x00000000u)) & (0x000000FFu)));

    return;
}


/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortTimeSyncCntlReg
 *
 *   @b Description
 *   @n This function retreives the contents of Time sync control register  
 *      corresponding to the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the register must be read.
        pTimeSyncCntlCfg        CSL_CPSW_3GF_TSCNTL that needs to be populated with 
                                contents of time sync control register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P_TS_CTL_REG_TS_RX_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_TX_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TX_MSG_TYPE_EN_15_0
 *
 *   @b Example
 *   @verbatim
 *      Uint32              portNum;
        CSL_CPSW_3GF_TSCNTL     tsCtlCfg;
 
        portNum =   1;
 
        CSL_CPSW_3GF_getPortTimeSyncCntlReg (portNum, &tsCtlCfg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortTimeSyncCntlReg (
    Uint32                      portNum,                
    CSL_CPSW_3GF_TSCNTL*        pTimeSyncCntlCfg                
)
{
    pTimeSyncCntlCfg->tsRxEnable                =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & (0x00000001u)) >> (0x00000000u));
    pTimeSyncCntlCfg->tsRxVlanLType1Enable      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & (0x00000002u)) >> (0x00000001u));
    pTimeSyncCntlCfg->tsRxVlanLType2Enable      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & (0x00000004u)) >> (0x00000002u));
    pTimeSyncCntlCfg->tsTxEnable                =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & (0x00000010u)) >> (0x00000004u));
    pTimeSyncCntlCfg->tsTxVlanLType1Enable      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & (0x00000020u)) >> (0x00000005u));
    pTimeSyncCntlCfg->tsTxVlanLType2Enable      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & (0x00000040u)) >> (0x00000006u));
    pTimeSyncCntlCfg->txMsgTypeEnable           =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPortTimeSyncCntlReg
 *
 *   @b Description
 *   @n This function sets up the contents of Time sync control register  
 *      corresponding to the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the register must be 
                                configured.
        pTimeSyncCntlCfg        CSL_CPSW_3GF_TSCNTL containing settings for time
                                sync control register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P_TS_CTL_REG_TS_RX_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_TX_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN,
 *      CPSW_3GF_P_TS_CTL_REG_TX_MSG_TYPE_EN_15_0
 *
 *   @b Example
 *   @verbatim
 *      Uint32              portNum;
        CSL_CPSW_3GF_TSCNTL     tsCtlCfg;
 
        portNum =   1;

        tsCtlCfg.tsRxEnable             =   1;
        tsCtlCfg.tsRxVlanLType1Enable   =   0;
        tsCtlCfg.tsRxVlanLType2Enable   =   0;
        ...
 
        CSL_CPSW_3GF_setPortTimeSyncCntlReg (portNum, &tsCtlCfg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPortTimeSyncCntlReg (
    Uint32                      portNum,                
    CSL_CPSW_3GF_TSCNTL*        pTimeSyncCntlCfg                
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & ~(0x00000001u)) | (((pTimeSyncCntlCfg->tsRxEnable) << (0x00000000u)) & (0x00000001u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & ~(0x00000002u)) | (((pTimeSyncCntlCfg->tsRxVlanLType1Enable) << (0x00000001u)) & (0x00000002u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & ~(0x00000004u)) | (((pTimeSyncCntlCfg->tsRxVlanLType2Enable) << (0x00000002u)) & (0x00000004u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & ~(0x00000010u)) | (((pTimeSyncCntlCfg->tsTxEnable) << (0x00000004u)) & (0x00000010u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & ~(0x00000020u)) | (((pTimeSyncCntlCfg->tsTxVlanLType1Enable) << (0x00000005u)) & (0x00000020u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & ~(0x00000040u)) | (((pTimeSyncCntlCfg->tsTxVlanLType2Enable) << (0x00000006u)) & (0x00000040u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_CTL_REG) & ~(0xFFFF0000u)) | (((pTimeSyncCntlCfg->txMsgTypeEnable) << (0x00000010u)) & (0xFFFF0000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortTimeSyncSeqIdReg
 *
 *   @b Description
 *   @n This function retreives the contents of Time Sync Sequence Id and   
 *      LTYPE register corresponding to the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the register must be read.
        pTsLtype                Time sync LTYPE read.
        pTsSeqIdOffset          Time sync sequence Id offset read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P_TS_SEQ_LTYPE_REG_TS_LTYPE,
 *      CPSW_3GF_P_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET
 *
 *   @b Example
 *   @verbatim
 *      Uint32              portNum, tsLtype, tsSeqIdOffset;
 
        portNum =   1;
 
        CSL_CPSW_3GF_getPortTimeSyncSeqIdReg (portNum, &tsLtype, &tsSeqIdOffset);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortTimeSyncSeqIdReg (
    Uint32                      portNum,                
    Uint32*                     pTsLtype,                
    Uint32*                     pTsSeqIdOffset
)
{
    *pTsLtype           =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_SEQ_LTYPE_REG) & (0x0000FFFFu)) >> (0x00000000u));
    *pTsSeqIdOffset     =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_SEQ_LTYPE_REG) & (0x003F0000u)) >> (0x00000010u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPortTimeSyncSeqIdReg
 *
 *   @b Description
 *   @n This function sets up the contents of Time Sync Sequence Id and   
 *      LTYPE register corresponding to the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the register must be 
                                configured.
        tsLtype                 Time sync LTYPE to be configured.
        tsSeqIdOffset           Time sync sequence Id offset to be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P_TS_SEQ_LTYPE_REG_TS_LTYPE,
 *      CPSW_3GF_P_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET
 *
 *   @b Example
 *   @verbatim
 *      Uint32              portNum, tsLtype, tsSeqIdOffset;
 
        portNum         =   1;
        tsLtype         =   0;
        tsSeqIdOffset   =   30;
 
        CSL_CPSW_3GF_getPortTimeSyncSeqIdReg (portNum, tsLtype, tsSeqIdOffset);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPortTimeSyncSeqIdReg (
    Uint32                      portNum,                
    Uint32                      tsLtype,                
    Uint32                      tsSeqIdOffset
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_SEQ_LTYPE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_SEQ_LTYPE_REG) & ~(0x0000FFFFu)) | (((tsLtype) << (0x00000000u)) & (0x0000FFFFu)));

    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_SEQ_LTYPE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_SEQ_LTYPE_REG) & ~(0x003F0000u)) | (((tsSeqIdOffset) << (0x00000010u)) & (0x003F0000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getPortTimeSyncVlanLTypeReg
 *
 *   @b Description
 *   @n This function retreives the contents of Time Sync VLAN LTYPE   
 *      register corresponding to the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the register must be read.
        pTsVlanLtype1           Time sync VLAN LTYPE1 value read.
        pTsVlanLtype2           Time sync VLAN LTYPE2 value read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1,
 *      CPSW_3GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2
 *
 *   @b Example
 *   @verbatim
 *      Uint32              portNum, tsLtype1, tsLtype2;
 
        portNum =   1;
 
        CSL_CPSW_3GF_getPortTimeSyncVlanLTypeReg (portNum, &tsLtype1, &tsLtype2);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getPortTimeSyncVlanLTypeReg (
    Uint32                      portNum,                
    Uint32*                     pTsVlanLtype1,                
    Uint32*                     pTsVlanLtype2
)
{
    *pTsVlanLtype1  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_VLAN_LTYPE_REG) & (0x0000FFFFu)) >> (0x00000000u));
    *pTsVlanLtype2  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_VLAN_LTYPE_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setPortTimeSyncVlanLTypeReg
 *
 *   @b Description
 *   @n This function sets up the contents of Time Sync VLAN LTYPE   
 *      register corresponding to the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the register must be read.
        tsVlanLtype1            Time sync VLAN LTYPE1 value to be configured.
        tsVlanLtype2            Time sync VLAN LTYPE2 value to be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1,
 *      CPSW_3GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2
 *
 *   @b Example
 *   @verbatim
 *      Uint32              portNum, tsLtype1, tsLtype2;
 
        portNum     =   1;
        tsLtype1    =   0x8100;
        tsLtype2    =   0x8100;
 
        CSL_CPSW_3GF_setPortTimeSyncVlanLTypeReg (portNum, &tsLtype1, &tsLtype2);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setPortTimeSyncVlanLTypeReg (
    Uint32                      portNum,                
    Uint32                      tsVlanLtype1,                
    Uint32                      tsVlanLtype2
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_VLAN_LTYPE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_VLAN_LTYPE_REG) & ~(0x0000FFFFu)) | (((tsVlanLtype1) << (0x00000000u)) & (0x0000FFFFu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_VLAN_LTYPE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_INFO_GROUP[portNum]. P_TS_VLAN_LTYPE_REG) & ~(0xFFFF0000u)) | (((tsVlanLtype2) << (0x00000010u)) & (0xFFFF0000u)));

    return;
}


/********************************************************************************
*************************  Statistics (STATS) Submodule *************************
********************************************************************************/

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getStats
 *
 *   @b Description
 *   @n The CPSW stats are divided into 2 blocks, i.e., Stats for Host port (switch Port 0) 
 *      and Stats for MAC ports (Port 1 and Port2). This function retreives hardware 
 *      statistics for both the stat blocks.
 *
 *   @b Arguments
     @verbatim
        pCpswStats              Array of CSL_CPSW_3GF_STATS structure that needs to be filled
                                with the stats read from the hardware. This function expects
                                that the array passed to it is big enough to hold the stats
                                for both stat blocks, i.e., size of array passed to this 
                                function must be 2.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_RXGOODFRAMES,
 *      CPSW_RXBROADCASTFRAMES,
 *      CPSW_RXMULTICASTFRAMES,
 *      CPSW_RXPAUSEFRAMES,
 *      CPSW_RXCRCERRORS,
 *      CPSW_RXALIGNCODEERRORS,
 *      CPSW_RXOVERSIZEDFRAMES,
 *      CPSW_RXJABBERFRAMES,
 *      CPSW_RXUNDERSIZEDFRAMES,
 *      CPSW_RXFRAGMENTS,
 *      CPSW_RXOCTETS,
 *      CPSW_TXGOODFRAMES,
 *      CPSW_TXBROADCASTFRAMES,
 *      CPSW_TXMULTICASTFRAMES,
 *      CPSW_TXPAUSEFRAMES,
 *      CPSW_TXDEFERREDFRAMES,
 *      CPSW_TXCOLLISIONFRAMES,
 *      CPSW_TXSINGLECOLLFRAMES,
 *      CPSW_TXMULTCOLLFRAMES,
 *      CPSW_TXEXCESSIVECOLLISIONS,
 *      CPSW_TXLATECOLLISIONS,
 *      CPSW_TXUNDERRUN,
 *      CPSW_TXCARRIERSENSEERRORS,
 *      CPSW_TXOCTETS,
 *      CPSW_OCTETFRAMES64,
 *      CPSW_OCTETFRAMES65T127,
 *      CPSW_OCTETFRAMES128T255,
 *      CPSW_OCTETFRAMES256T511,
 *      CPSW_OCTETFRAMES512T1023,
 *      CPSW_OCTETFRAMES1024TUP,
 *      CPSW_NETOCTETS,
 *      CPSW_RXSOFOVERRUNS,
 *      CPSW_RXMOFOVERRUNS,
 *      CPSW_RXDMAOVERRUNS
 *
 *   @b Affects
 *   @n CPSW_RXGOODFRAMES=0,
 *      CPSW_RXBROADCASTFRAMES=0,
 *      CPSW_RXMULTICASTFRAMES=0,
 *      CPSW_RXPAUSEFRAMES=0,
 *      CPSW_RXCRCERRORS=0,
 *      CPSW_RXALIGNCODEERRORS=0,
 *      CPSW_RXOVERSIZEDFRAMES=0,
 *      CPSW_RXJABBERFRAMES=0,
 *      CPSW_RXUNDERSIZEDFRAMES=0,
 *      CPSW_RXFRAGMENTS=0,
 *      CPSW_RXOCTETS=0,
 *      CPSW_TXGOODFRAMES=0,
 *      CPSW_TXBROADCASTFRAMES=0,
 *      CPSW_TXMULTICASTFRAMES=0,
 *      CPSW_TXPAUSEFRAMES=0,
 *      CPSW_TXDEFERREDFRAMES=0,
 *      CPSW_TXCOLLISIONFRAMES=0,
 *      CPSW_TXSINGLECOLLFRAMES=0,
 *      CPSW_TXMULTCOLLFRAMES=0,
 *      CPSW_TXEXCESSIVECOLLISIONS=0,
 *      CPSW_TXLATECOLLISIONS=0,
 *      CPSW_TXUNDERRUN=0,
 *      CPSW_TXCARRIERSENSEERRORS=0,
 *      CPSW_TXOCTETS=0,
 *      CPSW_OCTETFRAMES64=0,
 *      CPSW_OCTETFRAMES65T127=0,
 *      CPSW_OCTETFRAMES128T255=0,
 *      CPSW_OCTETFRAMES256T511=0,
 *      CPSW_OCTETFRAMES512T1023=0,
 *      CPSW_OCTETFRAMES1024TUP=0,
 *      CPSW_NETOCTETS=0,
 *      CPSW_RXSOFOVERRUNS=0,
 *      CPSW_RXMOFOVERRUNS=0,
 *      CPSW_RXDMAOVERRUNS=0
 *
 *   @b Example
 *   @verbatim
 *      CSL_CPSW_3GF_STATS     stats [2];
 
        CSL_CPSW_3GF_getStats (stats);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getStats (
    CSL_CPSW_3GF_STATS*         pCpswStats                
)
{
    Uint32                      numStats, numBlocks;
    volatile Uint32             *pRegAddr;
    Uint32                      *pStatAddr;
    Uint32                      statval;

    pStatAddr   =   (Uint32 *)(pCpswStats);

    /* Read the entire stats block for both the
     * Host and the MAC ports and reset the stats
     * block when done.
     */
    for (numBlocks = 0; numBlocks < 2; numBlocks++)
    {
    	pRegAddr    =	&((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->PORT_STATS_GROUP [numBlocks].RXGOODFRAMES;    	
        for (numStats = 0; numStats < 36; numStats++)
        {
            statval         =   *pRegAddr;
            *pRegAddr++     =   statval;
            statval         +=  *pStatAddr;
            *pStatAddr++    =   statval;
        }
    }

    return;
}


/********************************************************************************
********************  Address Lookup Engine (ALE) Submodule *********************
********************************************************************************/

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleVersionInfo
 *
 *   @b Description
 *   @n This function retrieves the ALE submodule identification and version 
 *      information.
 *
 *   @b Arguments
     @verbatim
        pVersionInfo        CSL_CPSW_3GF_ALE_VERSION structure that needs to be populated
                            with the ALE version info read from the hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_ID_REG_ALE_MINOR_VER,
 *      CPSW_3GF_ALE_ID_REG_ALE_MAJOR_VER,
 *      CPSW_3GF_ALE_ID_REG_ALE_IDENT
 *
 *   @b Example
 *   @verbatim
        CSL_CPSW_3GF_ALE_VERSION    versionInfo;

        CSL_CPSW_3GF_getAleVersionInfo (&versionInfo);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleVersionInfo (
	CSL_CPSW_3GF_ALE_VERSION*       pVersionInfo     
)
{

    pVersionInfo->minorVer  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_ID_REG) & (0x000000FFu)) >> (0x00000000u));
    pVersionInfo->majorVer  =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_ID_REG) & (0x0000FF00u)) >> (0x00000008u));
    pVersionInfo->id        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_ID_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleRateLimitEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE Broadcast and Multicast Rate Limit is
 *      enabled.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE Broadcast and multicast rate limit enabled.
 *	                            Broadcast/multicast packet reception limited to
 *	                            port control register rate limit fields.
 *	 @n  FALSE                  ALE Broadcast and multicast rate limit disabled. 
 *	                            Broadcast/multicast rates not limited.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleRateLimitEnabled () == TRUE)
        {
            // ALE Broadcast/Multicast rate limit enabled
        }
        else
        {
            // ALE Broadcast/Multicast rate limit disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleRateLimitEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAleRateLimit
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable multicast,
 *      broadcast rate limiting.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAleRateLimit ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAleRateLimit (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAleRateLimit
 *
 *   @b Description
 *   @n This function configures the ALE control register to disable multicast,
 *      broadcast rate limiting.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAleRateLimit ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAleRateLimit (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleMacAuthModeEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE MAC Authorization mode is enabled.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE  is in MAC authorization mode.
 *	 @n  FALSE                  ALE not in MAC authorization mode. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleMacAuthModeEnabled () == TRUE)
        {
            // ALE  is in MAC authorization mode
        }
        else
        {
            // ALE not in MAC authorization mode
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleMacAuthModeEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x00000002u)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAleMacAuthMode
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable MAC authorization
 *      mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAleMacAuthMode ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAleMacAuthMode (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAleMacAuthMode
 *
 *   @b Description
 *   @n This function configures the ALE control register to disable MAC authorization
 *      mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAleMacAuthMode ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAleMacAuthMode (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000002u)) | (((0) << (0x00000001u)) & (0x00000002u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleVlanAwareEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE is programmed to be VLAN aware.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE VLAN aware. ALE drops packets if VLAN not found.
 *	 @n  FALSE                  ALE not VLAN aware. Floods if VLAN not found.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_ALE_VLAN_AWARE
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleVlanAwareEnabled () == TRUE)
        {
            // ALE VLAN aware
        }
        else
        {
            // ALE not VLAN aware
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleVlanAwareEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x00000004u)) >> (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAleVlanAware
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable VLAN aware
 *      mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ALE_VLAN_AWARE=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAleVlanAware ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAleVlanAware (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000004u)) | (((1) << (0x00000002u)) & (0x00000004u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAleVlanAware
 *
 *   @b Description
 *   @n This function configures the ALE control register to disable VLAN aware
 *      mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ALE_VLAN_AWARE=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAleVlanAware ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAleVlanAware (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000004u)) | (((0) << (0x00000002u)) & (0x00000004u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleTxRateLimitEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE is programmed to be Tx rate limited.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE Tx rate limit enabled. Broadcast, multicast
 *	                            rate limit counters are transmit port based.
 *	 @n  FALSE                  ALE Tx rate limit disabled. Broadcast, multicast
 *	                            rate limit counters are receive port based.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_RATE_LIMIT_TX
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleTxRateLimitEnabled () == TRUE)
        {
            // ALE Tx rate limit on
        }
        else
        {
            // ALE Tx rate limit off
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleTxRateLimitEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x00000008u)) >> (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAleTxRateLimit
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable Tx rate limiting.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_RATE_LIMIT_TX=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAleTxRateLimit ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAleTxRateLimit (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000008u)) | (((1) << (0x00000003u)) & (0x00000008u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAleTxRateLimit
 *
 *   @b Description
 *   @n This function configures the ALE control register to disable Tx rate limiting.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_RATE_LIMIT_TX=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAleTxRateLimit ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAleTxRateLimit (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000008u)) | (((0) << (0x00000003u)) & (0x00000008u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleBypassEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE is programmed to be in Bypass mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE Bypass mode enabled.
 *	 @n  FALSE                  ALE Bypass mode disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_ALE_BYPASS
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleBypassEnabled () == TRUE)
        {
            // ALE Bypass mode on
        }
        else
        {
            // ALE Bypass mode off
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleBypassEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x00000010u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAleBypass
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable Bypass mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ALE_BYPASS=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAleBypass ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAleBypass (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000010u)) | (((1) << (0x00000004u)) & (0x00000010u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAleBypass
 *
 *   @b Description
 *   @n This function configures the ALE control register to disable Bypass mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ALE_BYPASS=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAleBypass ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAleBypass (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000010u)) | (((0) << (0x00000004u)) & (0x00000010u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleOUIDenyModeEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE is programmed to be in OUI deny mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE OUI deny mode enabled.
 *	 @n  FALSE                  ALE OUI deny mode disabled. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_OUI_DENY
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleOUIDenyModeEnabled () == TRUE)
        {
            // ALE OUI deny mode on
        }
        else
        {
            // ALE OUI deny mode off
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleOUIDenyModeEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x00000020u)) >> (0x00000005u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAleOUIDenyMode
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable OUI deny mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_OUI_DENY=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAleOUIDenyMode ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAleOUIDenyMode (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000020u)) | (((1) << (0x00000005u)) & (0x00000020u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAleOUIDenyMode
 *
 *   @b Description
 *   @n This function configures the ALE control register to disable OUI deny mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_OUI_DENY=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAleOUIDenyMode ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAleOUIDenyMode (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000020u)) | (((0) << (0x00000005u)) & (0x00000020u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleVID0ModeEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE is programmed to be in VID0 (VLAN ID=0) mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE VID0 mode enabled. 
 *	                            Process the packet with VLAN Id = 0
 *	 @n  FALSE                  ALE VID0 mode disabled. Process the packet with 
 *	                            VLAN Id =PORT_VLAN[11-0]
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_EN_VID0_MODE
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleVID0ModeEnabled () == TRUE)
        {
            // ALE VID0 mode on
        }
        else
        {
            // ALE VID0 mode off
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleVID0ModeEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x00000040u)) >> (0x00000006u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAleVID0Mode
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable VID0 mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_EN_VID0_MODE=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAleVID0Mode ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAleVID0Mode (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000040u)) | (((1) << (0x00000006u)) & (0x00000040u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAleVID0Mode
 *
 *   @b Description
 *   @n This function configures the ALE control register to disable VID0 mode.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_EN_VID0_MODE=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAleVID0Mode ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAleVID0Mode (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000040u)) | (((0) << (0x00000006u)) & (0x00000040u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleLearnNoVIDEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE is programmed to not learn VLAN Ids.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE Learn no VID enabled. 
 *	                            VLAN Id is not learned with source address (source 
 *	                            address is not tied to VID)
 *	 @n  FALSE                  ALE VID learning mode enabled. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_LEARN_NO_VID
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleLearnNoVIDEnabled () == TRUE)
        {
            // ALE VID learning disabled
        }
        else
        {
            // ALE VID learning enabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleLearnNoVIDEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x00000080u)) >> (0x00000007u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAleLearnNoVID
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable VLAN Id No
 *      Learn, i.e., disable VLAN Id learning.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_LEARN_NO_VID=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAleLearnNoVID ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAleLearnNoVID (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000080u)) | (((1) << (0x00000007u)) & (0x00000080u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAleLearnNoVID
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable VLAN Id learning.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_LEARN_NO_VID=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAleLearnNoVID ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAleLearnNoVID (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x00000080u)) | (((0) << (0x00000007u)) & (0x00000080u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_startAleAgeOutNow
 *
 *   @b Description
 *   @n This function configures the ALE control register to initiate an ALE
 *      ageable entry cleanup. This enables the ALE hardware to remove any
 *      ageable table entry that does not have a set touch bit.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_AGE_OUT_NOW=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_startAleAgeOutNow ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_startAleAgeOutNow (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x20000000u)) | (((1) << (0x0000001Du)) & (0x20000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleAgeOutDone
 *
 *   @b Description
 *   @n This function reads the ALE control register's AGE_OUT_NOW bit to check
 *      if the ALE ageable entry cleanup process is done.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE age out process done. 
 *	 @n  FALSE                  ALE age out process not yet completed.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_AGE_OUT_NOW
 *
 *   @b Example
 *   @verbatim
 
        if (CSL_CPSW_3GF_isAleAgeOutDone ();
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleAgeOutDone (void)
{
    if (((((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x20000000u)) >> (0x0000001Du)) == 0))
    {
        return 1;
    }
    else
    {
        return 0;            
    }
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_clearAleTable
 *
 *   @b Description
 *   @n This function initiates a full ALE table cleanup. The ALE hardware 
 *      clears all table entries. 
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_CLEAR_TABLE=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_clearAleTable ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_clearAleTable (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x40000000u)) | (((1) << (0x0000001Eu)) & (0x40000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_isAleEnabled
 *
 *   @b Description
 *   @n This function indicates if ALE processing is enabled.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   ALE enabled. ALE packet processing will be done.
 *	 @n  FALSE                  ALE disabled. All packets are dropped by ALE.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_ALE
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPSW_3GF_isAleEnabled () == TRUE)
        {
            // ALE enabled
        }
        else
        {
            // ALE disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_isAleEnabled (void)
{

    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & (0x80000000u)) >> (0x0000001Fu));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_enableAle
 *
 *   @b Description
 *   @n This function configures the ALE control register to enable ALE processing.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_ALE=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_enableAle ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_enableAle (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x80000000u)) | ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_disableAle
 *
 *   @b Description
 *   @n This function configures the ALE control register to disable ALE processing.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG_ENABLE_ALE=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPSW_3GF_disableAle ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_disableAle (void)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG) & ~(0x80000000u)) | (((0) << (0x0000001Fu)) & (0x80000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleControlReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the ALE control register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 >=0                ALE control register contents.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_CONTROL_REG
 *
 *   @b Example
 *   @verbatim
        Uint32      aleCtrlVal;
 
        aleCtrlVal  =   CSL_CPSW_3GF_getAleControlReg ();
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_getAleControlReg (void)
{
    return ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleControlReg
 *
 *   @b Description
 *   @n This function sets up the contents of the ALE control register.
 *
 *   @b Arguments
     @verbatim
        aleCtrlVal          Value to be configured to the ALE control register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_CONTROL_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32          aleCtrlVal = 0;

        aleCtrlVal      =   CSL_CPSW_3GF_getAleControlReg ();
        aleCtrlVal      |=  CSL_CPSW_3GF_ALECONTROL_CLRTABLE_EN;

        CSL_CPSW_3GF_setAleControlReg (&aleCtrlRegInfo);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleControlReg 
(
    Uint32                      aleCtrlVal
)
{
    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_CONTROL_REG  =   aleCtrlVal;

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAlePrescaleReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the ALE Prescale register.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 >=0                ALE prescale register contents.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_PRESCALE_REG_ALE_PRESCALE
 *
 *   @b Example
 *   @verbatim
        Uint32      alePrescaleVal;
 
        alePrescaleVal  =   CSL_CPSW_3GF_getAlePrescaleReg ();
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPSW_3GF_getAlePrescaleReg (void)
{
    return (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PRESCALE_REG) & (0x000FFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAlePrescaleReg
 *
 *   @b Description
 *   @n This function sets up the contents of the ALE prescale register.
 *
 *   @b Arguments
     @verbatim
        alePrescaleVal      Value to be configured to the ALE Prescale register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_PRESCALE_REG_ALE_PRESCALE
 *
 *   @b Example
 *   @verbatim
 *      Uint32          alePrescaleVal = 0;

        alePrescaleVal  =   10;

        CSL_CPSW_3GF_setAlePrescaleReg (&aleCtrlRegInfo);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAlePrescaleReg 
(
    Uint32                      alePrescaleVal
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PRESCALE_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PRESCALE_REG) & ~(0x000FFFFFu)) | (((alePrescaleVal) << (0x00000000u)) & (0x000FFFFFu)));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleUnkownVlanReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the ALE Unknown VLAN register.
 *
 *   @b Arguments
     @verbatim
        pUnVlanMemList          Unknown VLAN member list.
        pUnMcastFloodMask       Unknown VLAN Multicast flood mask.
        pUnRegMcastFloodMask    Unknown VLAN Registered Multicast Flood mask.
        pUnForceUntagEgress     Unknown VLAN Force Untagged Egress.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_VLAN_MEMBER_LIST,
 *      CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_MCAST_FLOOD_MASK,
 *      CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_REG_MCAST_FLOOD_MASK,
 *      CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_FORCE_UNTAGGED_EGRESS
 *
 *   @b Example
 *   @verbatim
        Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;
 
        CSL_CPSW_3GF_getAleUnkownVlanReg (&unVlanMemList, 
                                          &unMcastFloodMask,
                                          &unRegMcastFloodMask,
                                          &unForceUntagEgress);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleUnkownVlanReg
(
    Uint32*                        pUnVlanMemList,
    Uint32*                        pUnMcastFloodMask,
    Uint32*                        pUnRegMcastFloodMask,
    Uint32*                        pUnForceUntagEgress
)
{
    *pUnVlanMemList         =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) & (0x0000003Fu)) >> (0x00000000u));
    *pUnMcastFloodMask      =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) & (0x00003F00u)) >> (0x00000008u));
    *pUnRegMcastFloodMask   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) & (0x003F0000u)) >> (0x00000010u));
    *pUnForceUntagEgress    =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) & (0x3F000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleUnkownVlanReg
 *
 *   @b Description
 *   @n This function sets up the contents of the ALE Unknown VLAN register.
 *
 *   @b Arguments
     @verbatim
        unVlanMemList           Unknown VLAN member list.
        unMcastFloodMask        Unknown VLAN Multicast flood mask.
        unRegMcastFloodMask     Unknown VLAN Registered Multicast Flood mask.
        unForceUntagEgress      Unknown VLAN Force Untagged Egress.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_VLAN_MEMBER_LIST,
 *      CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_MCAST_FLOOD_MASK,
 *      CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_REG_MCAST_FLOOD_MASK,
 *      CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_FORCE_UNTAGGED_EGRESS
 *
 *   @b Example
 *   @verbatim
        Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

        unVlanMemList           =   0;
        unMcastFloodMask        =   3;
        unRegMcastFloodMask     =   0;
        unForceUntagEgress      =   0;
 
        CSL_CPSW_3GF_setAleUnkownVlanReg (unVlanMemList, 
                                          unMcastFloodMask,
                                          unRegMcastFloodMask,
                                          unForceUntagEgress);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleUnkownVlanReg
(
    Uint32                      unVlanMemList,
    Uint32                      unMcastFloodMask,
    Uint32                      unRegMcastFloodMask,
    Uint32                      unForceUntagEgress
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) & ~(0x0000003Fu)) | (((unVlanMemList) << (0x00000000u)) & (0x0000003Fu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) & ~(0x00003F00u)) | (((unMcastFloodMask) << (0x00000008u)) & (0x00003F00u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) & ~(0x003F0000u)) | (((unRegMcastFloodMask) << (0x00000010u)) & (0x003F0000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_UNKNOWN_VLAN_REG) & ~(0x3F000000u)) | (((unForceUntagEgress) << (0x00000018u)) & (0x3F000000u)));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleTableEntry
 *
 *   @b Description
 *   @n This function retrieves an ALE table entry corresponding to the 
 *      ALE entry index specified in 'index' input parameter. The ALE
 *      entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and
 *      ALE_TBLW2 registers are returned in 'pAleInfoWd0', 'pAleInfoWd1', 'pAleInfoWd2'
 *      output parameters.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
        pAleInfoWd0             Contents of ALE Table Word 0 Register (ALE_TBLW0).
        pAleInfoWd1             Contents of ALE Table Word 1 Register (ALE_TBLW1).
        pAleInfoWd2             Contents of ALE Table Word 2 Register (ALE_TBLW2).
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD0_REG_ENTRY_31_0,
 *      CPSW_3GF_ALE_TABLE_WORD1_REG_ENTRY_63_32,
 *      CPSW_3GF_ALE_TABLE_WORD2_REG_ENTRY_71_64
 *
 *   @b Example
 *   @verbatim
        Uint32      index, info0, info1, info2;

        index   =   0;
 
        CSL_CPSW_3GF_getAleUnkownVlanReg (index, 
                                          &info0,
                                          &info1,
                                          &info2);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleTableEntry
(
    Uint32                      index,
    Uint32*                     pAleInfoWd0,
    Uint32*                     pAleInfoWd1,
    Uint32*                     pAleInfoWd2
)
{
    Uint32                      aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;

    /* Read the ALE table word registers */
    *pAleInfoWd0            =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) & (0xFFFFFFFFu)) >> (0x00000000u));
    *pAleInfoWd1            =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) & (0xFFFFFFFFu)) >> (0x00000000u));
    *pAleInfoWd2            =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) & (0x000000FFu)) >> (0x00000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleTableEntry
 *
 *   @b Description
 *   @n This function sets up an ALE table entry corresponding to the 
 *      ALE entry index specified in 'index' input parameter. The ALE
 *      entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and
 *      ALE_TBLW2 registers msut be specified in 'aleInfoWd0', 'aleInfoWd1', 'aleInfoWd2'
 *      input parameters.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be written.
        aleInfoWd0              Value to write to ALE Table Word 0 Register (ALE_TBLW0).
        aleInfoWd1              Value to write to Table Word 1 Register (ALE_TBLW1).
        aleInfoWd2              Value to write to ALE Table Word 2 Register (ALE_TBLW2).
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_WORD0_REG_ENTRY_31_0,
 *      CPSW_3GF_ALE_TABLE_WORD1_REG_ENTRY_63_32,
 *      CPSW_3GF_ALE_TABLE_WORD2_REG_ENTRY_71_64,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1
 *      
 *
 *   @b Example
 *   @verbatim
        Uint32      index, info0, info1, info2;

        index   =   0;
        info0   =   ...;
        info1   =   ...;
        info2   =   ...;
 
        CSL_CPSW_3GF_setAleTableEntry (index, 
                                          info0,
                                          info1,
                                          info2);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleTableEntry
(
    Uint32                      index,
    Uint32                      aleInfoWd0,
    Uint32                      aleInfoWd1,
    Uint32                      aleInfoWd2
)
{
    Uint32                      aleTblCtrlVal   =   0;

    /* Set the ALE table word registers */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) & ~(0xFFFFFFFFu)) | (((aleInfoWd0) << (0x00000000u)) & (0xFFFFFFFFu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) & ~(0xFFFFFFFFu)) | (((aleInfoWd1) << (0x00000000u)) & (0xFFFFFFFFu)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) & ~(0x000000FFu)) | (((aleInfoWd2) << (0x00000000u)) & (0x000000FFu)));

    /* Set the index in the ALE table to "write" operation and let
     * the hardware set up the ALE table entry corresponding to index
     * specified.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getALEEntryType
 *
 *   @b Description
 *   @n This function returns the ALE entry type for any given ALE table
 *      entry index.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  CSL_CPSW_3GF_ALE_ENTRYTYPE
 *	 @n	 ALE_ENTRYTYPE_FREE             ALE entry is free.
 *	 @n  ALE_ENTRYTYPE_ADDRESS          ALE entry contains a unicast/multicast address.
 *	 @n  ALE_ENTRYTYPE_VLAN             VLAN ALE entry.
 *	 @n  ALE_ENTRYTYPE_VLANADDRESS      VLAN Address Entry. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD1_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
        if (CSL_CPSW_3GF_getALEEntryType () == ALE_ENTRYTYPE_FREE)
        {
            // ALE entry free
        }
	 @endverbatim
 * =============================================================================
 */
static inline CSL_CPSW_3GF_ALE_ENTRYTYPE CSL_CPSW_3GF_getALEEntryType 
(
    Uint32                      index
)
{
    Uint32                      aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;

    return (CSL_CPSW_3GF_ALE_ENTRYTYPE) (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (28)) & ((1 << ((29) - (28) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getALEAddressType
 *
 *   @b Description
 *   @n This function returns the address type of an ALE entry.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  CSL_CPSW_3GF_ALE_ADDRTYPE
 *	 @n	 ALE_ADDRTYPE_UCAST         Address at this entry is unicast
 *	 @n  ALE_ADDRTYPE_MCAST         Address at this entry is multicast 
 *	 @n  ALE_ADDRTYPE_OUI           Address at this entry is OUI address
 *
 *   <b> Pre Condition </b>
 *   @n  This function must be called only for an ALE address entry, i.e., 
 *       if @a CSL_CPSW_3GF_getALEEntryType () returns ALE_ENTRYTYPE_ADDRESS
 *       or ALE_ENTRYTYPE_VLANADDRESS only.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD0_REG,
 *      CPSW_3GF_ALE_TABLE_WORD1_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
        {
            // ALE entry has an address

            if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
            {
                // Unicast address
            }
        }
        else
        {
            // Do nothing
        }

        ...
	 @endverbatim
 * =============================================================================
 */
static inline CSL_CPSW_3GF_ALE_ADDRTYPE CSL_CPSW_3GF_getALEAddressType 
(
    Uint32                      index
)
{
    Uint32                      aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;

    if ((((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (0)) & ((1 << ((23) - (0) + 1)) - 1)) == 0)            
    {
        /* Lower 24 bits of Word 0 are all zeros for an OUI address */            
        return  ALE_ADDRTYPE_OUI;             
    }

    if (((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG & (1 << 8))            
    {
        /* 40th bit of MAC address is 1 for a multicast address. */
        return  ALE_ADDRTYPE_MCAST;
    }
    else
    {
        return  ALE_ADDRTYPE_UCAST;
    }
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleMcastAddrEntry
 *
 *   @b Description
 *   @n This function reads the ALE table entry for the index specified and
 *      fills the output parameter structure with Multicast address configuration
 *      read from the hardware.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
        pMcastAddrCfg           ALE entry contents read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                              index;
        CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

        index   =   0;
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
        {
            // ALE entry has an address

            if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
            {
                // Read Multicast address config from hardware
                CSL_CPSW_3GF_getAleMcastAddrEntry (index, &mcastAddrCfg);
            }
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleMcastAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY*       pMcastAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG =   aleTblCtrlVal;

    /* Read the multicast address configuration */
    pMcastAddrCfg->macAddress[0]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pMcastAddrCfg->macAddress[1]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pMcastAddrCfg->macAddress[2]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (24)) & ((1 << ((31) - (24) + 1)) - 1));
    pMcastAddrCfg->macAddress[3]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (16)) & ((1 << ((23) - (16) + 1)) - 1));
    pMcastAddrCfg->macAddress[4]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pMcastAddrCfg->macAddress[5]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pMcastAddrCfg->mcastFwdState        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (30)) & ((1 << ((31) - (30) + 1)) - 1));    
    pMcastAddrCfg->superEnable          =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (1)) & ((1 << ((1) - (1) + 1)) - 1));
    pMcastAddrCfg->portMask             =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (2)) & ((1 << ((4) - (2) + 1)) - 1));
                
    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleMcastAddrEntry
 *
 *   @b Description
 *   @n This function sets up the ALE table entry for the index specified with 
 *      Multicast address configuration specified here.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index.
        pMcastAddrCfg           ALE entry contents to be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1
 *      CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                              index;
        CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

        index   =   0;
        mcastAddrCfg.macAddress [0] = 0x00;
        mcastAddrCfg.macAddress [1] = 0x01;
        ...
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
        {
            // ALE entry is free

            // Add Multicast address entry
            CSL_CPSW_3GF_setAleMcastAddrEntry (index, &mcastAddrCfg);
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleMcastAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY*       pMcastAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Setup the multicast address configuration */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pMcastAddrCfg->macAddress[0]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pMcastAddrCfg->macAddress[1]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((31) - (24) + 1)) - 1) << (24))) | (((pMcastAddrCfg->macAddress[2]) & ((1 << ((31) - (24) + 1)) - 1)) << (24)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((23) - (16) + 1)) - 1) << (16))) | (((pMcastAddrCfg->macAddress[3]) & ((1 << ((23) - (16) + 1)) - 1)) << (16)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pMcastAddrCfg->macAddress[4]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pMcastAddrCfg->macAddress[5]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((31) - (30) + 1)) - 1) << (30))) | (((pMcastAddrCfg->mcastFwdState) & ((1 << ((31) - (30) + 1)) - 1)) << (30)));    
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((1) - (1) + 1)) - 1) << (1))) | (((pMcastAddrCfg->superEnable) & ((1 << ((1) - (1) + 1)) - 1)) << (1)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((4) - (2) + 1)) - 1) << (2))) | (((pMcastAddrCfg->portMask) & ((1 << ((4) - (2) + 1)) - 1)) << (2)));

    /* set entry type to address entry */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((29) - (28) + 1)) - 1) << (28))) | (((1) & ((1 << ((29) - (28) + 1)) - 1)) << (28)));
    
    /* Set the index in the ALE table to "write" operation and let
     * the hardware set up the ALE table entry corresponding to index
     * specified.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;    

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleVlanMcastAddrEntry
 *
 *   @b Description
 *   @n This function reads the ALE table entry for the index specified and
 *      fills the output parameter structure with VLAN Multicast address configuration
 *      read from the hardware.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
        pVlanMcastAddrCfg       ALE entry contents read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

        index   =   0;
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
        {
            // ALE entry has a VLAN address

            if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
            {
                // Read VLAN Multicast address config from hardware
                CSL_CPSW_3GF_getAleVlanMcastAddrEntry (index, &vlanMcastAddrCfg);
            }
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleVlanMcastAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY*   pVlanMcastAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG =   aleTblCtrlVal;

    /* Read the multicast address configuration */
    pVlanMcastAddrCfg->macAddress[0]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pVlanMcastAddrCfg->macAddress[1]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pVlanMcastAddrCfg->macAddress[2]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (24)) & ((1 << ((31) - (24) + 1)) - 1));
    pVlanMcastAddrCfg->macAddress[3]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (16)) & ((1 << ((23) - (16) + 1)) - 1));
    pVlanMcastAddrCfg->macAddress[4]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pVlanMcastAddrCfg->macAddress[5]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pVlanMcastAddrCfg->vlanId               =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (16)) & ((1 << ((27) - (16) + 1)) - 1));
    pVlanMcastAddrCfg->mcastFwdState        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (30)) & ((1 << ((31) - (30) + 1)) - 1));    
    pVlanMcastAddrCfg->superEnable          =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (1)) & ((1 << ((1) - (1) + 1)) - 1));
    pVlanMcastAddrCfg->portMask             =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (2)) & ((1 << ((4) - (2) + 1)) - 1));
                
    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleVlanMcastAddrEntry
 *
 *   @b Description
 *   @n This function sets up the ALE table entry for the index specified with 
 *      VLAN Multicast address configuration specified here.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index.
        pVlanMcastAddrCfg       ALE entry contents to be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1
 *      CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

        index   =   0;
        vlanMcastAddrCfg.macAddress [0] = 0x00;
        vlanMcastAddrCfg.macAddress [1] = 0x01;
        ...
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
        {
            // ALE entry is free

            // Add VLAN Multicast address entry
            CSL_CPSW_3GF_setAleVlanMcastAddrEntry (index, &vlanMcastAddrCfg);
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleVlanMcastAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY*   pVlanMcastAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Setup the VLAN multicast address configuration */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pVlanMcastAddrCfg->macAddress[0]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pVlanMcastAddrCfg->macAddress[1]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((31) - (24) + 1)) - 1) << (24))) | (((pVlanMcastAddrCfg->macAddress[2]) & ((1 << ((31) - (24) + 1)) - 1)) << (24)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((23) - (16) + 1)) - 1) << (16))) | (((pVlanMcastAddrCfg->macAddress[3]) & ((1 << ((23) - (16) + 1)) - 1)) << (16)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pVlanMcastAddrCfg->macAddress[4]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pVlanMcastAddrCfg->macAddress[5]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((27) - (16) + 1)) - 1) << (16))) | (((pVlanMcastAddrCfg->vlanId) & ((1 << ((27) - (16) + 1)) - 1)) << (16)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((31) - (30) + 1)) - 1) << (30))) | (((pVlanMcastAddrCfg->mcastFwdState) & ((1 << ((31) - (30) + 1)) - 1)) << (30)));    
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((1) - (1) + 1)) - 1) << (1))) | (((pVlanMcastAddrCfg->superEnable) & ((1 << ((1) - (1) + 1)) - 1)) << (1)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((4) - (2) + 1)) - 1) << (2))) | (((pVlanMcastAddrCfg->portMask) & ((1 << ((4) - (2) + 1)) - 1)) << (2)));
    
    /* set entry type to VLAN address entry */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((29) - (28) + 1)) - 1) << (28))) | (((3) & ((1 << ((29) - (28) + 1)) - 1)) << (28)));
    
    /* Set the index in the ALE table to "write" operation and let
     * the hardware set up the ALE table entry corresponding to index
     * specified.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;    

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleUnicastAddrEntry
 *
 *   @b Description
 *   @n This function reads the ALE table entry for the index specified and
 *      fills the output parameter structure with Unicast address configuration
 *      read from the hardware.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
        pUcastAddrCfg           ALE entry contents read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

        index   =   0;
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
        {
            // ALE entry has an address

            if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
            {
                // Read Unicast address config from hardware
                CSL_CPSW_3GF_getAleUnicastAddrEntry (index, &ucastAddrCfg);
            }
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleUnicastAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY*     pUcastAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG =   aleTblCtrlVal;

    /* Read the multicast address configuration */
    pUcastAddrCfg->macAddress[0]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pUcastAddrCfg->macAddress[1]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pUcastAddrCfg->macAddress[2]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (24)) & ((1 << ((31) - (24) + 1)) - 1));
    pUcastAddrCfg->macAddress[3]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (16)) & ((1 << ((23) - (16) + 1)) - 1));
    pUcastAddrCfg->macAddress[4]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pUcastAddrCfg->macAddress[5]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pUcastAddrCfg->ucastType            =   (CSL_CPSW_3GF_ALE_UCASTTYPE) (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (30)) & ((1 << ((31) - (30) + 1)) - 1));
    pUcastAddrCfg->secureEnable         =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (0)) & ((1 << ((0) - (0) + 1)) - 1));    
    pUcastAddrCfg->blockEnable          =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (1)) & ((1 << ((1) - (1) + 1)) - 1));
    pUcastAddrCfg->portNumber           =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (2)) & ((1 << ((3) - (2) + 1)) - 1));
                
    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleUnicastAddrEntry
 *
 *   @b Description
 *   @n This function sets up the ALE table entry for the index specified with 
 *      unicast address configuration specified here.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index.
        pUcastAddrCfg           ALE entry contents to be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1
 *      CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

        index   =   0;
        ucastAddrCfg.macAddress [0] = 0x00;
        ucastAddrCfg.macAddress [1] = 0x01;
        ...
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
        {
            // ALE entry is free

            // Add Unicast address entry
            CSL_CPSW_3GF_setAleUnicastAddrEntry (index, &ucastAddrCfg);
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleUnicastAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY*     pUcastAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Setup the Unicast address configuration */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pUcastAddrCfg->macAddress[0]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pUcastAddrCfg->macAddress[1]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((31) - (24) + 1)) - 1) << (24))) | (((pUcastAddrCfg->macAddress[2]) & ((1 << ((31) - (24) + 1)) - 1)) << (24)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((23) - (16) + 1)) - 1) << (16))) | (((pUcastAddrCfg->macAddress[3]) & ((1 << ((23) - (16) + 1)) - 1)) << (16)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pUcastAddrCfg->macAddress[4]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pUcastAddrCfg->macAddress[5]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((31) - (30) + 1)) - 1) << (30))) | (((pUcastAddrCfg->ucastType) & ((1 << ((31) - (30) + 1)) - 1)) << (30)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((0) - (0) + 1)) - 1) << (0))) | (((pUcastAddrCfg->secureEnable) & ((1 << ((0) - (0) + 1)) - 1)) << (0)));    
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((1) - (1) + 1)) - 1) << (1))) | (((pUcastAddrCfg->blockEnable) & ((1 << ((1) - (1) + 1)) - 1)) << (1)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((3) - (2) + 1)) - 1) << (2))) | (((pUcastAddrCfg->portNumber) & ((1 << ((3) - (2) + 1)) - 1)) << (2)));
    
    /* set entry type to address entry */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((29) - (28) + 1)) - 1) << (28))) | (((1) & ((1 << ((29) - (28) + 1)) - 1)) << (28)));
    
    /* Set the index in the ALE table to "write" operation and let
     * the hardware set up the ALE table entry corresponding to index
     * specified.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;    

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleOUIAddrEntry
 *
 *   @b Description
 *   @n This function reads the ALE table entry for the index specified and
 *      fills the output parameter structure with OUI address configuration
 *      read from the hardware.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
        pOUIAddrCfg             ALE entry contents read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_OUIADDR_ENTRY          ouiAddrCfg;

        index   =   0;
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
        {
            // ALE entry has an address

            if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
            {
                // Read Unicast address config from hardware
                CSL_CPSW_3GF_getAleOUIAddrEntry (index, &ouiAddrCfg);
            }
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleOUIAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_OUIADDR_ENTRY*         pOUIAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG =   aleTblCtrlVal;

    /* Read the multicast address configuration */
    pOUIAddrCfg->ouiAddress[0]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pOUIAddrCfg->ouiAddress[1]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pOUIAddrCfg->ouiAddress[2]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (24)) & ((1 << ((31) - (24) + 1)) - 1));
    pOUIAddrCfg->ucastType            =   (CSL_CPSW_3GF_ALE_UCASTTYPE) (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (30)) & ((1 << ((31) - (30) + 1)) - 1));
                
    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleOUIAddrEntry
 *
 *   @b Description
 *   @n This function sets up the ALE table entry for the index specified with 
 *      OUI address configuration specified here.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index.
        pOUIAddrCfg             ALE entry contents to be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1
 *      CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_OUIADDR_ENTRY          ouiAddrCfg;

        index   =   0;
        ouiAddrCfg.ouiAddress [0] = 0x00;
        ouiAddrCfg.ouiAddress [1] = 0x01;
        ...
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
        {
            // ALE entry is free

            // Add OUI address entry
            CSL_CPSW_3GF_setAleOUIAddrEntry (index, &ouiAddrCfg);
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleOUIAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_OUIADDR_ENTRY*         pOUIAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Setup the Unicast address configuration */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pOUIAddrCfg->ouiAddress[0]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pOUIAddrCfg->ouiAddress[1]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((31) - (24) + 1)) - 1) << (24))) | (((pOUIAddrCfg->ouiAddress[2]) & ((1 << ((31) - (24) + 1)) - 1)) << (24)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((31) - (30) + 1)) - 1) << (30))) | (((pOUIAddrCfg->ucastType) & ((1 << ((31) - (30) + 1)) - 1)) << (30)));
    
    /* set entry type to address entry */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((29) - (28) + 1)) - 1) << (28))) | (((1) & ((1 << ((29) - (28) + 1)) - 1)) << (28)));
    
    /* Set the index in the ALE table to "write" operation and let
     * the hardware set up the ALE table entry corresponding to index
     * specified.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;    

    return;
}


/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleVlanUnicastAddrEntry
 *
 *   @b Description
 *   @n This function reads the ALE table entry for the index specified and
 *      fills the output parameter structure with VLAN Unicast address configuration
 *      read from the hardware.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
        pVlanUcastAddrCfg       ALE entry contents read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

        index   =   0;
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
        {
            // ALE entry has a VLAN address

            if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
            {
                // Read VLAN Unicast address config from hardware
                CSL_CPSW_3GF_getAleVlanUnicastAddrEntry (index, &ucvlanUcastAddrCfgastAddrCfg);
            }
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleVlanUnicastAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY* pVlanUcastAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG =   aleTblCtrlVal;

    /* Read the multicast address configuration */
    pVlanUcastAddrCfg->macAddress[0]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pVlanUcastAddrCfg->macAddress[1]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pVlanUcastAddrCfg->macAddress[2]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (24)) & ((1 << ((31) - (24) + 1)) - 1));
    pVlanUcastAddrCfg->macAddress[3]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (16)) & ((1 << ((23) - (16) + 1)) - 1));
    pVlanUcastAddrCfg->macAddress[4]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (8)) & ((1 << ((15) - (8) + 1)) - 1));
    pVlanUcastAddrCfg->macAddress[5]        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (0)) & ((1 << ((7) - (0) + 1)) - 1));
    pVlanUcastAddrCfg->vlanId               =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (16)) & ((1 << ((27) - (16) + 1)) - 1));
    pVlanUcastAddrCfg->ucastType            =   (CSL_CPSW_3GF_ALE_UCASTTYPE) (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (30)) & ((1 << ((31) - (30) + 1)) - 1));
    pVlanUcastAddrCfg->secureEnable         =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (0)) & ((1 << ((0) - (0) + 1)) - 1));    
    pVlanUcastAddrCfg->blockEnable          =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (1)) & ((1 << ((1) - (1) + 1)) - 1));
    pVlanUcastAddrCfg->portNumber           =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) >> (2)) & ((1 << ((3) - (2) + 1)) - 1));
                
    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleVlanUnicastAddrEntry
 *
 *   @b Description
 *   @n This function sets up the ALE table entry for the index specified with 
 *      VLAN unicast address configuration specified here.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index.
        pVlanUcastAddrCfg       ALE entry contents to be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1
 *      CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

        index   =   0;
        vlanUcastAddrCfg.macAddress [0] = 0x00;
        vlanUcastAddrCfg.macAddress [1] = 0x01;
        ...
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
        {
            // ALE entry is free

            // Add VLAN Unicast address entry
            CSL_CPSW_3GF_setAleVlanUnicastAddrEntry (index, &vlanUcastAddrCfg);
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleVlanUnicastAddrEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY* pVlanUcastAddrCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Setup the VLAN Unicast address configuration */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pVlanUcastAddrCfg->macAddress[0]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pVlanUcastAddrCfg->macAddress[1]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((31) - (24) + 1)) - 1) << (24))) | (((pVlanUcastAddrCfg->macAddress[2]) & ((1 << ((31) - (24) + 1)) - 1)) << (24)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((23) - (16) + 1)) - 1) << (16))) | (((pVlanUcastAddrCfg->macAddress[3]) & ((1 << ((23) - (16) + 1)) - 1)) << (16)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((15) - (8) + 1)) - 1) << (8))) | (((pVlanUcastAddrCfg->macAddress[4]) & ((1 << ((15) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((7) - (0) + 1)) - 1) << (0))) | (((pVlanUcastAddrCfg->macAddress[5]) & ((1 << ((7) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((27) - (16) + 1)) - 1) << (16))) | (((pVlanUcastAddrCfg->vlanId) & ((1 << ((27) - (16) + 1)) - 1)) << (16)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((31) - (30) + 1)) - 1) << (30))) | (((pVlanUcastAddrCfg->ucastType) & ((1 << ((31) - (30) + 1)) - 1)) << (30)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((0) - (0) + 1)) - 1) << (0))) | (((pVlanUcastAddrCfg->secureEnable) & ((1 << ((0) - (0) + 1)) - 1)) << (0)));    
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((1) - (1) + 1)) - 1) << (1))) | (((pVlanUcastAddrCfg->blockEnable) & ((1 << ((1) - (1) + 1)) - 1)) << (1)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG) &~ (((1 << ((3) - (2) + 1)) - 1) << (2))) | (((pVlanUcastAddrCfg->portNumber) & ((1 << ((3) - (2) + 1)) - 1)) << (2)));
    
    /* set entry type to address entry */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((29) - (28) + 1)) - 1) << (28))) | (((3) & ((1 << ((29) - (28) + 1)) - 1)) << (28)));
    
    /* Set the index in the ALE table to "write" operation and let
     * the hardware set up the ALE table entry corresponding to index
     * specified.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;    

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAleVlanEntry
 *
 *   @b Description
 *   @n This function reads the ALE table entry for the index specified and
 *      fills the output parameter structure with VLAN configuration
 *      read from the hardware.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index to be read.
        pVlanCfg                ALE entry contents read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_VLAN_ENTRY             vlanCfg;

        index   =   0;
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_VLAN)
        {
            // ALE entry has a VLAN configuration
            CSL_CPSW_3GF_getAleVlanEntry (index, &vlanCfg);
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAleVlanEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_VLAN_ENTRY*            pVlanCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Set the index in the ALE table to "read" operation and let
     * the hardware load the ALE table entry corresponding to index
     * specified into the ALE table word registers.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                (((0) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG =   aleTblCtrlVal;

    /* Read the multicast address configuration */
    pVlanCfg->vlanMemList                   =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (0)) & ((1 << ((2) - (0) + 1)) - 1));
    pVlanCfg->unRegMcastFloodMask           =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (8)) & ((1 << ((10) - (8) + 1)) - 1));
    pVlanCfg->regMcastFloodMask             =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (16)) & ((1 << ((18) - (16) + 1)) - 1));
    pVlanCfg->forceUntaggedEgress           =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) >> (24)) & ((1 << ((26) - (24) + 1)) - 1));
    pVlanCfg->vlanId                        =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) >> (16)) & ((1 << ((27) - (16) + 1)) - 1));
                
    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAleVlanEntry
 *
 *   @b Description
 *   @n This function sets up the ALE table entry for the index specified with 
 *      VLAN configuration specified here.
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index.
        pVlanCfg                ALE entry contents to be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1
 *      CPSW_3GF_ALE_TABLE_WORD0,
 *      CPSW_3GF_ALE_TABLE_WORD1,
 *      CPSW_3GF_ALE_TABLE_WORD2
 *
 *   @b Example
 *   @verbatim
        Uint32                                  index;
        CSL_CPSW_3GF_ALE_VLAN_ENTRY             vlanCfg;

        index   =   0;
        vlanCfg.vlanId  = 0x10;
        ...
 
        if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
        {
            // ALE entry is free

            // Add VLAN entry
            CSL_CPSW_3GF_setAleVlanEntry (index, &vlanCfg);
        }
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAleVlanEntry
(
    Uint32                                  index,
    CSL_CPSW_3GF_ALE_VLAN_ENTRY*            pVlanCfg
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Setup the Unicast address configuration */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((2) - (0) + 1)) - 1) << (0))) | (((pVlanCfg->vlanMemList) & ((1 << ((2) - (0) + 1)) - 1)) << (0)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((10) - (8) + 1)) - 1) << (8))) | (((pVlanCfg->unRegMcastFloodMask) & ((1 << ((10) - (8) + 1)) - 1)) << (8)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((18) - (16) + 1)) - 1) << (16))) | (((pVlanCfg->regMcastFloodMask) & ((1 << ((18) - (16) + 1)) - 1)) << (16)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG) &~ (((1 << ((26) - (24) + 1)) - 1) << (24))) | (((pVlanCfg->forceUntaggedEgress) & ((1 << ((26) - (24) + 1)) - 1)) << (24)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((27) - (16) + 1)) - 1) << (16))) | (((pVlanCfg->vlanId) & ((1 << ((27) - (16) + 1)) - 1)) << (16)));
    
    /* set entry type to VLAN entry */
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG) &~ (((1 << ((29) - (28) + 1)) - 1) << (28))) | (((2) & ((1 << ((29) - (28) + 1)) - 1)) << (28)));
    
    /* Set the index in the ALE table to "write" operation and let
     * the hardware set up the ALE table entry corresponding to index
     * specified.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;    

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_clearAleEntry
 *
 *   @b Description
 *   @n This function clears the ALE entry corresponding to the index 
 *      specified
 *
 *   @b Arguments
     @verbatim
        index                   ALE table index.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER,
 *      CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1
 *      CPSW_3GF_ALE_TABLE_WORD0=0,
 *      CPSW_3GF_ALE_TABLE_WORD1=0,
 *      CPSW_3GF_ALE_TABLE_WORD2=0
 *
 *   @b Example
 *   @verbatim
        Uint32                              index;

        index   =   0;

        CSL_CPSW_3GF_clearAleEntry (index);
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_clearAleEntry
(
    Uint32                                  index
)
{
    Uint32                                  aleTblCtrlVal   =   0;

    /* Clear all the ALE words */
    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD0_REG   =   0;
    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD1_REG   =   0;
    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_WORD2_REG   =   0;
    
    /* Set the index in the ALE table to "write" operation and let
     * the hardware set up the ALE table entry corresponding to index
     * specified.
     */
    aleTblCtrlVal           =   (((index) << (0x00000000u)) & (0x000003FFu)) |
                                ((((Uint32) 1) << (0x0000001Fu)) & (0x80000000u));

    ((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_TABLE_CONTROL_REG    =   aleTblCtrlVal;    

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_getAlePortControlReg
 *
 *   @b Description
 *   @n This function retrieves the contents of ALE Port control register
 *      corresponding to the port number specified.
 *
 *   @b Arguments
     @verbatim
        portNo                  Port number for which the ALE port control register
                                must be read.
        pPortControlInfo        CSL_CPSW_3GF_ALE_PORTCONTROL structure that needs to be 
                                filled with Port control register info read from
                                the hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSW_3GF_ALE_PORT_CONTROL_REG_PORT_STATE,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_DROP_UNTAGGED,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_VID_INGRESS_CHECK,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_NO_LEARN,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_MCAST_LIMIT,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_BCAST_LIMIT
 *
 *   @b Example
 *   @verbatim
        Uint32                          index;
        CSL_CPSW_3GF_ALE_PORTCONTROL    portControlInfo;

        index   =   0;
 
        CSL_CPSW_3GF_getAlePortControlReg (index, &portControlInfo);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_getAlePortControlReg
(
    Uint32                          portNo,
    CSL_CPSW_3GF_ALE_PORTCONTROL*   pPortControlInfo
)
{
    pPortControlInfo->portState             =   (CSL_CPSW_3GF_ALE_PORTSTATE) (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & (0x00000003u)) >> (0x00000000u));
    pPortControlInfo->dropUntaggedEnable    =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & (0x00000004u)) >> (0x00000002u));
    pPortControlInfo->vidIngressCheckEnable =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & (0x00000008u)) >> (0x00000003u));
    pPortControlInfo->noLearnModeEnable     =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & (0x00000010u)) >> (0x00000004u));
    pPortControlInfo->mcastLimit            =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & (0x00FF0000u)) >> (0x00000010u));
    pPortControlInfo->bcastLimit            =   (((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & (0xFF000000u)) >> (0x00000018u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPSW_3GF_setAlePortControlReg
 *
 *   @b Description
 *   @n This function sets up the contents of ALE Port control register
 *      corresponding to the port number specified.
 *
 *   @b Arguments
     @verbatim
        portNo                  Port number for which the ALE port control register
                                must be configured.
        pPortControlInfo        CSL_CPSW_3GF_ALE_PORTCONTROL structure that contains 
                                port control register settings to be written.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPSW_3GF_ALE_PORT_CONTROL_REG_PORT_STATE,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_DROP_UNTAGGED,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_VID_INGRESS_CHECK,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_NO_LEARN,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_MCAST_LIMIT,
 *      CPSW_3GF_ALE_PORT_CONTROL_REG_BCAST_LIMIT
 *
 *   @b Example
 *   @verbatim
        Uint32                          index;
        CSL_CPSW_3GF_ALE_PORTCONTROL    portControlInfo;

        index   =   0;
        portControlInfo.portState   =   ALE_PORTSTATE_FORWARD |
                                        ALE_PORTSTATE_LEARN;
 
        CSL_CPSW_3GF_setAlePortControlReg (index, &portControlInfo);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPSW_3GF_setAlePortControlReg
(
    Uint32                          portNo,
    CSL_CPSW_3GF_ALE_PORTCONTROL*   pPortControlInfo
)
{
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & ~(0x00000003u)) | (((pPortControlInfo->portState) << (0x00000000u)) & (0x00000003u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & ~(0x00000004u)) | (((pPortControlInfo->dropUntaggedEnable) << (0x00000002u)) & (0x00000004u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & ~(0x00000008u)) | (((pPortControlInfo->vidIngressCheckEnable) << (0x00000003u)) & (0x00000008u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & ~(0x00000010u)) | (((pPortControlInfo->noLearnModeEnable) << (0x00000004u)) & (0x00000010u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & ~(0x00FF0000u)) | (((pPortControlInfo->mcastLimit) << (0x00000010u)) & (0x00FF0000u)));
    ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) = ((((CSL_Cpsw_3gfRegs *) ((0x02000000) + 0x00090800))->ALE_PORT_CONTROL_REG [portNo]) & ~(0xFF000000u)) | (((pPortControlInfo->bcastLimit) << (0x00000018u)) & (0xFF000000u)));

    return;
}



/**
@}
*/
/**  
 * @file  csl_cpgmac_slAux.h
 *
 * @brief  
 *  API Auxilary header file for Ethernet MAC submodule CSL.
 *
 *  Contains the different control command and status query functions definations
 *   
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/**  
 * @file  csl_cpgmac_sl.h
 *
 * @brief  
 *  Header file containing various enumerations, structure definitions and function 
 *  declarations for the CP GMAC Sliver submodule (CPGMAC_SL) of EMAC.
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* Modified by CSL team for:
 *
 *      (1) Added padding in the 'CSL_Cpgmac_slRegs' structure
 *          to offset correctly to the next Sliver port start address.
 *      (2) Header files are included to be RTSC compliant
 */



/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/

typedef struct  {
    volatile Uint32 IDVER_REG;
    volatile Uint32 MACCONTROL_REG;
    volatile Uint32 MACSTATUS_REG;
    volatile Uint32 SOFT_RESET_REG;
    volatile Uint32 RX_MAXLEN_REG;
    volatile Uint8  RSVD0[4];
    volatile Uint32 RX_PAUSE_REG;
    volatile Uint32 TX_PAUSE_REG;
    volatile Uint32 EMCONTROL_REG;
    volatile Uint32 PRI_MAP_REG;

    volatile Uint8  RSVD1[24];

} CSL_Cpgmac_slRegs;

/* Modified by CSL team for:
 *
 *      (2) Defined a new structure to encapsulate the 2 Sliver ports.
 *          (CSL_Cpgmac_slPortRegs)
 */
typedef struct  {
    CSL_Cpgmac_slRegs   SL_PORT [2];        
} CSL_Cpgmac_slPortRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* idver_reg */






/* maccontrol_reg */


















/* macstatus_reg */







/* soft_reset_reg */



/* rx_maxlen_reg */



/* rx_pause_reg */



/* tx_pause_reg */



/* emcontrol_reg */




/* pri_map_reg */











/** ============================================================================ 
 *
 * @defgroup CSL_CPGMAC_SL_API GMAC Sliver submodule (CPGMAC_SL)
 * @ingroup CSL_CPSW_API
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * @subsection References
 *    -# Ethernet Media Access Controller User Guide
 * ============================================================================
 */         
/**
@defgroup CSL_CPGMAC_SL_SYMBOL  CPGMAC_SL Symbols Defined
@ingroup CSL_CPGMAC_SL_API
*/
/**
@defgroup CSL_CPGMAC_SL_DATASTRUCT  CPGMAC_SL Data Structures
@ingroup CSL_CPGMAC_SL_API
*/
/**
@defgroup CSL_CPGMAC_SL_FUNCTION  CPGMAC_SL Functions
@ingroup CSL_CPGMAC_SL_API
*/
/**
@defgroup CSL_CPGMAC_SL_ENUM CPGMAC_SL Enumerated Data Types
@ingroup CSL_CPGMAC_SL_API
*/

/**
@addtogroup CSL_CPGMAC_SL_SYMBOL
@{
*/

/**
@}
*/

/** @addtogroup CSL_CPGMAC_SL_DATASTRUCT
 @{ */

/** Constants for passing parameters to the functions.
 */
/** @brief Pointer to the EMAC overlay registers */

/** @brief MAC control register configuration definitions */       

/** Enable full duplex mode */

/** Enable loopback mode */

/** Enable Rx flow control mode */

/** Enable Tx flow control mode */

/** Enable GMII */

/** Enable Tx pacing */

/** Enable Gigabit mode */

/** Enable Tx short gap */

/** Enable idle mode */

/** Set IFCTL_A bit to 1 */

/** Set IFCTL_B bit to 1 */

/** Enable forced Gigabit mode */

/** Enable external control mode */

/** Enable Rx copy error frames mode */

/** Enable Rx copy short frames mode */

/** Enable Rx copy MAC control frames mode */

/** @brief      
 *
 *  Holds the Sliver submodule's version info. 
 */        
typedef struct {
	/**  Minor version value */	
	Uint32      minorVer;

	/**  Major version value */	
	Uint32      majorVer;

	/**  RTL version value */	
	Uint32      rtlVer;

	/**  Identification value */	
	Uint32      id;
} CSL_CPGMAC_SL_VERSION;        

/** @brief      
 *
 *  Holds MAC status register contents. 
 */        
typedef struct {
	/** Transmit flow control active? */	
	Uint32      txFlowActive;

	/** Receive flow control active? */	
	Uint32      rxFlowActive;

	/**  External full duplex input set? */	
	Uint32      extFullDuplexEnabled;

	/**  External gigabit input set? */	
	Uint32      extGigabitEnabled;

	/**  Is MAC idle? */	
	Uint32      idleEnabled;
} CSL_CPGMAC_SL_MACSTATUS;


/**
@}
*/


/** @addtogroup CSL_CPGMAC_SL_FUNCTION
 @{ */

/**
@}
*/



/**
@}
*/


/** @addtogroup CSL_CPGMAC_SL_FUNCTION
@{ */


/********************************************************************************
*************** Ethernet Media Access Controller (EMAC) Submodule ***************
********************************************************************************/

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_getMacVersionInfo
 *
 *   @b Description
 *   @n This function retrieves the MAC submodule identification and 
 *      version information for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the source MAC address
                                must be read and returned.
        pVersionInfo            CSL_CPGMAC_SL_VERSION structure that needs to be populated
                                with the version info read from the hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_IDVER_REG_Y,
 *      CPGMAC_SL_IDVER_REG_X,
 *      CPGMAC_SL_IDVER_REG_Z,
 *      CPGMAC_SL_IDVER_REG_IDENT
 *
 *   @b Example
 *   @verbatim
        CSL_CPGMAC_SL_VERSION    versionInfo, portNum;
 
        portNum =   1;

        CSL_CPGMAC_SL_getMacVersionInfo (portNum, &versionInfo);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_getMacVersionInfo 
(
    Uint32                      portNum,                
	CSL_CPGMAC_SL_VERSION*      pVersionInfo     
)
{

    pVersionInfo->minorVer  =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. IDVER_REG) & (0x000000FFu)) >> (0x00000000u));
    pVersionInfo->majorVer  =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. IDVER_REG) & (0x00000700u)) >> (0x00000008u));
    pVersionInfo->rtlVer    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. IDVER_REG) & (0x0000F800u)) >> (0x0000000Bu));
    pVersionInfo->id        =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. IDVER_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isFullDuplexEnabled
 *
 *   @b Description
 *   @n This function indicates if Full duplex mode is enabled in the
 *      MAC control register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must retrieve the 
                                settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Full duplex mode enabled
 *	 @n  FALSE                  Half duplex mode enabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_FULLDUPLEX
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum;
 
        portNum =   1;
        if (CSL_CPGMAC_SL_isFullDuplexEnabled (portNum) == TRUE)
        {
            // full duplex mode enabled
        }
        else
        {
            // full duplex mode disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isFullDuplexEnabled 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableFullDuplex
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable full duplex
 *      mode for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_FULLDUPLEX=1
 *
 *   @b Example
 *   @verbatim
 *      Uint32      portNum =   1;
 
        CSL_CPGMAC_SL_enableFullDuplex (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableFullDuplex 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableFullDuplex
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable full duplex
 *      mode for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_FULLDUPLEX=0
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum = 1;
 
        CSL_CPGMAC_SL_disableFullDuplex (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableFullDuplex 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isLoopbackModeEnabled
 *
 *   @b Description
 *   @n This function indicates if loopback mode is enabled in the
 *      MAC control register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Internal full duplex lopoback mode enabled
 *	 @n  FALSE                  Loopback mode disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_LOOPBACK
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum = 1;
 
        if (CSL_CPGMAC_SL_isLoopbackModeEnabled (portNum) == TRUE)
        {
            // loopback mode enabled
        }
        else
        {
            // loopback mode disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isLoopbackModeEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000002u)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableLoopback
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable lopback mode
 *      for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_LOOPBACK=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum = 1;

        CSL_CPGMAC_SL_enableLoopback (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableLoopback 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableLoopback
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable loopback
 *      mode for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_LOOPBACK=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_disableLoopback (portNum);
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableLoopback 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000002u)) | (((0) << (0x00000001u)) & (0x00000002u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isRxFlowControlEnabled
 *
 *   @b Description
 *   @n This function indicates if receive flow control is enabled in the
 *      MAC control register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Receive flow control enabled
 *	 @n  FALSE                  Receive flow control disabled
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_FLOW_EN
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum = 1;
        
        if (CSL_CPGMAC_SL_isRxFlowControlEnabled (portNum) == TRUE)
        {
            // rx flow control enabled
        }
        else
        {
            // rx flow control disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isRxFlowControlEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000008u)) >> (0x00000003u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableRxFlowControl
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable receive flow
 *      control for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_FLOW_EN=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_enableRxFlowControl (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableRxFlowControl 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000008u)) | (((1) << (0x00000003u)) & (0x00000008u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableRxFlowControl
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable Receive
 *      flow control mode for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_FLOW_EN=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_disableRxFlowControl (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableRxFlowControl 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000008u)) | (((0) << (0x00000003u)) & (0x00000008u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isTxFlowControlEnabled
 *
 *   @b Description
 *   @n This function indicates if transmit flow control is enabled in the
 *      MAC control register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Transmit flow control enabled
 *	 @n  FALSE                  Transmit flow control disabled
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_FLOW_EN
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum =   1;
 
        if (CSL_CPGMAC_SL_isTxFlowControlEnabled (portNum) == TRUE)
        {
            // tx flow control enabled
        }
        else
        {
            // tx flow control disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isTxFlowControlEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000010u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableTxFlowControl
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable transmit 
 *      flow control for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_FLOW_EN=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_enableTxFlowControl (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableTxFlowControl 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000010u)) | (((1) << (0x00000004u)) & (0x00000010u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableTxFlowControl
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable Transmit
 *      flow control for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_FLOW_EN=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_disableTxFlowControl (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableTxFlowControl 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000010u)) | (((0) << (0x00000004u)) & (0x00000010u)));

    return;
}


/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isGMIIEnabled
 *
 *   @b Description
 *   @n This function indicates if GMII is enabled in the MAC control register
 *      for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   GMII enabled
 *	 @n  FALSE                  GMII disabled
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_GMII_EN
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum =   1; 
 
        if (CSL_CPGMAC_SL_isGMIIEnabled (portNum) == TRUE)
        {
            // gmii enabled
        }
        else
        {
            // gmii disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isGMIIEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000020u)) >> (0x00000005u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableGMII
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable GMII for the
 *      MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_GMII_EN=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_enableGMII (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableGMII 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000020u)) | (((1) << (0x00000005u)) & (0x00000020u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableGMII
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable GMII for the
 *      MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_GMII_EN=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_disableGMII (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableGMII 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000020u)) | (((0) << (0x00000005u)) & (0x00000020u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isTxPaceEnabled
 *
 *   @b Description
 *   @n This function indicates if transmit pacing is enabled in the MAC 
 *      control register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Transmit pacing enabled
 *	 @n  FALSE                  Transmit pacing disabled
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_PACE
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum =   1;
 
        if (CSL_CPGMAC_SL_isTxPaceEnabled (portNum) == TRUE)
        {
            // tx pacing enabled
        }
        else
        {
            // tx pacing disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isTxPaceEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000040u)) >> (0x00000006u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableTxPace
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable transmit 
 *      pacing for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_PACE=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum = 1;

        CSL_CPGMAC_SL_enableTxPace (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableTxPace 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000040u)) | (((1) << (0x00000006u)) & (0x00000040u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableTxPace
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable transmit
 *      pacing for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_PACE=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum = 1; 

        CSL_CPGMAC_SL_disableTxPace (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableTxPace 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000040u)) | (((0) << (0x00000006u)) & (0x00000040u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isGigabitEnabled
 *
 *   @b Description
 *   @n This function indicates if Gigabit mode is enabled in the MAC 
 *      control register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Gigabit mode enabled
 *	 @n  FALSE                  Gigabit disabled. 10/100 mode enabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_GIG
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum = 1;
 
        if (CSL_CPGMAC_SL_isGigabitEnabled (portNum) == TRUE)
        {
            // gig enabled
        }
        else
        {
            // gig disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isGigabitEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000080u)) >> (0x00000007u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableGigabit
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable Gigabit 
 *      mode (full duplex only) for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_GIG=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1;

        CSL_CPGMAC_SL_enableGigabit (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableGigabit 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000080u)) | (((1) << (0x00000007u)) & (0x00000080u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableGigabit
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable Gigabit mode
 *      for MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_GIG=0
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1;

        CSL_CPGMAC_SL_disableGigabit (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableGigabit 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000080u)) | (((0) << (0x00000007u)) & (0x00000080u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isTxShortGapEnabled
 *
 *   @b Description
 *   @n This function indicates if Transmit short gap is enabled in the MAC 
 *      control register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Transmit short gap with a short IPG enabled
 *	 @n  FALSE                  Transmit short gap disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_SHORT_GAP_ENABLE
 *
 *   @b Example
 *   @verbatim
 *      Uint32 portNum  =   1;
 
        if (CSL_CPGMAC_SL_isTxShortGapEnabled (portNum) == TRUE)
        {
            // Tx short gap enabled
        }
        else
        {
            // Tx short gap disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isTxShortGapEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000400u)) >> (0x0000000Au));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableTxShortGap
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable transmit short
 *      gap for MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_SHORT_GAP_ENABLE=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum  =   1; 

        CSL_CPGMAC_SL_enableTxShortGap (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableTxShortGap 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000400u)) | (((1) << (0x0000000Au)) & (0x00000400u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableTxShortGap
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable transmit
 *      short gap for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_TX_SHORT_GAP_ENABLE=0
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum  =   1; 
        
        CSL_CPGMAC_SL_disableTxShortGap (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableTxShortGap 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000400u)) | (((0) << (0x0000000Au)) & (0x00000400u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isIdleModeEnabled
 *
 *   @b Description
 *   @n This function indicates if Idle mode is enabled in the MAC 
 *      control register for MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Idle mode enabled
 *	 @n  FALSE                  Idle mode disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_CMD_IDLE
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum = 1;
 
        if (CSL_CPGMAC_SL_isTxShortGapEnabled (portNum) == TRUE)
        {
            // idle mode enabled
        }
        else
        {
            // idle mode disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isIdleModeEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00000800u)) >> (0x0000000Bu));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableIdleMode
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable Idle mode for
 *      MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_CMD_IDLE=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum  =   1; 

        CSL_CPGMAC_SL_enableIdleMode (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableIdleMode 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000800u)) | (((1) << (0x0000000Bu)) & (0x00000800u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableIdleMode
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable Idle mode for
 *      MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_CMD_IDLE=0
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1; 

        CSL_CPGMAC_SL_disableIdleMode (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableIdleMode 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00000800u)) | (((0) << (0x0000000Bu)) & (0x00000800u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isIFCTLAEnabled
 *
 *   @b Description
 *   @n This function indicates if IFCTL_A bit is set in the MAC 
 *      control register for MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   IFCTL_A bit in MAC control register is set to 1.
 *	 @n  FALSE                  IFCTL_A bit in MAC control register reads 0.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_IFCTL_A
 *
 *   @b Example
 *   @verbatim
 *      Uint32 portNum  =   1;
        
        if (CSL_CPGMAC_SL_isIFCTLAEnabled (portNum) == TRUE)
        {
            // IFCTL_A bit set
        }
        else
        {
            // IFCTL_A bit cleared
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isIFCTLAEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00008000u)) >> (0x0000000Fu));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableIFCTLA
 *
 *   @b Description
 *   @n This function enables the IFCTL_A bit in the MAC control register for MAC
 *      port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_IFCTL_A=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum  =   1; 
        
        CSL_CPGMAC_SL_enableIFCTLA (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableIFCTLA 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00008000u)) | (((1) << (0x0000000Fu)) & (0x00008000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableIFCTLA
 *
 *   @b Description
 *   @n This function configures the MAC control register to clear the IFCTL_A
 *      bit for MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_IFCTL_A=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_disableIFCTLA (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableIFCTLA 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00008000u)) | (((0) << (0x0000000Fu)) & (0x00008000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isIFCTLBEnabled
 *
 *   @b Description
 *   @n This function indicates if IFCTL_B bit is set in the MAC 
 *      control register for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   IFCTL_B bit in MAC control register is set to 1.
 *	 @n  FALSE                  IFCTL_B bit in MAC control register reads 0.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_IFCTL_B
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        if (CSL_CPGMAC_SL_isIFCTLBEnabled (portNum) == TRUE)
        {
            // IFCTL_B bit set
        }
        else
        {
            // IFCTL_B bit cleared
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isIFCTLBEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00010000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableIFCTLB
 *
 *   @b Description
 *   @n This function enables the IFCTL_B bit in the MAC control register for the 
 *      MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_IFCTL_B=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_enableIFCTLB (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableIFCTLB 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00010000u)) | (((1) << (0x00000010u)) & (0x00010000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableIFCTLB
 *
 *   @b Description
 *   @n This function configures the MAC control register to clear the IFCTL_B
 *      bit for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_IFCTL_B=0
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1; 

        CSL_CPGMAC_SL_disableIFCTLB (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableIFCTLB 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00010000u)) | (((0) << (0x00000010u)) & (0x00010000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isGigForceModeEnabled
 *
 *   @b Description
 *   @n This function indicates if Gigabit mode force bit is enabled in the MAC 
 *      control register for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Gigabit mode force enabled.
 *	 @n  FALSE                  Gigabit mode force disabled. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_GIG_FORCE
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        if (CSL_CPGMAC_SL_isGigForceModeEnabled (portNum) == TRUE)
        {
            // gig mode force enabled
        }
        else
        {
            // gig mode force disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isGigForceModeEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00020000u)) >> (0x00000011u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableGigForceMode
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable Gigabit 
 *      force mode for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_GIG_FORCE=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_enableGigForceMode (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableGigForceMode 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00020000u)) | (((1) << (0x00000011u)) & (0x00020000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableGigForceMode
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable Gigabit 
 *      force mode for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_GIG_FORCE=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_CPGMAC_SL_disableGigForceMode (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableGigForceMode 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00020000u)) | (((0) << (0x00000011u)) & (0x00020000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isExtControlEnabled
 *
 *   @b Description
 *   @n This function indicates if EXT_EN bit is enabled in the MAC control 
 *      register for the MAC port specified. When this bit is set to 1, the Gigabit 
 *      and Full duplex mode input is taken from an external source and not from 
 *      the settings configured in this register.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   External control mode enabled.
 *	 @n  FALSE                  External control mode disabled. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_CTL_EN
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum =   1;
 
        if (CSL_CPGMAC_SL_isExtControlEnabled (portNum) == TRUE)
        {
            // external control mode enabled
        }
        else
        {
            // external control mode disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isExtControlEnabled 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00040000u)) >> (0x00000012u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableExtControl
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable external
 *      control of the Gigabit and full duplex mode settings.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_CTL_EN=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum  =   1;

        CSL_CPGMAC_SL_enableExtControl (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableExtControl 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00040000u)) | (((1) << (0x00000012u)) & (0x00040000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableExtControl
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable external 
 *      control of the Gigabit and full duplex settings.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_CTL_EN=0
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum  =   1; 

        CSL_CPGMAC_SL_disableExtControl (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableExtControl 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00040000u)) | (((0) << (0x00000012u)) & (0x00040000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isRxCEFEnabled
 *
 *   @b Description
 *   @n This function indicates if MAC control register is programmed to copy
 *      frames containing errors to its memory.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Copy Error frames mode enabled. Error frames
 *	                            will be transferred to memory.
 *	 @n  FALSE                  Copy Error frames mode disabled. Error frames
 *	                            will be filtered. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CEF_EN
 *
 *   @b Example
 *   @verbatim
 *      Uint32  portNum =   1;
 
        if (CSL_CPGMAC_SL_isRxCEFEnabled (portNum) == TRUE)
        {
            // Rx CEF enabled
        }
        else
        {
            // Rx CEF disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isRxCEFEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00400000u)) >> (0x00000016u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableRxCEF
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable transfer
 *      of frames containing errors.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CEF_EN=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1; 

        CSL_CPGMAC_SL_enableRxCEF (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableRxCEF 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00400000u)) | (((1) << (0x00000016u)) & (0x00400000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableRxCEF
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable any error
 *      frames being transferred to the memory.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CEF_EN=0
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1; 

        CSL_CPGMAC_SL_disableRxCEF (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableRxCEF 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00400000u)) | (((0) << (0x00000016u)) & (0x00400000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isRxCSFEnabled
 *
 *   @b Description
 *   @n This function indicates if MAC control register is programmed to copy
 *      short frames (frames shorter than 64 bytes) to its memory.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Copy Short frames mode enabled. Short frames
 *	                            will be transferred to memory.
 *	 @n  FALSE                  Copy Short frames mode disabled. Short frames
 *	                            will be filtered. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CSF_EN
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1;
    
        if (CSL_CPGMAC_SL_isRxCSFEnabled (portNum) == TRUE)
        {
            // Rx CSF enabled
        }
        else
        {
            // Rx CSF disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isRxCSFEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x00800000u)) >> (0x00000017u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableRxCSF
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable transfer
 *      of frames that are shorter than 64 bytes.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CSF_EN=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1;
        
        CSL_CPGMAC_SL_enableRxCSF (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableRxCSF 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00800000u)) | (((1) << (0x00000017u)) & (0x00800000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableRxCSF
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable any short
 *      frames being transferred to the memory.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CSF_EN=0
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1; 

        CSL_CPGMAC_SL_disableRxCSF (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableRxCSF 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x00800000u)) | (((0) << (0x00000017u)) & (0x00800000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isRxCMFEnabled
 *
 *   @b Description
 *   @n This function indicates if MAC control register is programmed to copy
 *      MAC Control Frames to its memory.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Copy MAC control frames mode enabled. MAC control 
 *	                            frames will be transferred to memory.
 *	 @n  FALSE                  Copy MAC control frames mode disabled. MAC control
 *	                            frames will be filtered. 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CMF_EN
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1;

        if (CSL_CPGMAC_SL_isRxCMFEnabled (portNum) == TRUE)
        {
            // Rx CMF enabled
        }
        else
        {
            // Rx CMF disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isRxCMFEnabled 
(
    Uint32                      portNum
)
{

    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & (0x01000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_enableRxCMF
 *
 *   @b Description
 *   @n This function configures the MAC control register to enable transfer
 *      of MAC control frames.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CMF_EN=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum = 1; 

        CSL_CPGMAC_SL_enableRxCMF (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_enableRxCMF 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x01000000u)) | (((1) << (0x00000018u)) & (0x01000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_disableRxCMF
 *
 *   @b Description
 *   @n This function configures the MAC control register to disable any MAC control
 *      frames being transferred to the memory.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG_RX_CMF_EN=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1; 

        CSL_CPGMAC_SL_disableRxCMF (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_disableRxCMF 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. MACCONTROL_REG) & ~(0x01000000u)) | (((0) << (0x00000018u)) & (0x01000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_getMacControlReg
 *
 *   @b Description
 *   @n This function retrieves the contents of MAC control register in entirety.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 >=0                MAC control register contents.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACCONTROL_REG
 *
 *   @b Example
 *   @verbatim
        Uint32          macControlVal, portNum = 1;
 
        macControlVal   =   CSL_CPGMAC_SL_getMacControlReg (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_getMacControlReg 
(
    Uint32                      portNum
)
{
    return ((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum].MACCONTROL_REG;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_setMacControlReg
 *
 *   @b Description
 *   @n This function configures the contents of MAC control register in entirety.
 *
 *   @b Arguments
     @verbatim
        portNum             MAC port number for which the reset must be performed.
        macControlRegVal    value to be configured to the MAC control register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_MACCONTROL_REG
 *
 *   @b Example
 *   @verbatim
        Uint32          macControlVal, portNum = 1;
 
        macControlVal   =   CSL_CPGMAC_SL_getMacControlReg ();

        // Enable full duplex, giagbit mode too 
        macControlVal   |=  CSL_CPGMAC_SL_MACCONTROL_FULLDUPLEX_EN |
                            CSL_CPGMAC_SL_MACCONTROL_GMII_EN;

        CSL_CPGMAC_SL_setMacControlReg (macControlVal, portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_setMacControlReg 
(
    Uint32                  portNum,
    Uint32                  macControlRegVal
)
{
    ((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum].MACCONTROL_REG   =   macControlRegVal;

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_getMacStatusReg
 *
 *   @b Description
 *   @n This function retrieves the contents of MAC status register.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
        pMacStatus              CSL_CPGMAC_SL_MACSTATUS structure to be populated with
                                the contents of MAC status register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_MACSTATUS_REG_TX_FLOW_ACT,
 *      CPGMAC_SL_MACSTATUS_REG_RX_FLOW_ACT,
 *      CPGMAC_SL_MACSTATUS_REG_EXT_FULLDUPLEX,
 *      CPGMAC_SL_MACSTATUS_REG_EXT_GIG,
 *      CPGMAC_SL_MACSTATUS_REG_IDLE
 *
 *   @b Example
 *   @verbatim
        CSL_CPGMAC_SL_MACSTATUS      macStatus;
        Uint32                       portNum = 1;
 
        CSL_CPGMAC_SL_getMacStatusReg (portNum, &macStatus);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_getMacStatusReg 
(
    Uint32                      portNum,
    CSL_CPGMAC_SL_MACSTATUS*    pMacStatus
)
{
    Uint32                      macStatusVal;

    macStatusVal                        =   ((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum].MACSTATUS_REG;
    pMacStatus->txFlowActive            =   (((macStatusVal) & (0x00000001u)) >> (0x00000000u));
    pMacStatus->rxFlowActive            =   (((macStatusVal) & (0x00000002u)) >> (0x00000001u));
    pMacStatus->extFullDuplexEnabled    =   (((macStatusVal) & (0x00000008u)) >> (0x00000003u));
    pMacStatus->extGigabitEnabled       =   (((macStatusVal) & (0x00000010u)) >> (0x00000004u));
    pMacStatus->idleEnabled             =   (((macStatusVal) & (0x80000000u)) >> (0x0000001Fu));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_resetMac
 *
 *   @b Description
 *   @n This function issues a software reset to the MAC for the MAC port number
 *      specified.
 *
 *   @b Arguments
     @verbatim
        portNum             MAC port number for which the reset must be performed.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None 
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_SOFT_RESET_REG_SOFT_RESET=1
 *
 *   @b Example
 *   @verbatim
        Uint32 portNum  =   1;

        CSL_CPGMAC_SL_resetMac (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_resetMac 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. SOFT_RESET_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. SOFT_RESET_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_isMACResetDone
 *
 *   @b Description
 *   @n This function reads the MAC Soft Reset register to check if the software
 *      reset operation has completed.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE               MAC Soft reset done. 
 *	 @n  FALSE              MAC Soft reset not yet completed.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_SOFT_RESET_REG_SOFT_RESET
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum = 1;

        CSL_CPGMAC_SL_resetMac (portNum);

        // Wait until MAC software reset completes 
        while (!CSL_CPGMAC_SL_isMACResetDone (portNum));
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_isMACResetDone 
(
    Uint32                      portNum
)
{
    if ((((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. SOFT_RESET_REG) & (0x00000001u)) >> (0x00000000u)) == 0)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_getRxMaxLen
 *
 *   @b Description
 *   @n This function retrieves the Receive maximum frame length configured in
 *      Receive Maximum length register for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 >=0                Receive maximum frame length read.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_RX_MAXLEN_REG_RX_MAXLEN
 *
 *   @b Example
 *   @verbatim
        Uint32          mtu, portNum = 1;
 
        mtu =   CSL_CPGMAC_SL_getRxMaxLen (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_getRxMaxLen 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. RX_MAXLEN_REG) & (0x00003FFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_setRxMaxLen
 *
 *   @b Description
 *   @n This function sets up the Receive maximum frame length in Receive Maximum 
 *      length register for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum             MAC port number for which the settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_RX_MAXLEN_REG_RX_MAXLEN
 *
 *   @b Example 
 *   @verbatim
        Uint32          mtu, portNum = 1;

        mtu =   1518;
 
        CSL_CPGMAC_SL_setRxMaxLen (portNum, mtu);
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_setRxMaxLen 
(
    Uint32                  portNum,
    Uint32                  rxMaxLen
)
{
    return ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. RX_MAXLEN_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. RX_MAXLEN_REG) & ~(0x00003FFFu)) | (((rxMaxLen) << (0x00000000u)) & (0x00003FFFu)));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_getRxPauseTimerReg
 *
 *   @b Description
 *   @n This function retrieves the Receive pause timer value configured in
 *      Receive pause timer register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 >=0                Receive pause timer value read.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_RX_PAUSE_REG_RX_PAUSETIMER
 *
 *   @b Example
 *   @verbatim
        Uint32          rxPauseTimer, portNum = 1;
 
        rxPauseTimer =   CSL_CPGMAC_SL_getRxPauseTimerReg (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_getRxPauseTimerReg 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. RX_PAUSE_REG) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_setRxPauseTimerReg
 *
 *   @b Description
 *   @n This function sets up the Receive pause timer value in Receive pause 
 *      timer register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum             MAC port number for which the settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_RX_PAUSE_REG_RX_PAUSETIMER
 *
 *   @b Example 
 *   @verbatim
        Uint32          rxPauseTimer = 2, portNum = 1;

        CSL_CPGMAC_SL_setRxPauseTimerReg (portNum, rxPauseTimer);
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_setRxPauseTimerReg 
(
    Uint32                  portNum,
    Uint32                  rxPauseTimer
)
{
    return ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. RX_PAUSE_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. RX_PAUSE_REG) & ~(0x0000FFFFu)) | (((rxPauseTimer) << (0x00000000u)) & (0x0000FFFFu)));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_getTxPauseTimerReg
 *
 *   @b Description
 *   @n This function retrieves the Transmit pause timer value configured in
 *      Transmit pause timer register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API must
                                retrieve the settings.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 >=0                Transmit pause timer value read.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_TX_PAUSE_REG_TX_PAUSETIMER
 *
 *   @b Example
 *   @verbatim
        Uint32          txPauseTimer, portNum = 1;
 
        txPauseTimer =   CSL_CPGMAC_SL_getTxPauseTimerReg (portNum);
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_getTxPauseTimerReg  
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. TX_PAUSE_REG) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_setTxPauseTimerReg
 *
 *   @b Description
 *   @n This function sets up the Transmit pause timer value in Transmit pause 
 *      timer register for the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum             MAC port number for which the settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_TX_PAUSE_REG_TX_PAUSETIMER
 *
 *   @b Example 
 *   @verbatim
        Uint32          txPauseTimer = 2, portNum = 1;

        CSL_CPGMAC_SL_setTxPauseTimerReg (portNum, txPauseTimer);
	 
     @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPGMAC_SL_setTxPauseTimerReg 
(
    Uint32                  portNum,
    Uint32                  txPauseTimer
)
{
    return ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. TX_PAUSE_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. TX_PAUSE_REG) & ~(0x0000FFFFu)) | (((txPauseTimer) << (0x00000000u)) & (0x0000FFFFu)));
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_getEmulControlReg
 *
 *   @b Description
 *   @n This function retrieves the contents of Emulation control register for
 *      the MAC port number specified.
 *
 *   @b Arguments
     @verbatim
        portNum             MAC port number for which the API should retrieve
                            emulation settings for.
        pEmulFreeBit        Emulation free bit.
        pEmulSoftBit        Emulation soft bit.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_EMCONTROL_REG_FREE,
 *      CPGMAC_SL_EMCONTROL_REG_SOFT
 *
 *   @b Example
 *   @verbatim
        Uint32          emulSoftBit, emulFreeBit, portNum = 1;
 
        CSL_CPGMAC_SL_getEmulControlReg (portNum, &emulFreeBit, &emulSoftBit);
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_getEmulControlReg 
(
    Uint32                  portNum,
    Uint32*                 pEmulFreeBit,
    Uint32*                 pEmulSoftBit
)
{
    *pEmulFreeBit   =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. EMCONTROL_REG) & (0x00000001u)) >> (0x00000000u));
    *pEmulSoftBit   =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. EMCONTROL_REG) & (0x00000002u)) >> (0x00000001u));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_setEmulControlReg
 *
 *   @b Description
 *   @n This function sets up the contents of Emulation control register for the
 *      MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum             MAC port for which the settings must be configured.
        emulFreeBit         Emulation free bit.
        emulSoftBit         Emulation soft bit.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_EMCONTROL_REG_FREE,
 *      CPGMAC_SL_EMCONTROL_REG_SOFT
 *
 *   @b Example
 *   @verbatim
        Uint32          emulSoftBit, emulFreeBit, portNum = 1;

        emulFreeBit =   1;
        emulSoftBit =   0;
 
        CSL_CPGMAC_SL_setEmulControlReg (portNum, emulFreeBit, emulSoftBit);
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_setEmulControlReg 
(
    Uint32                  portNum,
    Uint32                  emulFreeBit,
    Uint32                  emulSoftBit
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. EMCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. EMCONTROL_REG) & ~(0x00000001u)) | (((emulFreeBit) << (0x00000000u)) & (0x00000001u)));
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. EMCONTROL_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. EMCONTROL_REG) & ~(0x00000002u)) | (((emulSoftBit) << (0x00000001u)) & (0x00000002u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_getMacRxPriMapReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the MAC Receive Packet Priority to
 *      Header Priority Mapping Register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port number for which the API should retrieve
                                settings for.
        pMacRxPriMap            Array of MAC Rx packet priority map priority values 
                                read from the register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  The input parameter 'pMacRxPriMap' must be large enough to hold all
 *       the 8 priority values read from the register.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPGMAC_SL_PRI_MAP_REG_PRI0,
 *      CPGMAC_SL_PRI_MAP_REG_PRI1,
 *      CPGMAC_SL_PRI_MAP_REG_PRI2,
 *      CPGMAC_SL_PRI_MAP_REG_PRI3,
 *      CPGMAC_SL_PRI_MAP_REG_PRI4,
 *      CPGMAC_SL_PRI_MAP_REG_PRI5,
 *      CPGMAC_SL_PRI_MAP_REG_PRI6,
 *      CPGMAC_SL_PRI_MAP_REG_PRI7
 *
 *   @b Example
 *   @verbatim
 *      Uint32      pPortRxPriMap [8], portNum = 1;
 
        CSL_CPGMAC_SL_getMacRxPriMapReg (portNum, pPortRxPriMap);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_getMacRxPriMapReg 
(
    Uint32                      portNum,
    Uint32*                     pMacRxPriMap                
)
{
    pMacRxPriMap [0]    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & (0x00000007u)) >> (0x00000000u));
    pMacRxPriMap [1]    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & (0x00000070u)) >> (0x00000004u));
    pMacRxPriMap [2]    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & (0x00000700u)) >> (0x00000008u));
    pMacRxPriMap [3]    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & (0x00007000u)) >> (0x0000000Cu));
    pMacRxPriMap [4]    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & (0x00070000u)) >> (0x00000010u));
    pMacRxPriMap [5]    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & (0x00700000u)) >> (0x00000014u));
    pMacRxPriMap [6]    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & (0x07000000u)) >> (0x00000018u));
    pMacRxPriMap [7]    =   (((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & (0x70000000u)) >> (0x0000001Cu));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPGMAC_SL_setMacRxPriMapReg
 *
 *   @b Description
 *   @n This function sets up the contents of the MAC Receive Packet Priority
 *      to Header Priority Mapping Register for the MAC port specified.
 *
 *   @b Arguments
     @verbatim
        portNum                 MAC port for which the settings must be configured.
        pMacRxPriMap            Array of MAC Rx priority map priority values 
                                that must be configured to the register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPGMAC_SL_PRI_MAP_REG_PRI0,
 *      CPGMAC_SL_PRI_MAP_REG_PRI1,
 *      CPGMAC_SL_PRI_MAP_REG_PRI2,
 *      CPGMAC_SL_PRI_MAP_REG_PRI3,
 *      CPGMAC_SL_PRI_MAP_REG_PRI4,
 *      CPGMAC_SL_PRI_MAP_REG_PRI5,
 *      CPGMAC_SL_PRI_MAP_REG_PRI6,
 *      CPGMAC_SL_PRI_MAP_REG_PRI7
 *
 *   @b Example
 *   @verbatim
 *      Uint32      i, pMacRxPriMap [8], portNum = 1;

        for (i = 0; i < 8; i ++)
            pMacRxPriMap [i] = i;

        CSL_CPGMAC_SL_setMacRxPriMapReg (portNum, pMacRxPriMap);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPGMAC_SL_setMacRxPriMapReg 
(
    Uint32                      portNum,
    Uint32*                     pMacRxPriMap                
)
{
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & ~(0x00000007u)) | (((pMacRxPriMap [0]) << (0x00000000u)) & (0x00000007u)));
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & ~(0x00000070u)) | (((pMacRxPriMap [1]) << (0x00000004u)) & (0x00000070u)));
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & ~(0x00000700u)) | (((pMacRxPriMap [2]) << (0x00000008u)) & (0x00000700u)));
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & ~(0x00007000u)) | (((pMacRxPriMap [3]) << (0x0000000Cu)) & (0x00007000u)));
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & ~(0x00070000u)) | (((pMacRxPriMap [4]) << (0x00000010u)) & (0x00070000u)));
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & ~(0x00700000u)) | (((pMacRxPriMap [5]) << (0x00000014u)) & (0x00700000u)));
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & ~(0x07000000u)) | (((pMacRxPriMap [6]) << (0x00000018u)) & (0x07000000u)));
    ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) = ((((CSL_Cpgmac_slPortRegs *) ((0x02000000) + 0x00090900))->SL_PORT[portNum]. PRI_MAP_REG) & ~(0x70000000u)) | (((pMacRxPriMap [7]) << (0x0000001Cu)) & (0x70000000u)));

    return;
}



/**
@}
*/
/**  
 * @file  csl_cptsAux.h
 *
 * @brief  
 *  API Auxilary header file for Ethernet Time Synchronization module CSL. 
 *
 *  Contains the different control command and status query functions definations
 *   
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/**  
 * @file  csl_cpts.h
 *
 * @brief  
 *  Header file containing various enumerations, structure definitions and function 
 *  declarations for the Time synchronization submodule of EMAC.
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/



/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* Modified by CSL team for:
 *      (1) Header files are included to be RTSC compliant
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 IDVER_REG;
    volatile Uint32 CONTROL_REG;
    volatile Uint32 RFTCLK_SEL_REG;
    volatile Uint32 TS_PUSH_REG;
    volatile Uint32 TS_LOAD_VAL_REG;
    volatile Uint32 TS_LOAD_EN_REG;
    volatile Uint8 RSVD0[8];
    volatile Uint32 INTSTAT_RAW_REG;
    volatile Uint32 INTSTAT_MASKED_REG;
    volatile Uint32 INT_ENABLE_REG;
    volatile Uint8 RSVD1[4];
    volatile Uint32 EVENT_POP_REG;
    volatile Uint32 EVENT_LOW_REG;
    volatile Uint32 EVENT_HIGH_REG;
} CSL_CptsRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* idver_reg */






/* control_reg */




/* rftclk_sel_reg */



/* ts_push_reg */



/* ts_load_val_reg */



/* ts_load_en_reg */



/* intstat_raw_reg */



/* intstat_masked_reg */



/* int_enable_reg */



/* event_pop_reg */



/* event_low_reg */



/* event_high_reg */







/** ============================================================================ 
 *
 * @defgroup CSL_CPTS_API Time Sync Submodule (CPTS)
 * @ingroup CSL_CPSW_API
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * @subsection References
 *    -# Ethernet Media Access Controller User Guide
 * ============================================================================
 */         
/**
@defgroup CSL_CPTS_SYMBOL  CPTS Symbols Defined
@ingroup CSL_CPTS_API
*/
/**
@defgroup CSL_CPTS_DATASTRUCT  CPTS Data Structures
@ingroup CSL_CPTS_API
*/
/**
@defgroup CSL_CPTS_FUNCTION  CPTS Functions
@ingroup CSL_CPTS_API
*/
/**
@defgroup CSL_CPTS_ENUM CPTS Enumerated Data Types
@ingroup CSL_CPTS_API
*/

/**
@addtogroup CSL_CPTS_SYMBOL
@{
*/

/**
@}
*/

/** @addtogroup CSL_CPTS_DATASTRUCT
 @{ */

/** Constants for passing parameters to the functions.
 */
/** @brief Pointer to the Time synchronization submodule (CPTS) overlay registers */

/** @brief      
 *
 *  Defines CPTS event types. 
 */        
/**  Time stamp push event */	

/**  Time stamp rollover event */	

/**  Time stamp Half Rollover event */	

/**  Ethernet receive event */	

/**  Ethernet Transmit event */	
        

/** @brief      
 *
 *  Holds the Time sync submodule's version info. 
 */        
typedef struct {
	/**  Minor version value */	
	Uint32      minorVer;

	/**  Major version value */	
	Uint32      majorVer;

	/**  RTL version value */	
	Uint32      rtlVer;

	/**  Identification value */	
	Uint32      id;
} CSL_CPTS_VERSION;        

/** @brief      
 *
 *  Holds Time sync event info contents. 
 */        
typedef struct {
	/**  Time stamp read from the CPTS EVENT_LOW register */	
	Uint32      timeStamp;

	/**  Sequence Id read from CPTS EVENT_HIGH register */	
	Uint32      seqId;

	/**  Message Type read from CPTS EVENT_HIGH register */	
	Uint32      msgType;

	/**  Event Type read from CPTS EVENT_HIGH register */	
	Uint32      eventType;

	/**  Port number read from CPTS EVENT_HIGH register */	
	Uint32      portNo;
} CSL_CPTS_EVENTINFO;

        
/**
@}
*/


/** @addtogroup CSL_CPTS_FUNCTION
 @{ */

/**
@}
*/



/**
@}
*/


/** @addtogroup CSL_CPTS_FUNCTION
@{ */

/********************************************************************************
********************** Time Synchronization (CPTS) Submodule ********************
********************************************************************************/


/** ============================================================================
 *   @n@b CSL_CPTS_getCptsVersionInfo
 *
 *   @b Description
 *   @n This function retrieves the CPTS module identification and version 
 *      information.
 *
 *   @b Arguments
     @verbatim
        pVersionInfo        CSL_CPTS_VERSION structure that needs to be populated
                            with the version info read from the hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_IDVER_REG_MINOR_VER,
 *      CPTS_IDVER_REG_MAJOR_VER,
 *      CPTS_IDVER_REG_RTL_VER,
 *      CPTS_IDVER_REG_TX_IDENT
 *
 *   @b Example
 *   @verbatim
        CSL_CPTS_VERSION    versionInfo;

        CSL_CPTS_getCptsVersionInfo (&versionInfo);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_getCptsVersionInfo 
(
	CSL_CPTS_VERSION*           pVersionInfo     
)
{

    pVersionInfo->minorVer  =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->IDVER_REG) & (0x000000FFu)) >> (0x00000000u));
    pVersionInfo->majorVer  =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->IDVER_REG) & (0x00000700u)) >> (0x00000008u));
    pVersionInfo->rtlVer    =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->IDVER_REG) & (0x0000F800u)) >> (0x0000000Bu));
    pVersionInfo->id        =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->IDVER_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPTS_isCptsEnabled
 *
 *   @b Description
 *   @n This function indicates if time sync is enabled or not.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   CPTS enabled.
 *	 @n  FALSE                  CPTS disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_CONTROL_REG_CPTS_EN
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPTS_isCptsEnabled () == TRUE)
        {
            // CPTS on
        }
        else
        {
            // CPTS off
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPTS_isCptsEnabled (void)
{

    return (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->CONTROL_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPTS_enableCpts
 *
 *   @b Description
 *   @n This function configures the CPTS control register to enable time sync.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPTS_CONTROL_REG_CPTS_EN=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPTS_enableCpts ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_enableCpts (void)
{
    ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->CONTROL_REG) = ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->CONTROL_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPTS_disableCpts
 *
 *   @b Description
 *   @n This function configures the CPTS control register to disable time sync.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPTS_CONTROL_REG_CPTS_EN=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPTS_disableCpts ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_disableCpts (void)
{
    ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->CONTROL_REG) = ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->CONTROL_REG) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPTS_getRFTCLKSelectReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the reference clock select 
 *      register.
 *
 *   @b Arguments
     @verbatim
        pRefClockSelect         Reference clock select value read from hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_RFTCLK_SEL_REG_RFTCLK_SEL
 *
 *   @b Example
 *   @verbatim
        Uint32          refClockSelect;

        CSL_CPTS_getRFTCLKSelectReg (&refClockSelect);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_getRFTCLKSelectReg (
	Uint32*                     pRefClockSelect
)
{

    *pRefClockSelect    =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->RFTCLK_SEL_REG) & (0x0000001Fu)) >> (0x00000000u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPTS_setRFTCLKSelectReg
 *
 *   @b Description
 *   @n This function sets up the reference clock select value. The Reference
 *      clock value can be setup only when the CPTS enable bit is cleared in
 *      the CPTS control register.
 *
 *   @b Arguments
     @verbatim
        refClockSetVal          Reference clock select value to configure.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_CPTS_setTimeSyncControlReg () must be called to clear the
 *      CPTS enable bit before calling this API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Affects
 *   @n CPTS_RFTCLK_SEL_REG_RFTCLK_SEL
 *
 *   @b Example
 *   @verbatim
        Uint32          refClockSelect;

        refClockSelect  =   0;

        CSL_CPTS_setRFTCLKSelectReg (refClockSelect);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_setRFTCLKSelectReg (
	Uint32                      refClockSetVal
)
{
    ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->RFTCLK_SEL_REG) = ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->RFTCLK_SEL_REG) & ~(0x0000001Fu)) | (((refClockSetVal) << (0x00000000u)) & (0x0000001Fu)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPTS_getTSEventPushReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Time Stamp Event Push register.
 *
 *   @b Arguments
     @verbatim
        pTSPushVal              Time stamp push value read from hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_TS_PUSH_REG_TS_PUSH
 *
 *   @b Example
 *   @verbatim
        Uint32          tsPushVal;

        CSL_CPTS_getTSEventPushReg (&tsPushVal);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_getTSEventPushReg (
	Uint32*                     pTSPushVal
)
{
    *pTSPushVal     =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->TS_PUSH_REG) & (0x00000001u)) >> (0x00000000u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPTS_setTSEventPushReg
 *
 *   @b Description
 *   @n This function sets up the contents of the Time Stamp Event Push register.
 *
 *   @b Arguments
     @verbatim
        tsPushVal               Time stamp push value to configure.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Affects
 *   @n CPTS_TS_PUSH_REG_TS_PUSH
 *
 *   @b Example
 *   @verbatim
        Uint32          tsPushVal;

        tsPushVal   =   0;

        CSL_CPTS_setTSEventPushReg (tsPushVal);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_setTSEventPushReg (
	Uint32                      tsPushVal
)
{
    ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->TS_PUSH_REG) = ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->TS_PUSH_REG) & ~(0x00000001u)) | (((tsPushVal) << (0x00000000u)) & (0x00000001u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPTS_getTSLoadValReg
 *
 *   @b Description
 *   @n This function retrieves the contents of the Time Stamp Load Value register.
 *
 *   @b Arguments
     @verbatim
        pTSLoadVal              Time stamp load value read from hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_TS_LOAD_VAL_REG_TS_LOAD_VAL
 *
 *   @b Example
 *   @verbatim
        Uint32          tsLoadVal;

        CSL_CPTS_getTSLoadValReg (&tsLoadVal);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_getTSLoadValReg (
	Uint32*                     pTSLoadVal
)
{
    *pTSLoadVal     =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->TS_LOAD_VAL_REG) & (0xFFFFFFFFu)) >> (0x00000000u));

    return;        
}


/** ============================================================================
 *   @n@b CSL_CPTS_setTSLoadValReg
 *
 *   @b Description
 *   @n This function sets up the Time Stamp Load Value.
 *
 *   @b Arguments
     @verbatim
        tsLoadVal               Time stamp load value to configure.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Affects
 *   @n CPTS_TS_LOAD_VAL_REG_TS_LOAD_VAL
 *
 *   @b Example
 *   @verbatim
        Uint32          tsLoadVal;

        tsLoadVal   =   0;

        CSL_CPTS_setTSLoadValReg (tsLoadVal);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_setTSLoadValReg 
(
	Uint32                      tsLoadVal
)
{
    ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->TS_LOAD_VAL_REG) = ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->TS_LOAD_VAL_REG) & ~(0xFFFFFFFFu)) | (((tsLoadVal) << (0x00000000u)) & (0xFFFFFFFFu)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_CPTS_isRawInterruptStatusBitSet
 *
 *   @b Description
 *   @n This function checks the Time Sync Raw Pending Interrupt Register to 
 *      determine if there is one or more events in the event FIFO.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   One or more events in FIFO. Raw interrupt status
 *	                            bit set.
 *	 @n  FALSE                  No events in FIFO. Raw interrupt status bit cleared.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_INTSTAT_RAW_REG_TS_PEND_RAW
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPTS_isRawInterruptStatusBitSet () == TRUE)
        {
           // interrupt set 
        }
        else
        {
            // interrupt bit not set
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPTS_isRawInterruptStatusBitSet (void)
{

    return (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->INTSTAT_RAW_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPTS_isMaskedInterruptStatusBitSet
 *
 *   @b Description
 *   @n This function checks the Time Sync Interrupt Status Masked Register to 
 *      determine if there is one or more events in the event FIFO.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   One or more events in FIFO. masked interrupt status
 *	                            bit set.
 *	 @n  FALSE                  No events in FIFO. masked interrupt status bit cleared.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_INTSTAT_MASKED_REG_TS_PEND
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPTS_isMaskedInterruptStatusBitSet () == TRUE)
        {
           // masked interrupt set 
        }
        else
        {
            // masked interrupt bit not set
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPTS_isMaskedInterruptStatusBitSet (void)
{

    return (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->INTSTAT_MASKED_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPTS_isInterruptEnabled
 *
 *   @b Description
 *   @n This function indicates if Time sync interrupts are enabled.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 TRUE                   Time sync interrupts enabled.
 *	 @n  FALSE                  Time sync interrupts disabled.
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_INT_ENABLE_REG_TS_PEND_EN
 *
 *   @b Example
 *   @verbatim
        if (CSL_CPTS_isInterruptEnabled () == TRUE)
        {
           // interrupts enabled 
        }
        else
        {
            // interrupts disabled
        }
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_CPTS_isInterruptEnabled (void)
{

    return (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->INT_ENABLE_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_CPTS_enableInterrupt
 *
 *   @b Description
 *   @n This function enables the interrupts in Time sync submodule.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPTS_INT_ENABLE_REG_TS_PEND_EN=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPTS_enableInterrupt ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_enableInterrupt (void)
{
    ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->INT_ENABLE_REG) = ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->INT_ENABLE_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPTS_disableInterrupt
 *
 *   @b Description
 *   @n This function disables the interrupts in Time sync submodule.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPTS_INT_ENABLE_REG_TS_PEND_EN=0
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPTS_disableInterrupt ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_disableInterrupt (void)
{
    ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->INT_ENABLE_REG) = ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->INT_ENABLE_REG) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPTS_popEvent
 *
 *   @b Description
 *   @n This function sets up the Event pop bit in Event pop register. This 
 *      initiates an event to be popped off the event FIFO. Popping an event discards 
 *      the event and causes the next event, if any, to be moved to the top of 
 *      the FIFO ready to be read by software on interrupt.
 *
 *   @b Arguments
 *   @n None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n CPTS_EVENT_POP_REG_EVENT_POP=1
 *
 *   @b Example
 *   @verbatim
 
        CSL_CPTS_popEvent ();
	 
     @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_popEvent (void)
{
    ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->EVENT_POP_REG) = ((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->EVENT_POP_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_CPTS_getEventInfo
 *
 *   @b Description
 *   @n This function retrieves the contents of the Event low and Event High
 *      registers.
 *
 *   @b Arguments
     @verbatim
        pEventInfo              CSL_CPTS_EVENTINFO structure that needs to be filled
                                with time sync event info read from hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPTS_EVENT_LOW_REG_TIME_STAMP,
 *      CPTS_EVENT_HIGH_REG_SEQUENCE_ID,
 *      CPTS_EVENT_HIGH_REG_MESSAGE_TYPE,
 *      CPTS_EVENT_HIGH_REG_EVENT_TYPE,
 *      CPTS_EVENT_HIGH_REG_PORT_NUMBER
 *
 *   @b Example
 *   @verbatim
        CSL_CPTS_EVENTINFO          eventInfo;

        CSL_CPTS_getEventInfo (&eventInfo);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_CPTS_getEventInfo (
	CSL_CPTS_EVENTINFO*         pEventInfo
)
{
    pEventInfo->timeStamp   =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->EVENT_LOW_REG) & (0xFFFFFFFFu)) >> (0x00000000u));
    pEventInfo->seqId       =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->EVENT_HIGH_REG) & (0x0000FFFFu)) >> (0x00000000u));
    pEventInfo->msgType     =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->EVENT_HIGH_REG) & (0x000F0000u)) >> (0x00000010u));
    pEventInfo->eventType   =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->EVENT_HIGH_REG) & (0x00F00000u)) >> (0x00000014u));
    pEventInfo->portNo      =   (((((CSL_CptsRegs *) ((0x02000000) + 0x00090D00))->EVENT_HIGH_REG) & (0x1F000000u)) >> (0x00000018u));

    return;        
}



/**
@}
*/
        


/**  
 * @file csl_cpsgmii.h
 *
 * @brief 
 *  Header file for functional layer of CSL SGMII. 
 *
 *  It contains the various enumerations, structure definitions and function 
 *  declarations
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** ============================================================================ 
 *
 * @defgroup CSL_SGMII_API SGMII
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * @subsection References
 *    -# Ethernet Media Access Controller User Guide
 * ============================================================================
 */ 



/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */



/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 IDVER_REG;
    volatile Uint32 SOFT_RESET_REG;
    volatile Uint8  RSVD0[8];
    volatile Uint32 CONTROL_REG;
    volatile Uint32 STATUS_REG;
    volatile Uint32 MR_ADV_ABILITY_REG;
    volatile Uint8  RSVD1[4];
    volatile Uint32 MR_LP_ADV_ABILITY_REG;
    volatile Uint8  RSVD2[12];
    volatile Uint32 TX_CFG_REG;
    volatile Uint32 RX_CFG_REG;
    volatile Uint32 AUX_CFG_REG;
    volatile Uint8  RSVD3[16];

    /* Modified by the CSL team for:
     *
     *  (1) Adding extra padding to offset correctly
     *      to the next SGMII module start.
     */
    volatile Uint8  RSVD4[180];

} CSL_CpsgmiiRegs;

/* Modified by CSL team for:
 *
 *      (2) Defined a new structure to encapsulate the 2 SGMII ports.
 *          (CSL_Cpsgmii_PortRegs)
 */
typedef struct  {
    CSL_CpsgmiiRegs SGMII_PORT [2];        
} CSL_Cpsgmii_PortRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* idver_reg */






/* soft_reset_reg */




/* control_reg */






/* status_reg */






/* mr_adv_ability_reg */



/* mr_lp_adv_ability_reg */



/* tx_cfg_reg */




/* rx_cfg_reg */




/* aux_cfg_reg */




/**
@defgroup CSL_SGMII_SYMBOL  SGMII Symbols Defined
@ingroup CSL_SGMII_API
*/
/**
@defgroup CSL_SGMII_DATASTRUCT  SGMII Data Structures
@ingroup CSL_SGMII_API
*/
/**
@defgroup CSL_SGMII_FUNCTION  SGMII Functions
@ingroup CSL_SGMII_API
*/
/**
@defgroup CSL_SGMII_ENUM SGMII Enumerated Data Types
@ingroup CSL_SGMII_API
*/
    
/**
@addtogroup CSL_SGMII_SYMBOL
@{
*/

/**
@}
*/

/**
@addtogroup CSL_SGMII_ENUM
@{
*/

/** @brief      
 *
 *  Duplex mode enumerators. 
 */        
typedef enum 
{
    /** Half duplex mode */        
   CSL_SGMII_HALF_DUPLEX    =   0,

    /** Full duplex mode */
   CSL_SGMII_FULL_DUPLEX    =   1
} CSL_SGMII_DUPLEXMODE;

/** @brief      
 *
 *  Link speed enumerators. 
 */        
typedef enum 
{
    /** 10 Mbps */        
   CSL_SGMII_10_MBPS        =   0,

    /** 100 Mbps */        
   CSL_SGMII_100_MBPS       =   1,

    /** 1000 Mbps / Gigabit */
   CSL_SGMII_1000_MBPS      =   2
} CSL_SGMII_LINKSPEED;


/**
@}
*/        

/** @addtogroup CSL_SGMII_DATASTRUCT
 @{ */
/** @brief Pointer to the SGMII overlay registers */

/** @brief      
 *
 *  Holds the SGMII module version info. 
 */        
typedef struct {
	/**  Minor revision value */	
	Uint32      minor_version;

	/**  Major revision value */	
	Uint32      major_version;

	/**  RTL Version */	
	Uint32      rtl_version;

	/**  Identification Value */	
	Uint32      ident_val;
}CSL_SGMII_VERSION;        

/** @brief      
 *
 *  Holds the SGMII status info.
 */        
typedef struct {
	/**  Link Status */	
	Uint32      bIsLinkUp;

	/**  Auto-negotiation error indicator */	
	Uint32      bIsAutoNegError;

	/**  Auto-negotiation completion status */	
	Uint32      bIsAutoNegComplete;

	/**  Lock Status */	
	Uint32      bIsLocked;
}CSL_SGMII_STATUS;        

/** @brief      
 *
 *  SGMII advertised ability configuration 
 *  info.
 */        
typedef struct {
	/**  Link Status */	
	Uint32                  bLinkUp;

	/**  Duplex Mode */	
	CSL_SGMII_DUPLEXMODE    duplexMode;

	/**  Link speed */	
	CSL_SGMII_LINKSPEED     linkSpeed;
}CSL_SGMII_ADVABILITY;        
/**
@}
*/


/** @addtogroup CSL_SGMII_FUNCTION
 @{ */

/**
@}
*/


/**  
 * @file  csl_cpsgmiiAux.h
 *
 * @brief  
 *  API Auxilary header file for SGMII CSL. Contains the different control 
 *  command and status query functions definations
 *   
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009-2012, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/




/** @addtogroup CSL_SGMII_FUNCTION
@{ */

/** ============================================================================
 *   @n@b CSL_SGMII_getVersionInfo
 *
 *   @b Description
 *   @n This function retrieves the SGMII version information for the SGMII port
 *      specified.
 *
 *   @b Arguments
     @verbatim
        portNum             SGMII port number for which settings must be retrieved.
        sgmiiVersionInfo    CSL_SGMII_VERSION structure that needs to be populated
                            with the version info read from the SGMII_IDVER register.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_IDVER_REG_MINOR_VER,
 *      CPSGMII_IDVER_REG_MAJOR_VER,
 *      CPSGMII_IDVER_REG_RTL_VER,
 *      CPSGMII_IDVER_REG_TX_IDENT
 *
 *   @b Example
 *   @verbatim
        CSL_SGMII_VERSION   sgmiiVersionInfo;
        Uint32              portNum = 1;

        CSL_SGMII_getVersion (portNum, &sgmiiVersionInfo);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_getVersionInfo 
(
    Uint32                  portNum,
	CSL_SGMII_VERSION*      sgmiiVersionInfo     
)
{
    sgmiiVersionInfo->minor_version     =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. IDVER_REG) & (0x000000FFu)) >> (0x00000000u));
    sgmiiVersionInfo->major_version     =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. IDVER_REG) & (0x00000700u)) >> (0x00000008u));
    sgmiiVersionInfo->rtl_version       =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. IDVER_REG) & (0x0000F800u)) >> (0x0000000Bu));
    sgmiiVersionInfo->ident_val         =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. IDVER_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_doSoftReset
 *
 *   @b Description
 *   @n This function initiates a CPSGMII logic software reset for the SGMII port
 *      specified by setting the 'SOFT_RESET' bit of the CPSGMII Software Reset 
 *      register to 1.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which reset must be performed.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Software reset on CPSGMII port is initiated. The Soft reset bit is set
 *       back to 0 once the reset operation is completed.
 *
 *   @b Writes
 *   @n CPSGMII_SOFT_RESET_REG_SOFT_RESET=1
 *
 *   @b Affects
 *   @n CPSGMII_SOFT_RESET_REG_SOFT_RESET=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum = 1;

        CSL_SGMII_doSoftReset (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_doSoftReset 
(
	Uint32                  portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. SOFT_RESET_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. SOFT_RESET_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_getSoftResetStatus
 *
 *   @b Description
 *   @n This function reads the 'SOFT_RESET' bit of the CPSGMII Software Reset 
 *      register and returns its contents for the port specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which reset status must be 
                            retrieved.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_SOFT_RESET_REG_SOFT_RESET
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum = 1;

        if (!CSL_SGMII_getSoftResetStatus (portNum))
        {
            // Software reset is completed.
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_SGMII_getSoftResetStatus 
(
	Uint32                  portNum
)
{
    return (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. SOFT_RESET_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SGMII_startRxTxSoftReset
 *
 *   @b Description
 *   @n This function initiates a SGMII Receive and Transmit logic software reset 
 *      by setting the 'RT_SOFT_RESET' bit of the CPSGMII Software Reset register 
 *      to 1. This reset is to be started when switching between normal and loopback
 *      modes of operation.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which reset must started.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII Rx/Tx Software logic reset initiated.
 *
 *   @b Writes
 *   @n CPSGMII_SOFT_RESET_REG_RT_SOFT_RESET=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum = 1;

        CSL_SGMII_startRxTxSoftReset (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_startRxTxSoftReset 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. SOFT_RESET_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. SOFT_RESET_REG) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_endRxTxSoftReset
 *
 *   @b Description
 *   @n This function terminates a SGMII Receive and Transmit logic software reset 
 *      initiated earlier by calling @a CSL_SGMII_startRxTxSoftReset () API. This API
 *      sets the 'RT_SOFT_RESET' bit of the CPSGMII Software Reset register 
 *      to 0 to do so. This API is to be called once the loopback/normal switch is done.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which reset must be ended.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  @a CSL_SGMII_startRxTxSoftReset () API must have been called earlier to
 *       initiate the Rx/Tx Soft reset before calling this API.
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII Rx/Tx Software logic reset cleared.
 *
 *   @b Writes
 *   @n CPSGMII_SOFT_RESET_REG_RT_SOFT_RESET=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_SGMII_endRxTxSoftReset (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_endRxTxSoftReset 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. SOFT_RESET_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. SOFT_RESET_REG) & ~(0x00000002u)) | (((0) << (0x00000001u)) & (0x00000002u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_getRxTxSoftResetStatus
 *
 *   @b Description
 *   @n This function reads the 'RT_SOFT_RESET' bit of the CPSGMII Software Reset 
 *      register and returns its contents. 
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which reset status must be 
                            retrieved.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_SOFT_RESET_REG_RT_SOFT_RESET
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        if (!CSL_SGMII_getRxTxSoftResetStatus (portNum))
        {
            // Software reset is completed.
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_SGMII_getRxTxSoftResetStatus 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. SOFT_RESET_REG) & (0x00000002u)) >> (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_SGMII_enableMasterMode
 *
 *   @b Description
 *   @n This function configures the CPSGMII in 'Master' mode. Master mode allows
 *      a CPSGMII direct connection with auto-negotiation  or with forced link.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which settings must be configured
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII Master mode enabled.
 *
 *   @b Writes
 *   @n CPSGMII_CONTROL_REG_MASTER=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_SGMII_enableMasterMode (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_enableMasterMode 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & ~(0x00000020u)) | (((1) << (0x00000005u)) & (0x00000020u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_disableMasterMode
 *
 *   @b Description
 *   @n This function configures the CPSGMII in 'Slave' mode or in other words
 *      disables the master mode for the port specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which settings must be configured.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII Master mode disabled, slave mode enabled.
 *
 *   @b Writes
 *   @n CPSGMII_CONTROL_REG_MASTER=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_SGMII_disableMasterMode (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_disableMasterMode 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & ~(0x00000020u)) | (((0) << (0x00000005u)) & (0x00000020u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_isMasterModeEnabled
 *
 *   @b Description
 *   @n This function reads the 'MASTER' bit of the CPSGMII Control register and 
 *      returns 1 to indicate that the CPSGMII is configured in 'Master' mode 
 *      and 0 otherwise to indicate 'Slave' mode.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which settings must be retrieved.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_CONTROL_REG_MASTER
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        if (!CSL_SGMII_isMasterModeEnabled (portNum))
        {
            // Slave Mode
        }
        else
        {
            // Master mode
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_SGMII_isMasterModeEnabled 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & (0x00000020u)) >> (0x00000005u));
}

/** ============================================================================
 *   @n@b CSL_SGMII_enableLoopback
 *
 *   @b Description
 *   @n This function configures the CPSGMII in internal loopback mode for the
 *      port number specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which loopback must be enabled.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII internal loopback mode enabled.
 *
 *   @b Writes
 *   @n CPSGMII_CONTROL_REG_LOOPBACK=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_SGMII_enableLoopback (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_enableLoopback 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & ~(0x00000010u)) | (((1) << (0x00000004u)) & (0x00000010u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_disableLoopback
 *
 *   @b Description
 *   @n This function disables CPSGMII internal loopback for the port specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which loopback must be disabled
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII loopback mode disabled.
 *
 *   @b Writes
 *   @n CPSGMII_CONTROL_REG_LOOPBACK=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_SGMII_disableLoopback (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_disableLoopback 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & ~(0x00000010u)) | (((0) << (0x00000004u)) & (0x00000010u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_isLoopbackModeEnabled
 *
 *   @b Description
 *   @n This function reads the 'LOOPBACK' bit of the CPSGMII Control register and 
 *      returns 1 to indicate that the CPSGMII is configured in 'Loopback' mode 
 *      and 0 otherwise.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which loopback mode must be read.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_CONTROL_REG_LOOPBACK
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        if (CSL_SGMII_isLoopbackModeEnabled (portNum))
        {
            // Loopback mode enabled.
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_SGMII_isLoopbackModeEnabled 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & (0x00000010u)) >> (0x00000004u));
}

/** ============================================================================
 *   @n@b CSL_SGMII_restartAutoNegotiation
 *
 *   @b Description
 *   @n This function restarts link auto-negotiation process for the port 
 *      specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which the operation must be 
                            performed
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII auto-negotiation restarted.
 *
 *   @b Writes
 *   @n CPSGMII_CONTROL_REG_MR_AN_RESTART=1,
 *      CPSGMII_CONTROL_REG_MR_AN_RESTART=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_SGMII_restartAutoNegotiation (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_restartAutoNegotiation 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & ~(0x00000002u)) | (((1) << (0x00000001u)) & (0x00000002u)));
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & ~(0x00000002u)) | (((0) << (0x00000001u)) & (0x00000002u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_enableAutoNegotiation
 *
 *   @b Description
 *   @n This function enables auto-negotiation process for the port specified.
 *
 *   @b Arguments
     @verbatim
        portNum             SGMII port number for which the operation must be
                            performed.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII auto-negotiation enabled.
 *
 *   @b Writes
 *   @n CPSGMII_CONTROL_REG_MR_AN_ENABLE=1
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_SGMII_enableAutoNegotiation (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_enableAutoNegotiation 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & ~(0x00000001u)) | (((1) << (0x00000000u)) & (0x00000001u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_disableAutoNegotiation
 *
 *   @b Description
 *   @n This function disables auto-negotiation process for the port number 
 *      specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which the operation must be 
                            performed
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CPSGMII auto-negotiation disabled.
 *
 *   @b Writes
 *   @n CPSGMII_CONTROL_REG_MR_AN_ENABLE=0
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        CSL_SGMII_disableAutoNegotiation (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_disableAutoNegotiation 
(
    Uint32                      portNum
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & ~(0x00000001u)) | (((0) << (0x00000000u)) & (0x00000001u)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_isAutoNegotiationEnabled
 *
 *   @b Description
 *   @n This function reads the 'MR_AN_ENABLE' bit of the CPSGMII Control register and 
 *      returns 1 to indicate that the CPSGMII is configured in 'auto-negotiate' mode 
 *      and 0 otherwise.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which autonegotiation must be enabled.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_CONTROL_REG_MR_AN_ENABLE
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;

        if (CSL_SGMII_isAutoNegotiationEnabled (portNum))
        {
            // auto-negotiation enabled.
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_SGMII_isAutoNegotiationEnabled 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. CONTROL_REG) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SGMII_getStatus
 *
 *   @b Description
 *   @n This function retrieves the SGMII status information from the hardware.
 *      The status info returned by this function are valid only if
 *      the 'bIsLocked' bit of status info is set to 1 and must be disregarded
 *      otherwise.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which status must be retrieved.
 *      pSgmiiStatus        CSL_SGMII_STATUS structure pointer that needs to be
 *                          populated with link status information.
 *   @endverbatim                          
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_STATUS_REG_LINK,
 *      CPSGMII_STATUS_REG_AN_ERROR,
 *      CPSGMII_STATUS_REG_MR_AN_COMPLETE,
 *      CPSGMII_STATUS_REG_LOCK
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;
        CSL_SGMII_STATUS    sgmiiStatus;

        // Get link status info
        CSL_SGMII_getStatus (portNum, &sgmiiStatus);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_getStatus 
(
    Uint32                  portNum,
	CSL_SGMII_STATUS*       pSgmiiStatus
)
{
    pSgmiiStatus->bIsLinkUp             =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. STATUS_REG) & (0x00000001u)) >> (0x00000000u));
    pSgmiiStatus->bIsAutoNegError       =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. STATUS_REG) & (0x00000002u)) >> (0x00000001u));
    pSgmiiStatus->bIsAutoNegComplete    =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. STATUS_REG) & (0x00000004u)) >> (0x00000002u));
    pSgmiiStatus->bIsLocked             =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. STATUS_REG) & (0x00000010u)) >> (0x00000004u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_setAdvAbility
 *
 *   @b Description
 *   @n This function sets up the 'MR_ADV_ABILITY' register as per the input
 *      specified to this function in 'pSgmiiAdvAbility' param.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which configuration must be done.
 *      pSgmiiAdvAbility    CSL_SGMII_ADVABILITY input params structure that contains
 *                          the advertised ability configuration that needs to be
 *                          populated to the hardware registers.
 *   @endverbatim                          
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  MR_ADV_ABILITY register setup accordingly.
 *
 *   @b Writes
 *   @n CPSGMII_MR_ADV_ABILITY_REG
 *
 *   @b Example
 *   @verbatim
        Uint32  portNum =   1;
        CSL_SGMII_STATUS    sgmiiAdvAbility;
        
        sgmiiAdvAbility.bLinkUp     =   1;
        sgmiiAdvAbility.duplexMode  =   CSL_SGMII_FULL_DUPLEX;
        sgmiiAdvAbility.linkSpeed   =   CSL_SGMII_1000_MBPS;

        // Configure SGMII Advertised ability info
        CSL_SGMII_setAdvAbility (portNum, &sgmiiAdvAbility);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_setAdvAbility (
    Uint32                      portNum,
	CSL_SGMII_ADVABILITY*       pSgmiiAdvAbility
)
{
    //TX_CONFIG_REG[0] = 1 in the SGMII specification. 

    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) &~ (((1 << ((0) - (0) + 1)) - 1) << (0))) | (((1) & ((1 << ((0) - (0) + 1)) - 1)) << (0)));  
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) &~ (((1 << ((11) - (10) + 1)) - 1) << (10))) | (((pSgmiiAdvAbility->linkSpeed) & ((1 << ((11) - (10) + 1)) - 1)) << (10)));
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) &~ (((1 << ((12) - (12) + 1)) - 1) << (12))) | (((pSgmiiAdvAbility->duplexMode) & ((1 << ((12) - (12) + 1)) - 1)) << (12)));
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) &~ (((1 << ((15) - (15) + 1)) - 1) << (15))) | (((pSgmiiAdvAbility->bLinkUp) & ((1 << ((15) - (15) + 1)) - 1)) << (15)));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_getAdvAbility
 *
 *   @b Description
 *   @n This function rerturns the contents of 'MR_ADV_ABILITY' register in the 
 *      output parameter 'pSgmiiAdvAbility'.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which the read operation must
                            be done.
 *      pSgmiiAdvAbility    CSL_SGMII_ADVABILITY output param structure pointer
 *                          that needs to be populated with advertised ability
 *                          register contents.
 *   @endverbatim                          
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_MR_ADV_ABILITY_REG
 *
 *   @b Example
 *   @verbatim
 *      CSL_SGMII_STATUS    sgmiiAdvAbility;
        Uint32  portNum =   1;

        // Get SGMII Advertised ability info
        CSL_SGMII_getAdvAbility (portNum, &sgmiiAdvAbility);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_getAdvAbility (
    Uint32                      portNum,
	CSL_SGMII_ADVABILITY*       pSgmiiAdvAbility
)
{
    pSgmiiAdvAbility->linkSpeed     =   (CSL_SGMII_LINKSPEED) (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) >> (10)) & ((1 << ((11) - (10) + 1)) - 1));
    pSgmiiAdvAbility->duplexMode    =   (CSL_SGMII_DUPLEXMODE) (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) >> (12)) & ((1 << ((12) - (12) + 1)) - 1));
    pSgmiiAdvAbility->bLinkUp       =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_ADV_ABILITY_REG) >> (15)) & ((1 << ((15) - (15) + 1)) - 1));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_getLinkPartnerAdvAbility
 *
 *   @b Description
 *   @n This function rerturns the contents of 'MR_LP_ADV_ABILITY' register in the 
 *      output parameter 'pSgmiiAdvAbility'.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which read operation must be done
 *      pSgmiiAdvAbility    CSL_SGMII_ADVABILITY output param structure pointer
 *                          that needs to be populated with link partnet advertised 
 *                          ability register contents.
 *   @endverbatim                          
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_MR_LP_ADV_ABILITY_REG
 *
 *   @b Example
 *   @verbatim
 *      CSL_SGMII_STATUS    sgmiiAdvAbility;
        Uint32  portNum =   1;

        // Get SGMII Advertised ability info
        CSL_SGMII_getLinkPartnerAdvAbility (portNum, &sgmiiAdvAbility);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_getLinkPartnerAdvAbility (
    Uint32                      portNum,
	CSL_SGMII_ADVABILITY*       pSgmiiAdvAbility
)
{
    pSgmiiAdvAbility->linkSpeed     =   (CSL_SGMII_LINKSPEED) (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_LP_ADV_ABILITY_REG) >> (10)) & ((1 << ((11) - (10) + 1)) - 1));
    pSgmiiAdvAbility->duplexMode    =   (CSL_SGMII_DUPLEXMODE) (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_LP_ADV_ABILITY_REG) >> (12)) & ((1 << ((12) - (12) + 1)) - 1));
    pSgmiiAdvAbility->bLinkUp       =   (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. MR_LP_ADV_ABILITY_REG) >> (15)) & ((1 << ((15) - (15) + 1)) - 1));

    return;        
}

/** ============================================================================
 *   @n@b CSL_SGMII_getTxConfig
 *
 *   @b Description
 *   @n This function retrieves the contents of the Transmit configuration 
 *      register (TX_CFG).
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which read operation must be done.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_TX_CFG_REG
 *
 *   @b Example
 *   @verbatim
        Uint32      txCfgVal;
        Uint32      portNum =   1;

        txCfgVal = CSL_SGMII_getTxConfig (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_SGMII_getTxConfig 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. TX_CFG_REG) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SGMII_setTxConfig
 *
 *   @b Description
 *   @n This function sets up the contents of the Transmit configuration 
 *      register (TX_CFG) for the port specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which configuration must be done
 *      txCfgVal            SERDES transmit configuration value.
 *   @endverbatim
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  TX_CFG register setup with the value provided.
 *
 *   @b Writes
 *   @n CPSGMII_TX_CFG_REG
 *
 *   @b Example
 *   @verbatim
        Uint32      txCfgVal = 0x00000ea1;
        Uint32      portNum =   1;

        CSL_SGMII_setTxConfig (portNum, txCfgVal);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_setTxConfig 
(
    Uint32                      portNum,
	Uint32                      txCfgVal             
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. TX_CFG_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. TX_CFG_REG) & ~(0xFFFFFFFFu)) | (((txCfgVal) << (0x00000000u)) & (0xFFFFFFFFu)));

    return;
}

/** ============================================================================
 *   @n@b CSL_SGMII_getRxConfig
 *
 *   @b Description
 *   @n This function retrieves the contents of the Receive configuration 
 *      register (RX_CFG) for the port number specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which read operation must be done
 *	 @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_RX_CFG_REG
 *
 *   @b Example
 *   @verbatim
        Uint32      rxCfgVal;
        Uint32      portNum =   1;

        rxCfgVal = CSL_SGMII_getRxConfig (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_SGMII_getRxConfig 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. RX_CFG_REG) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SGMII_setRxConfig
 *
 *   @b Description
 *   @n This function sets up the contents of the Receive configuration 
 *      register (RX_CFG) for the port number specified
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which configuration must be done
 *      rxCfgVal            SERDES receive configuration value.
 *   @endverbatim
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  RX_CFG register setup with the value provided.
 *
 *   @b Writes
 *   @n CPSGMII_RX_CFG_REG
 *
 *   @b Example
 *   @verbatim
        Uint32      rxCfgVal = 0x00081021;
        Uint32      portNum =   1;

        CSL_SGMII_setRxConfig (portNum, rxCfgVal);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_setRxConfig 
(
    Uint32                      portNum,
	Uint32                      rxCfgVal             
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. RX_CFG_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. RX_CFG_REG) & ~(0xFFFFFFFFu)) | (((rxCfgVal) << (0x00000000u)) & (0xFFFFFFFFu)));

    return;
}

/** ============================================================================
 *   @n@b CSL_SGMII_getAuxConfig
 *
 *   @b Description
 *   @n This function retrieves the contents of the Auxilliary configuration 
 *      register (AUX_CFG) for the port number specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which read operation must be performed.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n CPSGMII_AUX_CFG_REG
 *
 *   @b Example
 *   @verbatim
        Uint32      auxCfgVal;
        Uint32      portNum =   1;

        auxCfgVal = CSL_SGMII_getAuxConfig (portNum);

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_SGMII_getAuxConfig 
(
    Uint32                      portNum
)
{
    return (((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. AUX_CFG_REG) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_SGMII_setAuxConfig
 *
 *   @b Description
 *   @n This function sets up the contents of the Auxilliary configuration 
 *      register (AUX_CFG) for the port specified.
 *
 *   @b Arguments   
     @verbatim
        portNum             SGMII port number for which configuration must be done
 *      auxCfgVal           SERDES PLL configuration value.
 *   @endverbatim
 *
 *   <b> Return Value </b>  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  AUX_CFG register setup with the value provided.
 *
 *   @b Writes
 *   @n CPSGMII_AUX_CFG_REG
 *
 *   @b Example
 *   @verbatim
        Uint32      auxCfgVal = 0x0000000b;
        Uint32      portNum =   1;

        CSL_SGMII_setAuxConfig (portNum, auxCfgVal);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_SGMII_setAuxConfig 
(
    Uint32                      portNum,
	Uint32                      auxCfgVal             
)
{
    ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. AUX_CFG_REG) = ((((CSL_Cpsgmii_PortRegs *) ((0x02000000) + 0x00090100))->SGMII_PORT[portNum]. AUX_CFG_REG) & ~(0xFFFFFFFFu)) | (((auxCfgVal) << (0x00000000u)) & (0xFFFFFFFFu)));

    return;
}
        



/**
@}
*/
        
/**  
 * @file csl_mdio.h
 *
 * @brief 
 *  Header file for functional layer of CSL MDIO. 
 *
 *  It contains the various enumerations, structure definitions and function 
 *  declarations
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** ============================================================================ 
 *
 * @defgroup CSL_MDIO_API MDIO
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * @subsection References
 *    -# Ethernet Media Access Controller User Guide
 * ============================================================================
 */ 



/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) Modified the header file includes to be RTSC compliant
 */

/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for mdio_user_group
\**************************************************************************/
typedef struct  {
    volatile Uint32 USER_ACCESS_REG;
    volatile Uint32 USER_PHY_SEL_REG;
} CSL_Mdio_user_groupRegs;

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 VERSION_REG;
    volatile Uint32 CONTROL_REG;
    volatile Uint32 ALIVE_REG;
    volatile Uint32 LINK_REG;
    volatile Uint32 LINK_INT_RAW_REG;
    volatile Uint32 LINK_INT_MASKED_REG;
    volatile Uint8  RSVD0[8];
    volatile Uint32 USER_INT_RAW_REG;
    volatile Uint32 USER_INT_MASKED_REG;
    volatile Uint32 USER_INT_MASK_SET_REG;
    volatile Uint32 USER_INT_MASK_CLEAR_REG;
    volatile Uint8  RSVD1[80];
    CSL_Mdio_user_groupRegs USER_GROUP[2];
} CSL_Mdio_Regs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* mdio_user_access0_reg */








/* mdio_user_phy_sel0_reg */





/* version_reg */





/* mdio_control_reg */









/* mdio_alive_reg */



/* mdio_link_reg */



/* mdio_link_int_raw_reg */



/* mdio_link_int_masked_reg */



/* mdio_user_int_raw_reg */



/* mdio_user_int_masked_reg */



/* mdio_user_int_mask_set_reg */



/* mdio_user_int_mask_clear_reg */




/**
@defgroup CSL_MDIO_SYMBOL  MDIO Symbols Defined
@ingroup CSL_MDIO_API
*/
/**
@defgroup CSL_MDIO_DATASTRUCT  MDIO Data Structures
@ingroup CSL_MDIO_API
*/
/**
@defgroup CSL_MDIO_FUNCTION  MDIO Functions
@ingroup CSL_MDIO_API
*/
/**
@defgroup CSL_MDIO_ENUM MDIO Enumerated Data Types
@ingroup CSL_MDIO_API
*/
    
/**
@addtogroup CSL_MDIO_SYMBOL
@{
*/

/**
@}
*/

/** @addtogroup CSL_MDIO_DATASTRUCT
 @{ */

/** Constants for passing parameters to the functions.
 */
/** @brief Pointer to the MDIO overlay registers */

/** @brief      
 *
 *  Holds the MDIO peripheral's version info. 
 */        
typedef struct {
	/**  Minor revision value */	
	Uint32      revMin;

	/**  Major revision value */	
	Uint32      revMaj;

	/**  Identifies the type of peripheral */	
	Uint32      modId;
}CSL_MDIO_VERSION;

/** @brief      
 *
 *  Holds the MDIO User Access Register
 *  contents.
 */        
typedef struct {
	/**  Data bits */	
	Uint16      data;

	/**  Phy Device Address */	
	Uint32      phyAddr;

	/**  Register Address */	
	Uint32      regAddr;

	/**  Acknowledgment bit */	
	Uint32      ack;

	/**  GO bit */	
	Uint32      go;
}CSL_MDIO_USERACCESS;

/** @brief      
 *
 *  Holds the MDIO User Phy Select Register
 *  contents.
 */        
typedef struct {
	/**  Link Status determination select bit. Always reads '0' */	
	Uint16      linkSel;

	/**  Link Status Change Interrupt Enable bit */	
	Uint32      bLinkIntEnable;

	/**  Phy Device Address */	
	Uint32      phyAddr;

}CSL_MDIO_USERPHYSEL;
        

/**
@}
*/


/** @addtogroup CSL_MDIO_FUNCTION
 @{ */

/**
@}
*/


/**  
 * @file  csl_mdioAux.h
 *
 * @brief  
 *  API Auxilary header file for MDIO CSL. Contains the different control 
 *  command and status query functions definations
 *   
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/




/** @addtogroup CSL_MDIO_FUNCTION
@{ */

/** ============================================================================
 *   @n@b CSL_MDIO_getVersionInfo
 *
 *   @b Description
 *   @n This function retrieves the MDIO version information.
 *
 *   @b Arguments
     @verbatim
        mdioVersionInfo     CSL_MDIO_VERSION structure that needs to be populated
                            with the version info read from the hardware.
 *	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_VERSION_REG_REVMINOR,
 *      MDIO_VERSION_REG_REVMAJ,
 *      MDIO_VERSION_REG_MODID
 *
 *   @b Example
 *   @verbatim
        CSL_MDIO_VERSION    mdioVersionInfo;

        CSL_MDIO_getVersion (&mdioVersionInfo);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_getVersionInfo (
	CSL_MDIO_VERSION*       mdioVersionInfo     
)
{
    mdioVersionInfo->revMin     =   (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->VERSION_REG) & (0x000000FFu)) >> (0x00000000u));
    mdioVersionInfo->revMaj     =   (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->VERSION_REG) & (0x0000FF00u)) >> (0x00000008u));
    mdioVersionInfo->modId      =   (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->VERSION_REG) & (0xFFFF0000u)) >> (0x00000010u));

    return;        
}

/** ============================================================================
 *   @n@b CSL_MDIO_getClkDivVal
 *
 *   @b Description
 *   @n This function retrieves the clock divider value (CLKDIV) from the
 *      MDIO control register.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_CONTROL_REG_CLKDIV
 *
 *   @b Example
 *   @verbatim
 *      Uint16      clkDivVal;

        clkDivVal   =   CSL_MDIO_getClkDivVal ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint16 CSL_MDIO_getClkDivVal (
    void
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_MDIO_setClkDivVal
 *
 *   @b Description
 *   @n This function configures the clock divider value (CLKDIV) in the
 *      MDIO control register with the value specified.
 *
 *   @b Arguments   
     @verbatim
        clkDivVal           The value to use for clock divider configuration.
                            When this set to 0, the MDIO clock is disabled.
 *	 @endverbatim
 *
 *   <b> Return Value </b>  
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  CONTROL_REG configured with the clock divider value. Configures the MDIO
 *       clock frequency.
 *
 *   @b Writes
 *   @n MDIO_CONTROL_REG_CLKDIV
 *
 *   @b Example
 *   @verbatim
 *      Uint16      clkDivVal;
 
        clkDivVal = 165;

        // Setup the MDIO clock frequency
        CSL_MDIO_setClkDivVal (clkDivVal);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_setClkDivVal (
    Uint16                 clkDivVal     
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & ~(0x0000FFFFu)) | (((clkDivVal) << (0x00000000u)) & (0x0000FFFFu)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_isFaultDetectEnabled
 *
 *   @b Description
 *   @n This function returns the value of the Fault detect enable bit of the
 *      MDIO control register. The Fault detect enable bit indicates whether
 *      physical layer fault detection is enabled.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_CONTROL_REG_FAULT_DETECT_ENABLE
 *
 *   @b Example
 *   @verbatim
        
        if (CSL_MDIO_isFaultDetectEnabled ())
        {
            // MDIO/Physical Layer fault detection is enabled
        }
        else
        {
            // MDIO/Physical Layer fault detection is disabled
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isFaultDetectEnabled (
    void
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & (0x00040000u)) >> (0x00000012u));
}


/** ============================================================================
 *   @n@b CSL_MDIO_enableFaultDetect
 *
 *   @b Description
 *   @n This function enables the Physical layer fault detection mechanism by
 *      setting 'FAULTENB' bit of the MDIO Control register to 1.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Enables PHY layer fault detection. 
 *
 *   @b Writes
 *   @n MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=1
 *
 *   @b Example
 *   @verbatim
 *
        // Enable Phy Layer fault detection
        CSL_MDIO_enableFaultDetect ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_enableFaultDetect (
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & ~(0x00040000u)) | (((1) << (0x00000012u)) & (0x00040000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_disableFaultDetect
 *
 *   @b Description
 *   @n This function disables the Physical layer fault detection mechanism by
 *      setting 'FAULTENB' bit of the MDIO Control register to 0.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Disables PHY layer fault detection.
 *
 *   @b Writes
 *   @n MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=0
 *
 *   @b Example
 *   @verbatim
 *
        // Disable Phy Layer fault detection
        CSL_MDIO_disableFaultDetect ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_disableFaultDetect (
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & ~(0x00040000u)) | (((0) << (0x00000012u)) & (0x00040000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_isFaultDetected
 *
 *   @b Description
 *   @n This function returns physical layer fault status, i.e., 1 to indicate 
 *      that the MDIO module has detected a physical layer fault and 0 otherwise.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_CONTROL_REG_FAULT
 *
 *   @b Example
 *   @verbatim
        
        if (CSL_MDIO_isFaultDetected ())
        {
            // Physical Layer fault detected
        }
        else
        {
            // No Physical Layer fault detected
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isFaultDetected (
    void
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & (0x00080000u)) >> (0x00000013u));
}

/** ============================================================================
 *   @n@b CSL_MDIO_clearFault
 *
 *   @b Description
 *   @n This function clears the 'FAULT' bit of the MDIO control register.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Clears the 'FAULT' bit of MDIO 'CONTROL_REG'.
 *
 *   @b Writes
 *   @n MDIO_CONTROL_REG_FAULT=1
 *
 *   @b Affects
 *   @n MDIO_CONTROL_REG_FAULT=0
 *
 *   @b Example
 *   @verbatim
 *
        // Clear MDIO fault bit
        CSL_MDIO_clearFault ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_clearFault (
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & ~(0x00080000u)) | (((1) << (0x00000013u)) & (0x00080000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_isPreambleEnabled
 *
 *   @b Description
 *   @n This function returns the value of the Preamble disable bit of the
 *      MDIO control register. It returns 1 to indicate the MDIO preamble is 
 *      enabled and 0 otherwise.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_CONTROL_REG_PREAMBLE
 *
 *   @b Example
 *   @verbatim
        
        if (CSL_MDIO_isPreambleEnabled ())
        {
            // MDIO preamble enabled
        }
        else
        {
            // MDIO preamble disabled
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isPreambleEnabled (
    void
)
{
    Uint32      bIsPreambleDisabled;

    bIsPreambleDisabled = (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & (0x00100000u)) >> (0x00000014u));

    return (bIsPreambleDisabled == 0 ? 1 : 0);
}


/** ============================================================================
 *   @n@b CSL_MDIO_enablePreamble
 *
 *   @b Description
 *   @n This function enables the MDIO preamble.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Enables MDIO Preamble frames.
 *
 *   @b Writes
 *   @n MDIO_CONTROL_REG_PREAMBLE=0
 *
 *   @b Example
 *   @verbatim
 *
        // Enable MDIO preamble frames
        CSL_MDIO_enablePreamble ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_enablePreamble (
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & ~(0x00100000u)) | (((0) << (0x00000014u)) & (0x00100000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_disablePreamble
 *
 *   @b Description
 *   @n This function disables the MDIO preamble.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Disables MDIO Preamble frames.
 *
 *   @b Writes
 *   @n MDIO_CONTROL_REG_PREAMBLE=1
 *
 *   @b Example
 *   @verbatim
 *
        // Disable MDIO preamble frames
        CSL_MDIO_disablePreamble ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_disablePreamble (
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & ~(0x00100000u)) | (((1) << (0x00000014u)) & (0x00100000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_getHighestUserChannel
 *
 *   @b Description
 *   @n This function returns the highest user access channel available in MDIO 
 *      module.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_CONTROL_REG_HIGHEST_USER_CHANNEL
 *
 *   @b Example
 *   @verbatim
 *      Uint32  userAccChannel;
     
        // Get the highest user access channel.
        userAccChannel = CSL_MDIO_getHighestUserChannel ();
	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_getHighestUserChannel (
    void
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & (0x1F000000u)) >> (0x00000018u));
}

/** ============================================================================
 *   @n@b CSL_MDIO_isStateMachineEnabled
 *
 *   @b Description
 *   @n This function returns the value of the Enable bit of the MDIO control 
 *      register. It returns 1 to indicate that the MDIO state machine is enabled
 *      and is active and 0 to indicate otherwise.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_CONTROL_REG_ENABLE
 *
 *   @b Example
 *   @verbatim
        
        if (CSL_MDIO_isStateMachineEnabled ())
        {
            // MDIO state machine enabled
        }
        else
        {
            // MDIO state machine disabled
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isStateMachineEnabled (
    void
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & (0x40000000u)) >> (0x0000001Eu));
}


/** ============================================================================
 *   @n@b CSL_MDIO_enableStateMachine
 *
 *   @b Description
 *   @n This function enables the MDIO state machine if not already active.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Enables MDIO State machine.
 *
 *   @b Writes
 *   @n MDIO_CONTROL_REG_ENABLE
 *
 *   @b Example
 *   @verbatim
 *
        // Enable MDIO state machine
        CSL_MDIO_enableStateMachine ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_enableStateMachine (
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & ~(0x40000000u)) | (((1) << (0x0000001Eu)) & (0x40000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_disableStateMachine
 *
 *   @b Description
 *   @n This function sets the 'ENABLE' bit of the MDIO control register to 0, 
 *      triggering the disable of MDIO state machine if active.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  If the MDIO state machine is active at the time it is disabled, will
 *       complete the current operation before halting it and setting the
 *       idle bit.
 *
 *   @b Writes
 *   @n MDIO_CONTROL_REG_ENABLE=0
 *
 *   @b Example
 *   @verbatim
 *
        // Disable MDIO state machine
        CSL_MDIO_disableStateMachine ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_disableStateMachine (
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & ~(0x40000000u)) | (((0) << (0x0000001Eu)) & (0x40000000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_isStateMachineIdle
 *
 *   @b Description
 *   @n This function returns the value of the 'IDLE' bit of the MDIO control 
 *      register. It returns 1 to indicate that the MDIO state machine is in idle
 *      state and 0 otherwise.
 *
 *   @b Arguments   None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_CONTROL_REG_IDLE
 *
 *   @b Example
 *   @verbatim
        
        if (CSL_MDIO_isStateMachineIdle ())
        {
            // MDIO state machine idle
        }
        else
        {
            // MDIO state machine not idle
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isStateMachineIdle (
    void
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->CONTROL_REG) & (0x80000000u)) >> (0x0000001Fu));
}

/** ============================================================================
 *   @n@b CSL_MDIO_isPhyAlive
 *
 *   @b Description
 *   @n For a given PHY address provided to this function in 'phyAddr',  this function
 *      reads the 'ALIVE' bit corresponding to that PHY; The function returns 1 to
 *      indicate that the most recent access for the address was acknowledged by the 
 *      PHY and 0 otherwise.
 *
 *   @b Arguments
 *   @verbatim
 *      phyAddr             The PHY address number (0-31) for which the alive bit
 *                          status must be checked and returned by this function.
 *   @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_ALIVE_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      phyAddr = 0;
       
        // Check if PHY Address 0 is alive
        if (CSL_MDIO_isPhyAlive (phyAddr))
        {
            // MDIO PHY 0 access succeeded
        }
        else
        {
            // MDIO PHY 0 access failed
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isPhyAlive (
    Uint32                  phyAddr
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->ALIVE_REG) >> (phyAddr)) & ((1 << ((phyAddr) - (phyAddr) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_MDIO_clearPhyAliveStatus
 *
 *   @b Description
 *   @n For a given PHY address provided to this function in 'phyAddr',  this function
 *      clears the 'ALIVE' bit corresponding to that PHY.
 *
 *   @b Arguments
 *   @verbatim
 *      phyAddr             The PHY address number (0-31) for which the alive bit
 *                          status must be cleared.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Clears the ALIVE bit for the PHY address specified
 *
 *   @b Writes
 *   @n MDIO_ALIVE_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      phyAddr = 0;
       
        // Clear PHY 0 alive status bit
        CSL_MDIO_clearPhyAliveStatus (phyAddr);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_clearPhyAliveStatus (
    Uint32                  phyAddr
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->ALIVE_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->ALIVE_REG) &~ (((1 << ((phyAddr) - (phyAddr) + 1)) - 1) << (phyAddr))) | (((1) & ((1 << ((phyAddr) - (phyAddr) + 1)) - 1)) << (phyAddr)));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_isPhyLinked
 *
 *   @b Description
 *   @n For a given PHY address provided to this function in 'phyAddr',  this function
 *      reads the 'LINK' bit corresponding to that PHY; The function returns 1 to
 *      indicate that the corresponding PHY address has a link.
 *
 *   @b Arguments
 *   @verbatim
 *      phyAddr             The PHY address number (0-31) for which the link bit
 *                          status must be checked and returned by this function.
 *   @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_LINK_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      phyAddr = 0;
       
        // Check if PHY Address 0 link is up
        if (CSL_MDIO_isPhyLinked (phyAddr))
        {
            // MDIO PHY 0 link up
        }
        else
        {
            // MDIO PHY 0 link not up
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isPhyLinked (
    Uint32                  phyAddr
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->LINK_REG) >> (phyAddr)) & ((1 << ((phyAddr) - (phyAddr) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_MDIO_isUnmaskedLinkStatusChangeIntSet
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERPHYSEL register, this function returns the 'LINKINTRAW' register
 *      contents corresponding to it. This functions returns a 1 to indicate that
 *      the link status has changed for the PHY provided and 0 otherwise.
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the link status change
 *                          bit must be read. Phy selector value 0 corresponds to the
 *                          PHY address programmed in USERPHYSEL0 register and a Phy
 *                          selector value 1 corresponds to the PHY address in 
 *                          USERPHYSEL1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_ALIVE_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        if (CSL_MDIO_isUnmaskedLinkStatusChangeIntSet (index))
        {
            // Link status has changed
        }
        else
        {
            // Link status has not changed
        }
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isUnmaskedLinkStatusChangeIntSet (
    Uint32                  index
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->LINK_INT_RAW_REG) >> (index)) & ((1 << ((index) - (index) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_MDIO_clearUnmaskedLinkStatusChangeInt
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERPHYSEL register, this function clears the 'LINKINTRAW' register
 *      contents corresponding to it. 
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the link status change
 *                          bit must be read. Phy selector value 0 corresponds to the
 *                          PHY address programmed in USERPHYSEL0 register and a Phy
 *                          selector value 1 corresponds to the PHY address in 
 *                          USERPHYSEL1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Clears the Link change interrupt.
 *
 *   @b Writes
 *   @n MDIO_LINK_INT_RAW_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        CSL_MDIO_clearUnmaskedLinkStatusChangeInt (index);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_clearUnmaskedLinkStatusChangeInt (
    Uint32                  index
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->LINK_INT_RAW_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->LINK_INT_RAW_REG) &~ (((1 << ((index) - (index) + 1)) - 1) << (index))) | (((1) & ((1 << ((index) - (index) + 1)) - 1)) << (index)));
}

/** ============================================================================
 *   @n@b CSL_MDIO_isMaskedLinkStatusChangeIntSet
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERPHYSEL register, this function returns the 'LINKINTMASKED' register
 *      contents corresponding to it. This functions returns a 1 to indicate that
 *      the link status has changed for the PHY provided and 0 otherwise.
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the link status change
 *                          bit must be read. Phy selector value 0 corresponds to the
 *                          PHY address programmed in USERPHYSEL0 register and a Phy
 *                          selector value 1 corresponds to the PHY address in 
 *                          USERPHYSEL1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_LINK_INT_MASKED_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        if (CSL_MDIO_isMaskedLinkStatusChangeIntSet (index))
        {
            // Link status has changed
        }
        else
        {
            // Link status has not changed
        }
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isMaskedLinkStatusChangeIntSet (
    Uint32                  index
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->LINK_INT_MASKED_REG) >> (index)) & ((1 << ((index) - (index) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_MDIO_clearMaskedLinkStatusChangeInt
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERPHYSEL register, this function clears the 'LINKINTMASKED' register
 *      contents corresponding to it. 
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the link status change
 *                          bit must be read. Phy selector value 0 corresponds to the
 *                          PHY address programmed in USERPHYSEL0 register and a Phy
 *                          selector value 1 corresponds to the PHY address in 
 *                          USERPHYSEL1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Clears the Link change interrupt.
 *
 *   @b Writes
 *   @n MDIO_LINK_INT_MASKED_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        CSL_MDIO_clearMaskedLinkStatusChangeInt (index);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_clearMaskedLinkStatusChangeInt (
    Uint32                  index
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->LINK_INT_MASKED_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->LINK_INT_MASKED_REG) &~ (((1 << ((index) - (index) + 1)) - 1) << (index))) | (((1) & ((1 << ((index) - (index) + 1)) - 1)) << (index)));
}


/** ============================================================================
 *   @n@b CSL_MDIO_isUnmaskedUserCmdCompleteIntSet
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERACCESS register, this function returns the 'USERINTRAW' register
 *      contents corresponding to it. This functions returns a 1 to indicate that
 *      the previously scheduled PHY read/write command using that particular
 *      USERACCESS register has completed and returns 0 otherwise.
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the unmasked user 
 *                          command complete interrupt bit must be read. Phy selector 
 *                          value 0 corresponds to the PHY address used in USERACCESS0
 *                          register and a Phy selector value 1 corresponds to the PHY 
 *                          address in USERACCESS1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_USER_INT_RAW_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        if (CSL_MDIO_isUnmaskedUserCmdCompleteIntSet (index))
        {
            // User command completed
        }
        else
        {
            // User command not done
        }
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isUnmaskedUserCmdCompleteIntSet (
    Uint32                  index
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_RAW_REG) >> (index)) & ((1 << ((index) - (index) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_MDIO_clearUnmaskedUserCmdCompleteInt
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERACCESS register, this function clears the 'USERINTRAW' register
 *      contents corresponding to it. 
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the unmasked user 
 *                          command complete interrupt bit must be cleared. Phy selector 
 *                          value 0 corresponds to the PHY address used in USERACCESS0
 *                          register and a Phy selector value 1 corresponds to the PHY 
 *                          address in USERACCESS1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Clears the User command complete interrupt.
 *
 *   @b Writes
 *   @n MDIO_USER_INT_RAW_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        CSL_MDIO_clearUnmaskedUserCmdCompleteInt (index);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_clearUnmaskedUserCmdCompleteInt (
    Uint32                  index
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_RAW_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_RAW_REG) &~ (((1 << ((index) - (index) + 1)) - 1) << (index))) | (((1) & ((1 << ((index) - (index) + 1)) - 1)) << (index)));
}

/** ============================================================================
 *   @n@b CSL_MDIO_isMaskedUserCmdCompleteIntSet
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERACCESS register, this function returns the 'USERINTMASKED' register
 *      contents corresponding to it. This functions returns a 1 to indicate that
 *      the previously scheduled PHY read/write command using that particular
 *      USERACCESS register has completed and corresponding USERINTMASKSET bit is
 *      set to 1 and returns 0 otherwise.
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the masked user 
 *                          command complete interrupt bit must be read. Phy selector 
 *                          value 0 corresponds to the PHY address used in USERACCESS0
 *                          register and a Phy selector value 1 corresponds to the PHY 
 *                          address in USERACCESS1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_USER_INT_MASKED_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        if (CSL_MDIO_isMaskedUserCmdCompleteIntSet (index))
        {
            // User command completed
        }
        else
        {
            // User command not done
        }
        }

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isMaskedUserCmdCompleteIntSet (
    Uint32                  index
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_MASKED_REG) >> (index)) & ((1 << ((index) - (index) + 1)) - 1));
}

/** ============================================================================
 *   @n@b CSL_MDIO_clearMaskedUserCmdCompleteInt
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERACCESS register, this function clears the 'USERINTMASKED' register
 *      contents corresponding to it. 
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the masked user 
 *                          command complete interrupt bit must be cleared. Phy selector 
 *                          value 0 corresponds to the PHY address used in USERACCESS0
 *                          register and a Phy selector value 1 corresponds to the PHY 
 *                          address in USERACCESS1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Clears the User command complete interrupt.
 *
 *   @b Writes
 *   @n MDIO_USER_INT_MASKED_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        CSL_MDIO_clearMaskedUserCmdCompleteInt (index);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_clearMaskedUserCmdCompleteInt (
    Uint32                  index
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_MASKED_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_MASKED_REG) &~ (((1 << ((index) - (index) + 1)) - 1) << (index))) | (((1) & ((1 << ((index) - (index) + 1)) - 1)) << (index)));
}

/** ============================================================================
 *   @n@b CSL_MDIO_enableUserCmdCompleteInterrupt
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERACCESS register, this function enables the user command complete
 *      interrupts for it.
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the masked user 
 *                          command complete interrupt bit must be enabled. Phy selector 
 *                          value 0 corresponds to the PHY address used in USERACCESS0
 *                          register and a Phy selector value 1 corresponds to the PHY 
 *                          address in USERACCESS1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Enables the interrupt for User command complete events posted using USERACCESS
 *       register.
 *
 *   @b Writes
 *   @n MDIO_USER_INT_MASK_SET_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        CSL_MDIO_enableUserCmdCompleteInterrupt (index);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_enableUserCmdCompleteInterrupt (
    Uint32                  index
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_MASK_SET_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_MASK_SET_REG) &~ (((1 << ((index) - (index) + 1)) - 1) << (index))) | (((1) & ((1 << ((index) - (index) + 1)) - 1)) << (index)));
}

/** ============================================================================
 *   @n@b CSL_MDIO_disableUserCmdCompleteInterrupt
 *
 *   @b Description
 *   @n For a given PHY selector(0-1) provided corresponding to the PHY address 
 *      in USERACCESS register, this function disables the user command complete
 *      interrupts for it.
 *
 *   @b Arguments
 *   @verbatim
 *      index              The PHY selector (0-1) for which the masked user 
 *                          command complete interrupt bit must be enabled. Phy selector 
 *                          value 0 corresponds to the PHY address used in USERACCESS0
 *                          register and a Phy selector value 1 corresponds to the PHY 
 *                          address in USERACCESS1 register.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  Disables the interrupt for User command complete events posted using USERACCESS
 *       register.
 *
 *   @b Writes
 *   @n MDIO_USER_INT_MASK_CLEAR_REG
 *
 *   @b Example
 *   @verbatim
 *      Uint32      index = 0;
       
        CSL_MDIO_disableUserCmdCompleteInterrupt (index);
	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_disableUserCmdCompleteInterrupt (
    Uint32                  index
)
{
    ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_MASK_CLEAR_REG) = ((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_INT_MASK_CLEAR_REG) &~ (((1 << ((index) - (index) + 1)) - 1) << (index))) | (((1) & ((1 << ((index) - (index) + 1)) - 1)) << (index)));
}

/** ============================================================================
 *   @n@b CSL_MDIO_getUserAccessRegister
 *
 *   @b Description
 *   @n This function retrieves the contents of the USERACCESS register 
 *      corresponding to the 'index' (0-1) provided.
 *
 *   @b Arguments
 *   @verbatim
 *      index               Specifies which of the USERACCESS register contents
 *                          must be read by this function. Valid values are 0-1,
 *                          both inclusive.
 *      pUserAccessReg      CSL_MDIO_USERACCESS structure that needs to be 
 *                          populated with the User Access register contents.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n MDIO_USER_ACCESS_REG_DATA,
 *      MDIO_USER_ACCESS_REG_PHYADR,
 *      MDIO_USER_ACCESS_REG_REGADR,
 *      MDIO_USER_ACCESS_REG_ACK,
 *      MDIO_USER_ACCESS_REG_GO
 *
 *   @b Example
 *   @verbatim
 *      CSL_MDIO_USERACCESS      userAccReg;

        // Get User Access Reg 0 contents
        CSL_MDIO_getUserAccessRegister (0, &userAccReg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_getUserAccessRegister (
    Uint32                  index,                        
    CSL_MDIO_USERACCESS*    pUserAccessReg
)
{
    Uint32                  regVal;

    regVal  =   ((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_GROUP [index].USER_ACCESS_REG;
    pUserAccessReg->data    =   (((regVal) & (0x0000FFFFu)) >> (0x00000000u));
    pUserAccessReg->phyAddr =   (((regVal) & (0x001F0000u)) >> (0x00000010u));
    pUserAccessReg->regAddr =   (((regVal) & (0x03E00000u)) >> (0x00000015u));
    pUserAccessReg->ack     =   (((regVal) & (0x20000000u)) >> (0x0000001Du));
    pUserAccessReg->go      =   (((regVal) & (0x80000000u)) >> (0x0000001Fu));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_setUserAccessRegister
 *
 *   @b Description
 *   @n This function configures the contents of the USERACCESS register 
 *      corresponding to the 'index' (0-1) provided with the values provided
 *      in 'pUserAccessReg' input parameter.
 *
 *   @b Arguments
 *   @verbatim
 *      index               Specifies which of the USERACCESS register contents
 *                          must be configured by this function. Valid values are 0-1,
 *                          both inclusive.
 *      pUserAccessReg      CSL_MDIO_USERACCESS structure that specifies the values
 *                          that need to be configured into the User Access register 
 *                          contents.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  User Access Register(USERACCESS) corresponding to the index specified is 
 *       configured.
 *
 *   @b Reads
 *   @n MDIO_USER_ACCESS_REG_DATA,
 *      MDIO_USER_ACCESS_REG_PHYADR,
 *      MDIO_USER_ACCESS_REG_REGADR,
 *      MDIO_USER_ACCESS_REG_WRITE=1,
 *      MDIO_USER_ACCESS_REG_GO
 *
 *   @b Example
 *   @verbatim
 *      CSL_MDIO_USERACCESS      userAccReg;
 
        userAccessReg.data      =   1;
        userAccessReg.phyAddr   =   0;
        ...
        userAccessReg.go        =   1;

        // Set User Access Reg 0 contents
        CSL_MDIO_setUserAccessRegister (0, &userAccReg);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_setUserAccessRegister (
    Uint32                  index,                        
    CSL_MDIO_USERACCESS*    pUserAccessReg
)
{
    ((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_GROUP [index].USER_ACCESS_REG   =   (((pUserAccessReg->data) << (0x00000000u)) & (0x0000FFFFu)) |
                                                        (((pUserAccessReg->phyAddr) << (0x00000010u)) & (0x001F0000u)) |
                                                        (((pUserAccessReg->regAddr) << (0x00000015u)) & (0x03E00000u)) |
                                                        (((1) << (0x0000001Eu)) & (0x40000000u)) |
                                                        (((pUserAccessReg->go) << (0x0000001Fu)) & (0x80000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_isUserAccessPending
 *
 *   @b Description
 *   @n This function reads the 'GO' bit of the USERACCESS register corresponding
 *      to the 'index' specified and returns its value. When 1 returned, indicates
 *      that the user access transaction (read/write) performed earlier is still
 *      pending and has not yet completed. 0 indicates that the transaction has 
 *      completed.
 *
 *   @b Arguments
 *   @verbatim
 *      index               Specifies which of the USERACCESS register's GO bit
 *                          must be read by this function. Valid values are 0-1,
 *                          both inclusive.
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None.
 *
 *   @b Reads
 *   @n MDIO_USER_ACCESS_REG_GO
 *
 *   @b Example
 *   @verbatim
 *      CSL_MDIO_USERACCESS      userAccReg;
 
        userAccessReg.data      =   1;
        userAccessReg.phyAddr   =   0;
        ...
        userAccessReg.go        =   1;

        // Set User Access Reg 0 contents
        CSL_MDIO_setUserAccessRegister (0, &userAccReg);

        // Wait till the set completes
        while (CSL_MDIO_isUserAccessPending (0));

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_MDIO_isUserAccessPending (
    Uint32                  index                        
)
{
    return (((((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_GROUP [index]. USER_ACCESS_REG) & (0x80000000u)) >> (0x0000001Fu));
}


/** ============================================================================
 *   @n@b CSL_MDIO_enableLinkStatusChangeInterrupt
 *
 *   @b Description
 *   @n This function sets the 'LINKINTENB' bit to 1 for a PHY address 'phyAddr'
 *      being monitored by the MDIO module. This configuration is done for
 *      the 'USERPHYSEL' register corresponding to the index specified here.
 *
 *   @b Arguments
 *   @verbatim
 *      index               Specifies which of the USERPHYSEL register contents
 *                          must be configured by this function. Valid values are 0-1,
 *                          both inclusive.
 *      phyAddr             PHY Address for which the Link Status change interrupt 
 *                          must be enabled.                         
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for 
 *       the index specified. Link Status Change interrupt enabled for PHY address
 *       specified.
 *
 *   @b Writes
 *   @n MDIO_USER_PHY_SEL_REG_PHYADR_MON,
 *      MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=1
 *
 *   @b Example
 *   @verbatim
 *      
        // Enable PHY 0's interrupt
        CSL_MDIO_enableLinkStatusChangeInterrupt (0, 0);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_enableLinkStatusChangeInterrupt (
    Uint32                  index,                        
    Uint32                  phyAddr
)
{
    ((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_GROUP [index].USER_PHY_SEL_REG  =   (((phyAddr) << (0x00000000u)) & (0x0000001Fu)) |
                                                        (((1) << (0x00000006u)) & (0x00000040u));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_disableLinkStatusChangeInterrupt
 *
 *   @b Description
 *   @n This function sets the 'LINKINTENB' bit to 0 for a PHY address 'phyAddr'
 *      being monitored by the MDIO module. This configuration is done for
 *      the 'USERPHYSEL' register corresponding to the index specified here.
 *
 *   @b Arguments
 *   @verbatim
 *      index               Specifies which of the USERPHYSEL register contents
 *                          must be configured by this function. Valid values are 0-1,
 *                          both inclusive.
 *      phyAddr             PHY Address for which the Link Status change interrupt 
 *                          must be disabled.                         
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for 
 *       the index specified.Link Status Change interrupt disabled for PHY address
 *       specified.
 *
 *   @b Writes
 *   @n MDIO_USER_PHY_SEL_REG_PHYADR_MON,
 *      MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=0
 *
 *   @b Example
 *   @verbatim
 *      
        // Disable PHY 0's interrupt
        CSL_MDIO_disableLinkStatusChangeInterrupt (0, 0);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_disableLinkStatusChangeInterrupt (
    Uint32                  index,                        
    Uint32                  phyAddr
)
{
    ((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_GROUP [index].USER_PHY_SEL_REG  =   (((phyAddr) << (0x00000000u)) & (0x0000001Fu)) |
                                                        (((0) << (0x00000006u)) & (0x00000040u));

    return;
}

/** ============================================================================
 *   @n@b CSL_MDIO_getUserPhySelect
 *
 *   @b Description
 *   @n This function reads the 'USERPHYSEL' register contents corresponding to 
 *      the index specified here and returns its contents in the output param
 *      'pUserPhySelect'.
 *
 *   @b Arguments
 *   @verbatim
 *      index               Specifies which of the USERPHYSEL register contents
 *                          must be configured by this function. Valid values are 0-1,
 *                          both inclusive.
 *      pUserPhySelect      CSL_MDIO_USERPHYSEL structure that needs to be populated
 *                          with register contents
 *   @endverbatim
 *
 *   <b> Return Value </b>  
 *   @n  None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None.
 *
 *   @b Reads
 *   @n MDIO_USER_PHY_SEL_REG_PHYADR_MON,
 *      MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE,
 *      MDIO_USER_PHY_SEL_REG_LINKSEL
 *
 *   @b Example
 *   @verbatim
 *      CSL_MDIO_USERPHYSEL    userPhySelect; 
 
        // Get USERPHYSEL0 contents
        CSL_MDIO_getUserPhySelect (0, &userPhySelect);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_MDIO_getUserPhySelect (
    Uint32                  index,                        
    CSL_MDIO_USERPHYSEL*    pUserPhySelect
)
{
    Uint32                  regVal;

    regVal  =   ((CSL_Mdio_Regs *) ((0x02000000) + 0x00090300))->USER_GROUP [index].USER_PHY_SEL_REG;
    pUserPhySelect->linkSel         =   (((regVal) & (0x00000080u)) >> (0x00000007u));
    pUserPhySelect->phyAddr         =   (((regVal) & (0x0000001Fu)) >> (0x00000000u));
    pUserPhySelect->bLinkIntEnable  =   (((regVal) & (0x00000040u)) >> (0x00000006u));

    return;
}




/**
@}
*/

/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/
 
/******************************************************************************	
 *
 * File	Name:	evmc66x_i2c_uart.h
 *
 * Description:	This contains UART specific structure, typedefs, function
 *		prototypes.
 *
 ******************************************************************************/

/************************
 * Defines and Macros
 ************************/
// Mask	to enable DLL and DLM

// for 19200 baudrate for crystal clock	14.7456	MHz

// Macros to be	used for setting baudrate



/************************
 * Function declarations
************************/
void UartInit(void);
void UartSetBaudRate(uint16_t uiBaudRate);
uint16_t UartReadBaudRate(void);
uint8_t UartReadData(void);
void UartWriteData(uint8_t uchByte);
Bool UartIsDataReady(void);

/*
 * cslr_uart.h
 *
 * This file contains the macros for Register Chip Support Library (CSL) which 
 * can be used for operations on the respective underlying hardware/peripheral
 *
 * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** ============================================================================
 *   @file  cslr_uart.h
 *
 *   @path  $(CSLPATH)
 *
 *   @desc  This file contains the Register Descriptions for UART
 *
 *  ============================================================================
 */






/* Minimum unit = 4 bytes */

/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint32 RBR;
    volatile Uint32 IER;
    volatile Uint32 IIR;
    volatile Uint32 LCR;
    volatile Uint32 MCR;
    volatile Uint32 LSR;
    volatile Uint32 MSR;
    volatile Uint32 SCR;
    volatile Uint32 DLL;
    volatile Uint32 DLH;
    volatile Uint32 REVID1;
    volatile Uint32 REVID2;
    volatile Uint32 PWREMU_MGMT;
    volatile Uint32 MDR;
} CSL_UartRegs;

/*************************************************************************** Overlay structure typedef definition
\**************************************************************************/
typedef volatile CSL_UartRegs             *CSL_UartRegsOvly;

/* Following 2 lines are added due to CSL3.x tools limitations */

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* RBR */




/* THR */




/* IER */


/*----EDSSI Tokens----*/

/*----ELSI Tokens----*/

/*----ETBEI Tokens----*/

/*----ERBI Tokens----*/


/* IIR */


/*----FIFOEN Tokens----*/


/*----INTID Tokens----*/

/*----IPEND Tokens----*/


/* FCR */


/*----RXFIFTL Tokens----*/


/*----DMAMODE1 Tokens----*/

/*----TXCLR Tokens----*/

/*----RXCLR Tokens----*/

/*----FIFOEN Tokens----*/


/* LCR */


/*----DLAB Tokens----*/

/*----BC Tokens----*/

/*----SP Tokens----*/

/*----EPS Tokens----*/

/*----PEN Tokens----*/

/*----STB Tokens----*/

/*----WLS Tokens----*/


/* MCR */


/*----AFE Tokens----*/

/*----LOOP Tokens----*/

/*----OUT2 Tokens----*/

/*----OUT1 Tokens----*/

/*----RTS Tokens----*/

/*----DTR Tokens----*/


/* LSR */


/*----RXFIFOE Tokens----*/

/*----TEMT Tokens----*/

/*----THRE Tokens----*/

/*----BI Tokens----*/

/*----FE Tokens----*/

/*----PE Tokens----*/

/*----OE Tokens----*/

/*----DR Tokens----*/


/* MSR */


/*----CD Tokens----*/

/*----RI Tokens----*/

/*----DSR Tokens----*/

/*----CTS Tokens----*/

/*----DCD Tokens----*/

/*----TERI Tokens----*/

/*----DDSR Tokens----*/

/*----DCTS Tokens----*/


/* SCR */




/* DLL */




/* DLH */




/* PID1 */



/* PID2 */




/* PWREMU_MGMT */



/*----UTRST Tokens----*/

/*----URRST Tokens----*/



/*----FREE Tokens----*/


/* MDR */


/*----OSM_SEL Tokens----*/







/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/
 
 /******************************************************************************	
 *
 * File	Name:	evmc66x_gpio.h
 *
 * Description:	This file is the header	file for GPIO module
 *
 *
 ******************************************************************************/

/**
 *   @file  csl_gpioAux.h
 *
 *   @brief   
 *      This is the GPIO Auxilary Header File which exposes the various
 *      CSL Functional Layer API's to configure the GPIO Module.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2009, Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/




/** @addtogroup CSL_GPIO_FUNCTION
 @{ */


/** ============================================================================
 *   @n@b CSL_GPIO_getPID
 *
 *   @b Description
 *   @n This function reads the peripheral ID register which identifies the 
 *      scheme of PID encoding, function, rtl id, major id, custom id and minor id.
 *
 *   @b Arguments
     @verbatim
          scheme        Scheme of PID encoding
          function      GPIO function
          rtl           RTL ID of GPIO module 
          major         Major ID of GPIO module 
          custom        Custom ID of GPIO module 
          minor         Minor ID of GPIO module 
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_PID_SCHEME,GPIO_PID_FUNC,GPIO_PID_RTL,GPIO_PID_MAJOR,GPIO_PID_CUSTOM,GPIO_PID_MINOR
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint16          function;
        Uint8           scheme, rtl, major, custom, minor;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Get the GPIO Peripheral Identification.
        CSL_GPIO_getPID (hGpio, &scheme, &function, &rtl, &major, &custom, &minor);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_getPID 
(
    CSL_GpioHandle  hGpio, 
    Uint8           *scheme, 
    Uint16          *function, 
    Uint8           *rtl,
    Uint8           *major,
    Uint8           *custom,
    Uint8           *minor
)
{
    Uint32 value = hGpio->PID;

    *scheme     = (((value) & (0xC0000000u)) >> (0x0000001Eu));
    *function   = (((value) & (0x0FFF0000u)) >> (0x00000010u));
    *rtl        = (((value) & (0x0000F800u)) >> (0x0000000Bu));
    *major      = (((value) & (0x00000700u)) >> (0x00000008u));
    *custom     = (((value) & (0x000000C0u)) >> (0x00000006u));
    *minor      = (((value) & (0x0000003Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_GPIO_getPCR
 *
 *   @b Description
 *   @n This function reads the peripheral Control register which identifies the 
 *      emulation mode. 
 *
 *   @b Arguments
     @verbatim
          soft          Used in conjunction with FREE bit to determine
                        the emulation suspend mode. GPIO has FREE bit set to 1 
                        so SOFT bit does not affect functionality.
          free          For GPIO, the FREE bit is fixed at 1, which
                        means GPIO runs free in emulation suspend.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_PCR_SOFT,GPIO_PCR_FREE
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           soft, free;
 
        ...
        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);

        // Get the GPIO Peripheral Control register configuration.
        CSL_GPIO_getPCR (hGpio, &soft, &free);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_getPCR 
(
    CSL_GpioHandle  hGpio, 
    Uint8           *soft, 
    Uint8           *free 
)
{
    Uint32 value = hGpio->PCR;
    *soft = (((value) & (0x00000002u)) >> (0x00000001u));
    *free = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_GPIO_bankInterruptEnable
 *
 *   @b Description
 *   @n This function enables the GPIO per bank interrupt. Each bank supports 16 GPIO signals.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          bankNum           GPIO Bank Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_BINTEN_EN=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           bankNum = 0;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Enable GPIO per bank interrupt for bank zero
        CSL_GPIO_bankInterruptEnable (hGpio, bankNum);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_bankInterruptEnable 
(
    CSL_GpioHandle  hGpio,
    Uint8           bankNum
)
{
    ((hGpio->BINTEN) = ((hGpio->BINTEN) &~ (((1 << ((bankNum) - (bankNum) + 1)) - 1) << (bankNum))) | (((1) & ((1 << ((bankNum) - (bankNum) + 1)) - 1)) << (bankNum)));
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_bankInterruptDisable
 *
 *   @b Description
 *   @n This function disables the GPIO per bank interrupt. Each bank supports 16 GPIO signals.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          bankNum           GPIO Bank Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_BINTEN_EN=0
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           bankNum = 0;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Disable GPIO per bank interrupt for bank zero
        CSL_GPIO_bankInterruptDisable (hGpio, bankNum);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_bankInterruptDisable 
(
    CSL_GpioHandle  hGpio,
    Uint8           bankNum
)
{
    ((hGpio->BINTEN) = ((hGpio->BINTEN) &~ (((1 << ((bankNum) - (bankNum) + 1)) - 1) << (bankNum))) | (((0) & ((1 << ((bankNum) - (bankNum) + 1)) - 1)) << (bankNum)));
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_isBankInterruptEnabled
 *
 *   @b Description
 *   @n This function returns the status of GPIO per bank interrupt. Each bank supports 16 GPIO signals.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          bankNum           GPIO Bank Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Interrupt is enabled
 *   @n FALSE - Interrupt is disabled
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_BINTEN_EN
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Check if GPIO per bank interrupt is enabled or disabled
        if (CSL_GPIO_isBankInterruptEnabled (hGpio) == TRUE)
        {
            // GPIO per bank interrupt is ENABLED
        }
        else
        {
            // GPIO per bank interrupt is DISABLED
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_GPIO_isBankInterruptEnabled
(
    CSL_GpioHandle  hGpio,
    Uint8           bankNum
)
{
    if ((((hGpio->BINTEN) >> (bankNum)) & ((1 << ((bankNum) - (bankNum) + 1)) - 1)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_GPIO_setPinDirOutput
 *
 *   @b Description
 *   @n This function sets the direction of GPIO pin as an output pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_DIR_DIR=0
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Set GPIO pin number 1 as an output pin
        CSL_GPIO_setPinDirOutput (hGpio, pinNum);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_setPinDirOutput 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    ((hGpio->BANK_REGISTERS[bankIndex]. DIR) = ((hGpio->BANK_REGISTERS[bankIndex]. DIR) &~ (((1 << ((bitPos) - (bitPos) + 1)) - 1) << (bitPos))) | (((0) & ((1 << ((bitPos) - (bitPos) + 1)) - 1)) << (bitPos)));
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_setPinDirInput
 *
 *   @b Description
 *   @n This function sets the direction of GPIO pin as an input pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_DIR_DIR=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Set GPIO pin number 1 as an input pin
        CSL_GPIO_setPinDirInput (hGpio, pinNum);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_setPinDirInput 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
    ((hGpio->BANK_REGISTERS[bankIndex]. DIR) = ((hGpio->BANK_REGISTERS[bankIndex]. DIR) &~ (((1 << ((bitPos) - (bitPos) + 1)) - 1) << (bitPos))) | (((1) & ((1 << ((bitPos) - (bitPos) + 1)) - 1)) << (bitPos)));
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_getPinDirection
 *
 *   @b Description
 *   @n This function gets the direction configuration of GPIO pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n 0  - Pin is configured as output pin
 *   @n 1  - Pin is configured as input pin
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_DIR_DIR
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Check if pin 1 is configured as input or output pin
        if (CSL_GPIO_getPinDirection (hGpio, pinNum))
        {
            // GPIO pin is configured as INPUT
        }
        else
        {
            // GPIO pin is configured as OUTPUT
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_GPIO_getPinDirection 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    return ((((hGpio->BANK_REGISTERS[bankIndex]. DIR) >> (bitPos)) & ((1 << ((bitPos) - (bitPos) + 1)) - 1)));
}

/** ============================================================================
 *   @n@b CSL_GPIO_getOutputData
 *
 *   @b Description
 *   @n This function gets the output drive state of GPIO pin when it is configured as an output pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
          outData           Bit data when GPIO is configured as output pin
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_OUT_DATA_OUT
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1, outData;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Get the output data on pin 1
        CSL_GPIO_getOutputData (hGpio, pinNum, &outData));
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_getOutputData 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum,
    Uint8           *outData
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    *outData = (((hGpio->BANK_REGISTERS[bankIndex]. OUT_DATA) >> (bitPos)) & ((1 << ((bitPos) - (bitPos) + 1)) - 1));
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_setOutputData
 *
 *   @b Description
 *   @n This function sets the output drive state of GPIO pin when it is configured as an output pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_SET_DATA_SET=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 0;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Set output of GPIO pin number 0 to 1
        CSL_GPIO_setOutputData (hGpio, pinNum);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_setOutputData 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;

    hGpio->BANK_REGISTERS[bankIndex].SET_DATA = 1 << bitPos;
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_clearOutputData
 *
 *   @b Description
 *   @n This function clears the output drive state of GPIO pin when it is configured as an output pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_CLR_DATA_CLR=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 0;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Clear output of GPIO pin number 0
        CSL_GPIO_clearOutputData (hGpio, pinNum);
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_clearOutputData 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    hGpio->BANK_REGISTERS[bankIndex].CLR_DATA = 1 << bitPos;

    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_getInputData
 *
 *   @b Description
 *   @n This function gets the input bit data on GPIO pin when it is configured as an input pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
          inData            Bit data when GPIO is configured as input pin
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_IN_DATA_IN
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1, inData;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Get the output data on pin 1
        CSL_GPIO_getInputData (hGpio, pinNum, &inData));
        ...  
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_getInputData 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum,
    Uint8           *inData
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    *inData = (((hGpio->BANK_REGISTERS[bankIndex]. IN_DATA) >> (bitPos)) & ((1 << ((bitPos) - (bitPos) + 1)) - 1));
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_setRisingEdgeDetect
 *
 *   @b Description
 *   @n This function sets rising edge interrupt detection for GPIO pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_SET_RIS_TRIG_SETRIS=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Set interrupt detection on GPIO pin 1 to rising edge
        CSL_GPIO_setRisingEdgeDetect (hGpio, pinNum));
        ...    
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_setRisingEdgeDetect 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    ((hGpio->BANK_REGISTERS[bankIndex]. SET_RIS_TRIG) = ((hGpio->BANK_REGISTERS[bankIndex]. SET_RIS_TRIG) &~ (((1 << ((bitPos) - (bitPos) + 1)) - 1) << (bitPos))) | (((1) & ((1 << ((bitPos) - (bitPos) + 1)) - 1)) << (bitPos)));
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_clearRisingEdgeDetect
 *
 *   @b Description
 *   @n This function clears rising edge interrupt detection for GPIO pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_CLR_RIS_TRIG_CLRRIS=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Clear rising edge interrupt detection on GPIO pin 1
        CSL_GPIO_clearRisingEdgeDetect (hGpio, pinNum));
        ...    
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_clearRisingEdgeDetect 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex;
    
    bankIndex = pinNum / 32;
        
    hGpio->BANK_REGISTERS[bankIndex].CLR_RIS_TRIG = 1 << pinNum;
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_isRisingEdgeDetect
 *
 *   @b Description
 *   @n This function checks if the interrupt detection for GPIO pin is set to rising edge or not.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Interrupt detection is set to rising edge
 *   @n FALSE - Interrupt detection is not set to rising edge
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_SET_RIS_TRIG_SETRIS
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Check interrupt detection state on GPIO pin 1 
        if (CSL_GPIO_isRisingEdgeDetect (hGpio, pinNum) == TRUE)
        {
            // Interrupt detection is set to RISING EDGE
        }
        else
        {
            // Interrupt detection is not set to RISING EDGE
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_GPIO_isRisingEdgeDetect 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    if ((((hGpio->BANK_REGISTERS[bankIndex]. SET_RIS_TRIG) >> (bitPos)) & ((1 << ((bitPos) - (bitPos) + 1)) - 1)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_GPIO_setFallingEdgeDetect
 *
 *   @b Description
 *   @n This function sets falling edge interrupt detection for GPIO pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_SET_FAL_TRIG_SETFAL=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Set interrupt detection on GPIO pin 1 to falling edge
        CSL_GPIO_setFallingEdgeDetect (hGpio, pinNum));
        ...
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_setFallingEdgeDetect 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    ((hGpio->BANK_REGISTERS[bankIndex]. SET_FAL_TRIG) = ((hGpio->BANK_REGISTERS[bankIndex]. SET_FAL_TRIG) &~ (((1 << ((bitPos) - (bitPos) + 1)) - 1) << (bitPos))) | (((1) & ((1 << ((bitPos) - (bitPos) + 1)) - 1)) << (bitPos)));
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_clearFallingEdgeDetect
 *
 *   @b Description
 *   @n This function clears falling edge interrupt detection for GPIO pin.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_CLR_FAL_TRIG_CLRFAL=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Clear falling edge interrupt detection on GPIO pin 1
        CSL_GPIO_clearFallingEdgeDetect (hGpio, pinNum));
        ...     
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_clearFallingEdgeDetect 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex;
    
    bankIndex = pinNum / 32;
        
    hGpio->BANK_REGISTERS[bankIndex].CLR_FAL_TRIG =  1 << pinNum;
    return;
}

/** ============================================================================
 *   @n@b CSL_GPIO_isFallingEdgeDetect
 *
 *   @b Description
 *   @n This function checks if the interrupt detection for GPIO pin is set to falling edge or not.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n TRUE  - Interrupt detection is set to falling edge
 *   @n FALSE - Interrupt detection is not set to falling edge
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_SET_FAL_TRIG_SETFAL
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Check interrupt detection state on GPIO pin 1 
        if (CSL_GPIO_isFallingEdgeDetect (hGpio, pinNum) == TRUE)
        {
            // Interrupt detection is set to FALLING EDGE
        }
        else
        {
            // Interrupt detection is not set to FALLING EDGE
        }
        ...
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_GPIO_isFallingEdgeDetect 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    if ((((hGpio->BANK_REGISTERS[bankIndex]. SET_FAL_TRIG) >> (bitPos)) & ((1 << ((bitPos) - (bitPos) + 1)) - 1)) == 1)
        return 1;
    return 0;
}

/** ============================================================================
 *   @n@b CSL_GPIO_getInterruptStatus
 *
 *   @b Description
 *   @n This function gets the GPIO pin interrupt status.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n 0 - Interrupt has not occurred since last cleared
 *   @n 1 - Interrupt has occurred
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Reads
 *   @n GPIO_INTSTAT_STAT
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Check interrupt status on pin 1
        if (CSL_GPIO_getInterruptStatus (hGpio, pinNum) == 0)
        {
            // Interrupt has not occured
        }
        else
        {
            // Interrupt has occured
        }
        ...     
     @endverbatim
 * =============================================================================
 */
static inline Bool CSL_GPIO_getInterruptStatus 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex, bitPos;
    
    bankIndex = pinNum / 32;
    bitPos = pinNum % 32;
        
    return ((((hGpio->BANK_REGISTERS[bankIndex]. INTSTAT) >> (bitPos)) & ((1 << ((bitPos) - (bitPos) + 1)) - 1)));
}

/** ============================================================================
 *   @n@b CSL_GPIO_clearInterruptStatus
 *
 *   @b Description
 *   @n This function clears the GPIO pin interrupt status.
 *
 *   @b Arguments
     @verbatim
          hGpio             Handle of the GPIO device
          pinNum            GPIO Pin Number
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n None
 *
 *   <b> Pre Condition </b>
 *   @n  CSL_GPIO_open() must be called 
 *
 *   <b> Post Condition </b>
 *   @n None
 *
 *   @b Writes
 *   @n GPIO_INTSTAT_STAT=1
 *
 *   @b Example
 *   @verbatim
        CSL_GpioHandle  hGpio;
        Uint8           pinNum = 1;

        // Open the CSL GPIO Module 0
        hGpio = CSL_GPIO_open (0);
        ...
        // Check interrupt status on pin 1
        CSL_GPIO_getInterruptStatus (hGpio, pinNum));
        ...        
        // Clear interrupt status on pin 1
        CSL_GPIO_clearInterruptStatus (hGpio, pinNum));
        ...     
     @endverbatim
 * =============================================================================
 */
static inline void CSL_GPIO_clearInterruptStatus 
(
    CSL_GpioHandle  hGpio,
    Uint8           pinNum
)
{
    Uint8       bankIndex;
    
    bankIndex = pinNum / 32;
        
    hGpio->BANK_REGISTERS[bankIndex].INTSTAT = 1 << pinNum;
    return;
}

/**
@}
*/





/******************************************************************************	
 * Copyright (c) 2011 Texas Instruments	Incorporated - http://www.ti.com
 *
 *  Redistribution and use in source and binary	forms, with or without
 *  modification, are permitted	provided that the following conditions
 *  are	met:
 *
 *    Redistributions of source	code must retain the above copyright
 *    notice, this list	of conditions and the following	disclaimer.
 *
 *    Redistributions in binary	form must reproduce the	above copyright	
 *    notice, this list	of conditions and the following	disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas	Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this	software without specific prior	written	permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS	
 *  "AS	IS" AND	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO,	THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR	ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY,	OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO,	PROCUREMENT OF SUBSTITUTE GOODS	OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION)	HOWEVER	CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,	OR TORT	
 *  (INCLUDING NEGLIGENCE OR OTHERWISE)	ARISING	IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *****************************************************************************/	

/******************************************************************************	
 *
 * File	Name:	evmc64x_i2c_eeprom.h
 *
 * Description:	Provides defintions and	prototypes local to the	i2c module.
 *
 ******************************************************************************/


/************************
 * Defines and Macros
 ************************/
// Register values for specific	purpose	


// Bit field definitions

// Return values

// Desired frequency for module operation

// Timeout limit for master	receiver. The units are	
// in number of bits, so provide some overhead

// Timeout limit for master	transmitter. The units are
// in number of bits, so provide some overhead

// Timeout limit for the master transmitter	to get access
// to the bus. In 10ms units.

/* Timeout limit after a master transmitter	operation is
 * complete, and waiting for access	to the MMRs. This should be on 
 * the order of two bytes, for the last two that are being sent 
 * (one in the shift register, one in the dxr. The units are in bits. */

/* Timeout limit in	slave receiver mode. The unit is in
 * expected	bit periods, but is long since the master
 * may have	a long delay before beginning transmission. */


/************************
 * Structures and Enums
 ************************/
 	
// Bus release
enum {
  I2C_RELEASE_BUS,
  I2C_DO_NOT_RELEASE_BUS
};

typedef	uint16_t I2C_RET;

// Byte	ordering
enum {
  I2C_BYTE_LSB,	
  I2C_BYTE_SLSB,
  I2C_BYTE_SMSB,
  I2C_BYTE_MSB
};

/************************
 * Function declarations
 ************************/
I2C_RET	i2cEepromWriteBlock( uint8_t uchEepromI2cAddress, uint32_t *puiData,
							 uint32_t uiNumBytes, uint32_t uiEndBusState);
I2C_RET	i2cEepromRead ( uint32_t byte_addr, uint32_t	uiNumBytes,
						uint8_t *puiData, uint8_t uchEepromI2cAddress);
I2C_RET	i2cEepromWrite( uint16_t uchEepromI2cAddress, uint32_t *puiData,
						uint32_t uiNumBytes, uint32_t uiEndBusState);
I2C_RET i2cEepromWriteByteAddr( uint32_t byte_addr, uint16_t uchEepromI2cAddress,
						uint8_t *puiData, uint32_t uiNumBytes, uint32_t uiEndBusState);
I2C_RET	i2cEepromMacWrite(uint8_t	*puchSrc);
I2C_RET	i2cEepromMacRead(uint8_t *puchDst);




/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/

/******************************************************************************	
 *
 * File	Name:	evmc66x_nand.h
 *
 * Description:	This is	the header file	for Nand flash API's.
 ******************************************************************************/

/*********************************
 * Defines and Macros and globals
 *********************************/
/* NAND FLASH ADDRESS */


/* NAND FLASH COMMANDS */
					

/* Maximum number of ECC bytes per page */

 /**
  *  Handle to access BOOTCFG registers.
  */
 
 /**
 @}
 */


/****************
 * Defines
 ****************/

// Macros for delay in micro Sec


// Macros for errors



// ECC related macros

typedef	struct _NAND_ADDR
{
    uint32_t uiColumnAddr;
    uint32_t uiPageAddr;
    uint32_t uiBlockAddr;
} NAND_ADDR;

typedef	struct	{
    uint32_t uiDeviceID;		// DeviceID
    uint32_t uiPageCount;		// Page	count per block
    uint32_t uiPageSize;		// Byte	count per page(include redundant parts)
    uint32_t blk_shift;		// Number of bits by which block address is to be shifted
    uint32_t addr_cycles;		// Number of address cycles
} StdNANDDeviceInfoObj;	

//  NAND_info structure	
typedef	struct	{
    uint32_t uiNandWidth;		// NAND	width 1-&gt;16 bits 0-&gt;8 bits
    uint32_t dev_code;		// NAND_DevTable index
    uint32_t uiPageCount;		// page	count per block
    uint32_t addr_cycles;		// Number of address cycles
    uint32_t big_block;		// 1 - Big block device, 0 - small block device
    uint32_t uiPageSize;		// Number of bytes in a	page including extra data 264/528
    uint32_t blk_shift;		// Number of bits by which block address is to be shifted
    uint32_t page_shift;		// Number of bits by which	page address is	to be shifted
    uint32_t numPage;			// Number of pages where boot loader is	stored
    uint32_t block;			// starting block number where User boot loader	is stored
    uint32_t page;			// starting page number	where boot-loader is stored
} StdNANDBootInfoObj;

/************************
 * Function declarations
 ************************/
uint32_t nandInit(void);
uint32_t readNandPage(PLATFORM_DEVICE_info* pNandInfo, NAND_ADDR address, uint8_t* puchBuffer);
uint32_t writeNandPage(PLATFORM_DEVICE_info* pNandInfo, NAND_ADDR address,	uint8_t* puchBuffer);
uint32_t enableNandECC(uint32_t uiUseSoftEcc);
uint32_t nandFlashBlockErase(PLATFORM_DEVICE_info* pNandInfo, uint32_t uiBlockNumber);
uint32_t NandGetDetails(PLATFORM_DEVICE_info* pNandInfo);
uint32_t NandReadSpareArea(PLATFORM_DEVICE_info* pNandInfo, uint32_t uiBlkAddr, uint32_t uiPage, uint8_t *pBuffer);
uint32_t NandWriteSpareArea (PLATFORM_DEVICE_info* pNandInfo, uint32_t uiBlkAddr, uint32_t uiPage, uint8_t *pBuffer);

/************************
 * Function declarations
 ************************/







/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/

/******************************************************************************	
 *
 * File Name:   evmc66x_nor.h
 *
 * Description: This is the header file for NOR flash API's.
 *
 ******************************************************************************/

/* ------------------------------------------------------------------------ *
 *  SPI NOR Definitions                                                     *
 * ------------------------------------------------------------------------ */

/* ------------------------------------------------------------------------ *
 *  SPI NOR Commands                                                        *
 * ------------------------------------------------------------------------ */


/* Read status Write In Progress timeout */

/* ------------------------------------------------------------------------ *
 *  NOR Error Status                                                        *
 * ------------------------------------------------------------------------ */

/* ------------------------------------------------------------------------ *
 *  Function declarations                                                   *
 * ------------------------------------------------------------------------ */
Uint32 
nor_init
(   
    void
);

Uint32
nor_read
(
	PLATFORM_DEVICE_info*   p_device,
    Uint32      addr, 
    Uint32      len, 
    Uint8*      buf
);

Uint32 
nor_write
(
	PLATFORM_DEVICE_info*   p_device,
    Uint32      addr, 
    Uint32      len, 
    Uint8*      buf
);

Uint32 
nor_erase
(
	PLATFORM_DEVICE_info*   p_device,
    Uint32  sector_number
);

uint32_t
nor_get_details
(
		PLATFORM_DEVICE_info* nor_info
);

/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/

/******************************************************************************	
 *
 * File Name:   evmc66x_spi.h
 *
 * Description: This is the header file for SPI API's.
 *
 ******************************************************************************/

/**
 *   @file  csl_pllcAux.h
 *
 *   @brief API Auxilary header file for PLLC CSL
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2010 Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/**
 *   @file  csl_pllc.h
 *
 *   @brief
 *      This is the main Header File for the PLLC Module which defines all
 *      the data structures and exported API.
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2010 Texas Instruments, Inc.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/
/** @defgroup CSL_PLLC_API PLLC
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 * 
 * The Phase-Locked Loop (PLL) controller offers flexibility and 
 * convenience by way of software configurable multipliers and
 * dividers to modify the clock input signal internally. The 
 * resulting clock outputs are passed to the DSP core, peripherals 
 * and other modules in the DSP.
 *
 * @subsection References
 *   -# PLLC User Guide. 
 *
 * @subsection Assumptions
 *    The abbreviations PLLC, pllc and Pllc have been used throughout this
 *    document to refer to PLL Controller.
 */


/********************************************************************
* Copyright (C) 2010 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/


/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    volatile Uint8 RSVD0[228];
    volatile Uint32 RSTYPE;
    volatile Uint32 RSTCTRL;
    volatile Uint32 RSTCFG;
    volatile Uint32 RSISO;
    volatile Uint8 RSVD1[12];
    volatile Uint32 PLLCTL;
    volatile Uint8 RSVD2[4];
    volatile Uint32 SECCTL;
    volatile Uint8 RSVD3[4];
    volatile Uint32 PLLM;
    volatile Uint32 PREDIV;
    volatile Uint32 PLLDIV1_3[3];
    volatile Uint8 RSVD4[4];
    volatile Uint32 POSTDIV;
    volatile Uint8 RSVD5[12];
    volatile Uint32 PLLCMD;
    volatile Uint32 PLLSTAT;
    volatile Uint32 ALNCTL;
    volatile Uint32 DCHANGE;
    volatile Uint32 CKEN;
    volatile Uint32 CKSTAT;
    volatile Uint32 SYSTAT;
    volatile Uint8 RSVD6[12];
    volatile Uint32 PLLDIV4_16[13];
} CSL_PllcRegs;

/*************************************************************************** Overlay structure typedef definition
\**************************************************************************/
typedef volatile CSL_PllcRegs               *CSL_PllcRegsOvly;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* RSTYPE */


/*----EMUSRST Tokens----*/



/*----PLLCTLRST Tokens----*/


/*----RESET Tokens----*/


/*----POR Tokens----*/


/* RSTCTRL */


/*----SWRST Tokens----*/



/* RSTCFG */


/*----PLLCTLRSTTYPE Tokens----*/


/*----RESETTYPE Tokens----*/


/*----WDTYPEN Tokens----*/


/* RSISO */


/*----SRIOISO Tokens----*/


/*----SRISO Tokens----*/


/*----AIF2ISO Tokens----*/


/* PLLCTL */


/*----PLLENSRC Tokens----*/


/*----PLLRST Tokens----*/


/*----PLLPWRDN Tokens----*/


/*----PLLEN Tokens----*/


/* SECCTL */



/* PLLM */



/* PREDIV */


/*----PREDEN Tokens----*/



/* PLLDIV1_3 */


/*----DnEN Tokens----*/



/* POSTDIV */


/*----POSTDEN Tokens----*/



/* PLLCMD */


/*----GOSET Tokens----*/


/* PLLSTAT */


/*----GOSTAT Tokens----*/


/* ALNCTL */



/* DCHANGE */



/* CKEN */


/*----AUXEN Tokens----*/


/* CKSTAT */


/*----AUXON Tokens----*/


/* SYSTAT */



/* PLLDIV4_16 */


/*----DnEN Tokens----*/




/**
@defgroup CSL_PLLC_SYMBOL  PLLC Symbols Defined
@ingroup CSL_PLLC_API
*/
/**
@defgroup CSL_PLLC_DATASTRUCT  PLLC Data Structures
@ingroup CSL_PLLC_API
*/
/**
@defgroup CSL_PLLC_FUNCTION  PLLC Functions
@ingroup CSL_PLLC_API
*/
/**
@defgroup CSL_PLLC_ENUM PLLC Enumerated Data Types
@ingroup CSL_PLLC_API
*/

/**
@addtogroup CSL_PLLC_SYMBOL
@{
*/

/**
@}
*/

/** @addtogroup CSL_PLLC_DATASTRUCT
 @{ */

/** @brief This is the handle to the PLLC instance */
typedef volatile CSL_PllcRegs*                  CSL_PllcHandle;

/** @brief PLLC Valid Key for configure Reset Control and Reset Cfg registers */


/**
@}
*/

/* Device specific API which opens the PLLC instance and returns a handle used in all subsequent calls */
extern CSL_PllcHandle CSL_PLLC_open (Int32 instNum);        






/** @addtogroup CSL_PLLC_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_PLLC_getResetStatus
 *
 *   @b Description
 *   @n Gets the Reset Type Status of the PLLC.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n RSTYPE
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint32          response;
        ...

        response = CSL_pllcGetResetStatus (hPllc);
     @endverbatim
 *  ============================================================================
 */
static inline Uint32 CSL_PLLC_getResetStatus (CSL_PllcHandle   hPllc)
{
   	return hPllc->RSTYPE;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setResetCtrlReg
 *
 *   @b Description
 *   @n Sets up the Key and Software Reset bit in Reset control register contents.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            key             Key value to setup
            swRstEnable     Enable/disable software reset
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_RSTCTRL_KEY,
 *      PLLC_RSTCTRL_SWRST
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        CSL_PLLC_setResetCtrlReg (hPllc, CSL_PLLC_RSTCTRL_VALID_KEY, 1);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setResetCtrlReg 
(
    CSL_PllcHandle      hPllc,
    Uint16              key,
    Uint8               swRstEnable
)
{
   	hPllc->RSTCTRL  =   (((key) << (0x00000000u)) & (0x0000FFFFu)) |
                        (((swRstEnable) << (0x00000010u)) & (0x00010000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getResetCtrlReg
 *
 *   @b Description
 *   @n Retrieves the contents of the Reset control register
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pKey            Key value read
            pSwRstEnable    Software reset enable bit read
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_RSTCTRL_KEY,
 *      PLLC_RSTCTRL_SWRST
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint16          key;
        Uint8           swRstEnable
        ...

        CSL_PLLC_getResetCtrlReg (hPllc, &key, &swRstEnable);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getResetCtrlReg 
(
    CSL_PllcHandle      hPllc, 
    Uint16*             pKey,
    Uint8*              pSwRstEnable
)
{
    Uint32              regVal;        

    regVal  =   hPllc->RSTCTRL;

    *pKey           =   (((regVal) & (0x0000FFFFu)) >> (0x00000000u));
    *pSwRstEnable   =   (((regVal) & (0x00010000u)) >> (0x00000010u));

   	return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setResetCfgReg
 *
 *   @b Description
 *   @n Sets up the contents of Reset configuration register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            wdType          Reset type initiated by Watchdog timers. Set 0 for hard
                            reset and 1 for soft reset
            resetType       Reset type initiated by RESET. Set 0 for hard
                            reset and 1 for soft reset
            pllCtrlRstType  Reset type initiated by PLL controller. Set 0 for hard
                            reset and 1 for soft reset
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API. Setup a 
 *       valid key using @a CSL_PLLC_setResetCtrlReg () API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_RSTCFG_WDTYPEN,
 *      PLLC_RSTCFG_RESETTYPE,
 *      PLLC_RSTCFG_PLLCTLRSTTYPE
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        CSL_PLLC_setResetCfgReg (hPllc, 0, 0, 0);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setResetCfgReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               wdType,
    Uint8               resetType,
    Uint8               pllCtrlRstType
)
{
   	hPllc->RSTCFG   =   (((wdType) << (0x00000000u)) & (0x000000FFu)) |
                        (((resetType) << (0x0000000Cu)) & (0x00001000u)) |
                        (((pllCtrlRstType) << (0x0000000Du)) & (0x00002000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getResetCfgReg
 *
 *   @b Description
 *   @n Retrieves the contents of Reset configuration register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pWdType         Reset type initiated by Watchdog timers. Returns 0 for hard
                            reset and 1 for soft reset
            pResetType      Reset type initiated by RESET. Returns 0 for hard
                            reset and 1 for soft reset
            pPllCtrlRstType Reset type initiated by PLL controller. Returns 0 for hard
                            reset and 1 for soft reset
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_RSTCFG_WDTYPEN,
 *      PLLC_RSTCFG_RESETTYPE,
 *      PLLC_RSTCFG_PLLCTLRSTTYPE
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           wdType, resetType, pllCtrlRstType;

        ...

        CSL_PLLC_getResetCfgReg (hPllc, &wdType, &resetType, &pllCtrlRstType);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getResetCfgReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pWdType,
    Uint8*              pResetType,
    Uint8*              pPllCtrlRstType
)
{
    Uint32              regVal;

    regVal  =   hPllc->RSTCFG;
    
    *pWdType            =   (((regVal) & (0x000000FFu)) >> (0x00000000u));
    *pResetType         =   (((regVal) & (0x00001000u)) >> (0x0000000Cu));
    *pPllCtrlRstType    =   (((regVal) & (0x00002000u)) >> (0x0000000Du));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setResetIsoReg
 *
 *   @b Description
 *   @n Sets up the contents of Reset Islolation register. Can be used to setup
 *      the module clocks that need to be work without pausing through non Power-on
 *      reset.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            aif2Iso         Isolate AIF2 module? Set to 1 to isolate it
            srIso           Isolate Smart Reflex module? Set to 1 to isolate it
            srioIso         Isolate SRIO module? Set to 1 to isolate it
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_RSISO_AIF2ISO,
 *      PLLC_RSISO_SRISO,
 *      PLLC_RSISO_SRIOISO
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        CSL_PLLC_setResetIsoReg (hPllc, 0, 0, 0);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setResetIsoReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               aif2Iso,
    Uint8               srIso,
    Uint8               srioIso
)
{
   	hPllc->RSISO    =   (((aif2Iso) << (0x00000003u)) & (0x00000008u)) |
                        (((srIso) << (0x00000008u)) & (0x00000100u)) |
                        (((srioIso) << (0x00000009u)) & (0x00000200u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getResetIsoReg
 *
 *   @b Description
 *   @n Retrieves the contents of Reset Islolation register. Indicates 
 *      the module clocks that are setup to work without pausing through non Power-on
 *      reset.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pAif2Iso        Indicates if AIF2 module is reset isolated
            pSrIso          Indicates if Smart Reflex module is reset isolated
            pSrioIso        Indicates if SRIO module is reset isolated
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_RSISO_AIF2ISO,
 *      PLLC_RSISO_SRISO,
 *      PLLC_RSISO_SRIOISO
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           aif2Iso, srIso, srioIso;

        ...

        CSL_PLLC_getResetIsoReg (hPllc, &aif2Iso, &srIso, &srioIso);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getResetIsoReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pAif2Iso,
    Uint8*              pSrIso,
    Uint8*              pSrioIso
)
{
    Uint32              regVal;

    regVal  =   hPllc->RSISO;
    
    *pAif2Iso   =   (((regVal) & (0x00000008u)) >> (0x00000003u));
    *pSrIso     =   (((regVal) & (0x00000100u)) >> (0x00000008u));
    *pSrioIso   =   (((regVal) & (0x00000200u)) >> (0x00000009u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllCtrlPllEnSrc
 *
 *   @b Description
 *   @n Sets up the PLLENSRC bit of PLL Control Register. Can be used to enable/disable
 *      configuration of PLLEN bit of PLLCTL register. Writes to PLLEN bit take 
 *      effect on PLLC only when PLLENSRC bit is set to 0.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            value           0/1 value to configure in PLLENSRC bit
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PLLCTL_PLLENSRC
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        // Enable PLLEN bit configuration
        CSL_PLLC_setPllCtrlPllEnSrc (hPllc, 0);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllCtrlPllEnSrc 
(
    CSL_PllcHandle      hPllc,
    Uint8               value  
)
{
    ((hPllc->PLLCTL) = ((hPllc->PLLCTL) & ~(0x00000020u)) | (((value) << (0x00000005u)) & (0x00000020u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllCtrlPllEn
 *
 *   @b Description
 *   @n Sets the PLLEN bit of PLL Control Register. This bit must be set to 0
 *      to put PLLC in Bypass mode and to 1 to put it in PLL operational mode.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            value           0/1 value to configure in PLL Enable bit. Set to 0 
                            to put PLLC in Bypass mode and to 1 to put in PLL mode.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *       Enable configuration of PLLEN bit first using @a CSL_PLLC_setPllCtrlPllEnSrc () API
 *       by passing it a value 0.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PLLCTL_PLLEN
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        // Enable PLLEN bit configuration
        CSL_PLLC_setPllCtrlPllEnSrc (hPllc, 0);

        // Put PLLC in Bypass mode 
        CSL_PLLC_setPllCtrlPllEn (hPllc, 0);

        // Configure PLLM/Pre-Divider
        ...

        // Put PLLC back in PLL mode
        CSL_PLLC_setPllCtrlPllEn (hPllc, 1);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllCtrlPllEn 
(
    CSL_PllcHandle      hPllc,
    Uint8               value
)
{
    ((hPllc->PLLCTL) = ((hPllc->PLLCTL) & ~(0x00000001u)) | (((value) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllCtrlPllReset
 *
 *   @b Description
 *   @n Sets up the PLLRST bit of PLL Control Register. Must be set to 1 to
 *      put PLLC in reset mode and to 0 to bring it out of reset.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            value           Value to configure in PLL Reset bit. Set to 1 to assert 
                            reset and 0 to release it from reset.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *       PLLC must be put in Bypass mode by passing a value 0 to @a CSL_PLLC_setPllCtrlPllEn () 
 *       API before asserting/de-asserting reset using this API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PLLCTL_PLLRST
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        // Enable PLLEN bit configuration
        CSL_PLLC_setPllCtrlPllEnSrc (hPllc, 0);

        // Put PLLC in Bypass mode 
        CSL_PLLC_setPllCtrlPllEn (hPllc, 0);

        // Put PLLC in reset
        CSL_PLLC_setPllCtrlPllReset (hPllc, 1);

        // Do PLLC configuration 
        ...

        // Bring PLLC out of reset
        CSL_PLLC_setPllCtrlPllReset (hPllc, 0);

        // Put PLLC back in PLL mode
        CSL_PLLC_setPllCtrlPllEn (hPllc, 1);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllCtrlPllReset 
(
    CSL_PllcHandle      hPllc,
    Uint8               value
)
{
    ((hPllc->PLLCTL) = ((hPllc->PLLCTL) & ~(0x00000008u)) | (((value) << (0x00000003u)) & (0x00000008u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllCtrlPllPowerDown
 *
 *   @b Description
 *   @n Sets up the PLLPWRDWN bit of PLL Control Register. Must be set to 1 to
 *      power down PLL and to 0 to wake up the PLL.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            value           Value to configure in PLL Power-down mode select bit. 
                            Set to 1 to place PLLC in power-down mode and to 0 to
                            wake it up.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *       PLLC must be put in Bypass mode by passing a value 0 to @a CSL_PLLC_setPllCtrlPllEn () 
 *       API before powering up/down using this API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PLLCTL_PLLPWRDN
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        // Enable PLLEN bit configuration
        CSL_PLLC_setPllCtrlPllEnSrc (hPllc, 0);

        // Put PLLC in Bypass mode 
        CSL_PLLC_setPllCtrlPllEn (hPllc, 0);

        // Power down PLL
        CSL_PLLC_setPllCtrlPllPowerDown (hPllc, 1);

        ...

        // Wake up PLL
        CSL_PLLC_setPllCtrlPllPowerDown (hPllc, 0);

        // Put PLLC back in PLL mode
        CSL_PLLC_setPllCtrlPllEn (hPllc, 1);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllCtrlPllPowerDown 
(
    CSL_PllcHandle      hPllc,
    Uint8               value
)
{
    ((hPllc->PLLCTL) = ((hPllc->PLLCTL) & ~(0x00000002u)) | (((value) << (0x00000001u)) & (0x00000002u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllCtrlReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Control Register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pllEn           PLL Enable bit. Set to 0 to put PLLC in Bypass mode and 
                            to 1 to put in PLL mode.
            pllPwrDwn       PLL Power-down mode select bit. Set to 1 to place PLLC
                            in power-down mode.
            pllRst          PLL Reset bit. Set to 1 to assert reset and 0 to release 
                            it from reset.
            pllEnSrc        PLL Enable Source bit. Set to 1 to enable writes to PLLEN
                            bit.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PLLCTL_PLLEN,
 *      PLLC_PLLCTL_PLLPWRDN,
 *      PLLC_PLLCTL_PLLRST,
 *      PLLC_PLLCTL_PLLENSRC
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        CSL_PLLC_setPllCtrlReg (hPllc, 0, 0, 1, 1);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllCtrlReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               pllEn,
    Uint8               pllPwrDwn,
    Uint8               pllRst,
    Uint8               pllEnSrc  
)
{
    /* Enable PLLEN bit if requested */                
    ((hPllc->PLLCTL) = ((hPllc->PLLCTL) & ~(0x00000020u)) | (((pllEnSrc) << (0x00000005u)) & (0x00000020u)));

    /* Configure rest of the bits in the register now */
   	hPllc->PLLCTL   =   (((pllEn) << (0x00000000u)) & (0x00000001u)) |
                        (((pllPwrDwn) << (0x00000001u)) & (0x00000002u)) |
                        (((pllRst) << (0x00000003u)) & (0x00000008u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllCtrlReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Control Register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pPllEn          PLL Enable bit. 0 indicates Bypass mode and 1 indicates 
                            PLL mode.
            pPllPwrDwn      PLL Power-down mode select bit. 1 indicates PLLC is
                            powered down and 0 indicates it is operational.
            pPllRst         PLL Reset bit. 1 indicates reset is asserted and 0 indicates
                            reset is cleared.
            pPllEnSrc       PLL Enable Source bit. Indicates if PLLEN bit is enabled.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_PLLCTL_PLLEN,
 *      PLLC_PLLCTL_PLLPWRDN,
 *      PLLC_PLLCTL_PLLRST,
 *      PLLC_PLLCTL_PLLENSRC
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           pllen, pllPwrDwn, pllRst, pllSrcEn;

        ...

        CSL_PLLC_getPllCtrlReg (hPllc, &pllen, &pllPwrDwn, &pllRst, &pllSrcEn);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getPllCtrlReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pPllEn,
    Uint8*              pPllPwrDwn,
    Uint8*              pPllRst,
    Uint8*              pPllEnSrc  
)
{
    Uint32              regVal;

    regVal  =   hPllc->PLLCTL;
    
    *pPllEn     =   (((regVal) & (0x00000001u)) >> (0x00000000u));
    *pPllPwrDwn =   (((regVal) & (0x00000002u)) >> (0x00000001u));
    *pPllRst    =   (((regVal) & (0x00000008u)) >> (0x00000003u));
    *pPllEnSrc  =   (((regVal) & (0x00000020u)) >> (0x00000005u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllSecCtrlReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Secondary Control Register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pllSecCtrlVal   Value to configure in the PLL Secondary control
                            register.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_SECCTL_PLLSECCTL
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        CSL_PLLC_setPllSecCtrlReg (hPllc, 0x10);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllSecCtrlReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               pllSecCtrlVal
)
{
    ((hPllc->SECCTL) = ((hPllc->SECCTL) & ~(0x00FF0000u)) | (((pllSecCtrlVal) << (0x00000010u)) & (0x00FF0000u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllSecCtrlReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Secondary Control Register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  Uint8
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_SECCTL_PLLSECCTL
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           pllSecCtrlVal;

        ...

        pllSecCtrlVal   =   CSL_PLLC_getPllSecCtrlReg (hPllc);
     @endverbatim
 *  ============================================================================
 */
static inline Uint8 CSL_PLLC_getPllSecCtrlReg 
(
    CSL_PllcHandle      hPllc
)
{
    return (((hPllc->SECCTL) & (0x00FF0000u)) >> (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllMultiplierCtrlReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Multiplier Control Register. 
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pllmVal         multiplier value to configure.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *       PLLC must be put in Bypass mode by passing a value 0 to @a CSL_PLLC_setPllCtrlPllEn () 
 *       API before setting up the multiplier using this API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PLLM_PLLM
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        // Enable PLLEN bit configuration
        CSL_PLLC_setPllCtrlPllEnSrc (hPllc, 0);

        // Put PLLC in Bypass mode 
        CSL_PLLC_setPllCtrlPllEn (hPllc, 0);

        // Configure PLLM/Pre-Divider
        // Setup x1 multiplier rate
        CSL_PLLC_setPllMultiplierCtrlReg (hPllc, 0);

        ...

        // Put PLLC back in PLL mode
        CSL_PLLC_setPllCtrlPllEn (hPllc, 1);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllMultiplierCtrlReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               pllmVal
)
{
    ((hPllc->PLLM) = ((hPllc->PLLM) & ~(0x0000003Fu)) | (((pllmVal) << (0x00000000u)) & (0x0000003Fu)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllMultiplierCtrlReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Multiplier Control Register. 
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  Uint8
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_PLLM_PLLM
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           pllmVal;

        ...

        pllmVal = CSL_PLLC_getPllMultiplierCtrlReg (hPllc);
     @endverbatim
 *  ============================================================================
 */
static inline Uint8 CSL_PLLC_getPllMultiplierCtrlReg 
(
    CSL_PllcHandle      hPllc
)
{
    return (((hPllc->PLLM) & (0x0000003Fu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllPreDivReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Pre-Divider Register. 
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            preDivEnable    Enable/disable the pre-divider
            preDivRatio     Divider ratio bits       
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *       PLLC must be put in Bypass mode by passing a value 0 to @a CSL_PLLC_setPllCtrlPllEn () 
 *       API before setting up the pre-divider using this API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PREDIV_RATIO,
 *      PLLC_PREDIV_PREDEN
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        // Enable PLLEN bit configuration
        CSL_PLLC_setPllCtrlPllEnSrc (hPllc, 0);

        // Put PLLC in Bypass mode 
        CSL_PLLC_setPllCtrlPllEn (hPllc, 0);

        // Configure Pre-Divider
        // Setup /1 divider rate and enable divider
        CSL_PLLC_setPllPreDivReg (hPllc, 1, 0);

        ...

        // Put PLLC back in PLL mode
        CSL_PLLC_setPllCtrlPllEn (hPllc, 1);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllPreDivReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               preDivEnable,
    Uint8               preDivRatio
)
{
    hPllc->PREDIV   =   (((preDivEnable) << (0x0000000Fu)) & (0x00008000u)) |
                        (((preDivRatio) << (0x00000000u)) & (0x0000001Fu));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllPreDivReg
 *
 *   @b Description
 *   @n Returns the contents of PLL Pre-Divider Register. 
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pPreDivEnable   Indicates if pre-divider is enabled
            pPreDivRatio    Divider ratio bits       
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_PREDIV_RATIO,
 *      PLLC_PREDIV_PREDEN
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           preDivEnable, preDivRatio;

        ...

        CSL_PLLC_getPllPreDivReg (hPllc, &preDivEnable, &preDivRatio);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getPllPreDivReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pPreDivEnable,
    Uint8*              pPreDivRatio
)
{
    Uint32              regVal;

    regVal  =   hPllc->PREDIV;
    
    *pPreDivEnable  =   (((regVal) & (0x00008000u)) >> (0x0000000Fu));
    *pPreDivRatio   =   (((regVal) & (0x0000001Fu)) >> (0x00000000u));

    return;
}


/** ============================================================================
 *   @n@b CSL_PLLC_setPllDivReg
 *
 *   @b Description
 *   @n Sets up the contents of any given PLL Divider Register corresponding to 
 *      the divider number specified.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            divNum          PLLC Divider register number. The divider number is 
                            1 based.
            divEnable       Enable/disable the divider
            divRatio        Divider ratio bits       
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *       Ensure @a CSL_PLLC_getPllStatusReg () returns 0 for GOSTAT bit status before
 *       configuring the Dividers.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PLLDIV1_3_DNEN,
 *      PLLC_PLLDIV1_3_RATIO;
 *      PLLC_PLLDIV4_16_DNEN, 
 *      PLLC_PLLDIV4_16_RATIO
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           goStatus;

        // Ensure no GO operation in progress already
        CSL_PLLC_getPllStatusReg (hPllc, &goStatus);
        while (goStatus != 0)
        {
            // wait some time and recheck GOSTAT status
            ...

            CSL_PLLC_getPllStatusReg (hPllc, &goStatus);
        }

        // Setup /1 divider rate and enable divider 1
        CSL_PLLC_setPllDivReg (hPllc, 1, 0);

        // Set the respective ALNn bit in ALNCTL register
        CSL_PLLC_setPllAlignCtrlReg (hPllc, 1);

        // Start GO operation
        CSL_PLLC_setPllCmdReg (hPllc, 1);

        // Ensure GO operation completes
        CSL_PLLC_getPllStatusReg (hPllc, &goStatus);
        while (goStatus != 0)
        {
            // wait some time and recheck GOSTAT status
            ...

            CSL_PLLC_getPllStatusReg (hPllc, &goStatus);
        }
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllDivReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               divNum,
    Uint8               divEnable,
    Uint8               divRatio
)
{
    if (divNum <= 3)
    {
        hPllc->PLLDIV1_3 [divNum - 1]   =   (((divEnable) << (0x0000000Fu)) & (0x00008000u)) |
                                            (((divRatio) << (0x00000000u)) & (0x0000001Fu));
    }
    else
    {
        hPllc->PLLDIV4_16 [divNum - 3 - 1]  =   (((divEnable) << (0x0000000Fu)) & (0x00008000u)) |
                                                (((divRatio) << (0x00000000u)) & (0x000000FFu));
    }

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllDivReg
 *
 *   @b Description
 *   @n Returns the contents of PLL Divider Register corresponding to a given
 *      divider number.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            divNum          PLLC Divider register number. The divider number is 
                            1 based.
            pDivEnable      Indicates if divider is enabled
            pDivRatio       Divider ratio bits       
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_PLLDIV1_3_DNEN,
 *      PLLC_PLLDIV1_3_RATIO;
 *      PLLC_PLLDIV4_16_DNEN, 
 *      PLLC_PLLDIV4_16_RATIO
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           divEnable, divRatio;

        ...

        // Get div 3 settings
        CSL_PLLC_getPllDivReg (hPllc, 3, &divEnable, &divRatio);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getPllDivReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               divNum,
    Uint8*              pDivEnable,
    Uint8*              pDivRatio
)
{
    Uint32              regVal;

    if (divNum <= 3)
    {
        regVal  =   hPllc->PLLDIV1_3 [divNum - 1];
    
        *pDivEnable =   (((regVal) & (0x00008000u)) >> (0x0000000Fu));
        *pDivRatio  =   (((regVal) & (0x0000001Fu)) >> (0x00000000u));
    }
    else
    {
        regVal  =   hPllc->PLLDIV4_16 [divNum - 3 - 1];
    
        *pDivEnable =   (((regVal) & (0x00008000u)) >> (0x0000000Fu));
        *pDivRatio  =   (((regVal) & (0x000000FFu)) >> (0x00000000u));
    }

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllPostDivReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Post-Divider Register. 
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            postDivEnable   Enable/disable the post-divider
            postDivRatio    Divider ratio bits       
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_POSTDIV_RATIO,
 *      PLLC_POSTDIV_POSTDEN
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        // Setup /1 divider rate and enable post divider
        CSL_PLLC_setPllPostDivReg (hPllc, 1, 0);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllPostDivReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               postDivEnable,
    Uint8               postDivRatio
)
{
    hPllc->POSTDIV  =   (((postDivEnable) << (0x0000000Fu)) & (0x00008000u)) |
                        (((postDivRatio) << (0x00000000u)) & (0x0000001Fu));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllPostDivReg
 *
 *   @b Description
 *   @n Returns the contents of PLL Post-Divider Register. 
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pPostDivEnable  Indicates if post-divider is enabled
            pPostDivRatio   Divider ratio bits       
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_POSTDIV_RATIO,
 *      PLLC_POSTDIV_POSTDEN
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           postDivEnable, postDivRatio;

        ...

        CSL_PLLC_getPllPostDivReg (hPllc, &postDivEnable, &postDivRatio);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getPllPostDivReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pPostDivEnable,
    Uint8*              pPostDivRatio
)
{
    Uint32              regVal;

    regVal  =   hPllc->POSTDIV;
    
    *pPostDivEnable =   (((regVal) & (0x00008000u)) >> (0x0000000Fu));
    *pPostDivRatio  =   (((regVal) & (0x0000001Fu)) >> (0x00000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllCmdReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Command register. Can be used to enable the 
 *      GOSET bit in PLLC Command register to initiate the GO operation or to
 *      clear it.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            goSetEnable     Set to 1 to enable GOSET bit and start GO operation 
                            and 0 to clear the bit.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_PLLCMD_GOSET
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        // Enable GO operation
        CSL_PLLC_setPllCmdReg (hPllc, 1);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllCmdReg 
(
    CSL_PllcHandle      hPllc,
    Uint8               goSetEnable
)
{
    ((hPllc->PLLCMD) = ((hPllc->PLLCMD) & ~(0x00000001u)) | (((goSetEnable) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllCmdReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Command register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pGoSetEnable    GOSET bit status.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_PLLCMD_GOSET
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           goSetEnable;
        ...

        CSL_PLLC_getPllCmdReg (hPllc, &goSetEnable);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getPllCmdReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pGoSetEnable
)
{
    *pGoSetEnable   =   (((hPllc->PLLCMD) & (0x00000001u)) >> (0x00000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllStatusReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Status register. Indicates the status 
 *      of the GO operation.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pGoStatus       GO operation status. 1 indicates GO operation is
                            in progress. 0 indicates GO operation is not in progress.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_PLLSTAT_GOSTAT
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           goStatus;
        ...

        CSL_PLLC_getPllStatusReg (hPllc, &goStatus);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getPllStatusReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pGoStatus
)
{
    *pGoStatus   =   (((hPllc->PLLSTAT) & (0x00000001u)) >> (0x00000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllAlignCtrlReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Clock Align control register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            alnCtlVal       Value to write to register.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_ALNCTL_ALN1_16
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        CSL_PLLC_setPllAlignCtrlReg (hPllc, 0);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllAlignCtrlReg 
(
    CSL_PllcHandle      hPllc,
    Uint32              alnCtlVal
)
{
    ((hPllc->ALNCTL) = ((hPllc->ALNCTL) & ~(0x0000FFFFu)) | (((alnCtlVal) << (0x00000000u)) & (0x0000FFFFu)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllAlignCtrlReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Clock Align control register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_ALNCTL_ALN1_16
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint32          alnCtlVal;
        ...

        alnCtlVal   =   CSL_PLLC_getPllAlignCtrlReg (hPllc);
     @endverbatim
 *  ============================================================================
 */
static inline Uint32 CSL_PLLC_getPllAlignCtrlReg 
(
    CSL_PllcHandle      hPllc
)
{
    return (((hPllc->ALNCTL) & (0x0000FFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_PLLC_setPllDChangeReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Divider Ratio Change Status register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            dChangeVal      Value to write to register.
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_DCHANGE_SYS1_16
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        CSL_PLLC_setPllDChangeReg (hPllc, 0);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllDChangeReg 
(
    CSL_PllcHandle      hPllc,
    Uint32              dChangeVal
)
{
    ((hPllc->DCHANGE) = ((hPllc->DCHANGE) & ~(0x0000FFFFu)) | (((dChangeVal) << (0x00000000u)) & (0x0000FFFFu)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllDChangeReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Divider Ratio Change Status register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_DCHANGE_SYS1_16
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint32          dChangeVal;
        ...

        dChangeVal   =   CSL_PLLC_getPllDChangeReg (hPllc);
     @endverbatim
 *  ============================================================================
 */
static inline Uint32 CSL_PLLC_getPllDChangeReg 
(
    CSL_PllcHandle      hPllc
)
{
    return (((hPllc->DCHANGE) & (0x0000FFFFu)) >> (0x00000000u));
}


/** ============================================================================
 *   @n@b CSL_PLLC_setPllClkEnableCtrlReg
 *
 *   @b Description
 *   @n Sets up the contents of PLL Clock Enable Control register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            auxClkEnable    Enable/disable PLLC output clock, AUXCLK
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n PLLC_CKEN_AUXEN
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;

        ...

        CSL_PLLC_setPllClkEnableCtrlReg (hPllc, 0);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_setPllClkEnableCtrlReg 
(
    CSL_PllcHandle      hPllc,
    Uint32              auxClkEnable
)
{
    ((hPllc->CKEN) = ((hPllc->CKEN) & ~(0x00000001u)) | (((auxClkEnable) << (0x00000000u)) & (0x00000001u)));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllClkEnableCtrlReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Clock Enable Control register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pAuxClkEnable   Indicates if AUXCLK is disabled/enabled
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_CKEN_AUXEN
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           auxClkEnable;
        ...

        CSL_PLLC_getPllClkEnableCtrlReg (hPllc, &auxClkEnable);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getPllClkEnableCtrlReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pAuxClkEnable
)
{
    *pAuxClkEnable  =   (((hPllc->CKEN) & (0x00000001u)) >> (0x00000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllClkStatusReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL Clock Status register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
            pAuxOn          Indicates if AUXCLK is ON
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  void
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_CKSTAT_AUXON
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint8           auxOn;
        ...

        CSL_PLLC_getPllClkStatusReg (hPllc, &auxOn);
     @endverbatim
 *  ============================================================================
 */
static inline void CSL_PLLC_getPllClkStatusReg 
(
    CSL_PllcHandle      hPllc,
    Uint8*              pAuxOn
)
{
    *pAuxOn =   (((hPllc->CKSTAT) & (0x00000001u)) >> (0x00000000u));

    return;
}

/** ============================================================================
 *   @n@b CSL_PLLC_getPllSysClkStatusReg
 *
 *   @b Description
 *   @n Retrieves the contents of PLL SYSCLK Status register.
 *
 *   @b Arguments
 *   @verbatim
            hPllc           Handle to the PLLC instance
     @endverbatim
 *
 *   <b> Return Value </b>
 *   @n  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  Must call @a CSL_PLLC_open () before calling any PLLC CSL API.
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n PLLC_SYSTAT_SYS1_16ON
 *
 *   @b Example
 *   @verbatim
        CSL_PllcHandle  hPllc;
        Uint32          sysClkStatus;
        ...

        sysClkStatus    =   CSL_PLLC_getPllSysClkStatusReg (hPllc);
     @endverbatim
 *  ============================================================================
 */
static inline Uint32 CSL_PLLC_getPllSysClkStatusReg 
(
    CSL_PllcHandle      hPllc
)
{
    return (((hPllc->SYSTAT) & (0x0000FFFFu)) >> (0x00000000u));
}

/**
@}
*/



/* ============================================================================
 * Copyright (c) Texas Instruments Incorporated 2008, 2009
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** 
 * @file csl_xmcAux.h
 *
 * @brief 
 *  API Auxilary header file for XMC CSL. It gives the definitions of the 
 *  status query & control functions.
 * 
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 *  @n   Use of this software is controlled by the terms and conditions found 
 *  @n   in the license agreement under which this software has been supplied.
 *  ===========================================================================
 *  \par  
 */



/*  ============================================================================
 *   Copyright (c) Texas Instruments Incorporated 2008, 2009
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/** 
 *   @file  csl_xmc.h
 *
 *   @brief  
 *      XMC CSL Implementation on DSP side
 *
 *  \par
 *  ============================================================================
 *  @n   (C) Copyright 2008, 2009, Texas Instruments, Inc.
 *  @n   Use of this software is controlled by the terms and conditions found 
 *  @n   in the license agreement under which this software has been supplied.
 *  ===========================================================================
 *  \par  
 */

/** @defgroup CSL_XMC_API XMC
 *
 * @section Introduction
 *
 * @subsection xxx Overview
 *
 * The XMC takes on the following roles:
 * 		a) UMC to VBusM conversion
 * 		b) Shared memory access path
 * 		c) Prefetch support
 * 		d) Address extension/translation
 * 		e) Memory protection for addresses outside CGEM eg. MSMC RAM or EMIF
 *
 * @subsection References
 *   -# XMC User's Guide
 *
 * @subsection Assumptions
 *    The abbreviations XMC, xmc and Xmc have been used throughout this
 *    document to refer to CGEM eXtended Memory Controller
 */



/********************************************************************
* Copyright (C) 2003-2008 Texas Instruments Incorporated.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/* CSL Modification:
 *  The file has been modified from the AUTOGEN file for the following
 *  reasons:-
 *      a) 	Modified the 'CSL_XmcRegs' register overlay structure. Merged 
 * 			the XMPAXL0, XMPAXH0, XMPAXL1, XMPAXH1 into the XMPAX array
 * 			and made XMPAX[] array an array of 16 such register pairs. This
 * 			was done because all the XMPAXL/H register pairs 0-15 had the 
 * 			exact same bit fields and masks and only diferred in the
 * 			reset values (which we do not use programatically). This 
 * 			simplifies the code and use of the APIs lot more simpler and
 * 			more consistent.
 * 	    b) Modified the header file includes to be RTSC compliant 
 */


/* Minimum unit = 1 byte */

/*************************************************************************** Register Overlay Structure for XMPAX
\**************************************************************************/
typedef struct  {
    volatile Uint32 XMPAXL;
    volatile Uint32 XMPAXH;
} CSL_XmcXmpaxRegs;


/*************************************************************************** Register Overlay Structure
\**************************************************************************/
typedef struct  {
    CSL_XmcXmpaxRegs XMPAX[16];
    volatile Uint8 RSVD0[384];
    volatile Uint32 XMPFAR;
    volatile Uint32 XMPFSR;
    volatile Uint32 XMPFCR;
    volatile Uint8 RSVD1[116];
    volatile Uint32 MDMAARBX;
    volatile Uint8 RSVD2[124];
    volatile Uint32 XPFCMD;
    volatile Uint32 XPFACS;
    volatile Uint8 RSVD3[8];
    volatile Uint32 XPFAC0;
    volatile Uint32 XPFAC1;
    volatile Uint32 XPFAC2;
    volatile Uint32 XPFAC3;
    volatile Uint8 RSVD4[224];
    volatile Uint32 XPFADDR[8];
} CSL_XmcRegs;

/*************************************************************************** Field Definition Macros
\**************************************************************************/

/* XMPAXL */











/* XMPAXH */





/* XMPAXL0 */











/* XMPAXH0 */





/* XMPAXL1 */











/* XMPAXH1 */





/* XMPFAR */



/* XMPFSR */












/* XMPFCR */




/* MDMAARBX */





/* XPFCMD */







/* XPFACS */





/* XPFAC0 */




/* XPFAC1 */




/* XPFAC2 */




/* XPFAC3 */




/* XPFADDR */











/**
@defgroup CSL_XMC_SYMBOL  XMC Symbols Defined
@ingroup CSL_XMC_API
*/
/**
@defgroup CSL_XMC_DATASTRUCT  XMC Data Structures
@ingroup CSL_XMC_API
*/
/**
@defgroup CSL_XMC_FUNCTION  XMC Functions
@ingroup CSL_XMC_API
*/

/** @addtogroup CSL_XMC_DATASTRUCT
 @{ */

/** @brief This is the definition of CSL_XMC_XMPAXH */
typedef struct CSL_XMC_XMPAXH
{
	/** Base Address */	
	Uint32 bAddr;
	
	/** Encoded Segment Size */	
	Uint8 segSize;
}CSL_XMC_XMPAXH;

/** @brief This is the definition of CSL_XMC_XMPAXL */
typedef struct CSL_XMC_XMPAXL 
{
	/** Replacement Address */
	Uint32 rAddr;
	
	/** When set, supervisor may read from segment */	
	Uint32 sr;

	/** When set, supervisor may write to segment */	
	Uint32 sw;
	
	/** When set, supervisor may execute from segment */	
	Uint32 sx;
	
	/** When set, user may read from segment */	
	Uint32 ur;

	/** When set, user may write to segment */	
	Uint32 uw;

	/** When set, user may execute from segment */	
	Uint32 ux;
}CSL_XMC_XMPAXL;

/** @brief This is the definition of CSL_XMC_MPFSR */
typedef struct CSL_XMC_MPFSR 
{
	/** Local Access ? */	
	Uint32 local;
	
	/** When set, indicates a Supervisor Read Request */
	Uint32 sr;
	
	/** When set, indicates a Supervisor Write Request */	
	Uint32 sw;
	
	/** When set, indicates a Supervisor program fetch Request */	
	Uint32 sx;
	
	/** When set, indicates a User Read Request */	
	Uint32 ur;
	
	/** When set, indicates a User Write Request */	
	Uint32 uw;

	/** When set, indicates a User program fetch Request */	
	Uint32 ux;			
}CSL_XMC_MPFSR;

/** @brief This is the definition of CSL_XMC_XPFADDR */
typedef struct CSL_XMC_XPFADDR 
{
	/** Stream address (128-bit aligned) */	
	Uint32 addr;

	/** Sign bit of stream direction (0=fwd, 1=rev) */	
	Uint32 dir;
	
	/** Data pending for upper ("high") half */	
	Uint32 dph;
	
	/** Data valid for upper half */	
	Uint32 dvh;
	
	/** Address valid for upper half */	
	Uint32 avh;
	
	/** Data pending for lower half */	
	Uint32 dpl;
	
	/** Data valid for lower half */	
	Uint32 dvl;
	
	/** Address valid for lower half */	
	Uint32 avl;
}CSL_XMC_XPFADDR;

/** @brief This is the definition of CSL_XMC_ACEN_MODE */
typedef enum {
    /** Disable analysis counters. */        
    CSL_XMC_ACEN_MODE_COUNT_DISABLE = 0,
    /** Count Program events only. */        
    CSL_XMC_ACEN_MODE_COUNT_PROGEVENTS = 1,
    /** Count Data events only. */        
    CSL_XMC_ACEN_MODE_COUNT_DATAEVENTS = 0,
    /** Count both program and data events. */        
    CSL_XMC_ACEN_MODE_COUNT_ALL = 0
}CSL_XMC_ACEN_MODE;
	
/**
 *  Handle to access XMC registers accessible through config bus.
 */

/**
@}
*/




/** @addtogroup CSL_XMC_FUNCTION
 @{ */

/** ============================================================================
 *   @n@b CSL_XMC_setXMPAXH
 *
 *   @b Description
 *   @n This function sets the contents of XMPAXH register indicated by the
 * 		index here.
 *
 *   @b Arguments
     @verbatim
        index       Index into the set of 16 registers (0-15)
        mpaxh       CSL_XMC_XMPAXH structure that needs to be set into the
                    register
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	 Corresponding XMPAXH register configured with the value passed.
 *
 *   @b Writes
 * 	 @n XMC_XMPAXH_SEGSZ, XMC_XMPAXH_BADDR
 *
 *   @b Example
 *   @verbatim
        Uint32 index = 0;
        CSL_XMC_XMPAXH mpaxh;

        mpaxh.segSize = 4;
        mpaxh.baseAddress = 0x1000;

        CSL_XMC_setXMPAXH (index, &mpaxh);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_setXMPAXH 
(
	Uint32          index,
	CSL_XMC_XMPAXH* mpaxh
)
{
    ((CSL_XmcRegs*)(0x08000000))->XMPAX[index].XMPAXH = (((mpaxh->segSize) << (0x00000000u)) & (0x0000001Fu)) |
                                (((mpaxh->bAddr) << (0x0000000Cu)) & (0xFFFFF000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_setXMPAXL
 *
 *   @b Description
 *   @n This function sets the contents of XMPAXL register corresponding to the
 * 		index specified. 
 *
 *   @b Arguments
     @verbatim
        index       Index into the set of 16 registers (0-15)
        mpaxl       CSL_XMC_XMPAXL structure that needs to be set into the
                    register
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	Corresponding XMPAXL register configured with the value passed.
 *
 *   @b Writes
 *   @n XMC_XMPAXL_RADDR, 
 *      XMC_XMPAXL_UX, 
 *      XMC_XMPAXL_UW,
 *      XMC_XMPAXL_UR, 
 *      XMC_XMPAXL_SX, 
 *      XMC_XMPAXL_SW,
 *      XMC_XMPAXL_SR
 *
 *   @b Example
 *   @verbatim
        Uint32 index = 0;
        CSL_XMC_XMPAXL mpaxl;

        mpaxl.ux = 1;
        mpaxl.uw = 1;
        mpaxl.ur = 1;
        mpaxl.sx = 1;
        mpaxl.sw = 1;
        mpaxl.sr = 1;
        mpaxl.rAddr = 0x4000 ;

        CSL_XMC_setXMPAXL (index, &mpaxl);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_setXMPAXL 
(
	Uint32           index,
	CSL_XMC_XMPAXL*  mpaxl
)
{
    Uint32 value = 0;

	/* Configure the XMPAXL register specified by the index. */	
	((value) = ((value) & ~(0x00000001u)) | (((mpaxl->ux) << (0x00000000u)) & (0x00000001u)));
	((value) = ((value) & ~(0x00000002u)) | (((mpaxl->uw) << (0x00000001u)) & (0x00000002u)));
	((value) = ((value) & ~(0x00000004u)) | (((mpaxl->ur) << (0x00000002u)) & (0x00000004u)));
	((value) = ((value) & ~(0x00000008u)) | (((mpaxl->sx) << (0x00000003u)) & (0x00000008u)));
	((value) = ((value) & ~(0x00000010u)) | (((mpaxl->sw) << (0x00000004u)) & (0x00000010u)));
	((value) = ((value) & ~(0x00000020u)) | (((mpaxl->sr) << (0x00000005u)) & (0x00000020u)));
	((value) = ((value) & ~(0xFFFFFF00u)) | (((mpaxl->rAddr) << (0x00000008u)) & (0xFFFFFF00u)));

	((CSL_XmcRegs*)(0x08000000))->XMPAX[index].XMPAXL = value;
}

/** ============================================================================
 *   @n@b CSL_XMC_getXMPAXH
 *
 *   @b Description
 *   @n This function gets the contents of XMPAXH register.
 *
 *   @b Arguments
     @verbatim
        index       Index into the set of 16 XMPAXH registers
        mpaxh       CSL_XMC_XMPAXH structure that needs to be populated with
                    XMPAXH register contents.
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n XMC_XMPAXH_SEGSZ, XMC_XMPAXH_BADDR
 *
 *   @b Example
 *   @verbatim
        Uint32 index = 0;
        CSL_XMC_XMPAXH mpaxh;

        CSL_XMC_getXMPAXH (index, &mpaxh);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_getXMPAXH 
(
	Uint32           index,
	CSL_XMC_XMPAXH*  mpaxh
)
{
    Uint32 value = ((CSL_XmcRegs*)(0x08000000))->XMPAX[index].XMPAXH;

	/* Retrieve contents of XMPAXH register specified by the index */		
	mpaxh->segSize = (((value) & (0x0000001Fu)) >> (0x00000000u));
	mpaxh->bAddr   = (((value) & (0xFFFFF000u)) >> (0x0000000Cu));
}

/** ============================================================================
 *   @n@b CSL_XMC_getXMPAXL
 *
 *   @b Description
 *   @n This function gets the contents of XMPAXL register.
 *
 *   @b Arguments
     @verbatim
        index       Index into the set of 16 registers
        mpaxl       CSL_XMC_XMPAXL structure that needs to be populated with
                    XMPAXL register contents.
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n XMC_XMPAXL_RADDR, 
 *      XMC_XMPAXL_UX, 
 *      XMC_XMPAXL_UW,
 *      XMC_XMPAXL_UR, 
 *      XMC_XMPAXL_SX, 
 *      XMC_XMPAXL_SW,
 *      XMC_XMPAXL_SR
 *
 *   @b Example
 *   @verbatim
        Uint32 index = 0;
        CSL_XMC_XMPAXL mpaxl;

        CSL_XMC_getXMPAXL (index, &mpaxl);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_getXMPAXL (
	Uint32 index,
	CSL_XMC_XMPAXL * mpaxl
)
{
    Uint32 value = ((CSL_XmcRegs*)(0x08000000))->XMPAX[index].XMPAXL;

	/* Retrieve contents of XMPAXL register using the index specified */		
	mpaxl->rAddr = (((value) & (0xFFFFFF00u)) >> (0x00000008u));
	mpaxl->sr = (((value) & (0x00000020u)) >> (0x00000005u));
	mpaxl->sw = (((value) & (0x00000010u)) >> (0x00000004u));
	mpaxl->sx = (((value) & (0x00000008u)) >> (0x00000003u));
	mpaxl->ur = (((value) & (0x00000004u)) >> (0x00000002u));
	mpaxl->uw = (((value) & (0x00000002u)) >> (0x00000001u));
	mpaxl->ux = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_getFaultAddress
 *
 *   @b Description
 *   @n This function gets the access address causing the fault.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n XMC_XMPFAR_FADDR
 *
 *   @b Example
 *   @verbatim
        Uint32 faultAddr;

        faultAddr = CSL_XMC_getFaultAddress ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_XMC_getFaultAddress (void)
{
	return (((((CSL_XmcRegs*)(0x08000000))->XMPFAR) & (0xFFFFFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_clearFault
 *
 *   @b Description
 *   @n This function clears the fault information.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	XMPFCR register configured with the value passed. Fault 
 *	    address and status registers are cleared.
 *
 *   @b Writes
 *   @n XMC_XMPFCR_MPFCLR=1
 *
 *   @b Affects
 *   @n XMC_XMPFAR_FADDR=0,
 *      XMC_XMPFSR_LOCAL=0, 
 * 		XMC_XMPFSR_SR=0, 
 * 		XMC_XMPFSR_SX=0,
 * 		XMC_XMPFSR_UR=0, 
 * 		XMC_XMPFSR_UW=0, 
 * 		XMC_XMPFSR_UW=0
 *
 *   @b Example
 *   @verbatim
        CSL_XMC_clearFault ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_clearFault (void)
{
	((CSL_XmcRegs*)(0x08000000))->XMPFCR = (((1) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_XMC_getFaultStatus
 *
 *   @b Description
 *   @n This function gets the contents of Fault Status Register XMPFSR.
 *
 *   @b Arguments
     @verbatim
          xmpfsr    CSL_XMC_MPFSR structure that needs to be filled in from
                    XMPFSR register
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n XMC_XMPFSR_LOCAL, 
 * 		XMC_XMPFSR_SR, 
 * 		XMC_XMPFSR_SX,
 * 		XMC_XMPFSR_UR, 
 * 		XMC_XMPFSR_UW, 
 * 		XMC_XMPFSR_UW
 *
 *   @b Example
 *   @verbatim
        CSL_XMC_MPFSR xmpfsr;

        CSL_XMC_getFaultStatus (&xmpfsr);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_getFaultStatus (CSL_XMC_MPFSR * xmpfsr)
{
    Uint32 value = ((CSL_XmcRegs*)(0x08000000))->XMPFSR;

	xmpfsr->local = (((value) & (0x00000100u)) >> (0x00000008u));
	xmpfsr->sr = (((value) & (0x00000020u)) >> (0x00000005u));
	xmpfsr->sw = (((value) & (0x00000010u)) >> (0x00000004u));
	xmpfsr->sx = (((value) & (0x00000008u)) >> (0x00000003u));
	xmpfsr->ur = (((value) & (0x00000004u)) >> (0x00000002u));
	xmpfsr->uw = (((value) & (0x00000002u)) >> (0x00000001u));
	xmpfsr->ux = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_invalidatePrefetchBuffer
 *
 *   @b Description
 *   @n This function when called marks all slots in the data prefetch buffer and program
 * 		prefetch buffer invalid by writing 1 in the XPFCMD register's INV bit.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	CSL_XMC_XPFCMD_INV bit set to 1 and data and program prefetch buffers are 
 * 		invalidated.
 *
 *   @b Writes
 *   @n XMC_XPFCMD_INV=1
 *
 *   @b Affects
 *   @n XMC_XPFADDR_DVH=0,
 *      XMC_XPFADDR_DVL=0
 *
 *
 *   @b Example
 *   @verbatim
 * 
        CSL_XMC_invalidatePrefetchBuffer ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_invalidatePrefetchBuffer (void)
{
	((CSL_XmcRegs*)(0x08000000))->XPFCMD = (((1) << (0x00000000u)) & (0x00000001u));
}

/** ============================================================================
 *   @n@b CSL_XMC_loadAnalysisCounterEnable
 *
 *   @b Description
 *   @n This function when called sets the 'ACENL' bit of the XPFCMD register, thus
 *      triggering a copy/load of ACEN bits (Analysis counter enable mode) into 
 *      ACEN bits of XPFACS register.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	CSL_XMC_XPFCMD_ACENL bit set to 1 and ACEN bits value is loaded into the
 *	    ACEN bits of XPFACS register.
 *
 *   @b Writes
 *   @n XMC_XPFCMD_ACENL=1
 *
 *   @b Affects
 *   @n XMC_XPFACS_ACEN
 *
 *   @b Example
 *   @verbatim
 * 
        CSL_XMC_loadAnalysisCounterEnable ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_loadAnalysisCounterEnable (void)
{
	((CSL_XmcRegs*)(0x08000000))->XPFCMD = (((1) << (0x00000001u)) & (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_XMC_setAnalysisCounterEnableMode
 *
 *   @b Description
 *   @n This function when called sets up the Event counting mode by writing to
 *      the 'ACEN' bits of the XPFCMD register.
 *
 *   @b Arguments
     @verbatim
          acenMode  Analyis counter mode.
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	CSL_XMC_XPFCMD_ACEN bits written with the Analysis counter mode specified.
 *
 *   @b Writes
 *   @n XMC_XPFCMD_ACEN
 *
 *   @b Example
 *   @verbatim
 
        // Enable both program and data events
        CSL_XMC_setAnalysisCounterEnableMode (CSL_XMC_ACEN_MODE_COUNT_ALL);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_setAnalysisCounterEnableMode (CSL_XMC_ACEN_MODE acenMode)
{
	((CSL_XmcRegs*)(0x08000000))->XPFCMD = (((acenMode) << (0x00000002u)) & (0x0000000Cu));
}

/** ============================================================================
 *   @n@b CSL_XMC_resetAnalysisCounters
 *
 *   @b Description
 *   @n This function when called sets the 'ACRST' bit of the XPFCMD register, thus
 *      triggering a clear/reset operation on the prefetch analysis counter registers.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	CSL_XMC_XPFCMD_ACRST bit set to 1 and prefetch analysis counter registers
 *	    are cleared.
 *
 *   @b Writes
 *   @n XMC_XPFCMD_ACRST=1
 *
 *   @b Affects
 *   @n XMC_XPFAC0_SENT=0,
 *      XMC_XPFAC1_CANCELED=0,
 *      XMC_XPFAC2_HIT=0,
 *      XMC_XPFAC3_MISS=0
 *
 *
 *   @b Example
 *   @verbatim
 * 
        CSL_XMC_resetAnalysisCounters ();

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_resetAnalysisCounters (void)
{
	((CSL_XmcRegs*)(0x08000000))->XPFCMD = (((1) << (0x00000004u)) & (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_XMC_setPrefetchCommand
 *
 *   @b Description
 *   @n This function sets up the contents of the XPFCMD register based on the
 *      inputs specified.
 *
 *   @b Arguments
     @verbatim
        inv         Invalidate Prefetch Buffer command flag. When set to 1,
                    data and program prefetch buffers are invalidated.
        acEnLoad    Analysis Counter Enable Load flag. When set to 1, the
                    Analysis Counter Enable mode is loaded into the XPFACS status
                    register.
        acEnMode    Analyis counter enable mode. Specifies the event counting mode
                    for the prefetcher.
        acRst       Analysis counter Reset flag. When set to 1, resets all
                    the prefetch event counters.
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	CSL_XMC_XPFCMD written with the settings specified.
 *
 *   @b Writes
 *   @n XMC_XPFCMD_INV,
 *      XMC_XPFCMD_ACENL,
 *      XMC_XPFCMD_ACEN,
 *      XMC_XPFCMD_ACRST
 *
 *   @b Example
 *   @verbatim
        // Issue the following prefetch commands:
        //  - Dont invalidate prefetch buffers
        //  - Enable Analysis Counter Enable load
        //  - Enable both program and data event counting
        //  - Dont reset the prefetch counters
        CSL_XMC_setPrefetchCommand (0, 1, CSL_XMC_ACEN_MODE_COUNT_ALL, 0);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_setPrefetchCommand 
(
    Uint8               inv,
    Uint8               acEnLoad,
    CSL_XMC_ACEN_MODE   acenMode,
    Uint8               acRst
)
{
    ((CSL_XmcRegs*)(0x08000000))->XPFCMD    =   (((inv) << (0x00000000u)) & (0x00000001u))        |
                        (((acEnLoad) << (0x00000001u)) & (0x00000002u)) |
                        (((acenMode) << (0x00000002u)) & (0x0000000Cu))  |
                        (((acRst) << (0x00000004u)) & (0x00000010u));
}

/** ============================================================================
 *   @n@b CSL_XMC_getAnalysisCounterEnableStatus
 *
 *   @b Description
 *   @n This function returns the Analysis counter enable mode by reading the
 *      contents of 'ACEN' bits from the XPFACS register.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>  CSL_XMC_ACEN_MODE   - Event counting mode
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	CSL_XMC_XPFACS_ACEN bits read and returned
 *
 *   @b Reads
 *   @n XMC_XPFACS_ACEN
 *
 *   @b Example
 *   @verbatim
        CSL_XMC_ACEN_MODE   acenMode;

        // Read ACEN Mode Status
        acenMode = CSL_XMC_getAnalysisCounterEnableStatus ();
        if (acenMode == CSL_XMC_ACEN_MODE_COUNT_DISABLE)
        {
            ...
        }

	 @endverbatim
 * =============================================================================
 */
static inline CSL_XMC_ACEN_MODE CSL_XMC_getAnalysisCounterEnableStatus (void)
{
	return (CSL_XMC_ACEN_MODE) (((((CSL_XmcRegs*)(0x08000000))->XPFACS) & (0x0000000Cu)) >> (0x00000002u));
}

/** ============================================================================
 *   @n@b CSL_XMC_getNumPrefetchSent
 *
 *   @b Description
 *   @n This function returns the contents of XPFAC0 register, i.e., the number
 *      of prefetch requests sent into the system.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	None
 *
 *   @b Reads
 *   @n XMC_XPFAC0_SENT
 *
 *   @b Example
 *   @verbatim
        Uint32      numPrefetchSent;

        // Read Prefetch request sent count
        numPrefetchSent = CSL_XMC_getNumPrefetchSent ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_XMC_getNumPrefetchSent (void)
{
	return (((((CSL_XmcRegs*)(0x08000000))->XPFAC0) & (0x000FFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_getNumPrefetchCanceled
 *
 *   @b Description
 *   @n This function returns the contents of XPFAC1 register, i.e., the number
 *      of prefetch requests canceled (prefetch requests that returned a non-zero 
 *      rstatus or other error).
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	None
 *
 *   @b Reads
 *   @n XMC_XPFAC1_CANCELED
 *
 *   @b Example
 *   @verbatim
        Uint32      numPrefetchCanceled;

        // Read Prefetch request canceled
        numPrefetchCanceled = CSL_XMC_getNumPrefetchCanceled ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_XMC_getNumPrefetchCanceled (void)
{
	return (((((CSL_XmcRegs*)(0x08000000))->XPFAC1) & (0x000FFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_getNumPrefetchHits
 *
 *   @b Description
 *   @n This function returns the contents of XPFAC2 register, i.e., the number
 *      of demand prefetch requests that resulted in a successful prefetch.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	None
 *
 *   @b Reads
 *   @n XMC_XPFAC2_HIT
 *
 *   @b Example
 *   @verbatim
        Uint32      numPrefetchHits;

        // Read Number of Prefetch request hits
        numPrefetchHits = CSL_XMC_getNumPrefetchHits ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_XMC_getNumPrefetchHits (void)
{
	return (((((CSL_XmcRegs*)(0x08000000))->XPFAC2) & (0x000FFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_getNumPrefetchMisses
 *
 *   @b Description
 *   @n This function returns the contents of XPFAC3 register, i.e., the number
 *      of prefetch requests that resulted in a miss and had to be submitted as
 *      a demand prefetch request into the system.
 *
 *   @b Arguments
 *	 @n	None
 *
 *   <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *	 @n	None
 *
 *   @b Reads
 *   @n XMC_XPFAC3_MISS
 *
 *   @b Example
 *   @verbatim
        Uint32      numPrefetchMisses;

        // Read Number of Prefetch request misses
        numPrefetchMisses = CSL_XMC_getNumPrefetchMisses ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_XMC_getNumPrefetchMisses (void)
{
	return (((((CSL_XmcRegs*)(0x08000000))->XPFAC3) & (0x000FFFFFu)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_getPrefetchAddress
 *
 *   @b Description
 *   @n This function gets the contents of XPFADDR register.
 *
 *   @b Arguments
     @verbatim
          index     Index into the set of 8 registers
          xpfaddr   CSL_XMC_XPFADDR structure that needs to be filled from
                    XPFADDR register
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n XMC_XPFADDR_ADDR, 
 * 		XMC_XPFADDR_DIR, 
 * 		XMC_XPFADDR_DPH,
 * 		XMC_XPFADDR_DVH, 
 * 		XMC_XPFADDR_AVH, 
 * 		XMC_XPFADDR_DPL,
 * 		XMC_XPFADDR_DVL, 
 * 		XMC_XPFADDR_AVL
 *
 *   @b Example
 *   @verbatim
        Uint32 index = 0;
        CSL_XMC_XPFADDR xpfaddr;

        CSL_XMC_getPrefetchAddress (index, &xpfaddr);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_getPrefetchAddress 
(
    Uint32              index,
	CSL_XMC_XPFADDR*    xpfaddr
)
{
    Uint32 value = ((CSL_XmcRegs*)(0x08000000))->XPFADDR[index];

	xpfaddr->addr = (((value) & (0xFFFFFF80u)) >> (0x00000007u));
	xpfaddr->dir  = (((value) & (0x00000040u)) >> (0x00000006u));
	xpfaddr->dph  = (((value) & (0x00000020u)) >> (0x00000005u));
	xpfaddr->dvh  = (((value) & (0x00000010u)) >> (0x00000004u));
	xpfaddr->avh  = (((value) & (0x00000008u)) >> (0x00000003u));
	xpfaddr->dpl  = (((value) & (0x00000004u)) >> (0x00000002u));
	xpfaddr->dvl  = (((value) & (0x00000002u)) >> (0x00000001u));
	xpfaddr->avl  = (((value) & (0x00000001u)) >> (0x00000000u));
}

/** ============================================================================
 *   @n@b CSL_XMC_setMDMAPriority
 *
 *   @b Description
 *   @n This function configures the priority of transaction submissions to 
 *    	Master DMA (MDMA).
 *
 *   @b Arguments
     @verbatim
        priority        Priority value to set for MDMA transactions.
	 @endverbatim
 *
 *   <b> Return Value </b>
 *	 @n	 None
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Writes
 *   @n XMC_MDMAARBX_PRI
 *
 *   @b Example
 *   @verbatim
        Uint32 priority = 4;

        CSL_XMC_setMDMAPriority (priority);

	 @endverbatim
 * =============================================================================
 */
static inline void CSL_XMC_setMDMAPriority (Uint32 priority)
{
	((((CSL_XmcRegs*)(0x08000000))->MDMAARBX) = ((((CSL_XmcRegs*)(0x08000000))->MDMAARBX) & ~(0x00070000u)) | (((priority) << (0x00000010u)) & (0x00070000u)));
}

/** ============================================================================
 *   @n@b CSL_XMC_getMDMAPriority
 *
 *   @b Description
 *   @n This function retrieves the priority of transaction submissions to 
 *    	Master DMA (MDMA).
 *
 *   @b Arguments
 *	 @n	 None
 *
 *  <b> Return Value </b>  Uint32
 *
 *   <b> Pre Condition </b>
 *   @n  None
 *
 *   <b> Post Condition </b>
 *   @n  None
 *
 *   @b Reads
 *   @n XMC_MDMAARBX_PRI
 *
 *   @b Example
 *   @verbatim
        Uint32 priority;

        priority = CSL_XMC_getMDMAPriority ();

	 @endverbatim
 * =============================================================================
 */
static inline Uint32 CSL_XMC_getMDMAPriority (void)
{
	return (((((CSL_XmcRegs*)(0x08000000))->MDMAARBX) & (0x00070000u)) >> (0x00000010u));
}



/* @} */

/******************************************************************************
 * Copyright (c) 2011 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************/

/******************************************************************************	
 *
 * File	Name:	pllc.h
 *
 * Description:	This contains PLL Control specific functions and defines
 *		prototypes.
 *
 ******************************************************************************/

typedef struct PllcHwSetup {
    /** \brief Divider Enable/Disable
     *  \param CSL_BitMask32
     */
    CSL_BitMask32 divEnable;
    /** \brief PLL Multiplier
     *  \param Uint32
     */
    Uint32        pllM;
    /** \brief PLL Divider 2
     *  \param Uint32
     */
    Uint32        pllDiv2;
    /** \brief PLL Divider 5
     *  \param Uint32
     */
    Uint32        pllDiv5;
    /** \brief PLL Divider 8
     *  \param Uint32
     */
    Uint32        pllDiv8;    
    /** \brief pre Divider value
     *  \param Uint32
     */
    Uint32        preDiv;
    /** \brief post Divider value
     *  \param Uint32
     */
    Uint32        postDiv;
    /** \brief Setup that can be used for future implementation
     *  \param void*
     */     
    void*         extendSetup;
} PllcHwSetup;

CSL_Status  CorePllcGetHwSetup(PllcHwSetup*);
CSL_Status  CorePllcHwSetup (PllcHwSetup*);
CSL_Status  corePllcInit(void *);
CSL_Status  SetPaPllConfig(void);
CSL_Status  SetDDR3PllConfig();
CSL_Status  DDR3Init(void);
void  		evmI2CInit(void);


/* Nothing past this point */

/********************************************************************************************
 * 					Platform Specific Declarations											*
 *******************************************************************************************/



/* Clock rate */

/* PREDIV */

/* POSTDIV */

/* Default PLL PLLM value (100/1*(20/2)) = 1.0GHz) */

/* Default PLL PLLD value for 1.0GHz) */

/* Default UART baudrate value */

/* Input crystal frequency 100 MHz */

/* 1/x-rate clock for CorePac (emulation) and the ADTF module */
/* 1/y-rate clock for system trace module only */
/* 1/z-rate clock is used as slow_sysclck in the system */


/* LED Definitions */

/* Number of cores on the platform */

/* Mmeory Sections */

/* 24AA1025 EEPROM */

/********************************************************************************************
 * 					General Declarations													*
 *******************************************************************************************/

/* Size of a string we can output with platform_write */

/* Device Tables */
extern PLATFORM_DEVICE_info gDeviceNand;

extern  PLATFORM_DEVICE_info gDeviceNor;

extern PLATFORM_DEVICE_info gDeviceEeprom0;
extern PLATFORM_DEVICE_info gDeviceEeprom1;


/********************************************************************************************
 * 					Function Prototypes														*
 *******************************************************************************************/

/* Function prototypes that don't live anywhere else */
//extern void configSerdes();
//extern void Init_SGMII(uint32_t macport);
extern void PowerUpDomains (void);
extern void xmc_setup();

/********************************************************************************************
 *                     PLL control local Declarations                                          *
 *******************************************************************************************/

/**
 *  Handle to access BOOTCFG registers.
 */

/**
  @}
  */
/* Boot Cfg Registers */

/* PA PLL Registers */


/*PLL controller registers*/


/* PA PLL Registers */



/* PASS PLL settings for 1044 MHz */

/* DDR3 PLL settings for 1333 MHz */



//#define SRIO_LOOPBACK
typedef enum
{
	DB_CALLBACK0,
	DB_CALLBACK1,
//	CALLBACK2,  Valid. commented for not using in Application
//	CALLBACK3,	Valid. commented for not using in Application
	MAX_DB_CB  // Its value should be 4 if above two are valid.
}DbCallBack;

typedef enum 
{
	 SRIO_DATARATE_1250 = 1,
	 SRIO_DATARATE_2500,
	 SRIO_DATARATE_3125,
	 SRIO_DATARATE_5000,
	 MAX_SRIO_DATARATE
}SrioSpeed;

typedef enum
{
	SRIO_IF_0 = 0,
    SRIO_IF_1
}SrioIf;
typedef void (*FxnPtr)(void *);
typedef struct Srio
{
	CSL_SrioHandle pCSLSrioHandle;
	UINT16         DevId;
	SrioSpeed      eLineRate;
	volatile UINT16		   Doorbellbits[4];  
	FxnPtr         RingCb[4];     
	//Interrupt Objects
	Intr			oDbellIntr;
	Intr			oErrorIntr;
	Intr			oLSUIntr;     
}Srio;




//VOID Srio_Init(Srio *pThis, UINT16 DevId, SrioSpeed eLineRate);
void Srio_Init(Srio *pThis, UINT16 DevId, SrioSpeed eLineRate,uint8_t PortNo);
BOOL Srio_TxPacket(Srio *pThis, void *pTxBuff, UINT16 Txlen, UINT16 DestDevId, UINT32 DestAddr, SrioIf SrioPort);
BOOL Srio_TxDoorBell(Srio *pThis, UINT16 DoorbellInfo, UINT16 DestDevId, SrioIf SrioPort);
Srio* Srio_GetHandle();
BOOL Srio_IsInitialized();
extern int32_t SrioDevice_init (Srio *pThis,uint8_t PortNo,uint8_t datarate,UINT16 DevID);

void Srio_InitDBCallBack(Srio *pThis, DbCallBack cb, FxnPtr pfn);







//----------------- config for DDC Rx ---------------

// User Config to be sent to FPGA via DSP
//#define SRIO_DDC_BASE_ADDR (UINT32) 	0x83800000  for testing this value is changing








/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== module ti.sysbios.utils.Load ========
 */

typedef struct ti_sysbios_utils_Load_Stat ti_sysbios_utils_Load_Stat;
typedef struct ti_sysbios_utils_Load_HookContext ti_sysbios_utils_Load_HookContext;
typedef struct ti_sysbios_utils_Load_Module_State ti_sysbios_utils_Load_Module_State;



/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.interfaces; 2, 0, 0, 0,545; 3-20-2012 14:03:22; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */



/*
 * ======== module ti.sysbios.gates.GateHwi ========
 */

typedef struct ti_sysbios_gates_GateHwi_Fxns__ ti_sysbios_gates_GateHwi_Fxns__;
typedef const ti_sysbios_gates_GateHwi_Fxns__* ti_sysbios_gates_GateHwi_Module;
typedef struct ti_sysbios_gates_GateHwi_Params ti_sysbios_gates_GateHwi_Params;
typedef struct ti_sysbios_gates_GateHwi_Object ti_sysbios_gates_GateHwi_Object;
typedef struct ti_sysbios_gates_GateHwi_Struct ti_sysbios_gates_GateHwi_Struct;
typedef ti_sysbios_gates_GateHwi_Object* ti_sysbios_gates_GateHwi_Handle;
typedef struct ti_sysbios_gates_GateHwi_Object__ ti_sysbios_gates_GateHwi_Instance_State;
typedef ti_sysbios_gates_GateHwi_Object* ti_sysbios_gates_GateHwi_Instance;

/*
 * ======== module ti.sysbios.gates.GateAll ========
 */

typedef struct ti_sysbios_gates_GateAll_Fxns__ ti_sysbios_gates_GateAll_Fxns__;
typedef const ti_sysbios_gates_GateAll_Fxns__* ti_sysbios_gates_GateAll_Module;
typedef struct ti_sysbios_gates_GateAll_Params ti_sysbios_gates_GateAll_Params;
typedef struct ti_sysbios_gates_GateAll_Object ti_sysbios_gates_GateAll_Object;
typedef struct ti_sysbios_gates_GateAll_Struct ti_sysbios_gates_GateAll_Struct;
typedef ti_sysbios_gates_GateAll_Object* ti_sysbios_gates_GateAll_Handle;
typedef struct ti_sysbios_gates_GateAll_Object__ ti_sysbios_gates_GateAll_Instance_State;
typedef ti_sysbios_gates_GateAll_Object* ti_sysbios_gates_GateAll_Instance;

/*
 * ======== module ti.sysbios.gates.GateSwi ========
 */

typedef struct ti_sysbios_gates_GateSwi_Fxns__ ti_sysbios_gates_GateSwi_Fxns__;
typedef const ti_sysbios_gates_GateSwi_Fxns__* ti_sysbios_gates_GateSwi_Module;
typedef struct ti_sysbios_gates_GateSwi_Params ti_sysbios_gates_GateSwi_Params;
typedef struct ti_sysbios_gates_GateSwi_Object ti_sysbios_gates_GateSwi_Object;
typedef struct ti_sysbios_gates_GateSwi_Struct ti_sysbios_gates_GateSwi_Struct;
typedef ti_sysbios_gates_GateSwi_Object* ti_sysbios_gates_GateSwi_Handle;
typedef struct ti_sysbios_gates_GateSwi_Object__ ti_sysbios_gates_GateSwi_Instance_State;
typedef ti_sysbios_gates_GateSwi_Object* ti_sysbios_gates_GateSwi_Instance;

/*
 * ======== module ti.sysbios.gates.GateTask ========
 */

typedef struct ti_sysbios_gates_GateTask_Fxns__ ti_sysbios_gates_GateTask_Fxns__;
typedef const ti_sysbios_gates_GateTask_Fxns__* ti_sysbios_gates_GateTask_Module;
typedef struct ti_sysbios_gates_GateTask_Params ti_sysbios_gates_GateTask_Params;
typedef struct ti_sysbios_gates_GateTask_Object ti_sysbios_gates_GateTask_Object;
typedef struct ti_sysbios_gates_GateTask_Struct ti_sysbios_gates_GateTask_Struct;
typedef ti_sysbios_gates_GateTask_Object* ti_sysbios_gates_GateTask_Handle;
typedef struct ti_sysbios_gates_GateTask_Object__ ti_sysbios_gates_GateTask_Instance_State;
typedef ti_sysbios_gates_GateTask_Object* ti_sysbios_gates_GateTask_Instance;

/*
 * ======== module ti.sysbios.gates.GateTest ========
 */

typedef struct ti_sysbios_gates_GateTest_Fxns__ ti_sysbios_gates_GateTest_Fxns__;
typedef const ti_sysbios_gates_GateTest_Fxns__* ti_sysbios_gates_GateTest_Module;
typedef struct ti_sysbios_gates_GateTest_Params ti_sysbios_gates_GateTest_Params;
typedef struct ti_sysbios_gates_GateTest_Object ti_sysbios_gates_GateTest_Object;
typedef struct ti_sysbios_gates_GateTest_Struct ti_sysbios_gates_GateTest_Struct;
typedef ti_sysbios_gates_GateTest_Object* ti_sysbios_gates_GateTest_Handle;
typedef struct ti_sysbios_gates_GateTest_Object__ ti_sysbios_gates_GateTest_Instance_State;
typedef ti_sysbios_gates_GateTest_Object* ti_sysbios_gates_GateTest_Instance;

/*
 * ======== module ti.sysbios.gates.GateMutexPri ========
 */

typedef struct ti_sysbios_gates_GateMutexPri_Fxns__ ti_sysbios_gates_GateMutexPri_Fxns__;
typedef const ti_sysbios_gates_GateMutexPri_Fxns__* ti_sysbios_gates_GateMutexPri_Module;
typedef struct ti_sysbios_gates_GateMutexPri_Params ti_sysbios_gates_GateMutexPri_Params;
typedef struct ti_sysbios_gates_GateMutexPri_Object ti_sysbios_gates_GateMutexPri_Object;
typedef struct ti_sysbios_gates_GateMutexPri_Struct ti_sysbios_gates_GateMutexPri_Struct;
typedef ti_sysbios_gates_GateMutexPri_Object* ti_sysbios_gates_GateMutexPri_Handle;
typedef struct ti_sysbios_gates_GateMutexPri_Object__ ti_sysbios_gates_GateMutexPri_Instance_State;
typedef ti_sysbios_gates_GateMutexPri_Object* ti_sysbios_gates_GateMutexPri_Instance;

/*
 * ======== module ti.sysbios.gates.GateMutex ========
 */

typedef struct ti_sysbios_gates_GateMutex_Fxns__ ti_sysbios_gates_GateMutex_Fxns__;
typedef const ti_sysbios_gates_GateMutex_Fxns__* ti_sysbios_gates_GateMutex_Module;
typedef struct ti_sysbios_gates_GateMutex_Params ti_sysbios_gates_GateMutex_Params;
typedef struct ti_sysbios_gates_GateMutex_Object ti_sysbios_gates_GateMutex_Object;
typedef struct ti_sysbios_gates_GateMutex_Struct ti_sysbios_gates_GateMutex_Struct;
typedef ti_sysbios_gates_GateMutex_Object* ti_sysbios_gates_GateMutex_Handle;
typedef struct ti_sysbios_gates_GateMutex_Object__ ti_sysbios_gates_GateMutex_Instance_State;
typedef ti_sysbios_gates_GateMutex_Object* ti_sysbios_gates_GateMutex_Instance;



/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:33; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Copyright 2012 by Texas Instruments Incorporated.
 *
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y22
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     CREATE ARGS
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.knl; 2, 0, 0, 0,545; 3-20-2012 14:03:34; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:32; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Q_BLOCKING */

/* Q_PREEMPTING */


/*
 * ======== INTERNAL DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_gates_GateMutex_Module__diagsEnabled;
extern far const CT__ti_sysbios_gates_GateMutex_Module__diagsEnabled ti_sysbios_gates_GateMutex_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_gates_GateMutex_Module__diagsIncluded;
extern far const CT__ti_sysbios_gates_GateMutex_Module__diagsIncluded ti_sysbios_gates_GateMutex_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_gates_GateMutex_Module__diagsMask;
extern far const CT__ti_sysbios_gates_GateMutex_Module__diagsMask ti_sysbios_gates_GateMutex_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_gates_GateMutex_Module__gateObj;
extern far const CT__ti_sysbios_gates_GateMutex_Module__gateObj ti_sysbios_gates_GateMutex_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_gates_GateMutex_Module__gatePrms;
extern far const CT__ti_sysbios_gates_GateMutex_Module__gatePrms ti_sysbios_gates_GateMutex_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_gates_GateMutex_Module__id;
extern far const CT__ti_sysbios_gates_GateMutex_Module__id ti_sysbios_gates_GateMutex_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_gates_GateMutex_Module__loggerDefined;
extern far const CT__ti_sysbios_gates_GateMutex_Module__loggerDefined ti_sysbios_gates_GateMutex_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_gates_GateMutex_Module__loggerObj;
extern far const CT__ti_sysbios_gates_GateMutex_Module__loggerObj ti_sysbios_gates_GateMutex_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_gates_GateMutex_Module__loggerFxn0;
extern far const CT__ti_sysbios_gates_GateMutex_Module__loggerFxn0 ti_sysbios_gates_GateMutex_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_gates_GateMutex_Module__loggerFxn1;
extern far const CT__ti_sysbios_gates_GateMutex_Module__loggerFxn1 ti_sysbios_gates_GateMutex_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_gates_GateMutex_Module__loggerFxn2;
extern far const CT__ti_sysbios_gates_GateMutex_Module__loggerFxn2 ti_sysbios_gates_GateMutex_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_gates_GateMutex_Module__loggerFxn4;
extern far const CT__ti_sysbios_gates_GateMutex_Module__loggerFxn4 ti_sysbios_gates_GateMutex_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_gates_GateMutex_Module__loggerFxn8;
extern far const CT__ti_sysbios_gates_GateMutex_Module__loggerFxn8 ti_sysbios_gates_GateMutex_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_gates_GateMutex_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_gates_GateMutex_Module__startupDoneFxn ti_sysbios_gates_GateMutex_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_gates_GateMutex_Object__count;
extern far const CT__ti_sysbios_gates_GateMutex_Object__count ti_sysbios_gates_GateMutex_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_gates_GateMutex_Object__heap;
extern far const CT__ti_sysbios_gates_GateMutex_Object__heap ti_sysbios_gates_GateMutex_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_gates_GateMutex_Object__sizeof;
extern far const CT__ti_sysbios_gates_GateMutex_Object__sizeof ti_sysbios_gates_GateMutex_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_gates_GateMutex_Object__table;
extern far const CT__ti_sysbios_gates_GateMutex_Object__table ti_sysbios_gates_GateMutex_Object__table__C;

/* A_badContext */
typedef xdc_runtime_Assert_Id CT__ti_sysbios_gates_GateMutex_A_badContext;
extern far const CT__ti_sysbios_gates_GateMutex_A_badContext ti_sysbios_gates_GateMutex_A_badContext__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct ti_sysbios_gates_GateMutex_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct ti_sysbios_gates_GateMutex_Struct {
    const ti_sysbios_gates_GateMutex_Fxns__* __fxns;
    ti_sysbios_knl_Task_Handle __f0;
    ti_sysbios_knl_Semaphore_Struct __f1;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct ti_sysbios_gates_GateMutex_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*query)(xdc_Int);
    xdc_IArg (*enter)(ti_sysbios_gates_GateMutex_Handle);
    void (*leave)(ti_sysbios_gates_GateMutex_Handle, xdc_IArg);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const ti_sysbios_gates_GateMutex_Fxns__ ti_sysbios_gates_GateMutex_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Instance_init__F */

extern void ti_sysbios_gates_GateMutex_Instance_init__F( ti_sysbios_gates_GateMutex_Object*, const ti_sysbios_gates_GateMutex_Params* );

/* Instance_finalize__F */

extern void ti_sysbios_gates_GateMutex_Instance_finalize__F( ti_sysbios_gates_GateMutex_Object* );

/* Instance_init__R */

extern void ti_sysbios_gates_GateMutex_Instance_init__R( ti_sysbios_gates_GateMutex_Object*, const ti_sysbios_gates_GateMutex_Params* );

/* Instance_finalize__R */

extern void ti_sysbios_gates_GateMutex_Instance_finalize__R( ti_sysbios_gates_GateMutex_Object* );

/* Handle__label__S */

extern xdc_runtime_Types_Label* ti_sysbios_gates_GateMutex_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_gates_GateMutex_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr ti_sysbios_gates_GateMutex_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void ti_sysbios_gates_GateMutex_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void ti_sysbios_gates_GateMutex_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr ti_sysbios_gates_GateMutex_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr ti_sysbios_gates_GateMutex_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr ti_sysbios_gates_GateMutex_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void ti_sysbios_gates_GateMutex_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* query__E */

extern xdc_Bool ti_sysbios_gates_GateMutex_query__E( xdc_Int qual );

extern xdc_Bool ti_sysbios_gates_GateMutex_query__F( xdc_Int qual );
extern xdc_Bool ti_sysbios_gates_GateMutex_query__R( xdc_Int qual );

/* enter__E */

extern xdc_IArg ti_sysbios_gates_GateMutex_enter__E( ti_sysbios_gates_GateMutex_Handle __inst );

extern xdc_IArg ti_sysbios_gates_GateMutex_enter__F( ti_sysbios_gates_GateMutex_Object* __inst );
extern xdc_IArg ti_sysbios_gates_GateMutex_enter__R( ti_sysbios_gates_GateMutex_Handle __inst );

/* leave__E */

extern void ti_sysbios_gates_GateMutex_leave__E( ti_sysbios_gates_GateMutex_Handle __inst, xdc_IArg key );

extern void ti_sysbios_gates_GateMutex_leave__F( ti_sysbios_gates_GateMutex_Object* __inst, xdc_IArg key );
extern void ti_sysbios_gates_GateMutex_leave__R( ti_sysbios_gates_GateMutex_Handle __inst, xdc_IArg key );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enter_{FxnT,fxnP} */
typedef xdc_IArg (*ti_sysbios_gates_GateMutex_enter_FxnT)(void*);
static inline ti_sysbios_gates_GateMutex_enter_FxnT ti_sysbios_gates_GateMutex_enter_fxnP( void )
{
    return (ti_sysbios_gates_GateMutex_enter_FxnT)ti_sysbios_gates_GateMutex_enter__E; 
}

/* leave_{FxnT,fxnP} */
typedef void (*ti_sysbios_gates_GateMutex_leave_FxnT)(void*, xdc_IArg);
static inline ti_sysbios_gates_GateMutex_leave_FxnT ti_sysbios_gates_GateMutex_leave_fxnP( void )
{
    return (ti_sysbios_gates_GateMutex_leave_FxnT)ti_sysbios_gates_GateMutex_leave__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IGateProvider_Module ti_sysbios_gates_GateMutex_Module_upCast( void )
{
    return (xdc_runtime_IGateProvider_Module)&ti_sysbios_gates_GateMutex_Module__FXNS__C;
}

/* Module_to_xdc_runtime_IGateProvider */

/* Handle_upCast */
static inline xdc_runtime_IGateProvider_Handle ti_sysbios_gates_GateMutex_Handle_upCast( ti_sysbios_gates_GateMutex_Handle i )
{
    return (xdc_runtime_IGateProvider_Handle)i;
}

/* Handle_to_xdc_runtime_IGateProvider */

/* Handle_downCast */
static inline ti_sysbios_gates_GateMutex_Handle ti_sysbios_gates_GateMutex_Handle_downCast( xdc_runtime_IGateProvider_Handle i )
{
    xdc_runtime_IGateProvider_Handle i2 = (xdc_runtime_IGateProvider_Handle)i;
    return (void*)i2->__fxns == (void*)&ti_sysbios_gates_GateMutex_Module__FXNS__C ? (ti_sysbios_gates_GateMutex_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IGateProvider */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_gates_GateMutex_Module__id ti_sysbios_gates_GateMutex_Module_id( void ) 
{
    return ti_sysbios_gates_GateMutex_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_gates_GateMutex_Module_hasMask( void ) 
{
    return ti_sysbios_gates_GateMutex_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_gates_GateMutex_Module_getMask( void ) 
{
    return ti_sysbios_gates_GateMutex_Module__diagsMask__C != 0 ? *ti_sysbios_gates_GateMutex_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_gates_GateMutex_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_gates_GateMutex_Module__diagsMask__C != 0) *ti_sysbios_gates_GateMutex_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void ti_sysbios_gates_GateMutex_Params_init( ti_sysbios_gates_GateMutex_Params* prms ) 
{
    if (prms) {
        ti_sysbios_gates_GateMutex_Params__init__S(prms, 0, sizeof(ti_sysbios_gates_GateMutex_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void ti_sysbios_gates_GateMutex_Params_copy( ti_sysbios_gates_GateMutex_Params* dst, const ti_sysbios_gates_GateMutex_Params* src ) 
{
    if (dst) {
        ti_sysbios_gates_GateMutex_Params__init__S(dst, (xdc_Ptr)src, sizeof(ti_sysbios_gates_GateMutex_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline ti_sysbios_gates_GateMutex_Handle ti_sysbios_gates_GateMutex_Object_get( ti_sysbios_gates_GateMutex_Instance_State* oarr, int i ) 
{
    return (ti_sysbios_gates_GateMutex_Handle)ti_sysbios_gates_GateMutex_Object__get__S(oarr, i);
}

/* Object_first */
static inline ti_sysbios_gates_GateMutex_Handle ti_sysbios_gates_GateMutex_Object_first( void )
{
    return (ti_sysbios_gates_GateMutex_Handle)ti_sysbios_gates_GateMutex_Object__first__S();
}

/* Object_next */
static inline ti_sysbios_gates_GateMutex_Handle ti_sysbios_gates_GateMutex_Object_next( ti_sysbios_gates_GateMutex_Object* obj )
{
    return (ti_sysbios_gates_GateMutex_Handle)ti_sysbios_gates_GateMutex_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* ti_sysbios_gates_GateMutex_Handle_label( ti_sysbios_gates_GateMutex_Handle inst, xdc_runtime_Types_Label* lab )
{
    return ti_sysbios_gates_GateMutex_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String ti_sysbios_gates_GateMutex_Handle_name( ti_sysbios_gates_GateMutex_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return ti_sysbios_gates_GateMutex_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline ti_sysbios_gates_GateMutex_Handle ti_sysbios_gates_GateMutex_create( const ti_sysbios_gates_GateMutex_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (ti_sysbios_gates_GateMutex_Handle)ti_sysbios_gates_GateMutex_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_gates_GateMutex_Params), __eb);
}

/* construct */
static inline void ti_sysbios_gates_GateMutex_construct( ti_sysbios_gates_GateMutex_Struct* __obj, const ti_sysbios_gates_GateMutex_Params* __prms )
{
    ti_sysbios_gates_GateMutex_Object__create__S(__obj, sizeof (ti_sysbios_gates_GateMutex_Struct), 0, (const xdc_UChar*)__prms, sizeof(ti_sysbios_gates_GateMutex_Params), 0);
}

/* delete */
static inline void ti_sysbios_gates_GateMutex_delete( ti_sysbios_gates_GateMutex_Handle* instp )
{
    ti_sysbios_gates_GateMutex_Object__delete__S(instp);
}

/* destruct */
static inline void ti_sysbios_gates_GateMutex_destruct( ti_sysbios_gates_GateMutex_Struct* obj )
{
    ti_sysbios_gates_GateMutex_Object__destruct__S(obj);
}

/* handle */
static inline ti_sysbios_gates_GateMutex_Handle ti_sysbios_gates_GateMutex_handle( ti_sysbios_gates_GateMutex_Struct* str )
{
    return (ti_sysbios_gates_GateMutex_Handle)str;
}

/* struct */
static inline ti_sysbios_gates_GateMutex_Struct* ti_sysbios_gates_GateMutex_struct( ti_sysbios_gates_GateMutex_Handle inst )
{
    return (ti_sysbios_gates_GateMutex_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) ti.sysbios.gates; 2, 0, 0, 0,541; 3-20-2012 14:03:11; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* FuncPtr */
typedef void (*ti_sysbios_utils_Load_FuncPtr)(void);

/* Stat */
struct ti_sysbios_utils_Load_Stat {
    xdc_UInt32 threadTime;
    xdc_UInt32 totalTime;
};


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* HookContext */
struct ti_sysbios_utils_Load_HookContext {
    ti_sysbios_knl_Queue_Elem qElem;
    xdc_UInt32 totalTimeElapsed;
    xdc_UInt32 totalTime;
    xdc_UInt32 nextTotalTime;
    xdc_UInt32 timeOfLastUpdate;
    xdc_Ptr threadHandle;
};


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__ti_sysbios_utils_Load_Module__diagsEnabled;
extern far const CT__ti_sysbios_utils_Load_Module__diagsEnabled ti_sysbios_utils_Load_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__ti_sysbios_utils_Load_Module__diagsIncluded;
extern far const CT__ti_sysbios_utils_Load_Module__diagsIncluded ti_sysbios_utils_Load_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__ti_sysbios_utils_Load_Module__diagsMask;
extern far const CT__ti_sysbios_utils_Load_Module__diagsMask ti_sysbios_utils_Load_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__ti_sysbios_utils_Load_Module__gateObj;
extern far const CT__ti_sysbios_utils_Load_Module__gateObj ti_sysbios_utils_Load_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__ti_sysbios_utils_Load_Module__gatePrms;
extern far const CT__ti_sysbios_utils_Load_Module__gatePrms ti_sysbios_utils_Load_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__ti_sysbios_utils_Load_Module__id;
extern far const CT__ti_sysbios_utils_Load_Module__id ti_sysbios_utils_Load_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__ti_sysbios_utils_Load_Module__loggerDefined;
extern far const CT__ti_sysbios_utils_Load_Module__loggerDefined ti_sysbios_utils_Load_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__ti_sysbios_utils_Load_Module__loggerObj;
extern far const CT__ti_sysbios_utils_Load_Module__loggerObj ti_sysbios_utils_Load_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__ti_sysbios_utils_Load_Module__loggerFxn0;
extern far const CT__ti_sysbios_utils_Load_Module__loggerFxn0 ti_sysbios_utils_Load_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__ti_sysbios_utils_Load_Module__loggerFxn1;
extern far const CT__ti_sysbios_utils_Load_Module__loggerFxn1 ti_sysbios_utils_Load_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__ti_sysbios_utils_Load_Module__loggerFxn2;
extern far const CT__ti_sysbios_utils_Load_Module__loggerFxn2 ti_sysbios_utils_Load_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__ti_sysbios_utils_Load_Module__loggerFxn4;
extern far const CT__ti_sysbios_utils_Load_Module__loggerFxn4 ti_sysbios_utils_Load_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__ti_sysbios_utils_Load_Module__loggerFxn8;
extern far const CT__ti_sysbios_utils_Load_Module__loggerFxn8 ti_sysbios_utils_Load_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__ti_sysbios_utils_Load_Module__startupDoneFxn)(void);
extern far const CT__ti_sysbios_utils_Load_Module__startupDoneFxn ti_sysbios_utils_Load_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__ti_sysbios_utils_Load_Object__count;
extern far const CT__ti_sysbios_utils_Load_Object__count ti_sysbios_utils_Load_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__ti_sysbios_utils_Load_Object__heap;
extern far const CT__ti_sysbios_utils_Load_Object__heap ti_sysbios_utils_Load_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__ti_sysbios_utils_Load_Object__sizeof;
extern far const CT__ti_sysbios_utils_Load_Object__sizeof ti_sysbios_utils_Load_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__ti_sysbios_utils_Load_Object__table;
extern far const CT__ti_sysbios_utils_Load_Object__table ti_sysbios_utils_Load_Object__table__C;

/* LS_cpuLoad */
typedef xdc_runtime_Log_Event CT__ti_sysbios_utils_Load_LS_cpuLoad;
extern far const CT__ti_sysbios_utils_Load_LS_cpuLoad ti_sysbios_utils_Load_LS_cpuLoad__C;

/* LS_hwiLoad */
typedef xdc_runtime_Log_Event CT__ti_sysbios_utils_Load_LS_hwiLoad;
extern far const CT__ti_sysbios_utils_Load_LS_hwiLoad ti_sysbios_utils_Load_LS_hwiLoad__C;

/* LS_swiLoad */
typedef xdc_runtime_Log_Event CT__ti_sysbios_utils_Load_LS_swiLoad;
extern far const CT__ti_sysbios_utils_Load_LS_swiLoad ti_sysbios_utils_Load_LS_swiLoad__C;

/* LS_taskLoad */
typedef xdc_runtime_Log_Event CT__ti_sysbios_utils_Load_LS_taskLoad;
extern far const CT__ti_sysbios_utils_Load_LS_taskLoad ti_sysbios_utils_Load_LS_taskLoad__C;

/* postUpdate */
typedef ti_sysbios_utils_Load_FuncPtr CT__ti_sysbios_utils_Load_postUpdate;
extern far const CT__ti_sysbios_utils_Load_postUpdate ti_sysbios_utils_Load_postUpdate__C;

/* updateInIdle */
typedef xdc_Bool CT__ti_sysbios_utils_Load_updateInIdle;
extern far const CT__ti_sysbios_utils_Load_updateInIdle ti_sysbios_utils_Load_updateInIdle__C;

/* windowInMs */
typedef xdc_UInt CT__ti_sysbios_utils_Load_windowInMs;
extern far const CT__ti_sysbios_utils_Load_windowInMs ti_sysbios_utils_Load_windowInMs__C;

/* hwiEnabled */
typedef xdc_Bool CT__ti_sysbios_utils_Load_hwiEnabled;
extern far const CT__ti_sysbios_utils_Load_hwiEnabled ti_sysbios_utils_Load_hwiEnabled__C;

/* swiEnabled */
typedef xdc_Bool CT__ti_sysbios_utils_Load_swiEnabled;
extern far const CT__ti_sysbios_utils_Load_swiEnabled ti_sysbios_utils_Load_swiEnabled__C;

/* taskEnabled */
typedef xdc_Bool CT__ti_sysbios_utils_Load_taskEnabled;
extern far const CT__ti_sysbios_utils_Load_taskEnabled ti_sysbios_utils_Load_taskEnabled__C;

/* autoAddTasks */
typedef xdc_Bool CT__ti_sysbios_utils_Load_autoAddTasks;
extern far const CT__ti_sysbios_utils_Load_autoAddTasks ti_sysbios_utils_Load_autoAddTasks__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Module__startupDone__S */

extern xdc_Bool ti_sysbios_utils_Load_Module__startupDone__S( void );

/* getTaskLoad__E */

extern xdc_Bool ti_sysbios_utils_Load_getTaskLoad__E( ti_sysbios_knl_Task_Handle task, ti_sysbios_utils_Load_Stat* stat );

extern xdc_Bool ti_sysbios_utils_Load_getTaskLoad__F( ti_sysbios_knl_Task_Handle task, ti_sysbios_utils_Load_Stat* stat );
extern xdc_Bool ti_sysbios_utils_Load_getTaskLoad__R( ti_sysbios_knl_Task_Handle task, ti_sysbios_utils_Load_Stat* stat );

/* update__E */

extern void ti_sysbios_utils_Load_update__E( void );

extern void ti_sysbios_utils_Load_update__F( void );
extern void ti_sysbios_utils_Load_update__R( void );

/* reset__E */

extern void ti_sysbios_utils_Load_reset__E( void );

extern void ti_sysbios_utils_Load_reset__F( void );
extern void ti_sysbios_utils_Load_reset__R( void );

/* getGlobalSwiLoad__E */

extern xdc_Bool ti_sysbios_utils_Load_getGlobalSwiLoad__E( ti_sysbios_utils_Load_Stat* stat );

extern xdc_Bool ti_sysbios_utils_Load_getGlobalSwiLoad__F( ti_sysbios_utils_Load_Stat* stat );
extern xdc_Bool ti_sysbios_utils_Load_getGlobalSwiLoad__R( ti_sysbios_utils_Load_Stat* stat );

/* getGlobalHwiLoad__E */

extern xdc_Bool ti_sysbios_utils_Load_getGlobalHwiLoad__E( ti_sysbios_utils_Load_Stat* stat );

extern xdc_Bool ti_sysbios_utils_Load_getGlobalHwiLoad__F( ti_sysbios_utils_Load_Stat* stat );
extern xdc_Bool ti_sysbios_utils_Load_getGlobalHwiLoad__R( ti_sysbios_utils_Load_Stat* stat );

/* getCPULoad__E */

extern xdc_UInt32 ti_sysbios_utils_Load_getCPULoad__E( void );

extern xdc_UInt32 ti_sysbios_utils_Load_getCPULoad__F( void );
extern xdc_UInt32 ti_sysbios_utils_Load_getCPULoad__R( void );

/* calculateLoad__E */

extern xdc_UInt32 ti_sysbios_utils_Load_calculateLoad__E( ti_sysbios_utils_Load_Stat* stat );

extern xdc_UInt32 ti_sysbios_utils_Load_calculateLoad__F( ti_sysbios_utils_Load_Stat* stat );
extern xdc_UInt32 ti_sysbios_utils_Load_calculateLoad__R( ti_sysbios_utils_Load_Stat* stat );

/* setMinIdle__E */

extern xdc_UInt32 ti_sysbios_utils_Load_setMinIdle__E( xdc_UInt32 newMinIdleTime );

extern xdc_UInt32 ti_sysbios_utils_Load_setMinIdle__F( xdc_UInt32 newMinIdleTime );
extern xdc_UInt32 ti_sysbios_utils_Load_setMinIdle__R( xdc_UInt32 newMinIdleTime );

/* addTask__E */

extern xdc_Bool ti_sysbios_utils_Load_addTask__E( ti_sysbios_knl_Task_Handle task, ti_sysbios_utils_Load_HookContext* env );

extern xdc_Bool ti_sysbios_utils_Load_addTask__F( ti_sysbios_knl_Task_Handle task, ti_sysbios_utils_Load_HookContext* env );
extern xdc_Bool ti_sysbios_utils_Load_addTask__R( ti_sysbios_knl_Task_Handle task, ti_sysbios_utils_Load_HookContext* env );

/* removeTask__E */

extern xdc_Bool ti_sysbios_utils_Load_removeTask__E( ti_sysbios_knl_Task_Handle task );

extern xdc_Bool ti_sysbios_utils_Load_removeTask__F( ti_sysbios_knl_Task_Handle task );
extern xdc_Bool ti_sysbios_utils_Load_removeTask__R( ti_sysbios_knl_Task_Handle task );

/* idleFxn__E */

extern void ti_sysbios_utils_Load_idleFxn__E( void );

extern void ti_sysbios_utils_Load_idleFxn__F( void );
extern void ti_sysbios_utils_Load_idleFxn__R( void );

/* taskCreateHook__E */

extern void ti_sysbios_utils_Load_taskCreateHook__E( ti_sysbios_knl_Task_Handle task, xdc_runtime_Error_Block* eb );

extern void ti_sysbios_utils_Load_taskCreateHook__F( ti_sysbios_knl_Task_Handle task, xdc_runtime_Error_Block* eb );
extern void ti_sysbios_utils_Load_taskCreateHook__R( ti_sysbios_knl_Task_Handle task, xdc_runtime_Error_Block* eb );

/* taskDeleteHook__E */

extern void ti_sysbios_utils_Load_taskDeleteHook__E( ti_sysbios_knl_Task_Handle task );

extern void ti_sysbios_utils_Load_taskDeleteHook__F( ti_sysbios_knl_Task_Handle task );
extern void ti_sysbios_utils_Load_taskDeleteHook__R( ti_sysbios_knl_Task_Handle task );

/* taskSwitchHook__E */

extern void ti_sysbios_utils_Load_taskSwitchHook__E( ti_sysbios_knl_Task_Handle curTask, ti_sysbios_knl_Task_Handle nextTask );

extern void ti_sysbios_utils_Load_taskSwitchHook__F( ti_sysbios_knl_Task_Handle curTask, ti_sysbios_knl_Task_Handle nextTask );
extern void ti_sysbios_utils_Load_taskSwitchHook__R( ti_sysbios_knl_Task_Handle curTask, ti_sysbios_knl_Task_Handle nextTask );

/* swiBeginHook__E */

extern void ti_sysbios_utils_Load_swiBeginHook__E( ti_sysbios_knl_Swi_Handle swi );

extern void ti_sysbios_utils_Load_swiBeginHook__F( ti_sysbios_knl_Swi_Handle swi );
extern void ti_sysbios_utils_Load_swiBeginHook__R( ti_sysbios_knl_Swi_Handle swi );

/* swiEndHook__E */

extern void ti_sysbios_utils_Load_swiEndHook__E( ti_sysbios_knl_Swi_Handle swi );

extern void ti_sysbios_utils_Load_swiEndHook__F( ti_sysbios_knl_Swi_Handle swi );
extern void ti_sysbios_utils_Load_swiEndHook__R( ti_sysbios_knl_Swi_Handle swi );

/* hwiBeginHook__E */

extern void ti_sysbios_utils_Load_hwiBeginHook__E( ti_sysbios_interfaces_IHwi_Handle hwi );

extern void ti_sysbios_utils_Load_hwiBeginHook__F( ti_sysbios_interfaces_IHwi_Handle hwi );
extern void ti_sysbios_utils_Load_hwiBeginHook__R( ti_sysbios_interfaces_IHwi_Handle hwi );

/* hwiEndHook__E */

extern void ti_sysbios_utils_Load_hwiEndHook__E( ti_sysbios_interfaces_IHwi_Handle hwi );

extern void ti_sysbios_utils_Load_hwiEndHook__F( ti_sysbios_interfaces_IHwi_Handle hwi );
extern void ti_sysbios_utils_Load_hwiEndHook__R( ti_sysbios_interfaces_IHwi_Handle hwi );

/* taskRegHook__E */

extern void ti_sysbios_utils_Load_taskRegHook__E( xdc_Int id );

extern void ti_sysbios_utils_Load_taskRegHook__F( xdc_Int id );
extern void ti_sysbios_utils_Load_taskRegHook__R( xdc_Int id );

/* logLoads__I */

extern void ti_sysbios_utils_Load_logLoads__I( void );


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__ti_sysbios_utils_Load_Module__id ti_sysbios_utils_Load_Module_id( void ) 
{
    return ti_sysbios_utils_Load_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool ti_sysbios_utils_Load_Module_hasMask( void ) 
{
    return ti_sysbios_utils_Load_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 ti_sysbios_utils_Load_Module_getMask( void ) 
{
    return ti_sysbios_utils_Load_Module__diagsMask__C != 0 ? *ti_sysbios_utils_Load_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void ti_sysbios_utils_Load_Module_setMask( xdc_Bits16 mask ) 
{
    if (ti_sysbios_utils_Load_Module__diagsMask__C != 0) *ti_sysbios_utils_Load_Module__diagsMask__C = mask;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/*
 *  @(#) ti.sysbios.utils; 2, 0, 0, 0,540; 3-20-2012 14:03:53; /db/vtree/library/trees/avala/avala-q31x/src/ xlibrary

 */



      


typedef struct TransferJob
{
	UINT32 		 lLastSentPakNum;

	// If the transfer need to be splitted in to two due to the rollover concern.
	// If true,  uses the following members.
	BOOL 		 bIsRollOverBreak;
	UINT32		 nSymbolSet1;
	UINT32		 nSymbolSet2; 
	DDC_RxData	 *pStartAddr;
	DDC_RxData	 *pEndAddr;
	UINT64		 JobCompPakNum;

	struct BurstInfo    oBurstInfo;
	UINT8				nExpectedSeqNum;
	UINT8				nTargetSeq;
	struct BurstInfo    *pNewBurstInfo;
	UINT32				lEndPakNum; // For a given job where the memory starts.
//	BOOL				bNewRequest;
}TransferJob;

typedef struct TransferJobList
{
	TransferJob               job;
	struct TransferJobList    *next;
	struct TransferJobList    *prev;
} transferJobList_t;

typedef struct 
{
//	UINT32  nPakNum;
	SysTime oSysTime;
}DDCTimeStampInfo;
#pragma DATA_SECTION(DDCRx, ".ddrdata")
typedef struct DDCRx
{
	DDC_RxData     *pDDC_RxPacket; 
	Signal  	    SigDDCRx_JobAvaliable;
	Signal			SigDDCRx_Doorbell;
	Signal			SigStop_Received;
    Task  		    Task_DDCRx_JobReceiver;
	Task  		    Task_DDCRx_JobProcessor;  
	ICoreQ			oQC1;
	ICoreQ			oQC2;
	ICoreQ			oQC3;
	ICoreQ			oQC4;
	ICoreQ			oQC5;
	ICoreQ			oQC6;
	ICoreQ			oQC7;


	ICoreQ			*pL1RxC1;
	ICoreQ			*pL1RxC2;
	ICoreQ			*pL1RxC3;
	ICoreQ			*pL1RxC4;
	ICoreQ			*pL1RxC5;
	ICoreQ			*pL1RxC6;
	ICoreQ			*pL1RxC7;



	volatile struct TransferJobList *pTransferJobListHead;
	volatile struct TransferJobList *pTransferJobListTail; 
	volatile UINT32	ListMemberCount; 
	Hsem					oBTSRefLock;
	Mutex					oTrfrLock;		
//	DDCTimeStampInfo		oTimeStamp;

}DDCRx;


typedef struct DebugDDCRx
{
	 UINT32 nDBMissCtr;
	 UINT64 lDBMissRollCtr;
	 SysTime oDBMissedTimeStamp[1024];

	 UINT32  nPktMissCtr;
	 UINT64  lpktMissRollCtr;
     SysTime oPktMissedTimeStamp[1024];

	 UINT32  nIncorrectBurstprocessed;
	 SysTime oIncorrectBurstTime[1024];
}DebugDDCRx;

extern void DDCRx_Init(DDCRx *pThis);
extern void DDCRx_Start(DDCRx *pThis);
// VOID DDCRx_CopySamples(VOID *pTgtPtr, VOID *pSrcPtr, UINT16 nSymbols); // using C code
//#pragma FUNC_EXT_CALLED ( DDCRx_CopySamples );
extern void DDCRx_CopySamples(void *pTgtPtr, void *pSrcPtr, UINT16 nSymbols); // for ASM code

//UINT32* DDCRx_CopySamples_test(VOID *, VOID *, UINT16 ) ;
//extern VOID UpdateLastSentPakNum(VOID *pBTS, SysTime nLastSentTime, UINT32 nLastSentFN);





extern void Transmit_Mesg(UINT8  TO_Queue,void *pDataptr);
extern void Transmit_data(UINT8  TO_Queue,void *pDataptr);

extern void IPCMSGQ_Init();

typedef enum
{
	MSGTYPE_PACKET = 0,
	MSGTYPE_PACKET2,
	MSGTYPE_BURSTINFOREQ,
	MSGTYPE_BURST,
	MSGTYPE_BURSTINFO,
	MSGTYPE_TRFRJOBLIST,
	MSGTYPE_TRFRJOB,
	MSGTYPE_MAX
}msgType_e;

typedef union
{
	Packet 					pckt;
	Packet2					pckt2;
	BurstInfoReq			burstInfoReq;
	Burst					burst;
	BurstInfo				burstInfo;
	transferJobList_t		jobList;
	TransferJob				job;
}steMsg_u;

typedef struct IPCMessage
{
	MessageQ_MsgHeader 	Header;
	msgType_e 			type;
	steMsg_u 			msg;
}IPCMessage;


typedef struct IPCMesgData
{
	MessageQ_MsgHeader Header;
	Burst Pack;
}IPCMesgData;


typedef struct ICoreQ
{
	Hsem	oLock;
	ITaskQ	oRxQ;
	LINKS	eLink;
	UINT16	eHashID;
	ITaskQ	*pRxQ;
	HSEM_NUM eSemNum;
	Hsem	*pExtLock;

}ICoreQ;





typedef enum TXMODES
{
	TXMODE_NONE			= 0,
	TXMODE_CALLBLOCKING, 
	TXMODE_AREAJAMMING, 
	TXMODE_VBTSOPERATION
}TXMODES;

typedef struct TxTimeSlotInfo
{
	// Inputs
	BOOL				bIsCiphered;

	UINT8				n5UsSyncCount;

	UINT8				SDCCHTSC[8];
	UINT8				nTSC;


	CHANNEL_COMB		eChannelComb;
	Packet				oLastReceivedCmd;

	L1FEC				*pL1FECTable[104];
	L1Config			oL1Config;
	
	BOOL				bConfigurationSuccess;

//	TxCookie			oCookie;

}TxTimeSlotInfo;



typedef struct TxFreqInfo
{
	UINT8			nID;
	FreqInfo		oCurrent;
	FreqInfo		oBeacon;
	FreqInfo		oPrevFreq;
	TN_ENABLED		eTN;
	BOOL			bIsHopped;
	HoppingInfo		oHoppingInfo;
	TxTimeSlotInfo	oTN[8];
	DCSPART			ePrevDCSPART;

}TxFreqInfo;

typedef struct TxCookie
{
	BOOL		bStartup;
	BOOL		bEnable;
	UINT8		nTN;
	DIRECTION 	eDir;
	UINT32		nNextFN;
	UINT32      nlastrequestFN;
	SysTime		oNextTimeToSend;
}TxCookie;


/**************************************************************************/

//The following code structure need to be moved to DUCTx.c

/*******************************************************/
// SHARED DATA MEMORY FOR BURST PACKET TO CORE 0
// BURST PACKET from DSP to FPGA

typedef struct BurstToFPGA
{

	DUC_TxData oDataPak;
	SysTime	   oTimeToSendData;
	UINT8	   oCmdPak[20];
	SysTime	   oTimeToSendCmd;
	GSMConfig  *pBTS;		
	UINT8	   bFlag;
	UINT8	   nID;
	BOOL	   bCB;

}BurstToFPGA;

typedef struct BurstToFPGAInfo
{
	BurstToFPGA	*pInfo;
	BOOL	bWrote;
	UINT8   nID; // added to free packets belonging to that TxManagerID.

}BurstToFPGAInfo;

typedef struct SharedBurstToFPGAMgr
{
	UINT16			nWriteIndex;	// dynamic
	UINT16			nReadIndex;	    // dynamic
	BurstToFPGAInfo	oPayloadInfo[1024];

}SharedBurstToFPGAMgr;

// STATIC MEMORY ALLOCATION FOR Burst to FPGA.
typedef struct BurstToFPGAMgr
{

	BurstToFPGA		oPayload[1024];	

}BurstToFPGAMgr;




typedef struct SharedMem
{
	UINT16		nSize;
	UINT16		nElements;
	void*		nSegment;
//	BOOL		bCriticalSection;

}SharedMem;


//#define		MAX_HEAP_MEM_SIZE				(10 * 1024 * 1024) // 8 MB   // old : remesh

typedef enum HASH_ID
{
	SEG_L1CONFIG_L1FECBLOCK_ID = 0,
	SEG_L1CONFIG_LOGCHANCLASS_ID,
	SEG_RECEIVER_IPU_CMDPKT_ID,
	SEG_RECEIVER_IPU_DATAPKT_ID,
	SEG_IIPC_TXINFO_ID,
	SEG_DDCRX_TRFR_JOBLIST_ID,
	SEG_DUCTX_UPLINK_JOBLIST_ID,
	SEG_BURSTINFOREQ_ID,

// FOR INTERCORE COMMUNCATION
	SEG_ICOREQ_COMMAND_ID,
	SEG_ICOREQ_BURST_FROM_FPGA_ID,
	SEG_ICOREQ_L2PACKET_TO_IPU_ID,
	SEG_ICOREQ_L2PACKET_FROM_IPU_ID,
	SEG_ICOREQ_BURST_TO_FPGA_ID,
	SEG_ICOREQ_BURSTINFO_TO_C0_ID,

	SEG_MEMMGR_LAST_ID

}HASH_ID;



extern UINT16	gHash[SEG_MEMMGR_LAST_ID+1];
extern SharedMem gHeapMem[SEG_MEMMGR_LAST_ID];
extern CHAR		gHeapMemSeg[(23 * 1024 * 1024)];
extern CHAR gDelcomMemSeg[];
extern L1FEC gDelcomMemL1FECSeg[];
extern transferJobList_t gTransferJobSeg[];





/*
typedef enum CORES
{
	 CORE0,
	 CORE1,
	 CORE2,
	 MAX_CORE
}CORES;
*/

typedef enum IIPC_ety
{
	ETY1,
	ETY2,
	ETY3,
	ETY4,
	ETY5,
	ETY6,
	ETY7
}IIPC_ety;
	




enum LinkState //InterCoreLinks Status
{
	ETY1_REGISTERED, // Bit 0
	ETY2_REGISTERED, // Bit 1
//	ETY3_REGISTERED,// Bit 2
//	ETY4_REGISTERED,// Bit3
//	ETY5_REGISTERED,// Bit4
//	ETY6_REGISTERED,// Bit5
//	ETY7_REGISTERED,// Bit6
	ETY1_TX,         // Bit7
	ETY2_TX,          // Bit8
//	ETY3_TX,// Bit9
//	ETY4_TX,// Bit10
//	ETY5_TX,// Bit11
//	ETY6_TX,// Bit12
//	ETY7_TX// Bit13
};



typedef struct stEpInfo
{
	UINT8       nCore;
	ITaskQ      *pPeerInfo;
	volatile void        *pMsgPtr;
	MemHashInfo *pMemPool;
	Hsem        *pMemPoolLock;
	HSEM_NUM	eSemNum; //added newly to enable L2RAM addressing
	UINT32      nMemSize;
} Endpoint;

typedef struct stInterCoreLink
{
	UINT8       nLinkNum;
	UINT16       nStatus;  // previously it was UINT8, changed to UINT16 for TRS, bcz it have to show status of more cores
	Endpoint    Endpoints[2]; //previously it was Endpoints[2]
}InterCoreLinks;


typedef struct stIIPC_TxInfo
{
	UINT8 nLinkNum;
	UINT8 nTargetEp;
	UINT8 nTgtCore;
	void  *pMsgPtr;
}IIPC_TxInfo;



extern far const int Core_Num;

extern void IIPC_Init();
extern void IIPC_Start(void);
extern void IIPC_InitLink(UINT8 LinkNum, ITaskQ *pPeerInfo, 						  void *pHashInfoPtr, HSEM_NUM eSemNum, Hsem *pMemPoolLock, 						  UINT32 nBlockSize,IIPC_ety etyNum );
extern void IIPC_TransportMessage(UINT8 LinkNum, void *pMsg, IIPC_ety TargetEty );
extern void IIPC_FreeMsg(UINT8 LinkNum, void *ptr, IIPC_ety TargetEty);


typedef struct ICoreQ
{
	Hsem	oLock;
	ITaskQ	oRxQ;
	LINKS	eLink;
	UINT16	eHashID;
	ITaskQ	*pRxQ;
	HSEM_NUM eSemNum;
	Hsem	*pExtLock;

}ICoreQ;

void ICoreQ_Init( ICoreQ *pThis,  CHAR *sName, UINT16 nQSize, HSEM_NUM nHSemNum, LINKS eLink);
void ICoreQ_Init2( ICoreQ *pThis, ICoreQ *ShareQ, HSEM_NUM nHsemNum, LINKS eLink);
void ICoreQ_Start(ICoreQ *pThis, UINT16 eHashID, IIPC_ety etyNum);
Signal *GetIIPCSignal( void );
extern void Transmit_Mesg(UINT8  TO_Queue,void *pDataptr);
extern void Transmit_data(UINT8  TO_Queue,void *pDataptr);

extern void IPCMSGQ_Init();

typedef enum
{
	MSGTYPE_PACKET = 0,
	MSGTYPE_PACKET2,
	MSGTYPE_BURSTINFOREQ,
	MSGTYPE_BURST,
	MSGTYPE_BURSTINFO,
	MSGTYPE_TRFRJOBLIST,
	MSGTYPE_TRFRJOB,
	MSGTYPE_MAX
}msgType_e;

typedef union
{
	Packet 					pckt;
	Packet2					pckt2;
	BurstInfoReq			burstInfoReq;
	Burst					burst;
	BurstInfo				burstInfo;
	transferJobList_t		jobList;
	TransferJob				job;
}steMsg_u;

typedef struct IPCMessage
{
	MessageQ_MsgHeader 	Header;
	msgType_e 			type;
	steMsg_u 			msg;
}IPCMessage;


typedef struct IPCMesgData
{
	MessageQ_MsgHeader Header;
	Burst Pack;
}IPCMesgData;


//#include <log.h>
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_ILogger_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_ILogger_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*enable)(void*);
    xdc_Bool (*disable)(void*);
    void (*write0)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId);
    void (*write1)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg);
    void (*write2)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg);
    void (*write4)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
    void (*write8)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base xdc_runtime_ILogger_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* delete */
static inline void xdc_runtime_ILogger_delete( xdc_runtime_ILogger_Handle* instp )
{
    (*instp)->__fxns->__sysp->__delete(instp);
}

/* Handle_to_Module */
static inline xdc_runtime_ILogger_Module xdc_runtime_ILogger_Handle_to_Module( xdc_runtime_ILogger_Handle inst )
{
    return inst->__fxns;
}

/* Handle_label */
static inline xdc_runtime_Types_Label* xdc_runtime_ILogger_Handle_label( xdc_runtime_ILogger_Handle inst, xdc_runtime_Types_Label* lab )
{
    return inst->__fxns->__sysp->__label(inst, lab);
}

/* Module_id */
static inline xdc_runtime_Types_ModuleId xdc_runtime_ILogger_Module_id( xdc_runtime_ILogger_Module mod )
{
    return mod->__sysp->__mid;
}

/* enable */
static inline xdc_Bool xdc_runtime_ILogger_enable( xdc_runtime_ILogger_Handle __inst )
{
    return __inst->__fxns->enable((void*)__inst);
}

/* disable */
static inline xdc_Bool xdc_runtime_ILogger_disable( xdc_runtime_ILogger_Handle __inst )
{
    return __inst->__fxns->disable((void*)__inst);
}

/* write0 */
static inline void xdc_runtime_ILogger_write0( xdc_runtime_ILogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid )
{
    __inst->__fxns->write0((void*)__inst, evt, mid);
}

/* write1 */
static inline void xdc_runtime_ILogger_write1( xdc_runtime_ILogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1 )
{
    __inst->__fxns->write1((void*)__inst, evt, mid, a1);
}

/* write2 */
static inline void xdc_runtime_ILogger_write2( xdc_runtime_ILogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2 )
{
    __inst->__fxns->write2((void*)__inst, evt, mid, a1, a2);
}

/* write4 */
static inline void xdc_runtime_ILogger_write4( xdc_runtime_ILogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4 )
{
    __inst->__fxns->write4((void*)__inst, evt, mid, a1, a2, a3, a4);
}

/* write8 */
static inline void xdc_runtime_ILogger_write8( xdc_runtime_ILogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4, xdc_IArg a5, xdc_IArg a6, xdc_IArg a7, xdc_IArg a8 )
{
    __inst->__fxns->write8((void*)__inst, evt, mid, a1, a2, a3, a4, a5, a6, a7, a8);
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enable_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_ILogger_enable_FxnT)(void*);
static inline xdc_runtime_ILogger_enable_FxnT xdc_runtime_ILogger_enable_fxnP( xdc_runtime_ILogger_Handle __inst )
{
    return (xdc_runtime_ILogger_enable_FxnT)__inst->__fxns->enable;
}

/* disable_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_ILogger_disable_FxnT)(void*);
static inline xdc_runtime_ILogger_disable_FxnT xdc_runtime_ILogger_disable_fxnP( xdc_runtime_ILogger_Handle __inst )
{
    return (xdc_runtime_ILogger_disable_FxnT)__inst->__fxns->disable;
}

/* write0_{FxnT,fxnP} */
typedef void (*xdc_runtime_ILogger_write0_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId);
static inline xdc_runtime_ILogger_write0_FxnT xdc_runtime_ILogger_write0_fxnP( xdc_runtime_ILogger_Handle __inst )
{
    return (xdc_runtime_ILogger_write0_FxnT)__inst->__fxns->write0;
}

/* write1_{FxnT,fxnP} */
typedef void (*xdc_runtime_ILogger_write1_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg);
static inline xdc_runtime_ILogger_write1_FxnT xdc_runtime_ILogger_write1_fxnP( xdc_runtime_ILogger_Handle __inst )
{
    return (xdc_runtime_ILogger_write1_FxnT)__inst->__fxns->write1;
}

/* write2_{FxnT,fxnP} */
typedef void (*xdc_runtime_ILogger_write2_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg);
static inline xdc_runtime_ILogger_write2_FxnT xdc_runtime_ILogger_write2_fxnP( xdc_runtime_ILogger_Handle __inst )
{
    return (xdc_runtime_ILogger_write2_FxnT)__inst->__fxns->write2;
}

/* write4_{FxnT,fxnP} */
typedef void (*xdc_runtime_ILogger_write4_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
static inline xdc_runtime_ILogger_write4_FxnT xdc_runtime_ILogger_write4_fxnP( xdc_runtime_ILogger_Handle __inst )
{
    return (xdc_runtime_ILogger_write4_FxnT)__inst->__fxns->write4;
}

/* write8_{FxnT,fxnP} */
typedef void (*xdc_runtime_ILogger_write8_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
static inline xdc_runtime_ILogger_write8_FxnT xdc_runtime_ILogger_write8_fxnP( xdc_runtime_ILogger_Handle __inst )
{
    return (xdc_runtime_ILogger_write8_FxnT)__inst->__fxns->write8;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_IFilterLogger_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_IFilterLogger_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*enable)(void*);
    xdc_Bool (*disable)(void*);
    void (*write0)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId);
    void (*write1)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg);
    void (*write2)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg);
    void (*write4)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
    void (*write8)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
    void (*setFilterLevel)(void*, xdc_runtime_Diags_Mask, xdc_runtime_Diags_EventLevel);
    xdc_runtime_Diags_Mask (*getFilterLevel)(void*, xdc_runtime_Diags_EventLevel);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base xdc_runtime_IFilterLogger_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* delete */
static inline void xdc_runtime_IFilterLogger_delete( xdc_runtime_IFilterLogger_Handle* instp )
{
    (*instp)->__fxns->__sysp->__delete(instp);
}

/* Handle_to_Module */
static inline xdc_runtime_IFilterLogger_Module xdc_runtime_IFilterLogger_Handle_to_Module( xdc_runtime_IFilterLogger_Handle inst )
{
    return inst->__fxns;
}

/* Handle_label */
static inline xdc_runtime_Types_Label* xdc_runtime_IFilterLogger_Handle_label( xdc_runtime_IFilterLogger_Handle inst, xdc_runtime_Types_Label* lab )
{
    return inst->__fxns->__sysp->__label(inst, lab);
}

/* Module_id */
static inline xdc_runtime_Types_ModuleId xdc_runtime_IFilterLogger_Module_id( xdc_runtime_IFilterLogger_Module mod )
{
    return mod->__sysp->__mid;
}

/* enable */
static inline xdc_Bool xdc_runtime_IFilterLogger_enable( xdc_runtime_IFilterLogger_Handle __inst )
{
    return __inst->__fxns->enable((void*)__inst);
}

/* disable */
static inline xdc_Bool xdc_runtime_IFilterLogger_disable( xdc_runtime_IFilterLogger_Handle __inst )
{
    return __inst->__fxns->disable((void*)__inst);
}

/* write0 */
static inline void xdc_runtime_IFilterLogger_write0( xdc_runtime_IFilterLogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid )
{
    __inst->__fxns->write0((void*)__inst, evt, mid);
}

/* write1 */
static inline void xdc_runtime_IFilterLogger_write1( xdc_runtime_IFilterLogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1 )
{
    __inst->__fxns->write1((void*)__inst, evt, mid, a1);
}

/* write2 */
static inline void xdc_runtime_IFilterLogger_write2( xdc_runtime_IFilterLogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2 )
{
    __inst->__fxns->write2((void*)__inst, evt, mid, a1, a2);
}

/* write4 */
static inline void xdc_runtime_IFilterLogger_write4( xdc_runtime_IFilterLogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4 )
{
    __inst->__fxns->write4((void*)__inst, evt, mid, a1, a2, a3, a4);
}

/* write8 */
static inline void xdc_runtime_IFilterLogger_write8( xdc_runtime_IFilterLogger_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4, xdc_IArg a5, xdc_IArg a6, xdc_IArg a7, xdc_IArg a8 )
{
    __inst->__fxns->write8((void*)__inst, evt, mid, a1, a2, a3, a4, a5, a6, a7, a8);
}

/* setFilterLevel */
static inline void xdc_runtime_IFilterLogger_setFilterLevel( xdc_runtime_IFilterLogger_Handle __inst, xdc_runtime_Diags_Mask mask, xdc_runtime_Diags_EventLevel filterLevel )
{
    __inst->__fxns->setFilterLevel((void*)__inst, mask, filterLevel);
}

/* getFilterLevel */
static inline xdc_runtime_Diags_Mask xdc_runtime_IFilterLogger_getFilterLevel( xdc_runtime_IFilterLogger_Handle __inst, xdc_runtime_Diags_EventLevel level )
{
    return __inst->__fxns->getFilterLevel((void*)__inst, level);
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enable_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_IFilterLogger_enable_FxnT)(void*);
static inline xdc_runtime_IFilterLogger_enable_FxnT xdc_runtime_IFilterLogger_enable_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_enable_FxnT)__inst->__fxns->enable;
}

/* disable_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_IFilterLogger_disable_FxnT)(void*);
static inline xdc_runtime_IFilterLogger_disable_FxnT xdc_runtime_IFilterLogger_disable_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_disable_FxnT)__inst->__fxns->disable;
}

/* write0_{FxnT,fxnP} */
typedef void (*xdc_runtime_IFilterLogger_write0_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId);
static inline xdc_runtime_IFilterLogger_write0_FxnT xdc_runtime_IFilterLogger_write0_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_write0_FxnT)__inst->__fxns->write0;
}

/* write1_{FxnT,fxnP} */
typedef void (*xdc_runtime_IFilterLogger_write1_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg);
static inline xdc_runtime_IFilterLogger_write1_FxnT xdc_runtime_IFilterLogger_write1_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_write1_FxnT)__inst->__fxns->write1;
}

/* write2_{FxnT,fxnP} */
typedef void (*xdc_runtime_IFilterLogger_write2_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg);
static inline xdc_runtime_IFilterLogger_write2_FxnT xdc_runtime_IFilterLogger_write2_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_write2_FxnT)__inst->__fxns->write2;
}

/* write4_{FxnT,fxnP} */
typedef void (*xdc_runtime_IFilterLogger_write4_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
static inline xdc_runtime_IFilterLogger_write4_FxnT xdc_runtime_IFilterLogger_write4_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_write4_FxnT)__inst->__fxns->write4;
}

/* write8_{FxnT,fxnP} */
typedef void (*xdc_runtime_IFilterLogger_write8_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
static inline xdc_runtime_IFilterLogger_write8_FxnT xdc_runtime_IFilterLogger_write8_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_write8_FxnT)__inst->__fxns->write8;
}

/* setFilterLevel_{FxnT,fxnP} */
typedef void (*xdc_runtime_IFilterLogger_setFilterLevel_FxnT)(void*, xdc_runtime_Diags_Mask, xdc_runtime_Diags_EventLevel);
static inline xdc_runtime_IFilterLogger_setFilterLevel_FxnT xdc_runtime_IFilterLogger_setFilterLevel_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_setFilterLevel_FxnT)__inst->__fxns->setFilterLevel;
}

/* getFilterLevel_{FxnT,fxnP} */
typedef xdc_runtime_Diags_Mask (*xdc_runtime_IFilterLogger_getFilterLevel_FxnT)(void*, xdc_runtime_Diags_EventLevel);
static inline xdc_runtime_IFilterLogger_getFilterLevel_FxnT xdc_runtime_IFilterLogger_getFilterLevel_fxnP( xdc_runtime_IFilterLogger_Handle __inst )
{
    return (xdc_runtime_IFilterLogger_getFilterLevel_FxnT)__inst->__fxns->getFilterLevel;
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_ILogger_Module xdc_runtime_IFilterLogger_Module_upCast( xdc_runtime_IFilterLogger_Module m )
{
    return(xdc_runtime_ILogger_Module)m;
}

/* Module_to_xdc_runtime_ILogger */

/* Module_downCast */
static inline xdc_runtime_IFilterLogger_Module xdc_runtime_IFilterLogger_Module_downCast( xdc_runtime_ILogger_Module m )
{
    xdc_runtime_Types_Base* b; for (b = m->__base; b; b = b->base) {
        if (b == &xdc_runtime_IFilterLogger_Interface__BASE__C) return (xdc_runtime_IFilterLogger_Module)m;
    } return 0;
}

/* Module_from_xdc_runtime_ILogger */

/* Handle_upCast */
static inline xdc_runtime_ILogger_Handle xdc_runtime_IFilterLogger_Handle_upCast( xdc_runtime_IFilterLogger_Handle i )
{
    return (xdc_runtime_ILogger_Handle)i;
}

/* Handle_to_xdc_runtime_ILogger */

/* Handle_downCast */
static inline xdc_runtime_IFilterLogger_Handle xdc_runtime_IFilterLogger_Handle_downCast( xdc_runtime_ILogger_Handle i )
{
    xdc_runtime_ILogger_Handle i2 = (xdc_runtime_ILogger_Handle)i;
    xdc_runtime_Types_Base* b; for (b = i2->__fxns->__base; b; b = b->base) {
        if (b == &xdc_runtime_IFilterLogger_Interface__BASE__C) return (xdc_runtime_IFilterLogger_Handle)i;
    } return 0;
}

/* Handle_from_xdc_runtime_ILogger */


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_ITimestampClient_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bits32 (*get32)(void);
    void (*get64)(xdc_runtime_Types_Timestamp64*);
    void (*getFreq)(xdc_runtime_Types_FreqHz*);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Interface__BASE__C */
extern const xdc_runtime_Types_Base xdc_runtime_ITimestampClient_Interface__BASE__C;


/*
 * ======== FUNCTION STUBS ========
 */

/* Module_id */
static inline xdc_runtime_Types_ModuleId xdc_runtime_ITimestampClient_Module_id( xdc_runtime_ITimestampClient_Module mod )
{
    return mod->__sysp->__mid;
}

/* get32 */
static inline xdc_Bits32 xdc_runtime_ITimestampClient_get32( xdc_runtime_ITimestampClient_Module __inst )
{
    return __inst->get32();
}

/* get64 */
static inline void xdc_runtime_ITimestampClient_get64( xdc_runtime_ITimestampClient_Module __inst, xdc_runtime_Types_Timestamp64* result )
{
    __inst->get64(result);
}

/* getFreq */
static inline void xdc_runtime_ITimestampClient_getFreq( xdc_runtime_ITimestampClient_Module __inst, xdc_runtime_Types_FreqHz* freq )
{
    __inst->getFreq(freq);
}


/*
 * ======== FUNCTION SELECTORS ========
 */

/* get32_{FxnT,fxnP} */
typedef xdc_Bits32 (*xdc_runtime_ITimestampClient_get32_FxnT)(void);
static inline xdc_runtime_ITimestampClient_get32_FxnT xdc_runtime_ITimestampClient_get32_fxnP( xdc_runtime_ITimestampClient_Module __inst )
{
    return (xdc_runtime_ITimestampClient_get32_FxnT)__inst->get32;
}

/* get64_{FxnT,fxnP} */
typedef void (*xdc_runtime_ITimestampClient_get64_FxnT)(xdc_runtime_Types_Timestamp64*);
static inline xdc_runtime_ITimestampClient_get64_FxnT xdc_runtime_ITimestampClient_get64_fxnP( xdc_runtime_ITimestampClient_Module __inst )
{
    return (xdc_runtime_ITimestampClient_get64_FxnT)__inst->get64;
}

/* getFreq_{FxnT,fxnP} */
typedef void (*xdc_runtime_ITimestampClient_getFreq_FxnT)(xdc_runtime_Types_FreqHz*);
static inline xdc_runtime_ITimestampClient_getFreq_FxnT xdc_runtime_ITimestampClient_getFreq_fxnP( xdc_runtime_ITimestampClient_Module __inst )
{
    return (xdc_runtime_ITimestampClient_getFreq_FxnT)__inst->getFreq;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsEnabled;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsEnabled xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsIncluded;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsIncluded xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsMask;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsMask xdc_runtime_LoggerBuf_TimestampProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__gateObj;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__gateObj xdc_runtime_LoggerBuf_TimestampProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__gatePrms;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__gatePrms xdc_runtime_LoggerBuf_TimestampProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__id;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__id xdc_runtime_LoggerBuf_TimestampProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerDefined;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerDefined xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerObj;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerObj xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn0;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn0 xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn1;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn1 xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn2;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn2 xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn4;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn4 xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn8;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn8 xdc_runtime_LoggerBuf_TimestampProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__startupDoneFxn xdc_runtime_LoggerBuf_TimestampProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_LoggerBuf_TimestampProxy_Object__count;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Object__count xdc_runtime_LoggerBuf_TimestampProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_LoggerBuf_TimestampProxy_Object__heap;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Object__heap xdc_runtime_LoggerBuf_TimestampProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_LoggerBuf_TimestampProxy_Object__sizeof;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Object__sizeof xdc_runtime_LoggerBuf_TimestampProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_TimestampProxy_Object__table;
extern far const CT__xdc_runtime_LoggerBuf_TimestampProxy_Object__table xdc_runtime_LoggerBuf_TimestampProxy_Object__table__C;


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_LoggerBuf_TimestampProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bits32 (*get32)(void);
    void (*get64)(xdc_runtime_Types_Timestamp64*);
    void (*getFreq)(xdc_runtime_Types_FreqHz*);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const xdc_runtime_LoggerBuf_TimestampProxy_Fxns__ xdc_runtime_LoggerBuf_TimestampProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* xdc_runtime_LoggerBuf_TimestampProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_LoggerBuf_TimestampProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_TimestampProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void xdc_runtime_LoggerBuf_TimestampProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void xdc_runtime_LoggerBuf_TimestampProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_TimestampProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_TimestampProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_TimestampProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void xdc_runtime_LoggerBuf_TimestampProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool xdc_runtime_LoggerBuf_TimestampProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_TimestampProxy_Proxy__delegate__S( void );

/* get32__E */

extern xdc_Bits32 xdc_runtime_LoggerBuf_TimestampProxy_get32__E( void );

extern xdc_Bits32 xdc_runtime_LoggerBuf_TimestampProxy_get32__R( void );

/* get64__E */

extern void xdc_runtime_LoggerBuf_TimestampProxy_get64__E( xdc_runtime_Types_Timestamp64* result );

extern void xdc_runtime_LoggerBuf_TimestampProxy_get64__R( xdc_runtime_Types_Timestamp64* result );

/* getFreq__E */

extern void xdc_runtime_LoggerBuf_TimestampProxy_getFreq__E( xdc_runtime_Types_FreqHz* freq );

extern void xdc_runtime_LoggerBuf_TimestampProxy_getFreq__R( xdc_runtime_Types_FreqHz* freq );


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_ITimestampClient_Module xdc_runtime_LoggerBuf_TimestampProxy_Module_upCast( void )
{
    return (xdc_runtime_ITimestampClient_Module)xdc_runtime_LoggerBuf_TimestampProxy_Proxy__delegate__S();
}

/* Module_to_xdc_runtime_ITimestampClient */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_LoggerBuf_TimestampProxy_Module__id xdc_runtime_LoggerBuf_TimestampProxy_Module_id( void ) 
{
    return xdc_runtime_LoggerBuf_TimestampProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */






/*
 * ======== INCLUDES ========
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:35; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */


/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION STUBS
 *     FUNCTION SELECTORS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */

/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* Q_BLOCKING */

/* Q_PREEMPTING */


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsEnabled;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsEnabled xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsIncluded;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsIncluded xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsMask;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsMask xdc_runtime_LoggerBuf_Module_GateProxy_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__gateObj;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__gateObj xdc_runtime_LoggerBuf_Module_GateProxy_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__gatePrms;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__gatePrms xdc_runtime_LoggerBuf_Module_GateProxy_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__id;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__id xdc_runtime_LoggerBuf_Module_GateProxy_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerDefined;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerDefined xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerObj;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerObj xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn0;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn0 xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn1;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn1 xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn2;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn2 xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn4;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn4 xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn8;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn8 xdc_runtime_LoggerBuf_Module_GateProxy_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__startupDoneFxn xdc_runtime_LoggerBuf_Module_GateProxy_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_LoggerBuf_Module_GateProxy_Object__count;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Object__count xdc_runtime_LoggerBuf_Module_GateProxy_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_LoggerBuf_Module_GateProxy_Object__heap;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Object__heap xdc_runtime_LoggerBuf_Module_GateProxy_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_LoggerBuf_Module_GateProxy_Object__sizeof;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Object__sizeof xdc_runtime_LoggerBuf_Module_GateProxy_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_Module_GateProxy_Object__table;
extern far const CT__xdc_runtime_LoggerBuf_Module_GateProxy_Object__table xdc_runtime_LoggerBuf_Module_GateProxy_Object__table__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_LoggerBuf_Module_GateProxy_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct xdc_runtime_LoggerBuf_Module_GateProxy_Struct {
    const xdc_runtime_LoggerBuf_Module_GateProxy_Fxns__* __fxns;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_LoggerBuf_Module_GateProxy_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*query)(xdc_Int);
    xdc_IArg (*enter)(xdc_runtime_LoggerBuf_Module_GateProxy_Handle);
    void (*leave)(xdc_runtime_LoggerBuf_Module_GateProxy_Handle, xdc_IArg);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const xdc_runtime_LoggerBuf_Module_GateProxy_Fxns__ xdc_runtime_LoggerBuf_Module_GateProxy_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

/* Handle__label__S */

extern xdc_runtime_Types_Label* xdc_runtime_LoggerBuf_Module_GateProxy_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_LoggerBuf_Module_GateProxy_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Module_GateProxy_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void xdc_runtime_LoggerBuf_Module_GateProxy_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void xdc_runtime_LoggerBuf_Module_GateProxy_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Module_GateProxy_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Module_GateProxy_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Module_GateProxy_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void xdc_runtime_LoggerBuf_Module_GateProxy_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* Proxy__abstract__S */

extern xdc_Bool xdc_runtime_LoggerBuf_Module_GateProxy_Proxy__abstract__S( void );

/* Proxy__delegate__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Module_GateProxy_Proxy__delegate__S( void );

/* query__E */

extern xdc_Bool xdc_runtime_LoggerBuf_Module_GateProxy_query__E( xdc_Int qual );

extern xdc_Bool xdc_runtime_LoggerBuf_Module_GateProxy_query__R( xdc_Int qual );

/* enter__E */

extern xdc_IArg xdc_runtime_LoggerBuf_Module_GateProxy_enter__E( xdc_runtime_LoggerBuf_Module_GateProxy_Handle __inst );

extern xdc_IArg xdc_runtime_LoggerBuf_Module_GateProxy_enter__R( xdc_runtime_LoggerBuf_Module_GateProxy_Handle __inst );

/* leave__E */

extern void xdc_runtime_LoggerBuf_Module_GateProxy_leave__E( xdc_runtime_LoggerBuf_Module_GateProxy_Handle __inst, xdc_IArg key );

extern void xdc_runtime_LoggerBuf_Module_GateProxy_leave__R( xdc_runtime_LoggerBuf_Module_GateProxy_Handle __inst, xdc_IArg key );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enter_{FxnT,fxnP} */
typedef xdc_IArg (*xdc_runtime_LoggerBuf_Module_GateProxy_enter_FxnT)(void*);
static inline xdc_runtime_LoggerBuf_Module_GateProxy_enter_FxnT xdc_runtime_LoggerBuf_Module_GateProxy_enter_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_Module_GateProxy_enter_FxnT)xdc_runtime_LoggerBuf_Module_GateProxy_enter__E; 
}

/* leave_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_Module_GateProxy_leave_FxnT)(void*, xdc_IArg);
static inline xdc_runtime_LoggerBuf_Module_GateProxy_leave_FxnT xdc_runtime_LoggerBuf_Module_GateProxy_leave_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_Module_GateProxy_leave_FxnT)xdc_runtime_LoggerBuf_Module_GateProxy_leave__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IGateProvider_Module xdc_runtime_LoggerBuf_Module_GateProxy_Module_upCast( void )
{
    return (xdc_runtime_IGateProvider_Module)xdc_runtime_LoggerBuf_Module_GateProxy_Proxy__delegate__S();
}

/* Module_to_xdc_runtime_IGateProvider */

/* Handle_upCast */
static inline xdc_runtime_IGateProvider_Handle xdc_runtime_LoggerBuf_Module_GateProxy_Handle_upCast( xdc_runtime_LoggerBuf_Module_GateProxy_Handle i )
{
    return (xdc_runtime_IGateProvider_Handle)i;
}

/* Handle_to_xdc_runtime_IGateProvider */

/* Handle_downCast */
static inline xdc_runtime_LoggerBuf_Module_GateProxy_Handle xdc_runtime_LoggerBuf_Module_GateProxy_Handle_downCast( xdc_runtime_IGateProvider_Handle i )
{
    xdc_runtime_IGateProvider_Handle i2 = (xdc_runtime_IGateProvider_Handle)i;
if (xdc_runtime_LoggerBuf_Module_GateProxy_Proxy__abstract__S()) return (xdc_runtime_LoggerBuf_Module_GateProxy_Handle)i;
    return (void*)i2->__fxns == (void*)xdc_runtime_LoggerBuf_Module_GateProxy_Proxy__delegate__S() ? (xdc_runtime_LoggerBuf_Module_GateProxy_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IGateProvider */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_LoggerBuf_Module_GateProxy_Module__id xdc_runtime_LoggerBuf_Module_GateProxy_Module_id( void ) 
{
    return xdc_runtime_LoggerBuf_Module_GateProxy_Module__id__C;
}

/* Proxy_abstract */

/* Proxy_delegate */

/* Params_init */
static inline void xdc_runtime_LoggerBuf_Module_GateProxy_Params_init( xdc_runtime_LoggerBuf_Module_GateProxy_Params* prms ) 
{
    if (prms) {
        xdc_runtime_LoggerBuf_Module_GateProxy_Params__init__S(prms, 0, sizeof(xdc_runtime_LoggerBuf_Module_GateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void xdc_runtime_LoggerBuf_Module_GateProxy_Params_copy( xdc_runtime_LoggerBuf_Module_GateProxy_Params* dst, const xdc_runtime_LoggerBuf_Module_GateProxy_Params* src ) 
{
    if (dst) {
        xdc_runtime_LoggerBuf_Module_GateProxy_Params__init__S(dst, (xdc_Ptr)src, sizeof(xdc_runtime_LoggerBuf_Module_GateProxy_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* create */
static inline xdc_runtime_LoggerBuf_Module_GateProxy_Handle xdc_runtime_LoggerBuf_Module_GateProxy_create( const xdc_runtime_LoggerBuf_Module_GateProxy_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (xdc_runtime_LoggerBuf_Module_GateProxy_Handle)xdc_runtime_LoggerBuf_Module_GateProxy_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(xdc_runtime_LoggerBuf_Module_GateProxy_Params), __eb);
}

/* delete */
static inline void xdc_runtime_LoggerBuf_Module_GateProxy_delete( xdc_runtime_LoggerBuf_Module_GateProxy_Handle* instp )
{
    xdc_runtime_LoggerBuf_Module_GateProxy_Object__delete__S(instp);
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== PREFIX ALIASES ========
 */



/*
 * ======== AUXILIARY DEFINITIONS ========
 */

/* BufType */
enum xdc_runtime_LoggerBuf_BufType {
    xdc_runtime_LoggerBuf_BufType_CIRCULAR,
    xdc_runtime_LoggerBuf_BufType_FIXED
};
typedef enum xdc_runtime_LoggerBuf_BufType xdc_runtime_LoggerBuf_BufType;


/*
 * ======== INTERNAL DEFINITIONS ========
 */

/* FULL */

/* WRAP */

/* NEXT */

/* Entry */
struct xdc_runtime_LoggerBuf_Entry {
    xdc_runtime_Types_Timestamp64 tstamp;
    xdc_Bits32 serial;
    xdc_runtime_Types_Event evt;
    xdc_IArg arg1;
    xdc_IArg arg2;
    xdc_IArg arg3;
    xdc_IArg arg4;
};

/* Instance_State */
typedef xdc_runtime_LoggerBuf_Entry __T1_xdc_runtime_LoggerBuf_Instance_State__entryArr;
typedef xdc_runtime_LoggerBuf_Entry *__ARRAY1_xdc_runtime_LoggerBuf_Instance_State__entryArr;
typedef __ARRAY1_xdc_runtime_LoggerBuf_Instance_State__entryArr __TA_xdc_runtime_LoggerBuf_Instance_State__entryArr;


/*
 * ======== MODULE-WIDE CONFIGS ========
 */

/* Module__diagsEnabled */
typedef xdc_Bits32 CT__xdc_runtime_LoggerBuf_Module__diagsEnabled;
extern far const CT__xdc_runtime_LoggerBuf_Module__diagsEnabled xdc_runtime_LoggerBuf_Module__diagsEnabled__C;

/* Module__diagsIncluded */
typedef xdc_Bits32 CT__xdc_runtime_LoggerBuf_Module__diagsIncluded;
extern far const CT__xdc_runtime_LoggerBuf_Module__diagsIncluded xdc_runtime_LoggerBuf_Module__diagsIncluded__C;

/* Module__diagsMask */
typedef xdc_Bits16* CT__xdc_runtime_LoggerBuf_Module__diagsMask;
extern far const CT__xdc_runtime_LoggerBuf_Module__diagsMask xdc_runtime_LoggerBuf_Module__diagsMask__C;

/* Module__gateObj */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_Module__gateObj;
extern far const CT__xdc_runtime_LoggerBuf_Module__gateObj xdc_runtime_LoggerBuf_Module__gateObj__C;

/* Module__gatePrms */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_Module__gatePrms;
extern far const CT__xdc_runtime_LoggerBuf_Module__gatePrms xdc_runtime_LoggerBuf_Module__gatePrms__C;

/* Module__id */
typedef xdc_runtime_Types_ModuleId CT__xdc_runtime_LoggerBuf_Module__id;
extern far const CT__xdc_runtime_LoggerBuf_Module__id xdc_runtime_LoggerBuf_Module__id__C;

/* Module__loggerDefined */
typedef xdc_Bool CT__xdc_runtime_LoggerBuf_Module__loggerDefined;
extern far const CT__xdc_runtime_LoggerBuf_Module__loggerDefined xdc_runtime_LoggerBuf_Module__loggerDefined__C;

/* Module__loggerObj */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_Module__loggerObj;
extern far const CT__xdc_runtime_LoggerBuf_Module__loggerObj xdc_runtime_LoggerBuf_Module__loggerObj__C;

/* Module__loggerFxn0 */
typedef xdc_runtime_Types_LoggerFxn0 CT__xdc_runtime_LoggerBuf_Module__loggerFxn0;
extern far const CT__xdc_runtime_LoggerBuf_Module__loggerFxn0 xdc_runtime_LoggerBuf_Module__loggerFxn0__C;

/* Module__loggerFxn1 */
typedef xdc_runtime_Types_LoggerFxn1 CT__xdc_runtime_LoggerBuf_Module__loggerFxn1;
extern far const CT__xdc_runtime_LoggerBuf_Module__loggerFxn1 xdc_runtime_LoggerBuf_Module__loggerFxn1__C;

/* Module__loggerFxn2 */
typedef xdc_runtime_Types_LoggerFxn2 CT__xdc_runtime_LoggerBuf_Module__loggerFxn2;
extern far const CT__xdc_runtime_LoggerBuf_Module__loggerFxn2 xdc_runtime_LoggerBuf_Module__loggerFxn2__C;

/* Module__loggerFxn4 */
typedef xdc_runtime_Types_LoggerFxn4 CT__xdc_runtime_LoggerBuf_Module__loggerFxn4;
extern far const CT__xdc_runtime_LoggerBuf_Module__loggerFxn4 xdc_runtime_LoggerBuf_Module__loggerFxn4__C;

/* Module__loggerFxn8 */
typedef xdc_runtime_Types_LoggerFxn8 CT__xdc_runtime_LoggerBuf_Module__loggerFxn8;
extern far const CT__xdc_runtime_LoggerBuf_Module__loggerFxn8 xdc_runtime_LoggerBuf_Module__loggerFxn8__C;

/* Module__startupDoneFxn */
typedef xdc_Bool (*CT__xdc_runtime_LoggerBuf_Module__startupDoneFxn)(void);
extern far const CT__xdc_runtime_LoggerBuf_Module__startupDoneFxn xdc_runtime_LoggerBuf_Module__startupDoneFxn__C;

/* Object__count */
typedef xdc_Int CT__xdc_runtime_LoggerBuf_Object__count;
extern far const CT__xdc_runtime_LoggerBuf_Object__count xdc_runtime_LoggerBuf_Object__count__C;

/* Object__heap */
typedef xdc_runtime_IHeap_Handle CT__xdc_runtime_LoggerBuf_Object__heap;
extern far const CT__xdc_runtime_LoggerBuf_Object__heap xdc_runtime_LoggerBuf_Object__heap__C;

/* Object__sizeof */
typedef xdc_SizeT CT__xdc_runtime_LoggerBuf_Object__sizeof;
extern far const CT__xdc_runtime_LoggerBuf_Object__sizeof xdc_runtime_LoggerBuf_Object__sizeof__C;

/* Object__table */
typedef xdc_Ptr CT__xdc_runtime_LoggerBuf_Object__table;
extern far const CT__xdc_runtime_LoggerBuf_Object__table xdc_runtime_LoggerBuf_Object__table__C;

/* filterByLevel */
typedef xdc_Bool CT__xdc_runtime_LoggerBuf_filterByLevel;
extern far const CT__xdc_runtime_LoggerBuf_filterByLevel xdc_runtime_LoggerBuf_filterByLevel__C;

/* E_badLevel */
typedef xdc_runtime_Error_Id CT__xdc_runtime_LoggerBuf_E_badLevel;
extern far const CT__xdc_runtime_LoggerBuf_E_badLevel xdc_runtime_LoggerBuf_E_badLevel__C;

/* enableFlush */
typedef xdc_Bool CT__xdc_runtime_LoggerBuf_enableFlush;
extern far const CT__xdc_runtime_LoggerBuf_enableFlush xdc_runtime_LoggerBuf_enableFlush__C;

/* statusLogger */
typedef xdc_runtime_ILogger_Handle CT__xdc_runtime_LoggerBuf_statusLogger;
extern far const CT__xdc_runtime_LoggerBuf_statusLogger xdc_runtime_LoggerBuf_statusLogger__C;

/* level1Mask */
typedef xdc_runtime_Diags_Mask CT__xdc_runtime_LoggerBuf_level1Mask;
extern far const CT__xdc_runtime_LoggerBuf_level1Mask xdc_runtime_LoggerBuf_level1Mask__C;

/* level2Mask */
typedef xdc_runtime_Diags_Mask CT__xdc_runtime_LoggerBuf_level2Mask;
extern far const CT__xdc_runtime_LoggerBuf_level2Mask xdc_runtime_LoggerBuf_level2Mask__C;

/* level3Mask */
typedef xdc_runtime_Diags_Mask CT__xdc_runtime_LoggerBuf_level3Mask;
extern far const CT__xdc_runtime_LoggerBuf_level3Mask xdc_runtime_LoggerBuf_level3Mask__C;

/* level4Mask */
typedef xdc_runtime_Diags_Mask CT__xdc_runtime_LoggerBuf_level4Mask;
extern far const CT__xdc_runtime_LoggerBuf_level4Mask xdc_runtime_LoggerBuf_level4Mask__C;


/*
 * ======== PER-INSTANCE TYPES ========
 */

/* Params */
struct xdc_runtime_LoggerBuf_Params {
    size_t __size;
    const void* __self;
    void* __fxns;
    xdc_runtime_IInstance_Params* instance;
    xdc_Int numEntries;
    xdc_runtime_LoggerBuf_BufType bufType;
    xdc_Bool exitFlush;
    xdc_runtime_IHeap_Handle bufHeap;
    xdc_runtime_IInstance_Params __iprms;
};

/* Struct */
struct xdc_runtime_LoggerBuf_Struct {
    const xdc_runtime_LoggerBuf_Fxns__* __fxns;
    xdc_runtime_IHeap_Handle __f0;
    __TA_xdc_runtime_LoggerBuf_Instance_State__entryArr __f1;
    xdc_runtime_LoggerBuf_Entry* __f2;
    xdc_runtime_LoggerBuf_Entry* __f3;
    xdc_runtime_LoggerBuf_Entry* __f4;
    xdc_Bits32 __f5;
    xdc_Int16 __f6;
    xdc_Int8 __f7;
    xdc_Bool __f8;
    xdc_Bool __f9;
    xdc_runtime_Types_CordAddr __name;
};


/*
 * ======== VIRTUAL FUNCTIONS ========
 */

/* Fxns__ */
struct xdc_runtime_LoggerBuf_Fxns__ {
    xdc_runtime_Types_Base* __base;
    const xdc_runtime_Types_SysFxns2* __sysp;
    xdc_Bool (*enable)(xdc_runtime_LoggerBuf_Handle);
    xdc_Bool (*disable)(xdc_runtime_LoggerBuf_Handle);
    void (*write0)(xdc_runtime_LoggerBuf_Handle, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId);
    void (*write1)(xdc_runtime_LoggerBuf_Handle, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg);
    void (*write2)(xdc_runtime_LoggerBuf_Handle, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg);
    void (*write4)(xdc_runtime_LoggerBuf_Handle, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
    void (*write8)(xdc_runtime_LoggerBuf_Handle, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
    void (*setFilterLevel)(xdc_runtime_LoggerBuf_Handle, xdc_runtime_Diags_Mask, xdc_runtime_Diags_EventLevel);
    xdc_runtime_Diags_Mask (*getFilterLevel)(xdc_runtime_LoggerBuf_Handle, xdc_runtime_Diags_EventLevel);
    xdc_runtime_Types_SysFxns2 __sfxns;
};

/* Module__FXNS__C */
extern const xdc_runtime_LoggerBuf_Fxns__ xdc_runtime_LoggerBuf_Module__FXNS__C;


/*
 * ======== FUNCTION DECLARATIONS ========
 */

/* Module_startup */

extern xdc_Int xdc_runtime_LoggerBuf_Module_startup__E( xdc_Int state );

extern xdc_Int xdc_runtime_LoggerBuf_Module_startup__F( xdc_Int state );

extern xdc_Int xdc_runtime_LoggerBuf_Module_startup__R( xdc_Int state );

/* Instance_init__F */

extern int xdc_runtime_LoggerBuf_Instance_init__F( xdc_runtime_LoggerBuf_Object*, const xdc_runtime_LoggerBuf_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__F */

extern void xdc_runtime_LoggerBuf_Instance_finalize__F( xdc_runtime_LoggerBuf_Object* , int );

/* Instance_init__R */

extern int xdc_runtime_LoggerBuf_Instance_init__R( xdc_runtime_LoggerBuf_Object*, const xdc_runtime_LoggerBuf_Params*, xdc_runtime_Error_Block* );

/* Instance_finalize__R */

extern void xdc_runtime_LoggerBuf_Instance_finalize__R( xdc_runtime_LoggerBuf_Object* , int );

/* Handle__label__S */

extern xdc_runtime_Types_Label* xdc_runtime_LoggerBuf_Handle__label__S( xdc_Ptr obj, xdc_runtime_Types_Label* lab );

/* Module__startupDone__S */

extern xdc_Bool xdc_runtime_LoggerBuf_Module__startupDone__S( void );

/* Object__create__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Object__create__S( xdc_Ptr __oa, xdc_SizeT __osz, xdc_Ptr __aa, const xdc_UChar* __pa, xdc_SizeT __psz, xdc_runtime_Error_Block* __eb );

/* Object__delete__S */

extern void xdc_runtime_LoggerBuf_Object__delete__S( xdc_Ptr instp );

/* Object__destruct__S */

extern void xdc_runtime_LoggerBuf_Object__destruct__S( xdc_Ptr objp );

/* Object__get__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Object__get__S( xdc_Ptr oarr, xdc_Int i );

/* Object__first__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Object__first__S( void );

/* Object__next__S */

extern xdc_Ptr xdc_runtime_LoggerBuf_Object__next__S( xdc_Ptr obj );

/* Params__init__S */

extern void xdc_runtime_LoggerBuf_Params__init__S( xdc_Ptr dst, xdc_Ptr src, xdc_SizeT psz, xdc_SizeT isz );

/* enable__E */

extern xdc_Bool xdc_runtime_LoggerBuf_enable__E( xdc_runtime_LoggerBuf_Handle __inst );

extern xdc_Bool xdc_runtime_LoggerBuf_enable__F( xdc_runtime_LoggerBuf_Object* __inst );
extern xdc_Bool xdc_runtime_LoggerBuf_enable__R( xdc_runtime_LoggerBuf_Handle __inst );

/* disable__E */

extern xdc_Bool xdc_runtime_LoggerBuf_disable__E( xdc_runtime_LoggerBuf_Handle __inst );

extern xdc_Bool xdc_runtime_LoggerBuf_disable__F( xdc_runtime_LoggerBuf_Object* __inst );
extern xdc_Bool xdc_runtime_LoggerBuf_disable__R( xdc_runtime_LoggerBuf_Handle __inst );

/* write0__E */

extern void xdc_runtime_LoggerBuf_write0__E( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid );

extern void xdc_runtime_LoggerBuf_write0__F( xdc_runtime_LoggerBuf_Object* __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid );
extern void xdc_runtime_LoggerBuf_write0__R( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid );

/* write1__E */

extern void xdc_runtime_LoggerBuf_write1__E( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1 );

extern void xdc_runtime_LoggerBuf_write1__F( xdc_runtime_LoggerBuf_Object* __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1 );
extern void xdc_runtime_LoggerBuf_write1__R( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1 );

/* write2__E */

extern void xdc_runtime_LoggerBuf_write2__E( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2 );

extern void xdc_runtime_LoggerBuf_write2__F( xdc_runtime_LoggerBuf_Object* __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2 );
extern void xdc_runtime_LoggerBuf_write2__R( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2 );

/* write4__E */

extern void xdc_runtime_LoggerBuf_write4__E( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4 );

extern void xdc_runtime_LoggerBuf_write4__F( xdc_runtime_LoggerBuf_Object* __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4 );
extern void xdc_runtime_LoggerBuf_write4__R( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4 );

/* write8__E */

extern void xdc_runtime_LoggerBuf_write8__E( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4, xdc_IArg a5, xdc_IArg a6, xdc_IArg a7, xdc_IArg a8 );

extern void xdc_runtime_LoggerBuf_write8__F( xdc_runtime_LoggerBuf_Object* __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4, xdc_IArg a5, xdc_IArg a6, xdc_IArg a7, xdc_IArg a8 );
extern void xdc_runtime_LoggerBuf_write8__R( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_Event evt, xdc_runtime_Types_ModuleId mid, xdc_IArg a1, xdc_IArg a2, xdc_IArg a3, xdc_IArg a4, xdc_IArg a5, xdc_IArg a6, xdc_IArg a7, xdc_IArg a8 );

/* setFilterLevel__E */

extern void xdc_runtime_LoggerBuf_setFilterLevel__E( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Diags_Mask mask, xdc_runtime_Diags_EventLevel filterLevel );

extern void xdc_runtime_LoggerBuf_setFilterLevel__F( xdc_runtime_LoggerBuf_Object* __inst, xdc_runtime_Diags_Mask mask, xdc_runtime_Diags_EventLevel filterLevel );
extern void xdc_runtime_LoggerBuf_setFilterLevel__R( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Diags_Mask mask, xdc_runtime_Diags_EventLevel filterLevel );

/* getFilterLevel__E */

extern xdc_runtime_Diags_Mask xdc_runtime_LoggerBuf_getFilterLevel__E( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Diags_EventLevel level );

extern xdc_runtime_Diags_Mask xdc_runtime_LoggerBuf_getFilterLevel__F( xdc_runtime_LoggerBuf_Object* __inst, xdc_runtime_Diags_EventLevel level );
extern xdc_runtime_Diags_Mask xdc_runtime_LoggerBuf_getFilterLevel__R( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Diags_EventLevel level );

/* flushAll__E */

extern void xdc_runtime_LoggerBuf_flushAll__E( void );

extern void xdc_runtime_LoggerBuf_flushAll__F( void );
extern void xdc_runtime_LoggerBuf_flushAll__R( void );

/* flushAllInternal__E */

extern void xdc_runtime_LoggerBuf_flushAllInternal__E( xdc_Int stat );

extern void xdc_runtime_LoggerBuf_flushAllInternal__F( xdc_Int stat );
extern void xdc_runtime_LoggerBuf_flushAllInternal__R( xdc_Int stat );

/* reset__E */

extern void xdc_runtime_LoggerBuf_reset__E( xdc_runtime_LoggerBuf_Handle __inst );

extern void xdc_runtime_LoggerBuf_reset__F( xdc_runtime_LoggerBuf_Object* __inst );
extern void xdc_runtime_LoggerBuf_reset__R( xdc_runtime_LoggerBuf_Handle __inst );

/* flush__E */

extern void xdc_runtime_LoggerBuf_flush__E( xdc_runtime_LoggerBuf_Handle __inst );

extern void xdc_runtime_LoggerBuf_flush__F( xdc_runtime_LoggerBuf_Object* __inst );
extern void xdc_runtime_LoggerBuf_flush__R( xdc_runtime_LoggerBuf_Handle __inst );

/* getNextEntry__E */

extern xdc_Int xdc_runtime_LoggerBuf_getNextEntry__E( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_EventRec* evtRec );

extern xdc_Int xdc_runtime_LoggerBuf_getNextEntry__F( xdc_runtime_LoggerBuf_Object* __inst, xdc_runtime_Log_EventRec* evtRec );
extern xdc_Int xdc_runtime_LoggerBuf_getNextEntry__R( xdc_runtime_LoggerBuf_Handle __inst, xdc_runtime_Log_EventRec* evtRec );

/* filterOutEvent__I */

extern xdc_Bool xdc_runtime_LoggerBuf_filterOutEvent__I( xdc_runtime_Diags_Mask mask );


/*
 * ======== FUNCTION SELECTORS ========
 */

/* enable_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_LoggerBuf_enable_FxnT)(void*);
static inline xdc_runtime_LoggerBuf_enable_FxnT xdc_runtime_LoggerBuf_enable_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_enable_FxnT)xdc_runtime_LoggerBuf_enable__E; 
}

/* disable_{FxnT,fxnP} */
typedef xdc_Bool (*xdc_runtime_LoggerBuf_disable_FxnT)(void*);
static inline xdc_runtime_LoggerBuf_disable_FxnT xdc_runtime_LoggerBuf_disable_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_disable_FxnT)xdc_runtime_LoggerBuf_disable__E; 
}

/* write0_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_write0_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId);
static inline xdc_runtime_LoggerBuf_write0_FxnT xdc_runtime_LoggerBuf_write0_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_write0_FxnT)xdc_runtime_LoggerBuf_write0__E; 
}

/* write1_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_write1_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg);
static inline xdc_runtime_LoggerBuf_write1_FxnT xdc_runtime_LoggerBuf_write1_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_write1_FxnT)xdc_runtime_LoggerBuf_write1__E; 
}

/* write2_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_write2_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg);
static inline xdc_runtime_LoggerBuf_write2_FxnT xdc_runtime_LoggerBuf_write2_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_write2_FxnT)xdc_runtime_LoggerBuf_write2__E; 
}

/* write4_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_write4_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
static inline xdc_runtime_LoggerBuf_write4_FxnT xdc_runtime_LoggerBuf_write4_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_write4_FxnT)xdc_runtime_LoggerBuf_write4__E; 
}

/* write8_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_write8_FxnT)(void*, xdc_runtime_Log_Event, xdc_runtime_Types_ModuleId, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg, xdc_IArg);
static inline xdc_runtime_LoggerBuf_write8_FxnT xdc_runtime_LoggerBuf_write8_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_write8_FxnT)xdc_runtime_LoggerBuf_write8__E; 
}

/* setFilterLevel_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_setFilterLevel_FxnT)(void*, xdc_runtime_Diags_Mask, xdc_runtime_Diags_EventLevel);
static inline xdc_runtime_LoggerBuf_setFilterLevel_FxnT xdc_runtime_LoggerBuf_setFilterLevel_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_setFilterLevel_FxnT)xdc_runtime_LoggerBuf_setFilterLevel__E; 
}

/* getFilterLevel_{FxnT,fxnP} */
typedef xdc_runtime_Diags_Mask (*xdc_runtime_LoggerBuf_getFilterLevel_FxnT)(void*, xdc_runtime_Diags_EventLevel);
static inline xdc_runtime_LoggerBuf_getFilterLevel_FxnT xdc_runtime_LoggerBuf_getFilterLevel_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_getFilterLevel_FxnT)xdc_runtime_LoggerBuf_getFilterLevel__E; 
}

/* reset_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_reset_FxnT)(void*);
static inline xdc_runtime_LoggerBuf_reset_FxnT xdc_runtime_LoggerBuf_reset_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_reset_FxnT)xdc_runtime_LoggerBuf_reset__E; 
}

/* flush_{FxnT,fxnP} */
typedef void (*xdc_runtime_LoggerBuf_flush_FxnT)(void*);
static inline xdc_runtime_LoggerBuf_flush_FxnT xdc_runtime_LoggerBuf_flush_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_flush_FxnT)xdc_runtime_LoggerBuf_flush__E; 
}

/* getNextEntry_{FxnT,fxnP} */
typedef xdc_Int (*xdc_runtime_LoggerBuf_getNextEntry_FxnT)(void*, xdc_runtime_Log_EventRec*);
static inline xdc_runtime_LoggerBuf_getNextEntry_FxnT xdc_runtime_LoggerBuf_getNextEntry_fxnP( void )
{
    return (xdc_runtime_LoggerBuf_getNextEntry_FxnT)xdc_runtime_LoggerBuf_getNextEntry__E; 
}


/*
 * ======== CONVERTORS ========
 */

/* Module_upCast */
static inline xdc_runtime_IFilterLogger_Module xdc_runtime_LoggerBuf_Module_upCast( void )
{
    return (xdc_runtime_IFilterLogger_Module)&xdc_runtime_LoggerBuf_Module__FXNS__C;
}

/* Module_to_xdc_runtime_IFilterLogger */

/* Handle_upCast */
static inline xdc_runtime_IFilterLogger_Handle xdc_runtime_LoggerBuf_Handle_upCast( xdc_runtime_LoggerBuf_Handle i )
{
    return (xdc_runtime_IFilterLogger_Handle)i;
}

/* Handle_to_xdc_runtime_IFilterLogger */

/* Handle_downCast */
static inline xdc_runtime_LoggerBuf_Handle xdc_runtime_LoggerBuf_Handle_downCast( xdc_runtime_IFilterLogger_Handle i )
{
    xdc_runtime_IFilterLogger_Handle i2 = (xdc_runtime_IFilterLogger_Handle)i;
    return (void*)i2->__fxns == (void*)&xdc_runtime_LoggerBuf_Module__FXNS__C ? (xdc_runtime_LoggerBuf_Handle)i : 0;
}

/* Handle_from_xdc_runtime_IFilterLogger */

/* Module_upCast2 */
static inline xdc_runtime_ILogger_Module xdc_runtime_LoggerBuf_Module_upCast2( void )
{
    return (xdc_runtime_ILogger_Module)&xdc_runtime_LoggerBuf_Module__FXNS__C;
}

/* Module_to_xdc_runtime_ILogger */

/* Handle_upCast2 */
static inline xdc_runtime_ILogger_Handle xdc_runtime_LoggerBuf_Handle_upCast2( xdc_runtime_LoggerBuf_Handle i )
{
    return (xdc_runtime_ILogger_Handle)i;
}

/* Handle_to_xdc_runtime_ILogger */

/* Handle_downCast2 */
static inline xdc_runtime_LoggerBuf_Handle xdc_runtime_LoggerBuf_Handle_downCast2( xdc_runtime_ILogger_Handle i )
{
    xdc_runtime_ILogger_Handle i2 = (xdc_runtime_ILogger_Handle)i;
    return (void*)i2->__fxns == (void*)&xdc_runtime_LoggerBuf_Module__FXNS__C ? (xdc_runtime_LoggerBuf_Handle)i : 0;
}

/* Handle_from_xdc_runtime_ILogger */


/*
 * ======== SYSTEM FUNCTIONS ========
 */

/* Module_startupDone */

/* Object_heap */

/* Module_heap */

/* Module_id */
static inline CT__xdc_runtime_LoggerBuf_Module__id xdc_runtime_LoggerBuf_Module_id( void ) 
{
    return xdc_runtime_LoggerBuf_Module__id__C;
}

/* Module_hasMask */
static inline xdc_Bool xdc_runtime_LoggerBuf_Module_hasMask( void ) 
{
    return xdc_runtime_LoggerBuf_Module__diagsMask__C != 0;
}

/* Module_getMask */
static inline xdc_Bits16 xdc_runtime_LoggerBuf_Module_getMask( void ) 
{
    return xdc_runtime_LoggerBuf_Module__diagsMask__C != 0 ? *xdc_runtime_LoggerBuf_Module__diagsMask__C : 0;
}

/* Module_setMask */
static inline void xdc_runtime_LoggerBuf_Module_setMask( xdc_Bits16 mask ) 
{
    if (xdc_runtime_LoggerBuf_Module__diagsMask__C != 0) *xdc_runtime_LoggerBuf_Module__diagsMask__C = mask;
}

/* Params_init */
static inline void xdc_runtime_LoggerBuf_Params_init( xdc_runtime_LoggerBuf_Params* prms ) 
{
    if (prms) {
        xdc_runtime_LoggerBuf_Params__init__S(prms, 0, sizeof(xdc_runtime_LoggerBuf_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Params_copy */
static inline void xdc_runtime_LoggerBuf_Params_copy( xdc_runtime_LoggerBuf_Params* dst, const xdc_runtime_LoggerBuf_Params* src ) 
{
    if (dst) {
        xdc_runtime_LoggerBuf_Params__init__S(dst, (xdc_Ptr)src, sizeof(xdc_runtime_LoggerBuf_Params), sizeof(xdc_runtime_IInstance_Params));
    }
}

/* Object_count */

/* Object_sizeof */

/* Object_get */
static inline xdc_runtime_LoggerBuf_Handle xdc_runtime_LoggerBuf_Object_get( xdc_runtime_LoggerBuf_Instance_State* oarr, int i ) 
{
    return (xdc_runtime_LoggerBuf_Handle)xdc_runtime_LoggerBuf_Object__get__S(oarr, i);
}

/* Object_first */
static inline xdc_runtime_LoggerBuf_Handle xdc_runtime_LoggerBuf_Object_first( void )
{
    return (xdc_runtime_LoggerBuf_Handle)xdc_runtime_LoggerBuf_Object__first__S();
}

/* Object_next */
static inline xdc_runtime_LoggerBuf_Handle xdc_runtime_LoggerBuf_Object_next( xdc_runtime_LoggerBuf_Object* obj )
{
    return (xdc_runtime_LoggerBuf_Handle)xdc_runtime_LoggerBuf_Object__next__S(obj);
}

/* Handle_label */
static inline xdc_runtime_Types_Label* xdc_runtime_LoggerBuf_Handle_label( xdc_runtime_LoggerBuf_Handle inst, xdc_runtime_Types_Label* lab )
{
    return xdc_runtime_LoggerBuf_Handle__label__S(inst, lab);
}

/* Handle_name */
static inline String xdc_runtime_LoggerBuf_Handle_name( xdc_runtime_LoggerBuf_Handle inst )
{
    xdc_runtime_Types_Label lab;
    return xdc_runtime_LoggerBuf_Handle__label__S(inst, &lab)->iname;
}

/* create */
static inline xdc_runtime_LoggerBuf_Handle xdc_runtime_LoggerBuf_create( const xdc_runtime_LoggerBuf_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    return (xdc_runtime_LoggerBuf_Handle)xdc_runtime_LoggerBuf_Object__create__S(0, 0, 0, (const xdc_UChar*)__prms, sizeof(xdc_runtime_LoggerBuf_Params), __eb);
}

/* construct */
static inline void xdc_runtime_LoggerBuf_construct( xdc_runtime_LoggerBuf_Struct* __obj, const xdc_runtime_LoggerBuf_Params* __prms, xdc_runtime_Error_Block* __eb )
{
    xdc_runtime_LoggerBuf_Object__create__S(__obj, sizeof (xdc_runtime_LoggerBuf_Struct), 0, (const xdc_UChar*)__prms, sizeof(xdc_runtime_LoggerBuf_Params), __eb);
}

/* delete */
static inline void xdc_runtime_LoggerBuf_delete( xdc_runtime_LoggerBuf_Handle* instp )
{
    xdc_runtime_LoggerBuf_Object__delete__S(instp);
}

/* destruct */
static inline void xdc_runtime_LoggerBuf_destruct( xdc_runtime_LoggerBuf_Struct* obj )
{
    xdc_runtime_LoggerBuf_Object__destruct__S(obj);
}

/* handle */
static inline xdc_runtime_LoggerBuf_Handle xdc_runtime_LoggerBuf_handle( xdc_runtime_LoggerBuf_Struct* str )
{
    return (xdc_runtime_LoggerBuf_Handle)str;
}

/* struct */
static inline xdc_runtime_LoggerBuf_Struct* xdc_runtime_LoggerBuf_struct( xdc_runtime_LoggerBuf_Handle inst )
{
    return (xdc_runtime_LoggerBuf_Struct*)inst;
}


/*
 * ======== EPILOGUE ========
 */




/*
 * ======== STATE STRUCTURES ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */

/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/* proxies */
/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     MODULE-WIDE CONFIGS
 *     PER-INSTANCE TYPES
 *     VIRTUAL FUNCTIONS
 *     FUNCTION DECLARATIONS
 *     FUNCTION SELECTORS
 *     CONVERTORS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== PREFIX ALIASES ========
 */



/* module prefix */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:34; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */

/*
 *  Do not modify this file; it is automatically 
 *  generated and any modifications will be overwritten.
 *
 * @(#) xdc-y25
 */

/*
 * ======== GENERATED SECTIONS ========
 *     
 *     PROLOGUE
 *     INCLUDES
 *     
 *     INTERNAL DEFINITIONS
 *     MODULE-WIDE CONFIGS
 *     FUNCTION DECLARATIONS
 *     SYSTEM FUNCTIONS
 *     
 *     EPILOGUE
 *     STATE STRUCTURES
 *     PREFIX ALIASES
 */


/*
 * ======== PROLOGUE ========
 */



/*
 * ======== STATE STRUCTURES ========
 */


/*
 * ======== PREFIX ALIASES ========
 */


/*
 *  @(#) xdc.runtime; 2, 1, 0,375; 4-27-2012 14:30:33; /db/ztree/library/trees/xdc/xdc-y25x/src/packages/
 */



static UINT16 nLastHnum = 0;
static UINT16 NodeInfoUsed = 0;
#pragma DATA_SECTION(MemList, ".ddrdata")
MemHashInfo MemList[1024];

UINT32 Hash_count_allotted=0,Hash_count_Released = 0;

/* Version 2 */
#pragma DATA_SECTION(MemListv2,".delcomObj")
MemHashInfo MemListv2[2];
#pragma DATA_SECTION(nLastHnumv2, ".delcomObj")
static UINT16 nLastHnumv2 = 0;


/*
 * This function must be protected by a semaphore if we are having
 * different priority
 */
//#pragma CODE_SECTION(Initialize_HashNewBucket,".textDDR")

/* Version 2 code */
UINT16 Initialize_HashNewBucket_v2(UINT16 BytesInBlock,
						UINT16 NoOfBlocks,
						void *HashMemSource )
{
	UINT16 blk_count;
	UINT16 retval;

	MemListv2[nLastHnumv2].BytesInBlock = BytesInBlock;
	MemListv2[nLastHnumv2].NoOfBlocks   = NoOfBlocks;
	MemListv2[nLastHnumv2].MemSource = HashMemSource;
	MemListv2[nLastHnumv2].Hash_id = nLastHnumv2; //unused for now

	FIFO_Init_v2(&MemListv2[nLastHnumv2].freelist, NoOfBlocks );

	for(blk_count = 0 ; blk_count < NoOfBlocks; ++blk_count)
	{
		FIFO_Put_v2(&MemListv2[nLastHnumv2].freelist, (void *)((char *)HashMemSource + blk_count * BytesInBlock));
	}

	retval = nLastHnumv2;
	nLastHnumv2++;
	return(retval); //returning the queue descriptor.
}

void * GetHashInfoHandlerv2(UINT16 nDesc)
{
	return (void *)&MemListv2[nDesc];
}

void* Alloc_v2(int HashId)
{

	void *pSrc;
	pSrc =  FIFO_Get(&MemListv2[HashId].freelist) ;
	if (pSrc != 0)
	{
		memset(pSrc, 0,MemListv2[HashId].BytesInBlock);
	}
	return pSrc;
}

void Free_v2(int HashId, void *ptr)
{
	FIFO_Put_v2(&MemListv2[HashId].freelist, ptr);
}

/* End of Version 2 code */

/* 
 * This function must be protected by a semaphore if we are having 
 * different priority
 */
//#pragma CODE_SECTION(Initialize_HashNewBucket,".textDDR")

UINT16 Initialize_HashNewBucket(UINT16 BytesInBlock,
						UINT16 NoOfBlocks,
						void *HashMemSource )
{
	UINT16 blk_count;
	UINT16 retval;


//	LOG_TRACE("\nHash ID: %d Size: %d  No Blocks:%d, MemSrc: 0x%x\n", nLastHnum, BytesInBlock, NoOfBlocks, HashMemSource);

	if (nLastHnum >= 1024)
	{
	//	LOG_FATAL("\nQUEUE ERROR: Only %d Queues Planned", MAX_BUCKETS);
		( (xdc_runtime_Main_Module__loggerDefined__C && (xdc_runtime_Main_Module__diagsIncluded__C & ((0x0100)) && (xdc_runtime_Main_Module__diagsEnabled__C & ((0x0100)) || *xdc_runtime_Main_Module__diagsMask__C & ((0x0100))))) ? xdc_runtime_Main_Module__loggerFxn2__C(xdc_runtime_Main_Module__loggerObj__C, ((0x0100)), (xdc_runtime_Main_Module__id__C), ((IArg) ("FATAL :" "\nQUEUE ERROR: Only %d Queues Planned")), (((xdc_IArg)1024))) : (void)0 );
		;

		// raise an exception
		return (UINT16)-1;
	}

	if (NodeInfoUsed + NoOfBlocks > 860160)
	{
	//	LOG_FATAL("\nQUEUE ERROR: Less nodes available, Cannot create Queue for the requested blocks");
		((xdc_runtime_Main_Module__loggerDefined__C && (xdc_runtime_Main_Module__diagsIncluded__C & ((0x0100)) && (xdc_runtime_Main_Module__diagsEnabled__C & ((0x0100)) || *xdc_runtime_Main_Module__diagsMask__C & ((0x0100))))) ? xdc_runtime_Main_Module__loggerFxn1__C(xdc_runtime_Main_Module__loggerObj__C, ((0x0100)), (xdc_runtime_Main_Module__id__C), ((IArg) ("FATAL :" "\nQUEUE ERROR: Less nodes available, Cannot create Queue for the requested blocks"))) : (void)0 );
		;
		// raise an exception
		return (UINT16)-1;
	}

	MemList[nLastHnum].BytesInBlock = BytesInBlock;
	MemList[nLastHnum].NoOfBlocks   = NoOfBlocks;
	MemList[nLastHnum].MemSource = HashMemSource;
	MemList[nLastHnum].Hash_id = nLastHnum;

	FIFO_Init(&MemList[nLastHnum].freelist, NoOfBlocks );
//	FIFO_Print(&MemList[nLastHnum].freelist);

	

	for(blk_count = 0 ; blk_count < NoOfBlocks; ++blk_count)
	{
		FIFO_Put(&MemList[nLastHnum].freelist, (void *)((char *)HashMemSource + blk_count * BytesInBlock));
	}

	nLastHnum++;
	NodeInfoUsed += NoOfBlocks;
	retval = nLastHnum - 1;

	return(retval); //returning the queue descriptor.

}

void * GetHashInfoHandler(UINT16 nDesc)
{

	return (void *)&MemList[nDesc];
}


void *Alloc(int type)
{
	IPCMessage *pMesg;
	pMesg = MessageQ_alloc (0, sizeof(IPCMessage));
	if (pMesg)
	{
		setMsgType(pMesg, (msgType_e)type);
		return (getSteMsg (pMesg));
	}
	else
	{
		return 0;
	}
}

void* Alloc_CoreSafe(int type, Hsem *pThis)
{
	return (Alloc(type));
}

void Free(int HashId, void *ptr)
{
	IPCMessage *pMesg;

	pMesg = (IPCMessage *)(((char *)ptr) - (sizeof(IPCMessage) - sizeof(steMsg_u)));
	if (MessageQ_free(pMesg) != 0)
	{
		xdc_runtime_System_abort__E("Message free failure!\n");
	}
}

void Free_CoreSafe(MemHashInfo *MemQptr ,void *ptr, Hsem *pThis)
{
	IPCMessage *pMesg;

	pMesg = (IPCMessage *)(((char *)ptr) - (sizeof(IPCMessage) - sizeof(steMsg_u)));
	if (MessageQ_free(pMesg) != 0)
	{
		xdc_runtime_System_abort__E("Message free failure!\n");
	}
}


